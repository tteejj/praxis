####\_Backup/20250726_003635/Base/BaseDialog.ps1
# BaseDialog.ps1 - Base class for modal dialogs to eliminate code duplication

class BaseDialog : Screen {
    # Dialog properties
    [int]$DialogWidth = 50
    [int]$DialogHeight = 14
    [int]$DialogPadding = 2
    [int]$ButtonHeight = 3
    [int]$ButtonSpacing = 2
    [int]$MaxButtonWidth = 12
    
    # Common buttons
    [Button]$PrimaryButton
    [Button]$SecondaryButton
    [string]$PrimaryButtonText = "OK"
    [string]$SecondaryButtonText = "Cancel"
    
    # Event handlers
    [scriptblock]$OnPrimary = {}
    [scriptblock]$OnSecondary = {}
    [scriptblock]$OnCreate = {}  # Legacy support
    [scriptblock]$OnCancel = {}  # Legacy support
    
    # Internal state
    hidden [hashtable]$_dialogBounds = @{}
    hidden [System.Collections.ArrayList]$_contentControls
    hidden [bool]$_initialized = $false
    [EventBus]$EventBus
    
    BaseDialog([string]$title) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    BaseDialog([string]$title, [int]$width, [int]$height) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this.DialogWidth = $width
        $this.DialogHeight = $height
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Prevent double initialization
        if ($this._initialized) {
            return
        }
        $this._initialized = $true
        
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create default buttons
        $this.CreateDefaultButtons()
        
        # Call derived class initialization
        $this.InitializeContent()
    }
    
    # Virtual method for derived classes to override
    [void] InitializeContent() {
        # Override in derived classes
    }
    
    [void] CreateDefaultButtons() {
        # Create primary button
        $this.PrimaryButton = [Button]::new($this.PrimaryButtonText)
        $this.PrimaryButton.IsDefault = $true
        $dialog = $this  # Capture reference
        $this.PrimaryButton.OnClick = {
            $dialog.HandlePrimaryAction()
        }.GetNewClosure()
        $this.PrimaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.PrimaryButton)
        
        # Create secondary button
        $this.SecondaryButton = [Button]::new($this.SecondaryButtonText)
        $this.SecondaryButton.OnClick = {
            $dialog.HandleSecondaryAction()
        }.GetNewClosure()
        $this.SecondaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SecondaryButton)
    }
    
    [void] AddContentControl([UIElement]$control, [int]$tabIndex = -1) {
        if ($tabIndex -gt 0) {
            $control.TabIndex = $tabIndex
        }
        $control.Initialize($global:ServiceContainer)
        $this.AddChild($control)
        $this._contentControls.Add($control) | Out-Null
    }
    
    [void] HandlePrimaryAction() {
        # Call custom handler first
        if ($this.OnPrimary -and $this.OnPrimary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnPrimary
        }
        
        # Legacy support
        if ($this.OnCreate -and $this.OnCreate.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCreate
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] HandleSecondaryAction() {
        # Call custom handler first
        if ($this.OnSecondary -and $this.OnSecondary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnSecondary
        }
        
        # Legacy support  
        if ($this.OnCancel -and $this.OnCancel.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCancel
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] CloseDialog() {
        if ($global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    # PARENT-DELEGATED INPUT MODEL (inherits from Screen)
    # Dialog shortcuts are handled via HandleScreenInput
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Dialog-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                if (-not $key.Modifiers) {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleSecondaryAction()
                return $true
            }
        }
        return $false
    }
    
    [void] OnActivated() {
        # Publish dialog opened event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::DialogOpened, @{ 
                Dialog = $this.GetType().Name
            })
        }
        
        # Focus first content control
        if ($this._contentControls.Count -gt 0) {
            $this._contentControls[0].Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog position (centered)
        $centerX = [int](($this.Width - $this.DialogWidth) / 2)
        $centerY = [int](($this.Height - $this.DialogHeight) / 2)
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $this.DialogWidth
            Height = $this.DialogHeight
        }
        
        # Position content controls
        $this.PositionContentControls($centerX, $centerY)
        
        # Position buttons
        $this.PositionButtons($centerX, $centerY)
    }
    
    # Virtual method for derived classes to override content positioning
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Default implementation - stack controls vertically
        $currentY = $dialogY + $this.DialogPadding
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $controlHeight = 3
        
        foreach ($control in $this._contentControls) {
            $control.SetBounds(
                $dialogX + $this.DialogPadding,
                $currentY,
                $controlWidth,
                $controlHeight
            )
            $currentY += $controlHeight + 1
        }
    }
    
    [void] PositionButtons([int]$dialogX, [int]$dialogY) {
        # Calculate button positioning
        $buttonY = $dialogY + $this.DialogHeight - $this.ButtonHeight - 1
        $totalButtonWidth = ($this.MaxButtonWidth * 2) + $this.ButtonSpacing
        
        # Center buttons if dialog is wide enough
        if ($this.DialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $dialogX + [int](($this.DialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $this.MaxButtonWidth
        } else {
            $buttonStartX = $dialogX + $this.DialogPadding
            $buttonWidth = [int](($this.DialogWidth - ($this.DialogPadding * 2) - $this.ButtonSpacing) / 2)
        }
        
        # Position primary button
        $this.PrimaryButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        # Position secondary button
        $this.SecondaryButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024  # Dialogs need moderate capacity
        
        # Render overlay background
        $this.RenderOverlay($sb)
        
        # Render dialog box
        if ($this._dialogBounds.Count -gt 0) {
            $this.RenderDialogBox($sb)
            $this.RenderTitle($sb)
        }
        
        # Render children (content controls and buttons) only within dialog bounds
        $this.RenderDialogChildren($sb)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [void] RenderOverlay([System.Text.StringBuilder]$sb) {
        # Dark overlay background
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
    }
    
    [void] RenderDialogBox([System.Text.StringBuilder]$sb) {
        $borderColor = $this.Theme.GetColor("dialog.border")
        $bgColor = $this.Theme.GetBgColor("dialog.background")
        
        $x = $this._dialogBounds.X
        $y = $this._dialogBounds.Y
        $w = $this._dialogBounds.Width
        $h = $this._dialogBounds.Height
        
        # Fill background
        for ($i = 0; $i -lt $h; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($w))
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo($x, $y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($w - 2) + [VT]::TR())
        
        for ($i = 1; $i -lt $h - 1; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo($x, $y + $h - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($w - 2) + [VT]::BR())
    }
    
    [void] RenderTitle([System.Text.StringBuilder]$sb) {
        if (-not [string]::IsNullOrEmpty($this.Title)) {
            $titleColor = $this.Theme.GetColor("dialog.title")
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            
            # Calculate title position (centered)
            $titleText = " $($this.Title) "
            $titleX = $x + [int](($w - $titleText.Length) / 2)
            
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($titleText)
        }
    }
    
    [void] RenderDialogChildren([System.Text.StringBuilder]$sb) {
        # Render all visible children - they should be positioned correctly by OnBoundsChanged
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
    }
}


####\_Backup/20250726_003635/Base/BaseModel.ps1
# BaseModel.ps1 - Base class for all data models to standardize common properties

class BaseModel {
    [string]$Id
    [DateTime]$CreatedAt
    [DateTime]$UpdatedAt
    [bool]$Deleted = $false
    
    BaseModel() {
        $this.Id = [guid]::NewGuid().ToString()
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    BaseModel([string]$id) {
        $this.Id = $id
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    # Method to update the UpdatedAt timestamp when model is modified
    [void] MarkAsUpdated() {
        $this.UpdatedAt = Get-Date
    }
    
    # Method to soft delete the model
    [void] SoftDelete() {
        $this.Deleted = $true
        $this.MarkAsUpdated()
    }
    
    # Method to restore a soft deleted model
    [void] Restore() {
        $this.Deleted = $false
        $this.MarkAsUpdated()
    }
    
    # Helper method to check if model is active (not deleted)
    [bool] IsActive() {
        return -not $this.Deleted
    }
    
    # Helper method to get age of the model
    [TimeSpan] GetAge() {
        return (Get-Date) - $this.CreatedAt
    }
    
    # Helper method to get time since last update
    [TimeSpan] GetTimeSinceUpdate() {
        return (Get-Date) - $this.UpdatedAt
    }
}


####\_Backup/20250726_003635/Base/Container.ps1
# Container.ps1 - Base class for components that contain other components
# Optimized for fast string aggregation

class Container : UIElement {
    # Optional background
    [bool]$DrawBackground = $false
    hidden [string]$_cachedBackground = ""
    hidden [string]$_cachedBgColor = ""
    hidden [ThemeManager]$Theme
    
    Container() : base() {
    }
    
    # Efficient child rendering with string builder
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Draw background if enabled
        if ($this.DrawBackground -and $this._cachedBackground) {
            $sb.Append($this._cachedBackground)
        }
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Pre-compute background
    [void] SetBackgroundColor([string]$ansiColor) {
        $this._cachedBgColor = $ansiColor
        $this.InvalidateBackground()
    }
    
    [void] InvalidateBackground() {
        if (-not $this.DrawBackground -or $this.Width -le 0 -or $this.Height -le 0) { 
            $this._cachedBackground = ""
            return 
        }
        
        $sb = Get-PooledStringBuilder ($this.Width * $this.Height * 2)
        $line = [StringCache]::GetSpaces($this.Width)
        
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            if ($this._cachedBgColor) {
                $sb.Append($this._cachedBgColor)
            }
            $sb.Append($line)
        }
        
        if ($this._cachedBgColor) {
            $sb.Append([VT]::Reset())
        }
        
        $this._cachedBackground = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    [void] OnBoundsChanged() {
        # Recalculate background when size changes
        if ($this.DrawBackground) {
            $this.InvalidateBackground()
        }
        
        # Let derived classes handle child layout
        $this.LayoutChildren()
    }
    
    # Override in derived classes for custom layouts
    [void] LayoutChildren() {
        # Base implementation does nothing
        # Derived classes like HorizontalSplit, VerticalSplit, etc. will implement
    }
    
    # Find child at specific coordinates
    [UIElement] HitTest([int]$x, [int]$y) {
        # Check if point is within our bounds
        if ($x -lt $this.X -or $x -ge ($this.X + $this.Width) -or
            $y -lt $this.Y -or $y -ge ($this.Y + $this.Height)) {
            return $null
        }
        
        # Check children in reverse order (top to bottom)
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                $hit = if ($child -is [Container]) {
                    $child.HitTest($x, $y)
                } else {
                    # Non-containers do simple bounds check
                    if ($x -ge $child.X -and $x -lt ($child.X + $child.Width) -and
                        $y -ge $child.Y -and $y -lt ($child.Y + $child.Height)) {
                        $child
                    } else {
                        $null
                    }
                }
                
                if ($hit) { return $hit }
            }
        }
        
        # No child hit, return self
        return $this
    }
    
    # Route input to focused child
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Debug logging removed for performance
        
        # Simple rule: Let focused child handle first
        $focused = $this.FindFocusedChild()
        if ($focused) {
            if ($global:Logger) {
                $global:Logger.Debug("Container: Routing to focused child $($focused.GetType().Name)")
            }
            return $focused.HandleInput($key)
        }
        
        # No focused child
        return $false
    }
    
    # Find direct focused child (not deep search)
    [UIElement] FindFocusedChild() {
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.IsFocused) {
                if ($global:Logger) {
                    $global:Logger.Debug("Container.FindFocusedChild: Found focused child $($child.GetType().Name)")
                }
                return $child
            }
        }
        if ($global:Logger) {
            $global:Logger.Debug("Container.FindFocusedChild: No focused child found among $($this.Children.Count) children")
        }
        return $null
    }
    
    # Parent-delegated focus navigation
    [void] FocusNextChild([UIElement]$currentChild) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.FocusNextChild: Type=$($this.GetType().Name), CurrentChild=$($currentChild.GetType().Name)")
        }
        
        # For containers, we need to consider both focusable children AND containers
        $allChildren = $this.Children | Where-Object { $_.Visible }
        $currentIndex = -1
        
        # Find current child index
        for ($i = 0; $i -lt $allChildren.Count; $i++) {
            if ($allChildren[$i] -eq $currentChild) {
                $currentIndex = $i
                break
            }
        }
        
        if ($currentIndex -eq -1) {
            # Current child not found, shouldn't happen
            return
        }
        
        # Look for next child that either is focusable or contains focusable elements
        for ($i = $currentIndex + 1; $i -lt $allChildren.Count; $i++) {
            $child = $allChildren[$i]
            if ($child.IsFocusable) {
                $child.Focus()
                return
            } elseif ($child -is [Container]) {
                # Try to focus first element in this container
                $child.FocusFirstInTree()
                if ($this.GetRoot().FindFocused()) {
                    return  # Focus was set
                }
            }
        }
        
        # No next child found, bubble up or wrap
        if ($this.Parent) {
            $this.Parent.FocusNextChild($this)
        } else {
            # We're at root, wrap to beginning
            $this.FocusFirstInTree()
        }
    }
    
    [void] FocusPreviousChild([UIElement]$currentChild) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.FocusPreviousChild: Type=$($this.GetType().Name), CurrentChild=$($currentChild.GetType().Name)")
        }
        
        # For containers, we need to consider both focusable children AND containers
        $allChildren = $this.Children | Where-Object { $_.Visible }
        $currentIndex = -1
        
        # Find current child index
        for ($i = 0; $i -lt $allChildren.Count; $i++) {
            if ($allChildren[$i] -eq $currentChild) {
                $currentIndex = $i
                break
            }
        }
        
        if ($currentIndex -eq -1) {
            # Current child not found, shouldn't happen
            return
        }
        
        # Look for previous child that either is focusable or contains focusable elements
        for ($i = $currentIndex - 1; $i -ge 0; $i--) {
            $child = $allChildren[$i]
            if ($child.IsFocusable) {
                $child.Focus()
                return
            } elseif ($child -is [Container]) {
                # Try to focus last element in this container
                $child.FocusLastInTree()
                if ($this.GetRoot().FindFocused()) {
                    return  # Focus was set
                }
            }
        }
        
        # No previous child found, bubble up or wrap
        if ($this.Parent) {
            $this.Parent.FocusPreviousChild($this)
        } else {
            # We're at root, wrap to end
            $this.FocusLastInTree()
        }
    }
    
    # Focus first focusable child
    [void] FocusFirst() {
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
        }
    }
    
    # Focus first focusable element in the entire tree
    [void] FocusFirstInTree() {
        # First check if any direct children are focusable
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
            return
        }
        
        # Otherwise check children's children
        foreach ($child in $this.Children) {
            if ($child -is [Container] -and $child.Visible) {
                $child.FocusFirstInTree()
                # If focus was set, we're done
                $root = $this.GetRoot()
                if ($root.FindFocused()) {
                    return
                }
            }
        }
    }
    
    # Focus last focusable element in the entire tree
    [void] FocusLastInTree() {
        # Check children in reverse order
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                if ($child -is [Container]) {
                    # Recurse into container
                    $child.FocusLastInTree()
                    # If focus was set, we're done
                    $root = $this.GetRoot()
                    if ($root.FindFocused()) {
                        return
                    }
                } elseif ($child.IsFocusable) {
                    $child.Focus()
                    return
                }
            }
        }
    }
}


####\_Backup/20250726_003635/Base/Screen.ps1
# Screen.ps1 - Base class for all screens
# Simplified from ALCAR with focus on speed

class Screen : Container {
    [string]$Title = "Screen"
    [bool]$Active = $true
    hidden [hashtable]$_keyBindings = @{}
    hidden [ThemeManager]$Theme
    
    # Protected service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    Screen() : base() {
        $this.IsFocusable = $false  # Screens are containers, not focusable elements
        $this.DrawBackground = $true
    }
    
    # Initialize with services
    [void] Initialize([ServiceContainer]$services) {
        # Call base initialization
        ([UIElement]$this).Initialize($services)
        
        # Screen-specific initialization
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    # Helper method for service access with error handling
    [object] GetService([string]$serviceName) {
        if (-not $this.ServiceContainer) {
            if ($global:Logger) {
                $global:Logger.Warning("Screen.GetService: ServiceContainer not available, falling back to global access for $serviceName")
            }
            return $global:ServiceContainer.GetService($serviceName)
        }
        return $this.ServiceContainer.GetService($serviceName)
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Theme change handler
    [void] OnThemeChanged() {
        # Use background color for screen background
        $bgColor = $this.Theme.GetBgColor("background")
        $this.SetBackgroundColor($bgColor)
        $this.InvalidateBackground()
        $this.Invalidate()
    }
    
    # Override this method in derived screens to handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        return $false  # Base implementation - no screen-specific handling
    }
    
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Debug logging removed for performance
        
        # 1. Let focused child handle first (components get priority)
        $handled = ([Container]$this).HandleInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen base handled: $handled")
        }
        if ($handled) {
            return $true
        }
        
        # 2. Screen shortcuts as fallback only
        $screenHandled = $this.HandleScreenInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen shortcuts handled: $screenHandled")
        }
        return $screenHandled
    }
    
    # Lifecycle methods - simple and fast
    [void] OnActivated() {
        # Force a render when screen is activated
        $this.Invalidate()
    }
    
    [void] OnDeactivated() {
        # Override in derived classes if needed
    }
    
    # Removed old FocusNext/FocusPrevious - now handled by parent delegation
    
    # Delegate to Container's FocusFirst
    [void] FocusFirst() {
        ([Container]$this).FocusFirst()
    }

    # Request a re-render
    [void] RequestRender() {
        $this.Invalidate()
        # The ScreenManager will handle the actual rendering
    }
}


####\_Backup/20250726_003635/Base/UIElement.ps1
# UIElement.ps1 - Fast base class for all UI components
# Inspired by AxiomPhoenix architecture but optimized for string-based rendering

class UIElement {
    # Position and dimensions
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 0
    [int]$Height = 0
    
    # Visibility and focus
    [bool]$Visible = $true
    [bool]$IsFocusable = $false
    [bool]$IsFocused = $false
    [int]$TabIndex = 0
    
    # Hierarchy
    [UIElement]$Parent = $null
    [System.Collections.Generic.List[UIElement]]$Children
    
    # Service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    # Caching for maximum speed
    hidden [string]$_renderCache = ""
    hidden [bool]$_cacheInvalid = $true
    
    # Pre-computed values
    hidden [string]$_cachedPosition = ""
    hidden [string]$_cachedClear = ""
    
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Fast render - returns cached string if valid
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        if ($this._cacheInvalid) {
            # Rebuild cache only when needed
            $this._renderCache = $this.OnRender()
            $this._cacheInvalid = $false
        }
        
        return $this._renderCache
    }
    
    # Override in derived classes
    [string] OnRender() {
        return ""
    }
    
    # Mark this element (and parents) as needing re-render
    [void] Invalidate() {
        if ($this._cacheInvalid) { return }  # Already invalid
        
        $this._cacheInvalid = $true
        $this.InvalidatePosition()  # Position might have changed too
        
        # Propagate up the tree
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
        
        # Render request is handled by propagation to root
    }
    
    # Pre-compute position strings
    [void] InvalidatePosition() {
        # Pre-compute ANSI sequences for this element's position
        $this._cachedPosition = [VT]::MoveTo($this.X, $this.Y)
        
        # Pre-compute clear sequence for this element's area
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $clearLine = [StringCache]::GetSpaces($this.Width)
            $clearSeq = Get-PooledStringBuilder ($this.Height * ($this.Width + 10))
            for ($i = 0; $i -lt $this.Height; $i++) {
                $clearSeq.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $clearSeq.Append($clearLine)
            }
            $this._cachedClear = $clearSeq.ToString()
            Return-PooledStringBuilder $clearSeq
        } else {
            $this._cachedClear = ""
        }
    }
    
    # Layout management
    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($this.X -eq $x -and $this.Y -eq $y -and 
            $this.Width -eq $width -and $this.Height -eq $height) {
            return  # No change
        }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        
        $this.InvalidatePosition()
        $this.Invalidate()
        $this.OnBoundsChanged()
    }
    
    # Override for custom layout logic
    [void] OnBoundsChanged() {
        # Base implementation does nothing
    }
    
    # Child management - now invalidates focus cache
    [void] AddChild([UIElement]$child) {
        $child.Parent = $this
        $this.Children.Add($child)
        
        # No focus cache invalidation needed - using simple direct focus
        
        $this.Invalidate()
    }
    
    [void] RemoveChild([UIElement]$child) {
        $child.Parent = $null
        $this.Children.Remove($child)
        
        # No focus cache invalidation needed - using simple direct focus
        
        $this.Invalidate()
    }
    
    # Simple focus management - works with PowerShell patterns
    [void] Focus() {
        if (-not $this.IsFocusable -or -not $this.Visible) { 
            if ($global:Logger) {
                $global:Logger.Debug("UIElement.Focus: Cannot focus $($this.GetType().Name) - IsFocusable=$($this.IsFocusable), Visible=$($this.Visible)")
            }
            return 
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("UIElement.Focus: Focusing $($this.GetType().Name)")
        }
        
        # Find root and clear any existing focus
        $root = $this
        while ($root.Parent) { $root = $root.Parent }
        $current = $this.FindFocusedElement($root)
        if ($current -and $current -ne $this) {
            $current.IsFocused = $false
            $current.OnLostFocus()
            $current.Invalidate()
        }
        
        # Focus this element
        $this.IsFocused = $true
        $this.OnGotFocus()
        $this.Invalidate()
    }
    
    # Find focused element in tree
    [UIElement] FindFocusedElement([UIElement]$element) {
        if ($element.IsFocused) { return $element }
        foreach ($child in $element.Children) {
            $found = $this.FindFocusedElement($child)
            if ($found) { return $found }
        }
        return $null
    }
    
    [UIElement] GetRoot() {
        $current = $this
        while ($current.Parent) {
            $current = $current.Parent
        }
        return $current
    }
    
    [UIElement] FindFocused() {
        if ($this.IsFocused) { return $this }
        
        foreach ($child in $this.Children) {
            $focused = $child.FindFocused()
            if ($focused) { return $focused }
        }
        
        return $null
    }
    
    # Override for focus behavior
    [void] OnGotFocus() {}
    [void] OnLostFocus() {}
    
    # Initialize with service container
    [void] Initialize([ServiceContainer]$services) {
        $this.ServiceContainer = $services
        $this.OnInitialize()
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Base implementation does nothing
        return $false
    }
}


####\_Backup/20250726_003635/Components/Button.ps1
# Button.ps1 - Fast button component with theming

class Button : UIElement {
    [string]$Text = "Button"
    [scriptblock]$OnClick = {}
    [bool]$IsDefault = $false
    
    # Cached rendering
    hidden [string]$_cachedRender = ""
    hidden [ThemeManager]$Theme
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    # Cached theme colors
    hidden [hashtable]$_colors = @{}
    
    Button() : base() {
        $this.IsFocusable = $true
        $this.Height = 3  # Default button height
    }
    
    Button([string]$text) : base() {
        $this.Text = $text
        $this.IsFocusable = $true
        $this.Height = 3
        if ($global:Logger) {
            $global:Logger.Debug("Button created with text: '$text'")
        }
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.Invalidate()  # Force initial render
    }
    
    [void] OnThemeChanged() {
        # Cache colors on theme change
        if ($this.Theme) {
            $this._colors = @{
                "button.background" = $this.Theme.GetBgColor("button.background")
                "button.foreground" = $this.Theme.GetColor("button.foreground")
                "button.focused.background" = $this.Theme.GetBgColor("button.focused.background")
                "button.focused.foreground" = $this.Theme.GetColor("button.focused.foreground")
                "border" = $this.Theme.GetColor("border")
                "border.focused" = $this.Theme.GetColor("border.focused")
                "accent" = $this.Theme.GetColor("accent")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Method to properly track text changes
    [void] SetText([string]$text) {
        if ($this.Text -ne $text) {
            $this.Text = $text
            $this._dataVersion++  # Increment on text change
            $this.Invalidate()
        }
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        # Debug logging removed for performance
        
        # Return early if Theme is not initialized
        if (-not $this.Theme) {
            $this._cachedRender = ""
            return
        }
        
        $sb = Get-PooledStringBuilder 512  # Button rendering typically needs small capacity
        
        # Determine colors based on state
        $bgColor = ""
        $fgColor = ""
        $borderColor = ""
        
        if ($this.IsFocused) {
            $bgColor = $this._colors["button.focused.background"]
            $fgColor = $this._colors["button.focused.foreground"]
            $borderColor = $this._colors["border.focused"]
        } else {
            $bgColor = $this._colors["button.background"]
            $fgColor = $this._colors["button.foreground"]
            $borderColor = $this._colors["border"]
        }
        
        # Calculate text position (centered)
        $textX = $this.X + [Math]::Max(1, [int](($this.Width - $this.Text.Length) / 2))
        $textY = $this.Y + 1  # For height=3, text should be on the middle line
        
        # Debug logging removed for performance
        
        # Draw button box
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $borderWidth = [Math]::Max(0, $this.Width - 2)
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($borderWidth) + [VT]::TR())
        } else {
            $sb.Append([VT]::TL() + [VT]::TR())
        }
        
        # Middle lines
        for ($y = $this.Y + 1; $y -lt $this.Y + $this.Height - 1; $y++) {
            # Debug logging removed for performance
            
            $sb.Append([VT]::MoveTo($this.X, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Fill line with background, but handle text line specially
            if ($y -eq $textY -and $this.Text) {
                # Draw background up to text
                $sb.Append($bgColor)
                $textStartOffset = [Math]::Max(0, ($this.Width - $this.Text.Length) / 2) - 1
                if ($textStartOffset -gt 0) {
                    $sb.Append([StringCache]::GetSpaces([int]$textStartOffset))
                }
                
                # Draw text
                $sb.Append($fgColor)
                $sb.Append($this.Text)
                
                # Fill rest of line
                $sb.Append($bgColor)
                $remainingSpace = $this.Width - 2 - [int]$textStartOffset - $this.Text.Length
                if ($remainingSpace -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($remainingSpace))
                }
            } else {
                # Non-text lines - just fill with background
                $sb.Append($bgColor)
                $paddingWidth = [Math]::Max(0, $this.Width - 2)
                if ($paddingWidth -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($paddingWidth))
                }
            }
            
            # Draw right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            $sb.Append([VT]::Reset())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($borderWidth) + [VT]::BR())
        } else {
            $sb.Append([VT]::BL() + [VT]::BR())
        }
        
        # Add default indicator if needed
        if ($this.IsDefault) {
            $sb.Append([VT]::MoveTo($this.X + 1, $this.Y))
            $sb.Append($this._colors["accent"])
            $sb.Append("*")
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -eq [System.ConsoleKey]::Enter -or 
                $key.Key -eq [System.ConsoleKey]::Spacebar) {
                $this.Click()
                return $true
            }
            return $false
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    [void] Click() {
        try {
            if ($this.OnClick) {
                & $this.OnClick
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.Click: Error executing OnClick handler - $($_.Exception.Message)")
            }
        }
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/CommandPalette.ps1
# CommandPalette.ps1 - Fast command palette overlay

class CommandPalette : Container {
    [string]$SearchText = ""
    [ListBox]$ResultsList
    [System.Collections.ArrayList]$AllCommands
    [System.Collections.ArrayList]$FilteredCommands
    [scriptblock]$OnCommandSelected = {}
    [bool]$IsVisible = $false
    [EventBus]$EventBus
    [ThemeManager]$Theme
    
    # Layout
    hidden [int]$PaletteWidth = 60
    hidden [int]$PaletteHeight = 20
    hidden [int]$MaxResults = 15
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    CommandPalette() : base() {
        $this.AllCommands = [System.Collections.ArrayList]::new()
        $this.FilteredCommands = [System.Collections.ArrayList]::new()
        $this.DrawBackground = $true
        
        # Create results list
        $this.ResultsList = [ListBox]::new()
        $this.ResultsList.ShowBorder = $false
        $this.ResultsList.ShowScrollbar = $true
        $this.ResultsList.ItemRenderer = {
            param($cmd)
            $name = $cmd.Name.PadRight(20)
            $desc = if ($cmd.Description.Length -gt 35) {
                $cmd.Description.Substring(0, 32) + "..."
            } else {
                $cmd.Description
            }
            return "$name $desc"
        }
        $this.AddChild($this.ResultsList)
    }
    
    [void] OnInitialize() {
        # Get services
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Subscribe to command registration events
        if ($this.EventBus) {
            $this.EventBus.Subscribe('command.registered', {
                param($sender, $eventData)
                if ($eventData.Name -and $eventData.Description -and $eventData.Action) {
                    $this.AddCommand($eventData.Name, $eventData.Description, $eventData.Action)
                }
            }.GetNewClosure())
        }
        
        # Initialize child components
        if ($this.ResultsList) {
            $this.ResultsList.Initialize($this.ServiceContainer)
        }
        
        # Set palette background if theme is available
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        # Load default commands
        $this.LoadDefaultCommands()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'menu.background' = $this.Theme.GetBgColor("menu.background")
                'border.focused' = $this.Theme.GetColor("border.focused")
                'accent' = $this.Theme.GetColor("accent")
                'foreground' = $this.Theme.GetColor("foreground")
                'disabled' = $this.Theme.GetColor("disabled")
            }
            $this.SetBackgroundColor($this._colors['menu.background'])
        }
        $this.Invalidate()
    }
    
    [void] LoadDefaultCommands() {
        # Store reference to this palette for use in scriptblocks
        $palette = $this
        
        # Add some default commands
        $this.AddCommand("new project", "Create a new project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new project command")
            }
            
            # Publish event to switch to projects tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
            }
            
            # Create and show the dialog
            $dialog = [NewProjectDialog]::new()
            $dialog.OnCreate = {
                param($project)
                if ($global:Logger) {
                    $global:Logger.Info("Creating project: $($project.Name)")
                }
                # Add project via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    # Create proper Project object using single-parameter constructor
                    $newProject = $projectService.AddProject($project.Name)
                    
                    # Publish project created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::ProjectCreated, @{ Project = $newProject })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        $this.AddCommand("new task", "Create a new task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new task command")
            }
            
            # Publish event to switch to tasks tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
            }
            
            # Create and show the dialog directly (same pattern as new project)
            $dialog = [NewTaskDialog]::new()
            $dialog.OnCreate = {
                param($task)
                if ($global:Logger) {
                    $global:Logger.Info("Creating task: $($task.Title)")
                }
                # Create task via service
                $taskService = $global:ServiceContainer.GetService("TaskService")
                if ($taskService) {
                    $newTask = $taskService.CreateTask($task)
                    
                    # Publish task created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TaskCreated, @{ Task = $newTask })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit project", "Edit selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit task", "Edit selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete project", "Delete selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete task", "Delete selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("time entry", "Go to time entry screen", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Time entry command executed")
            }
            # Switch to time tab (tab index 2)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 2 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("quick time entry", "Quick time entry for today", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quick time entry command executed")
            }
            
            # Switch to time tab first
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 2 })
            }
            
            # Get current week Friday for time entry
            $timeService = $global:ServiceContainer.GetService("TimeTrackingService")
            $currentWeekFriday = if ($timeService) { 
                $timeService.GetCurrentWeekFriday() 
            } else { 
                # Fallback to current week's Friday
                $today = [DateTime]::Today
                $daysUntilFriday = ([int][DayOfWeek]::Friday - [int]$today.DayOfWeek + 7) % 7
                if ($daysUntilFriday -eq 0 -and $today.DayOfWeek -ne [DayOfWeek]::Friday) {
                    $daysUntilFriday = 7
                }
                $today.AddDays($daysUntilFriday)
            }
            
            # Create and show quick time entry dialog
            $dialog = [QuickTimeEntryDialog]::new($currentWeekFriday)
            $dialog.OnSave = {
                param($timeEntry)
                if ($global:Logger) {
                    $global:Logger.Info("Creating time entry: $($timeEntry.Hours) hours for project $($timeEntry.ProjectId)")
                }
                # Create time entry via service
                $timeService = $global:ServiceContainer.GetService("TimeTrackingService")
                if ($timeService) {
                    $timeService.AddTimeEntry($timeEntry)
                    
                    # Publish time entry created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TimeEntryUpdated, @{ TimeEntry = $timeEntry })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("search", "Search in files", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Search command executed")
            }
            # TODO: Implement search
        }.GetNewClosure())
        
        $this.AddCommand("files", "Open file browser", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Files command executed")
            }
            # Switch to files tab (tab index 3 - Projects, Tasks, Time, Files)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 3 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("text editor", "Open text editor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Text editor command executed")
            }
            # Switch to editor tab (tab index 4 - Projects, Tasks, Time, Files, Editor)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("editor", "Open text editor tab", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Editor tab command executed")
            }
            # Switch to editor tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("settings", "Open settings", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Settings command executed")
            }
            # Switch to settings tab (tab index 5 - Projects, Tasks, Time, Files, Editor, Settings)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 5 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("eventbus monitor", "Open EventBus monitor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: EventBus monitor command executed")
            }
            # Open EventBus monitor dialog
            $monitor = [EventBusMonitor]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($monitor)
            }
        }.GetNewClosure())
        
        $this.AddCommand("reload", "Reload configuration", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Reload command executed")
            }
            # TODO: Implement reload
        }.GetNewClosure())
        
        $this.AddCommand("theme dark", "Switch to dark theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Dark theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        
        $this.AddCommand("theme light", "Switch to light theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Light theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        $this.AddCommand("quit", "Exit application (Ctrl+Q)", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quit command executed")
            }
            if ($global:ScreenManager) {
                $screen = $global:ScreenManager.GetActiveScreen()
                if ($screen) { 
                    $screen.Active = $false 
                }
            }
        }.GetNewClosure())
    }
    
    [void] AddCommand([string]$name, [string]$description, [scriptblock]$action) {
        $this.AllCommands.Add(@{
            Name = $name
            Description = $description
            Action = $action
        })
    }
    
    [void] Show() {
        $this.IsVisible = $true
        $this.SearchText = ""
        $this.UpdateFilter()
        $this.Invalidate()
        
        # Focus on results
        $this.ResultsList.Focus()
    }
    
    [void] Hide() {
        $this.IsVisible = $false
        $this.Invalidate()
        
        # Return focus to parent's active tab
        if ($this.Parent -and $this.Parent.GetType().Name -eq "MainScreen") {
            $activeTab = $this.Parent.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                $activeTab.Content.Focus()
            }
        }
    }
    
    [void] UpdateFilter() {
        $this.FilteredCommands.Clear()
        
        if ([string]::IsNullOrEmpty($this.SearchText)) {
            $this.FilteredCommands.AddRange($this.AllCommands)
        } else {
            # Simple fuzzy search
            $searchLower = $this.SearchText.ToLower()
            foreach ($cmd in $this.AllCommands) {
                if ($cmd.Name.ToLower().Contains($searchLower) -or 
                    $cmd.Description.ToLower().Contains($searchLower)) {
                    $this.FilteredCommands.Add($cmd)
                }
            }
        }
        
        # Update list
        $this.ResultsList.SetItems($this.FilteredCommands.ToArray())
    }
    
    [void] OnBoundsChanged() {
        # Center the palette
        $centerX = [int](($this.Width - $this.PaletteWidth) / 2)
        $centerY = [int](($this.Height - $this.PaletteHeight) / 2)
        
        # Update own bounds to be centered
        $this.X = $centerX
        $this.Y = $centerY
        $this.Width = $this.PaletteWidth
        $this.Height = $this.PaletteHeight
        
        # Layout results list (leave room for search box and border)
        $this.ResultsList.SetBounds(
            $this.X + 2,
            $this.Y + 4,
            $this.Width - 4,
            $this.Height - 6
        )
        
        # Recalculate visible items
        $this.ResultsList.VisibleItems = [Math]::Min($this.MaxResults, $this.Height - 6)
        
        ([Container]$this).OnBoundsChanged()
    }
    
    [string] OnRender() {
        if (-not $this.IsVisible) { return "" }
        
        $sb = Get-PooledStringBuilder 1024
        
        # Draw background first
        $sb.Append(([Container]$this).OnRender())
        
        # Draw border
        $borderColor = $this._colors['border.focused']
        
        # Top border with title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal(2))
        $accentColor = $this._colors['accent']
        $sb.Append($accentColor)
        $sb.Append(" Command Palette ")
        $sb.Append($borderColor)
        $sb.Append([StringCache]::GetVTHorizontal($this.Width - 19) + [VT]::TR())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        
        # Search box
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 2))
        $foregroundColor = $this._colors['foreground']
        $sb.Append($foregroundColor)
        $sb.Append("Search: ")
        $sb.Append($accentColor)
        $sb.Append($this.SearchText)
        $sb.Append("_")
        
        # Separator
        $sb.Append([VT]::MoveTo($this.X + 1, $this.Y + 3))
        $sb.Append($borderColor)
        $sb.Append([StringCache]::GetVTHorizontal($this.Width - 2))
        
        # Help text
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + $this.Height - 2))
        $disabledColor = $this._colors['disabled']
        $sb.Append($disabledColor)
        $sb.Append("[Enter] Select  [Esc] Cancel")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsVisible) { return $false }
        
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($global:Logger) {
                    $global:Logger.Debug("CommandPalette: Escape pressed, hiding palette")
                }
                try {
                    $this.Hide()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("CommandPalette: Error hiding palette: $_")
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.ResultsList.GetSelectedItem()
                if ($selected) {
                    if ($global:Logger) {
                        $global:Logger.Debug("CommandPalette: Executing command '$($selected.Name)'")
                    }
                    $this.Hide()
                    if ($selected.Action) {
                        try {
                            # Execute in the context of the CommandPalette
                            $selected.Action.Invoke()
                        } catch {
                            if ($global:Logger) {
                                $global:Logger.Error("CommandPalette: Error executing command '$($selected.Name)': $_")
                            }
                        }
                    }
                    if ($this.OnCommandSelected) {
                        & $this.OnCommandSelected $selected
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.SearchText.Length -gt 0) {
                    $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                    $this.UpdateFilter()
                    $this.Invalidate()
                }
                return $true
            }
            default {
                # Let list handle navigation
                if ($this.ResultsList.HandleInput($key)) {
                    return $true
                }
                
                # Add character to search
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or $key.KeyChar -eq ' ') {
                    $this.SearchText += $key.KeyChar
                    $this.UpdateFilter()
                    $this.Invalidate()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\_Backup/20250726_003635/Components/DataGrid.ps1
# DataGrid.ps1 - Fast data grid component for tabular display with full grid lines
# Optimized for performance with caching and pooled string builders

class DataGrid : UIElement {
    [System.Collections.ArrayList]$Items
    [hashtable[]]$Columns = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$ShowGridLines = $true  # New property for grid lines
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_colors = @{}
    hidden [hashtable]$_columnWidths = @{}
    hidden [string]$_cachedHeader = ""
    hidden [string]$_cachedSeparator = ""
    hidden [string[]]$_cachedHeaders = @()        # Pre-built header strings
    hidden [int[]]$_cachedColumnWidths = @()      # Pre-calculated widths
    hidden [string]$_cachedBorders = ""           # Pre-built border strings
    hidden [bool]$_layoutCacheValid = $false
    hidden [int]$_lastWidth = 0
    hidden [int]$_dataVersion = 0                 # Version-based change detection
    hidden [int]$_lastRenderedVersion = -1
    
    DataGrid() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Cache all colors used by DataGrid
        $this._colors['border'] = $this.Theme.GetColor('border')
        $this._colors['border.focused'] = $this.Theme.GetColor('border.focused')
        $this._colors['accent'] = $this.Theme.GetColor('accent')
        $this._colors['header.foreground'] = $this.Theme.GetColor('header.foreground')
        $this._colors['header.background'] = $this.Theme.GetBgColor('header.background')
        $this._colors['background'] = $this.Theme.GetBgColor('background')
        $this._colors['foreground'] = $this.Theme.GetColor('foreground')
        $this._colors['selection'] = $this.Theme.GetBgColor('selection')
        $this._colors['scrollbar'] = $this.Theme.GetColor('scrollbar')
        
        $this._dataVersion++  # Increment for theme change
        $this._layoutCacheValid = $false
        $this.Invalidate()
    }
    
    # Set the columns for the grid
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this._layoutCacheValid = $false
        $this._dataVersion++  # Increment on any data change
        $this.Invalidate()
    }
    
    # Set data items
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = if ($this.Items.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on any data change
        $this.Invalidate()
    }
    
    # Get selected item
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    # Select specific index
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    # Calculate column widths with auto-sizing
    hidden [void] CalculateColumnWidths([int]$availableWidth) {
        if ($this._layoutCacheValid -and $this._lastWidth -eq $availableWidth) {
            return
        }
        
        $this._columnWidths.Clear()
        $totalFixed = 0
        $flexCount = 0
        
        # First pass: calculate fixed widths and count flex columns
        foreach ($col in $this.Columns) {
            if ($col.Width -and $col.Width -gt 0) {
                $this._columnWidths[$col.Name] = $col.Width
                $totalFixed += $col.Width
            } else {
                $flexCount++
            }
        }
        
        # Add space for separators if grid lines are shown
        if ($this.ShowGridLines -and $this.Columns.Count -gt 1) {
            $totalFixed += ($this.Columns.Count - 1)  # Vertical separators
        }
        
        # Second pass: distribute remaining width to flex columns
        if ($flexCount -gt 0 -and $availableWidth -gt $totalFixed) {
            $flexWidth = [Math]::Floor(($availableWidth - $totalFixed) / $flexCount)
            foreach ($col in $this.Columns) {
                if (-not $col.Width -or $col.Width -eq 0) {
                    $this._columnWidths[$col.Name] = [Math]::Max(5, $flexWidth)  # Min width of 5
                }
            }
        }
        
        $this._lastWidth = $availableWidth
        $this._layoutCacheValid = $true
    }
    
    # Build cached header string
    hidden [void] BuildCachedHeader([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedHeader) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $header = if ($col.Header) { $col.Header } else { $col.Name }
                $text = if ($header.Length -gt $width) {
                    $header.Substring(0, $width - 1) + ""
                } else {
                    $header.PadRight($width)
                }
                $sb.Append($text)
                $x += $width
                
                # Add separator after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append([StringCache]::GetSpaces($contentWidth - $x))
        }
        
        $this._cachedHeader = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Build cached separator line
    hidden [void] BuildCachedSeparator([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedSeparator) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $sb.Append([StringCache]::GetHorizontalLine($width))
                $x += $width
                
                # Add intersection after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append([StringCache]::GetHorizontalLine($contentWidth - $x))
        }
        
        $this._cachedSeparator = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Ensure selected item is visible
    hidden [void] EnsureVisible() {
        if ($this.Items.Count -eq 0) { return }
        
        $contentHeight = $this.Height - 2  # Account for borders
        if ($this.ShowHeader) { 
            $contentHeight -= 2  # Header + separator line
        }
        
        # Account for row separators
        if ($this.ShowGridLines) {
            $contentHeight = [Math]::Floor($contentHeight / 2)  # Each row takes 2 lines with separator
        }
        
        # Scroll up if selected is above visible area
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        # Scroll down if selected is below visible area
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $contentHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Ensure scroll offset is valid
        $maxScroll = [Math]::Max(0, $this.Items.Count - $contentHeight)
        $this.ScrollOffset = [Math]::Max(0, [Math]::Min($this.ScrollOffset, $maxScroll))
    }
    
    [string] OnRender() {
        # Return empty if Theme is not initialized
        if (-not $this.Theme) {
            return ""
        }
        
        $sb = Get-PooledStringBuilder 4096  # Larger size for grid with separators
        
        # Calculate content area
        $contentX = $this.X + 1
        $contentY = $this.Y + 1
        $contentWidth = $this.Width - 2
        $contentHeight = $this.Height - 2
        
        # Draw border if enabled
        if ($this.ShowBorder -and $this.Theme) {
            $borderColor = if ($this.IsFocused) { 
                $this._colors['border.focused'] 
            } else { 
                $this._colors['border'] 
            }
            
            # Top border with title
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL())
            
            if ($this.Title) {
                $titleText = " " + $this.Title + " "  # Avoid string interpolation overhead
                $titleLen = $titleText.Length
                $borderLen = $this.Width - 2
                $leftPad = [int](($borderLen - $titleLen) / 2)
                
                if ($leftPad -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($leftPad))
                }
                $sb.Append($this._colors['accent'])
                $sb.Append($titleText)
                $sb.Append($borderColor)
                $remainingBorder = [Math]::Max(0, $borderLen - $leftPad - $titleLen)
                if ($remainingBorder -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($remainingBorder))
                }
            } else {
                $topBorderWidth = [Math]::Max(0, $this.Width - 2)
                if ($topBorderWidth -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($topBorderWidth))
                }
            }
            
            $sb.Append([VT]::TR())
            
            # Side borders
            for ($i = 1; $i -lt $this.Height - 1; $i++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i))
                $sb.Append([VT]::V())
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
            $sb.Append([VT]::BL())
            $bottomBorderWidth = [Math]::Max(0, $this.Width - 2)
            if ($bottomBorderWidth -gt 0) {
                $sb.Append([StringCache]::GetVTHorizontal($bottomBorderWidth))
            }
            $sb.Append([VT]::BR())
            $sb.Append([VT]::Reset())
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
            $contentHeight = $this.Height
        }
        
        # Calculate column widths
        $this.CalculateColumnWidths($contentWidth)
        
        # Clear content area
        $bgColor = $this._colors['background']
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $sb.Append([VT]::MoveTo($contentX, $contentY + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
        }
        
        $currentY = $contentY
        $dataStartY = $currentY
        
        # Render header if enabled
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            # Build cached header
            $this.BuildCachedHeader($contentWidth)
            
            # Render header
            $sb.Append([VT]::MoveTo($contentX, $currentY))
            $sb.Append($this._colors['header.background'])
            $sb.Append($this._colors['header.foreground'])
            $sb.Append($this._cachedHeader)
            $sb.Append([VT]::Reset())
            $currentY++
            
            # Render header separator line
            if ($this.ShowGridLines) {
                $this.BuildCachedSeparator($contentWidth)
                $sb.Append([VT]::MoveTo($contentX, $currentY))
                $sb.Append($this._colors['border'])
                $sb.Append($this._cachedSeparator)
                $sb.Append([VT]::Reset())
                $currentY++
            }
            
            $dataStartY = $currentY
            $contentHeight = $this.Height - 2 - ($currentY - $contentY)
        }
        
        # Calculate visible rows (accounting for separators) - optimization: only render visible rows
        $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
        $maxVisibleRows = [Math]::Floor($contentHeight / $rowHeight)
        
        # Optimization: Skip off-screen rows entirely - zero overhead bounds checking
        $startRow = $this.ScrollOffset
        $endRow = [Math]::Min($startRow + $maxVisibleRows, $this.Items.Count)
        $visibleRows = $endRow - $startRow
        
        # Render data rows (only visible ones)
        for ($i = 0; $i -lt $visibleRows; $i++) {
            $itemIndex = $startRow + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isSelected = ($itemIndex -eq $this.SelectedIndex)
            $rowY = $currentY + ($i * $rowHeight)
            
            # Render data row
            $sb.Append([VT]::MoveTo($contentX, $rowY))
            
            if ($isSelected) {
                $sb.Append($this._colors['selection'])
                $sb.Append($this._colors['foreground'])
            } else {
                $sb.Append($this._colors['background'])
                $sb.Append($this._colors['foreground'])
            }
            
            # Render columns
            $x = 0
            for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                $col = $this.Columns[$j]
                $width = $this._columnWidths[$col.Name]
                
                if ($x + $width -gt $contentWidth) {
                    $width = $contentWidth - $x
                }
                
                if ($width -gt 0) {
                    # Get value using property name or custom getter
                    $value = ""
                    if ($col.Getter) {
                        $value = & $col.Getter $item
                    } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                        $value = $item.($col.Name)
                    }
                    
                    # Apply formatter if provided
                    if ($col.Formatter) {
                        $value = & $col.Formatter $value
                    }
                    
                    # Convert to string and truncate if needed
                    $text = $value.ToString()
                    if ($text.Length -gt $width) {
                        $text = $text.Substring(0, $width - 1) + ""
                    } else {
                        $text = $text.PadRight($width)
                    }
                    
                    $sb.Append($text)
                    $x += $width
                    
                    # Add vertical separator after column (except last)
                    if ($this.ShowGridLines -and $j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                        if ($isSelected) {
                            # Keep selection colors for separator
                            $sb.Append("")
                        } else {
                            $sb.Append($this._colors['border'])
                            $sb.Append("")
                            $sb.Append($this._colors['foreground'])
                        }
                        $x++
                    }
                }
                
                if ($x -ge $contentWidth) { break }
            }
            
            # Fill remaining row space
            if ($x -lt $contentWidth) {
                $sb.Append([StringCache]::GetSpaces($contentWidth - $x))
            }
            
            # Render row separator (except after last visible row)
            if ($this.ShowGridLines -and $i -lt $visibleRows - 1) {
                $sb.Append([VT]::MoveTo($contentX, $rowY + 1))
                $sb.Append($this._colors['border'])
                
                $x = 0
                for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                    $col = $this.Columns[$j]
                    $width = $this._columnWidths[$col.Name]
                    
                    if ($x + $width -gt $contentWidth) {
                        $width = $contentWidth - $x
                    }
                    
                    if ($width -gt 0) {
                        $sb.Append([StringCache]::GetHorizontalLine($width))
                        $x += $width
                        
                        # Add intersection
                        if ($j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                            $sb.Append("")
                            $x++
                        }
                    }
                    
                    if ($x -ge $contentWidth) { break }
                }
                
                # Fill remaining separator
                if ($x -lt $contentWidth) {
                    $sb.Append([StringCache]::GetHorizontalLine($contentWidth - $x))
                }
                $sb.Append([VT]::Reset())
            }
        }
        
        # Show scroll indicator
        if ($this.Items.Count -gt $maxVisibleRows) {
            $scrollBarX = $this.X + $this.Width - 1
            $scrollBarHeight = $contentHeight
            $scrollThumbSize = [Math]::Max(1, [int]($scrollBarHeight * $maxVisibleRows / $this.Items.Count))
            $scrollThumbPos = [int]($this.ScrollOffset * ($scrollBarHeight - $scrollThumbSize) / ($this.Items.Count - $maxVisibleRows))
            
            $sb.Append($this._colors['scrollbar'])
            for ($i = 0; $i -lt $scrollBarHeight; $i++) {
                $sb.Append([VT]::MoveTo($scrollBarX, $dataStartY + $i))
                if ($i -ge $scrollThumbPos -and $i -lt ($scrollThumbPos + $scrollThumbSize)) {
                    $sb.Append("")
                } else {
                    $sb.Append("")
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsFocused -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.EnsureVisible()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._dataVersion++  # Increment for focus change
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._dataVersion++  # Increment for focus change
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        # Invalidate layout cache when bounds change
        if ($this.Width -ne $this._lastWidth) {
            $this._layoutCacheValid = $false
        }
        ([UIElement]$this).OnBoundsChanged()
    }
}


####\_Backup/20250726_003635/Components/DockPanel.ps1
# DockPanel.ps1 - Dock-based layout container
# Allows children to be docked to Top, Bottom, Left, Right, or Fill remaining space

enum DockPosition {
    Top
    Bottom
    Left
    Right
    Fill
}

class DockPanel : Container {
    [bool]$LastChildFill = $true
    [int]$DockSpacing = 0
    
    # Layout caching for performance
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastChildCount = 0
    
    # Available content area after docking
    hidden [int]$_contentX = 0
    hidden [int]$_contentY = 0  
    hidden [int]$_contentWidth = 0
    hidden [int]$_contentHeight = 0
    
    DockPanel() : base() {
        # DockPanel manages its own layout
    }
    
    [void] SetChildDock([UIElement]$child, [DockPosition]$position) {
        # Add custom property to track dock position
        $child | Add-Member -MemberType NoteProperty -Name "DockPosition" -Value $position -Force
        $this.InvalidateLayout()
    }
    
    [void] SetChildHeight([UIElement]$child, [int]$height) {
        # Add custom property to track fixed height
        $child | Add-Member -MemberType NoteProperty -Name "FixedHeight" -Value $height -Force
        $child.Height = $height
        $this.InvalidateLayout()
    }
    
    [void] SetChildWidth([UIElement]$child, [int]$width) {
        # Add custom property to track fixed width
        $child | Add-Member -MemberType NoteProperty -Name "FixedWidth" -Value $width -Force
        $child.Width = $width
        $this.InvalidateLayout()
    }
    
    [DockPosition] GetChildDock([UIElement]$child) {
        if ($child.PSObject.Properties["DockPosition"]) {
            return $child.DockPosition
        }
        return [DockPosition]::Fill
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        ([Container]$this).OnBoundsChanged()
    }
    
    [void] AddChild([UIElement]$child) {
        ([Container]$this).AddChild($child)
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        ([Container]$this).RemoveChild($child)
        $this.InvalidateLayout()
    }
    
    [void] UpdateLayout() {
        # Check if layout needs updating
        if (-not $this._layoutInvalid -and 
            $this.Width -eq $this._lastWidth -and 
            $this.Height -eq $this._lastHeight -and 
            $this.Children.Count -eq $this._lastChildCount) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Recalculating layout for $($this.Children.Count) children")
        }
        
        # Initialize available area (full container minus any padding)
        $availableX = $this.X
        $availableY = $this.Y
        $availableWidth = $this.Width
        $availableHeight = $this.Height
        
        # Group children by dock position
        $topChildren = @()
        $bottomChildren = @()
        $leftChildren = @()
        $rightChildren = @()
        $fillChild = $null
        
        foreach ($child in $this.Children) {
            if (-not $child.Visible) { continue }
            
            $dock = $this.GetChildDock($child)
            switch ($dock) {
                ([DockPosition]::Top) { $topChildren += $child }
                ([DockPosition]::Bottom) { $bottomChildren += $child }
                ([DockPosition]::Left) { $leftChildren += $child }
                ([DockPosition]::Right) { $rightChildren += $child }
                ([DockPosition]::Fill) { $fillChild = $child }
            }
        }
        
        # Process docked children in order: Top, Bottom, Left, Right
        
        # Top docked children
        foreach ($child in $topChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $child.SetBounds($availableX, $availableY, $availableWidth, $childHeight)
            $availableY += $childHeight + $this.DockSpacing
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Bottom docked children
        foreach ($child in $bottomChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $childY = $availableY + $availableHeight - $childHeight
            $child.SetBounds($availableX, $childY, $availableWidth, $childHeight)
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Left docked children  
        foreach ($child in $leftChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $child.SetBounds($availableX, $availableY, $childWidth, $availableHeight)
            $availableX += $childWidth + $this.DockSpacing
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Right docked children
        foreach ($child in $rightChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $childX = $availableX + $availableWidth - $childWidth
            $child.SetBounds($childX, $availableY, $childWidth, $availableHeight)
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Fill remaining space with fill child (if LastChildFill is enabled and we have one)
        if ($this.LastChildFill -and $fillChild) {
            # Ensure minimum size
            $fillWidth = [Math]::Max(0, $availableWidth)
            $fillHeight = [Math]::Max(0, $availableHeight)
            $fillChild.SetBounds($availableX, $availableY, $fillWidth, $fillHeight)
        }
        
        # Cache current state
        $this._contentX = $availableX
        $this._contentY = $availableY
        $this._contentWidth = $availableWidth
        $this._contentHeight = $availableHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Layout complete. Content area: ($availableX,$availableY) ${availableWidth}x$availableHeight")
        }
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering - render all visible children
        $sb = Get-PooledStringBuilder 2048
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child first
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [hashtable] GetContentArea() {
        $this.UpdateLayout()
        return @{
            X = $this._contentX
            Y = $this._contentY
            Width = $this._contentWidth
            Height = $this._contentHeight
        }
    }
    
    # Convenience methods for setting dock positions
    [void] DockTop([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Top) }
    [void] DockBottom([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Bottom) }
    [void] DockLeft([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Left) }
    [void] DockRight([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Right) }
    [void] DockFill([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Fill) }
}


####\_Backup/20250726_003635/Components/FastFileTree.ps1
# FastFileTree.ps1 - High-performance file system browser based on ALCAR patterns
# Fast string-based rendering with directory caching and lazy loading

class FileSystemNode {
    [string]$Name
    [string]$FullPath
    [bool]$IsDirectory
    [long]$Size
    [datetime]$LastModified
    [bool]$IsExpanded = $false
    [System.Collections.ArrayList]$Children
    [FileSystemNode]$Parent
    [int]$Level = 0
    [bool]$IsLoaded = $false
    [bool]$HasChildren = $false
    
    FileSystemNode([string]$fullPath) {
        $this.FullPath = $fullPath
        $this.Name = Split-Path $fullPath -Leaf
        $this.Children = [System.Collections.ArrayList]::new()
        
        if (Test-Path $fullPath) {
            $item = Get-Item $fullPath -ErrorAction SilentlyContinue
            if ($item) {
                $this.IsDirectory = $item.PSIsContainer
                $this.Size = if (-not $this.IsDirectory -and $item.Length) { $item.Length } else { 0 }
                $this.LastModified = $item.LastWriteTime
                
                # Check if directory has children without loading them
                if ($this.IsDirectory) {
                    try {
                        $hasItems = Get-ChildItem $fullPath -Force -ErrorAction Stop | Select-Object -First 1
                        $this.HasChildren = $hasItems -ne $null
                    } catch {
                        $this.HasChildren = $false
                    }
                }
            }
        }
    }
    
    [void] LoadChildren() {
        if ($this.IsLoaded -or -not $this.IsDirectory) {
            return
        }
        
        try {
            $items = Get-ChildItem $this.FullPath -Force -ErrorAction Stop | Sort-Object @{Expression={$_.PSIsContainer}; Descending=$true}, Name
            
            $this.Children.Clear()
            foreach ($item in $items) {
                $child = [FileSystemNode]::new($item.FullName)
                $child.Parent = $this
                $child.Level = $this.Level + 1
                $this.Children.Add($child) | Out-Null
            }
            
            $this.IsLoaded = $true
            $this.HasChildren = $this.Children.Count -gt 0
            
        } catch {
            # Access denied or other error - mark as loaded but empty
            $this.IsLoaded = $true
            $this.HasChildren = $false
        }
    }
    
    [string] GetIcon() {
        if ($this.IsDirectory) {
            if ($this.IsExpanded) { 
                return "" 
            } else { 
                return "" 
            }
        }
        
        # File type icons based on extension
        $ext = [System.IO.Path]::GetExtension($this.Name).ToLower()
        switch ($ext) {
            ".ps1" { return "" }
            ".txt" { return "" }
            ".log" { return "" }
            ".json" { return "" }
            ".xml" { return "" }
            ".md" { return "" }
            ".zip" { return "" }
            ".exe" { return "" }
            ".dll" { return "" }
            ".png" { return "" }
            ".jpg" { return "" }
            ".gif" { return "" }
            default { return "" }
        }
        return ""  # Fallback
    }
    
    [string] GetSizeString() {
        if ($this.IsDirectory) {
            return ""
        }
        
        if ($this.Size -lt 1KB) {
            return "$($this.Size) B"
        } elseif ($this.Size -lt 1MB) {
            return "$([math]::Round($this.Size / 1KB, 1)) KB"
        } elseif ($this.Size -lt 1GB) {
            return "$([math]::Round($this.Size / 1MB, 1)) MB"
        } else {
            return "$([math]::Round($this.Size / 1GB, 2)) GB"
        }
    }
}

class FastFileTree : UIElement {
    [string]$RootPath = ""
    [FileSystemNode]$RootNode
    [System.Collections.ArrayList]$_flatView
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = "File Browser"
    [bool]$ShowSize = $true
    [bool]$ShowModified = $false
    [string]$Filter = "*"
    
    # Events
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnFileSelected = {}
    [scriptblock]$OnDirectoryChanged = {}
    
    # Visual settings
    [int]$IndentSize = 2
    [string]$ExpandedIcon = ""
    [string]$CollapsedIcon = ""
    
    hidden [ThemeManager]$Theme
    hidden [int]$_lastSelectedIndex = -1
    hidden [System.Collections.Generic.HashSet[string]]$_expandedPaths
    hidden [hashtable]$_colors = @{}
    
    FastFileTree() : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        
        # Default to current directory
        $this.RootPath = $PWD.Path
    }
    
    FastFileTree([string]$rootPath) : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        $this.RootPath = $rootPath
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        $this.LoadDirectory($this.RootPath)
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selection' = $this.Theme.GetBgColor("selection")
                'normal' = $this.Theme.GetColor("normal")
                'directory' = $this.Theme.GetColor("directory")
                'file' = $this.Theme.GetColor("file")
                'border.focused' = $this.Theme.GetColor("border.focused")
                'foreground' = $this.Theme.GetColor("foreground")
                'background' = $this.Theme.GetBgColor("background")
            }
        }
        $this.Invalidate()
    }
    
    
    # Public API
    [void] LoadDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        try {
            $this.RootPath = Resolve-Path $path
            $this.RootNode = [FileSystemNode]::new($this.RootPath)
            $this.RootNode.IsExpanded = $true
            $this.RootNode.LoadChildren()
            
            # Auto-expand remembered paths
            $this.RestoreExpandedState()
            
            $this.RebuildFlatView()
            $this.SelectedIndex = 0
            $this.ScrollOffset = 0
            $this.Invalidate()
            
            # Fire directory changed event
            if ($this.OnDirectoryChanged) {
                & $this.OnDirectoryChanged $this.RootPath
            }
            
        } catch {
            # Handle errors - could show in status or log
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Error("FastFileTree: Failed to load directory '$path': $($_.Exception.Message)")
            }
        }
    }
    
    [void] NavigateUp() {
        $parentPath = Split-Path $this.RootPath -Parent
        if ($parentPath -and (Test-Path $parentPath)) {
            $this.LoadDirectory($parentPath)
        }
    }
    
    [void] NavigateToSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory) {
            $this.LoadDirectory($selected.FullPath)
        }
    }
    
    [FileSystemNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] ExpandSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and -not $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] CollapseSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] ToggleExpanded([FileSystemNode]$node) {
        if (-not $node.IsDirectory) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        
        if ($node.IsExpanded) {
            $node.LoadChildren()
            $this._expandedPaths.Add($node.FullPath) | Out-Null
        } else {
            $this._expandedPaths.Remove($node.FullPath) | Out-Null
        }
        
        $this.RebuildFlatView()
        
        # Try to keep selection on the same node
        $this.SetSelectedNode($node)
        $this.Invalidate()
    }
    
    [void] SetSelectedNode([FileSystemNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].FullPath -eq $node.FullPath) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex) {
                if ($this.OnSelectionChanged) {
                    & $this.OnSelectionChanged
                }
            }
            
            $this.Invalidate()
        }
    }
    
    [void] RefreshCurrent() {
        # Save current selection
        $selectedPath = $null
        $selected = $this.GetSelectedNode()
        if ($selected) {
            $selectedPath = $selected.FullPath
        }
        
        # Reload directory
        $this.LoadDirectory($this.RootPath)
        
        # Restore selection if possible
        if ($selectedPath) {
            for ($i = 0; $i -lt $this._flatView.Count; $i++) {
                if ($this._flatView[$i].FullPath -eq $selectedPath) {
                    $this.SelectIndex($i)
                    break
                }
            }
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        if ($this.RootNode) {
            $this.AddNodeToFlatView($this.RootNode)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([FileSystemNode]$node) {
        # Apply filter for non-directories
        if (-not $node.IsDirectory -and $this.Filter -ne "*") {
            if (-not ($node.Name -like $this.Filter)) {
                return
            }
        }
        
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] RestoreExpandedState() {
        if ($this.RootNode) {
            $this.RestoreExpandedStateRecursive($this.RootNode)
        }
    }
    
    [void] RestoreExpandedStateRecursive([FileSystemNode]$node) {
        if ($this._expandedPaths.Contains($node.FullPath)) {
            $node.IsExpanded = $true
            $node.LoadChildren()
        }
        
        foreach ($child in $node.Children) {
            $this.RestoreExpandedStateRecursive($child)
        }
    }
    
    [void] EnsureVisible() {
        # Calculate visible lines based on current dimensions
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        $borderReduction = $effectiveShowBorder ? 2 : 0
        $titleReduction = ($this.Title -and $this.Height -gt $borderReduction) ? 1 : 0
        $visibleLines = [Math]::Max(0, $this.Height - $borderReduction - $titleReduction)
        
        if ($visibleLines -gt 0) {
            if ($this.SelectedIndex -lt $this.ScrollOffset) {
                $this.ScrollOffset = $this.SelectedIndex
            } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
                $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
            }
            
            $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
        }
    }
    
    # Rendering
    [string] OnRender() {
        return $this.BuildRenderString()
    }
    
    [string] BuildRenderString() {
        # Validate dimensions before rendering
        if ($this.Width -le 0 -or $this.Height -le 0) {
            return ""
        }
        
        # Disable border if dimensions are too small
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        
        # Use StringBuilder pool if available, otherwise create new
        $sb = $null
        if (Get-Command -Name 'Get-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            $sb = Get-PooledStringBuilder 4096  # File trees can be quite large
        } else {
            $sb = [System.Text.StringBuilder]::new(4096)
        }
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selection']
        $normalColor = $this._colors['normal']
        $directoryColor = if ($this._colors['directory']) { $this._colors['directory'] } else { $normalColor }
        $fileColor = if ($this._colors['file']) { $this._colors['file'] } else { $normalColor }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area with proper bounds checking
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($effectiveShowBorder ? 2 : 0)
        
        # Ensure content width is never negative
        if ($contentWidth -lt 0) {
            $contentWidth = 0
        }
        
        if ($effectiveShowBorder) {
            # Top border - safe to render since we validated Width >= 3
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title -and $contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                if ($titleText.Length -gt $contentWidth) {
                    $titleText = "..." + $titleText.Substring($titleText.Length - $contentWidth + 3)
                }
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title -and $this.Width -gt 0) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render file/directory entries
        $visibleLines = $contentHeight - ($effectiveShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
            
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                }
                
                # Build display line
                $line = ""
                
                # Indentation
                $line += [StringCache]::GetSpaces($node.Level * $this.IndentSize)
                
                # Expand/collapse icon for directories
                if ($node.IsDirectory -and $node.HasChildren) {
                    $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
                } else {
                    $line += "  "  # Space for alignment
                }
                
                # File/directory icon
                $line += $node.GetIcon() + " "
                
                # Name
                $line += $node.Name
                
                # Size (for files, if enabled)
                if ($this.ShowSize -and -not $node.IsDirectory) {
                    $sizeStr = $node.GetSizeString()
                    if ($sizeStr) {
                        $line += " ($sizeStr)"
                    }
                }
                
                # Pad and truncate to fit
                $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
                
                # Apply appropriate color and render line
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                if ($i -eq $this.SelectedIndex) {
                    # Selected item - use selection colors
                    $sb.Append($selectedBg)
                    $foregroundColor = $this._colors['foreground']
                    $sb.Append($foregroundColor)
                } else {
                    # Normal item - directory or file color with normal background
                    $normalBg = $this._colors['background']
                    $sb.Append($normalBg)
                    $color = if ($node.IsDirectory) { $directoryColor } else { $fileColor }
                    $sb.Append($color)
                }
                $sb.Append($line)
            }
            
            # Side borders
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append([StringCache]::GetSpaces($contentWidth))
            }
            
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($effectiveShowBorder) {
            # Bottom border - safe to render since we validated Width >= 3
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        if (Get-Command -Name 'Return-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            Return-PooledStringBuilder $sb  # Return to pool for reuse
        }
        return $result
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.GetSelectedNode()
                if ($selected) {
                    if ($selected.IsDirectory) {
                        if ($selected.HasChildren) {
                            $this.ToggleExpanded($selected)
                        } else {
                            $this.LoadDirectory($selected.FullPath)
                        }
                    } else {
                        # Fire file selected event
                        if ($this.OnFileSelected) {
                            & $this.OnFileSelected $selected
                        }
                    }
                }
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                $selected = $this.GetSelectedNode()
                if ($selected -and $selected.IsDirectory -and $selected.HasChildren) {
                    $this.ToggleExpanded($selected)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Backspace) {
                $this.NavigateUp()
                $handled = $true
            }
            ([System.ConsoleKey]::F5) {
                $this.RefreshCurrent()
                $handled = $true
            }
        }
        
        # Handle character keys for quick navigation
        if (-not $handled -and $key.KeyChar -ge 'A' -and $key.KeyChar -le 'z') {
            $this.QuickNavigate($key.KeyChar)
            $handled = $true
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] QuickNavigate([char]$char) {
        $startIndex = ($this.SelectedIndex + 1) % $this._flatView.Count
        
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            $index = ($startIndex + $i) % $this._flatView.Count
            $node = $this._flatView[$index]
            
            if ($node.Name.Length -gt 0 -and [char]::ToLower($node.Name[0]) -eq [char]::ToLower($char)) {
                $this.SelectIndex($index)
                break
            }
        }
    }
    
    [void] OnGotFocus() {
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/GridPanel.ps1
# GridPanel.ps1 - Fast grid layout component for PRAXIS

class GridPanel : Container {
    [int]$Columns = 2
    [int]$Rows = 0  # Auto-calculated if 0
    [int]$CellSpacing = 1
    [int]$MinCellWidth = 5
    [int]$MinCellHeight = 2
    [bool]$ShowBorder = $false
    [bool]$AutoSize = $true  # Auto-calculate rows based on children
    
    # Cached layout calculations
    hidden [int]$_cachedCellWidth = 0
    hidden [int]$_cachedCellHeight = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastColumns = 0
    hidden [int]$_lastChildCount = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    GridPanel() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    GridPanel([int]$columns) : base() {
        $this.Columns = [Math]::Max(1, $columns)
        $this.DrawBackground = $false
    }
    
    [void] SetGridSize([int]$columns, [int]$rows) {
        $this.Columns = [Math]::Max(1, $columns)
        $this.Rows = [Math]::Max(0, $rows)
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] AddChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).AddChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).RemoveChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastHeight -eq $this.Height -and
            $this._lastColumns -eq $this.Columns -and
            $this._lastChildCount -eq $this.Children.Count) {
            return  # Layout is still valid
        }
        
        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) {
            $this._layoutInvalid = $false
            return
        }
        
        # Calculate grid dimensions
        $cols = $this.Columns
        $actualRows = if ($this.AutoSize) {
            [Math]::Ceiling($visibleChildren.Count / $cols)
        } else {
            [Math]::Max(1, $this.Rows)
        }
        
        # Calculate cell dimensions
        $totalSpacingWidth = ($cols - 1) * $this.CellSpacing
        $totalSpacingHeight = ($actualRows - 1) * $this.CellSpacing
        
        $cellWidth = [Math]::Max($this.MinCellWidth, 
            [int](($this.Width - $totalSpacingWidth) / $cols))
        $cellHeight = [Math]::Max($this.MinCellHeight, 
            [int](($this.Height - $totalSpacingHeight) / $actualRows))
        
        # Position children in grid
        for ($i = 0; $i -lt $visibleChildren.Count; $i++) {
            $child = $visibleChildren[$i]
            $col = $i % $cols
            $row = [int]($i / $cols)
            
            # Calculate position
            $childX = $this.X + ($col * ($cellWidth + $this.CellSpacing))
            $childY = $this.Y + ($row * ($cellHeight + $this.CellSpacing))
            
            # Set child bounds
            $child.SetBounds($childX, $childY, $cellWidth, $cellHeight)
        }
        
        # Cache the layout
        $this._cachedCellWidth = $cellWidth
        $this._cachedCellHeight = $cellHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastColumns = $this.Columns
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 2048
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        # Optional: render grid borders
        if ($this.ShowBorder -and $this._cachedCellWidth -gt 0) {
            $borderColor = $this._colors['border']
            $sb.Append($borderColor)
            
            # Draw grid lines (simplified - just basic grid)
            $cols = $this.Columns
            $actualRows = if ($this.AutoSize) {
                [Math]::Ceiling($this.Children.Count / $cols)
            } else {
                $this.Rows
            }
            
            # Vertical lines
            for ($col = 1; $col -lt $cols; $col++) {
                $lineX = $this.X + ($col * ($this._cachedCellWidth + $this.CellSpacing)) - 1
                for ($y = 0; $y -lt $this.Height; $y++) {
                    $sb.Append([VT]::MoveTo($lineX, $this.Y + $y))
                    $sb.Append("")
                }
            }
            
            # Horizontal lines
            for ($row = 1; $row -lt $actualRows; $row++) {
                $lineY = $this.Y + ($row * ($this._cachedCellHeight + $this.CellSpacing)) - 1
                $sb.Append([VT]::MoveTo($this.X, $lineY))
                $sb.Append([StringCache]::GetHorizontalLine($this.Width))
            }
            
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [int] GetCellWidth() { return $this._cachedCellWidth }
    [int] GetCellHeight() { return $this._cachedCellHeight }
    
    # Get child at grid position
    [UIElement] GetChildAt([int]$col, [int]$row) {
        $index = ($row * $this.Columns) + $col
        if ($index -ge 0 -and $index -lt $this.Children.Count) {
            return $this.Children[$index]
        }
        return $null
    }
    
    # Focus management with grid navigation
    [void] FocusCell([int]$col, [int]$row) {
        $child = $this.GetChildAt($col, $row)
        if ($child -and $child.IsFocusable) {
            $child.Focus()
        }
    }
}


####\_Backup/20250726_003635/Components/HorizontalSplit.ps1
# HorizontalSplit.ps1 - Fast horizontal layout component for PRAXIS

class HorizontalSplit : Container {
    [UIElement]$LeftPane
    [UIElement]$RightPane
    [int]$SplitRatio = 50  # Percentage for left pane (0-100)
    [int]$MinPaneWidth = 5
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedLeftWidth = 0
    hidden [int]$_cachedRightWidth = 0
    hidden [int]$_cachedRightX = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastSplitRatio = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    HorizontalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    [void] SetLeftPane([UIElement]$pane) {
        if ($this.LeftPane) {
            $this.RemoveChild($this.LeftPane)
        }
        $this.LeftPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetRightPane([UIElement]$pane) {
        if ($this.RightPane) {
            $this.RemoveChild($this.RightPane)
        }
        $this.RightPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalWidth = $this.Width
        $leftWidth = [int](($totalWidth * $this.SplitRatio) / 100)
        $leftWidth = [Math]::Max($this.MinPaneWidth, [Math]::Min($leftWidth, $totalWidth - $this.MinPaneWidth))
        $rightWidth = $totalWidth - $leftWidth
        $rightX = $this.X + $leftWidth
        
        # Update left pane
        if ($this.LeftPane) {
            $this.LeftPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        }
        
        # Update right pane
        if ($this.RightPane) {
            $this.RightPane.SetBounds($rightX, $this.Y, $rightWidth, $this.Height)
        }
        
        # Cache the layout
        $this._cachedLeftWidth = $leftWidth
        $this._cachedRightWidth = $rightWidth
        $this._cachedRightX = $rightX
        $this._lastWidth = $this.Width
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 1024
        
        # Render children
        if ($this.LeftPane -and $this.LeftPane.Visible) {
            $sb.Append($this.LeftPane.Render())
        }
        
        if ($this.RightPane -and $this.RightPane.Visible) {
            $sb.Append($this.RightPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedLeftWidth -gt 0) {
            $borderColor = $this._colors['border']
            for ($y = 0; $y -lt $this.Height; $y++) {
                $sb.Append([VT]::MoveTo($this._cachedRightX - 1, $this.Y + $y))
                $sb.Append($borderColor)
                $sb.Append("")
            }
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.LeftPane -and $this.LeftPane.IsFocused) {
            if ($this.LeftPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.RightPane -and $this.RightPane.IsFocused) {
            if ($this.RightPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetLeftFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetRightFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetLeftPane() { return $this.LeftPane }
    [UIElement] GetRightPane() { return $this.RightPane }
    
    # Focus management
    [void] FocusLeftPane() {
        if ($this.LeftPane -and $this.LeftPane.IsFocusable) {
            $this.LeftPane.Focus()
        }
    }
    
    [void] FocusRightPane() {
        if ($this.RightPane -and $this.RightPane.IsFocusable) {
            $this.RightPane.Focus()
        }
    }
}


####\_Backup/20250726_003635/Components/ListBox.ps1
# ListBox.ps1 - Fast list box component with selection and scrolling

class ListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [int]$VisibleItems = 10
    [bool]$ShowBorder = $true
    [bool]$ShowScrollbar = $true
    
    # Display properties
    [scriptblock]$ItemRenderer = { param($item) $item.ToString() }
    [string]$Title = ""
    
    # Callback for selection changes
    [scriptblock]$OnSelectionChanged = {}
    
    # Cached rendering
    hidden [string]$_cachedItems = ""
    hidden [bool]$_itemsCacheInvalid = $true
    hidden [ThemeManager]$Theme
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedRender = ""
    
    # Cached theme colors
    hidden [hashtable]$_colors = @{}
    
    ListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        # Cache colors on theme change
        if ($this.Theme) {
            $this._colors = @{
                "accent" = $this.Theme.GetColor("accent")
                "foreground" = $this.Theme.GetColor("foreground")
                "selection.bg" = $this.Theme.GetBgColor("selection")
                "selection.fg" = $this.Theme.GetColor("menu.selected.foreground")
                "border" = $this.Theme.GetColor("border")
                "border.focused" = $this.Theme.GetColor("border.focused")
                "scrollbar" = $this.Theme.GetColor("scrollbar")
                "scrollbar.thumb" = $this.Theme.GetColor("scrollbar.thumb")
                "disabled" = $this.Theme.GetColor("disabled")
                "background" = $this.Theme.GetBgColor("background")
            }
        }
        $this._dataVersion++  # Increment for theme change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] SetItems([array]$items) {
        $oldIndex = $this.SelectedIndex
        $this.Items.Clear()
        $this.Items.AddRange($items)
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on any data change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
        
        # Trigger callback if we have items and the selection changed
        if ($this.Items.Count -gt 0 -and ($oldIndex -ne 0 -or $this.Items.Count -eq 1) -and $this.OnSelectionChanged) {
            try {
                & $this.OnSelectionChanged
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("ListBox.SetItems: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                }
            }
        }
    }
    
    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible($index)
            $this._dataVersion++  # Increment on selection change
            $this._itemsCacheInvalid = $true
            $this.Invalidate()
            
            # Trigger callback if selection actually changed
            if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
                try {
                    & $this.OnSelectionChanged
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ListBox.SelectIndex: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                    }
                }
            }
        }
    }
    
    [void] EnsureVisible([int]$index) {
        # Adjust scroll to keep selected item visible
        $visibleEnd = $this.ScrollOffset + $this.VisibleItems - 1
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        } elseif ($index -gt $visibleEnd) {
            $this.ScrollOffset = $index - $this.VisibleItems + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # Recalculate visible items based on height
        $contentHeight = $this.Height
        if ($this.ShowBorder) { $contentHeight -= 2 }
        if ($this.Title) { $contentHeight -= 1 }
        
        $this.VisibleItems = [Math]::Max(1, $contentHeight)
        $this._itemsCacheInvalid = $true
    }
    
    [string] OnRender() {
        if ($this._itemsCacheInvalid) {
            $this.RebuildItemsCache()
        }
        return $this._cachedItems
    }
    
    [void] RebuildItemsCache() {
        $sb = Get-PooledStringBuilder 2048  # ListBox can have many items
        
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($sb)
            $contentX++
            $contentY++
            $contentWidth -= 2
        }
        
        # Draw title if present
        if ($this.Title) {
            $sb.Append([VT]::MoveTo($contentX, $contentY))
            $sb.Append($this._colors["accent"])
            $titleText = $this.Title
            if ($titleText.Length -gt $contentWidth) {
                $titleText = $titleText.Substring(0, $contentWidth - 3) + "..."
            }
            $sb.Append($titleText)
            $sb.Append($this._colors["foreground"])
            $contentY++
        }
        
        # Draw items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        $itemY = $contentY
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $text = & $this.ItemRenderer $item
            
            # Truncate if too long
            if ($text.Length -gt $contentWidth - 2) {
                $text = $text.Substring(0, $contentWidth - 5) + "..."
            }
            
            $sb.Append([VT]::MoveTo($contentX, $itemY))
            
            # Selection highlighting
            if ($i -eq $this.SelectedIndex) {
                if ($this.IsFocused) {
                    $sb.Append($this._colors["selection.bg"])
                    $sb.Append($this._colors["selection.fg"])
                } else {
                    $sb.Append($this._colors["disabled"])
                }
                $sb.Append("> ")
            } else {
                $sb.Append("  ")
            }
            
            $sb.Append($text)
            
            # Clear to end of line if selected
            if ($i -eq $this.SelectedIndex) {
                $remainingSpace = $contentWidth - $text.Length - 2
                if ($remainingSpace -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($remainingSpace))
                }
                $sb.Append([VT]::Reset())
            }
            
            $itemY++
        }
        
        # Clear any remaining empty lines in the visible area
        $remainingLines = $this.VisibleItems - ($endIndex - $this.ScrollOffset)
        if ($remainingLines -gt 0) {
            $bgColor = $this._colors["background"]
            $clearLine = [StringCache]::GetSpaces($contentWidth)
            
            for ($i = 0; $i -lt $remainingLines; $i++) {
                $sb.Append([VT]::MoveTo($contentX, $itemY))
                $sb.Append($bgColor)
                $sb.Append($clearLine)
                $sb.Append([VT]::Reset())
                $itemY++
            }
        }
        
        # Draw scrollbar if enabled and needed
        if ($this.ShowScrollbar -and $this.Items.Count -gt $this.VisibleItems) {
            $this.DrawScrollbar($sb)
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedItems = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._itemsCacheInvalid = $false
    }
    
    [void] DrawBorder([System.Text.StringBuilder]$sb) {
        $borderColor = if ($this.IsFocused) { 
            $this._colors["border.focused"] 
        } else { 
            $this._colors["border"] 
        }
        
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
        
        # Side borders
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        $sb.Append([VT]::Reset())
    }
    
    [void] DrawScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        if ($this.ShowBorder) { $scrollbarX-- }
        
        $scrollbarY = $this.Y + 1
        if ($this.ShowBorder) { $scrollbarY++ }
        if ($this.Title) { $scrollbarY++ }
        
        $scrollbarHeight = $this.VisibleItems
        
        # Calculate thumb position and size
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $this.VisibleItems / $this.Items.Count))
        $thumbPos = [int]($scrollbarY + ($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $this.VisibleItems))
        
        # Draw scrollbar track and thumb
        for ($y = $scrollbarY; $y -lt $scrollbarY + $scrollbarHeight; $y++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $y))
            
            if ($y -ge $thumbPos -and $y -lt $thumbPos + $thumbSize) {
                $sb.Append($this._colors["accent"])
                $sb.Append("")
            } else {
                $sb.Append($this._colors["border"])
                $sb.Append("")
            }
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $false
            
            switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectIndex($this.SelectedIndex - 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectIndex($this.SelectedIndex + 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $newIndex = [Math]::Max(0, $this.SelectedIndex - $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $newIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectIndex(0)
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectIndex($this.Items.Count - 1)
                $handled = $true
            }
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ListBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Focus handling
    [void] OnGotFocus() {
        $this._dataVersion++  # Increment for focus change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._dataVersion++  # Increment for focus change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/MultiSelectListBox.ps1
# MultiSelectListBox.ps1 - ListBox with multiple selection support
# Supports checkboxes, range selection, and bulk operations

class MultiSelectListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    
    # Multi-selection settings
    [System.Collections.Generic.HashSet[int]]$SelectedIndices
    [bool]$ShowCheckboxes = $true
    [bool]$AllowRangeSelection = $true
    [bool]$AllowToggleAll = $true
    
    # Visual indicators
    [char]$CheckedIcon = [char]0x2611    # 
    [char]$UncheckedIcon = [char]0x2610  # 
    [char]$PartialIcon = [char]0x2612    # 
    
    # Selection state tracking
    hidden [int]$_lastSelectedIndex = -1  # For range selection
    hidden [bool]$_allSelected = $false
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [hashtable]$_colors = @{}
    
    MultiSelectListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'checkbox' = $this.Theme.GetColor("checkbox")
                'checkbox.selected' = $this.Theme.GetColor("checkbox.selected")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        $this.SelectedIndices.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._lastSelectedIndex = -1
        $this._allSelected = $false
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $indexToRemove = -1
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if ($this.Items[$i] -eq $item) {
                $indexToRemove = $i
                break
            }
        }
        
        if ($indexToRemove -ge 0) {
            $this.RemoveItemAt($indexToRemove)
        }
    }
    
    [void] RemoveItemAt([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.Items.RemoveAt($index)
            
            # Update selected indices
            $newSelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
            foreach ($selectedIndex in $this.SelectedIndices) {
                if ($selectedIndex -lt $index) {
                    $newSelectedIndices.Add($selectedIndex) | Out-Null
                } elseif ($selectedIndex -gt $index) {
                    $newSelectedIndices.Add($selectedIndex - 1) | Out-Null
                }
                # Skip the removed index
            }
            $this.SelectedIndices = $newSelectedIndices
            
            # Update current selection
            if ($this.SelectedIndex -eq $index) {
                $this.SelectedIndex = [Math]::Min($index, $this.Items.Count - 1)
            } elseif ($this.SelectedIndex -gt $index) {
                $this.SelectedIndex--
            }
            
            $this.EnsureSelectionValid()
            $this.UpdateAllSelectedState()
            $this.Invalidate()
        }
    }
    
    # Selection management
    [bool] IsSelected([int]$index) {
        return $this.SelectedIndices.Contains($index)
    }
    
    [void] SetSelected([int]$index, [bool]$selected) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($selected) {
                $this.SelectedIndices.Add($index) | Out-Null
            } else {
                $this.SelectedIndices.Remove($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] ToggleSelected([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($this.IsSelected($index)) {
                $this.SelectedIndices.Remove($index) | Out-Null
            } else {
                $this.SelectedIndices.Add($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] SelectRange([int]$startIndex, [int]$endIndex) {
        if (-not $this.AllowRangeSelection) {
            return
        }
        
        $start = [Math]::Min($startIndex, $endIndex)
        $end = [Math]::Max($startIndex, $endIndex)
        
        for ($i = $start; $i -le $end -and $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [void] SelectAll() {
        $this.SelectedIndices.Clear()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        $this._allSelected = $true
        $this.FireSelectionChanged()
    }
    
    [void] SelectNone() {
        $this.SelectedIndices.Clear()
        $this._allSelected = $false
        $this.FireSelectionChanged()
    }
    
    [void] InvertSelection() {
        $newSelected = [System.Collections.Generic.HashSet[int]]::new()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if (-not $this.IsSelected($i)) {
                $newSelected.Add($i) | Out-Null
            }
        }
        $this.SelectedIndices = $newSelected
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [System.Collections.ArrayList] GetSelectedItems() {
        $selectedItems = [System.Collections.ArrayList]::new()
        foreach ($index in $this.SelectedIndices) {
            if ($index -ge 0 -and $index -lt $this.Items.Count) {
                $selectedItems.Add($this.Items[$index]) | Out-Null
            }
        }
        return $selectedItems
    }
    
    [System.Collections.Generic.List[int]] GetSelectedIndicesList() {
        $result = [System.Collections.Generic.List[int]]::new()
        $sortedIndices = $this.SelectedIndices | Sort-Object
        foreach ($index in $sortedIndices) {
            $result.Add($index)
        }
        return $result
    }
    
    [int] GetSelectedCount() {
        return $this.SelectedIndices.Count
    }
    
    # Navigation
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            $this.Invalidate()
        }
    }
    
    # Internal methods
    [void] UpdateAllSelectedState() {
        $this._allSelected = ($this.SelectedIndices.Count -eq $this.Items.Count -and $this.Items.Count -gt 0)
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this.Items.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [void] FireSelectionChanged() {
        if ($this.OnSelectionChanged) {
            & $this.OnSelectionChanged
        }
        $this.Invalidate()
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 2048  # MultiSelectListBox with items and checkboxes
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $checkboxColor = if ($this._colors['checkbox']) { $this._colors['checkbox'] } else { $normalColor }
        $selectedCheckboxColor = if ($this._colors['checkbox.selected']) { $this._colors['checkbox.selected'] } else { "`e[38;2;0;255;0m" }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title with selection info
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this.Items.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $y = $contentY + ($i - $startIndex)
            $isCurrentSelection = ($i -eq $this.SelectedIndex)
            $isSelected = $this.IsSelected($i)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for current item
            if ($isCurrentSelection) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Checkbox
            if ($this.ShowCheckboxes) {
                $checkboxIcon = if ($isSelected) { $this.CheckedIcon } else { $this.UncheckedIcon }
                $checkboxColorToUse = if ($isSelected) { $selectedCheckboxColor } else { $checkboxColor }
                
                $line += "$checkboxIcon "
            }
            
            # Item content
            $itemText = if ($this.ItemRenderer) {
                & $this.ItemRenderer $item
            } else {
                if ($item -eq $null) {
                    "<null>"
                } else {
                    $item.ToString()
                }
            }
            
            $line += $itemText
            
            # Adjust content width for checkbox
            $availableWidth = if ($this.ShowCheckboxes) { $contentWidth - 2 } else { $contentWidth }
            
            # Truncate if too long
            if ($line.Length -gt $availableWidth) {
                $line = $line.Substring(0, $availableWidth - 3) + "..."
            }
            
            # Pad to full width
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            # Side borders
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldSelectedIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    
                    # Shift+Up for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    
                    # Shift+Down for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                # Toggle selection of current item
                $this.ToggleSelected($this.SelectedIndex)
                $this._lastSelectedIndex = $this.SelectedIndex
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                # Toggle selection and move down
                $this.ToggleSelected($this.SelectedIndex)
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
                $this._lastSelectedIndex = $this.SelectedIndex - 1
                $handled = $true
            }
        }
        
        # Keyboard shortcuts
        if (($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            switch ($key.Key) {
                ([System.ConsoleKey]::A) {
                    if ($this.AllowToggleAll) {
                        if ($this._allSelected) {
                            $this.SelectNone()
                        } else {
                            $this.SelectAll()
                        }
                    }
                    $handled = $true
                }
                ([System.ConsoleKey]::I) {
                    $this.InvertSelection()
                    $handled = $true
                }
                ([System.ConsoleKey]::D) {
                    $this.SelectNone()
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Update last selected index for range operations
            if (-not ($key.Modifiers -band [System.ConsoleModifiers]::Shift)) {
                $this._lastSelectedIndex = $this.SelectedIndex
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/ProgressBar.ps1
# ProgressBar.ps1 - Progress visualization component based on AxiomPhoenix patterns
# Fast string-based rendering with percentage and status text display

class ProgressBar : UIElement {
    [int]$Value = 0                    # Current progress (0-100)
    [int]$Maximum = 100               # Maximum value (default 100 for percentages)
    [string]$StatusText = ""          # Optional status text
    [bool]$ShowPercentage = $true     # Show percentage text
    [bool]$ShowBorder = $true         # Show border around progress bar
    [string]$Title = ""               # Optional title
    
    # Visual customization
    [char]$FilledChar = [char]0x2588  #  (full block)
    [char]$EmptyChar = [char]0x2591   #  (light shade)
    [string]$ProgressColor = ""       # Color for filled portion
    [string]$CompleteColor = ""       # Color when 100% complete
    [string]$TextColor = ""           # Color for percentage text
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_lastValue = -1      # For change detection
    hidden [string]$_lastStatusText = ""
    hidden [hashtable]$_colors = @{}  # Cached color ANSI sequences
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    ProgressBar() : base() {
        $this.Height = 5  # Default height (border + bar + percentage + status + border)
        $this.Width = 40  # Default width
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Cache theme colors
        if ($this.Theme) {
            # Cache all color ANSI sequences
            $this._colors["progress.active"] = $this.Theme.GetColor("progress.active")
            $this._colors["progress.complete"] = $this.Theme.GetColor("progress.complete")
            $this._colors["progress.text"] = $this.Theme.GetColor("progress.text")
            $this._colors["border"] = $this.Theme.GetColor("border")
            $this._colors["title"] = $this.Theme.GetColor("title")
            $this._colors["normal"] = $this.Theme.GetColor("normal")
            
            # Set default colors if not already set
            if ([string]::IsNullOrEmpty($this.ProgressColor)) {
                $this.ProgressColor = $this._colors["progress.active"]
            }
            if ([string]::IsNullOrEmpty($this.CompleteColor)) {
                $this.CompleteColor = $this._colors["progress.complete"]
            }
            if ([string]::IsNullOrEmpty($this.TextColor)) {
                $this.TextColor = $this._colors["progress.text"]
            }
        }
        
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [void] SetProgress([int]$value) {
        $this.SetProgress($value, $this.StatusText)
    }
    
    [void] SetProgress([int]$value, [string]$statusText) {
        # Clamp value to valid range
        $this.Value = [Math]::Max(0, [Math]::Min($this.Maximum, $value))
        $this.StatusText = $statusText
        
        # Only invalidate if something actually changed
        if ($this.Value -ne $this._lastValue -or $this.StatusText -ne $this._lastStatusText) {
            $this._lastValue = $this.Value
            $this._lastStatusText = $this.StatusText
            $this._dataVersion++  # Increment on progress change
            $this.Invalidate()
        }
    }
    
    [int] GetPercentage() {
        if ($this.Maximum -eq 0) {
            return 0
        }
        return [int](($this.Value * 100) / $this.Maximum)
    }
    
    [bool] IsComplete() {
        return $this.Value -ge $this.Maximum
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 512  # ProgressBar is relatively simple
        
        # Colors from cache
        $borderColor = if ($this._colors.ContainsKey("border")) { $this._colors["border"] } else { "" }
        $titleColor = if ($this._colors.ContainsKey("title")) { $this._colors["title"] } else { "" }
        $normalColor = if ($this._colors.ContainsKey("normal")) { $this._colors["normal"] } else { "" }
        
        # Determine progress color based on completion
        $currentProgressColor = if ($this.IsComplete()) { 
            if ([string]::IsNullOrEmpty($this.CompleteColor)) { $this.ProgressColor } else { $this.CompleteColor }
        } else { 
            $this.ProgressColor 
        }
        
        # Calculate dimensions
        $contentY = $this.Y
        $contentHeight = $this.Height
        $barWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($barWidth).Substring(0, $barWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Calculate bar dimensions
        $percentage = $this.GetPercentage()
        $filledWidth = if ($barWidth -gt 0) { [Math]::Floor($barWidth * $percentage / 100) } else { 0 }
        $emptyWidth = $barWidth - $filledWidth
        
        # Render progress bar
        $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
        
        # Filled portion
        if ($filledWidth -gt 0) {
            $sb.Append($currentProgressColor)
            $sb.Append([StringCache]::GetRepeatedChar($this.FilledChar, $filledWidth))
        }
        
        # Empty portion  
        if ($emptyWidth -gt 0) {
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetRepeatedChar($this.EmptyChar, $emptyWidth))
        }
        
        $contentY++
        $contentHeight--
        
        # Percentage text (centered)
        if ($this.ShowPercentage) {
            $percentText = "$percentage%"
            $textX = $this.X + ($this.Width - $percentText.Length) / 2
            $sb.Append([VT]::MoveTo([int]$textX, $contentY))
            $sb.Append($this.TextColor)
            $sb.Append($percentText)
            $contentY++
            $contentHeight--
        }
        
        # Status text (left-aligned, truncated if needed)
        if ($this.StatusText -and $contentHeight -gt ($this.ShowBorder ? 1 : 0)) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($normalColor)
            
            $statusWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
            if ($this.StatusText.Length -gt $statusWidth) {
                $truncated = $this.StatusText.Substring(0, $statusWidth - 3) + "..."
                $sb.Append($truncated)
            } else {
                $paddedStatus = $this.StatusText.PadRight($statusWidth).Substring(0, $statusWidth)
                $sb.Append($paddedStatus)
            }
            $contentY++
            $contentHeight--
        }
        
        # Side borders for remaining height
        if ($this.ShowBorder) {
            while ($contentHeight -gt 1) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $contentY++
                $contentHeight--
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    # Animation helper method (for future use)
    [void] AnimateTo([int]$targetValue, [int]$durationMs = 1000) {
        # Basic animation - could be enhanced with timer/events
        $startValue = $this.Value
        $steps = [Math]::Max(1, $durationMs / 50)  # 50ms per step
        $increment = ($targetValue - $startValue) / $steps
        
        for ($i = 0; $i -lt $steps; $i++) {
            $currentValue = $startValue + ($increment * ($i + 1))
            $this.SetProgress([int]$currentValue)
            Start-Sleep -Milliseconds 50
        }
        
        # Ensure we reach the exact target
        $this.SetProgress($targetValue)
    }
    
    # No input handling needed for progress bar
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}


####\_Backup/20250726_003635/Components/RangerFileTree.ps1
# RangerFileTree.ps1 - Ranger-style 3-pane file browser
# Left: Parent directory, Center: Current directory, Right: Preview/child

class RangerFileTree : Container {
    [string]$CurrentPath
    [FileSystemNode]$ParentNode
    [FileSystemNode]$CurrentNode
    [FileSystemNode]$PreviewNode
    
    # Three panes
    [FastFileTree]$ParentPane
    [FastFileTree]$CurrentPane
    [FastFileTree]$PreviewPane
    
    # Layout
    [double]$LeftPaneWidth = 0.25
    [double]$CenterPaneWidth = 0.35
    [double]$RightPaneWidth = 0.40
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    hidden [ThemeManager]$Theme
    
    RangerFileTree() : base() {
        $this.CurrentPath = (Get-Location).Path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    RangerFileTree([string]$path) : base() {
        $this.CurrentPath = $path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    [void] CreatePanes() {
        # Create parent pane
        $this.ParentPane = [FastFileTree]::new()
        $this.ParentPane.ShowBorder = $true
        $this.ParentPane.Title = "Parent"
        $this.ParentPane.ShowSize = $false
        $this.AddChild($this.ParentPane)
        
        # Create current pane
        $this.CurrentPane = [FastFileTree]::new()
        $this.CurrentPane.ShowBorder = $true
        $this.CurrentPane.Title = "Current"
        $this.CurrentPane.ShowSize = $true
        $this.AddChild($this.CurrentPane)
        
        # Create preview pane
        $this.PreviewPane = [FastFileTree]::new()
        $this.PreviewPane.ShowBorder = $true
        $this.PreviewPane.Title = "Preview"
        $this.PreviewPane.ShowSize = $true
        $this.AddChild($this.PreviewPane)
        
        # Set up event handlers
        $ranger = $this
        $this.CurrentPane.OnSelectionChanged = {
            $ranger.UpdatePreviewPane()
        }.GetNewClosure()
        
        $this.CurrentPane.OnFileSelected = {
            param($node)
            if ($node.IsDirectory) {
                $ranger.NavigateToDirectory($node.FullPath)
            } else {
                if ($ranger.OnFileSelected) {
                    & $ranger.OnFileSelected $node
                }
            }
        }.GetNewClosure()
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnInitialize: Starting initialization")
            $global:Logger.Debug("  IsFocusable: $($this.IsFocusable)")
            $global:Logger.Debug("  CurrentPath: $($this.CurrentPath)")
        }
        
        # Initialize theme
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Initialize child panes
        $this.ParentPane.ServiceContainer = $this.ServiceContainer
        $this.ParentPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  ParentPane initialized, IsFocusable=$($this.ParentPane.IsFocusable)")
        }
        
        $this.CurrentPane.ServiceContainer = $this.ServiceContainer
        $this.CurrentPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  CurrentPane initialized, IsFocusable=$($this.CurrentPane.IsFocusable)")
        }
        
        $this.PreviewPane.ServiceContainer = $this.ServiceContainer
        $this.PreviewPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  PreviewPane initialized, IsFocusable=$($this.PreviewPane.IsFocusable)")
        }
        
        # Load initial directory
        $this.NavigateToDirectory($this.CurrentPath)
        
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnInitialize: Completed")
        }
    }
    
    [void] NavigateToDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        $this.CurrentPath = Resolve-Path $path
        
        # Update parent pane
        $parentPath = Split-Path $this.CurrentPath -Parent
        if ($parentPath) {
            $this.ParentPane.LoadDirectory($parentPath)
            # Select current directory in parent
            $currentName = Split-Path $this.CurrentPath -Leaf
            for ($i = 0; $i -lt $this.ParentPane._flatView.Count; $i++) {
                if ($this.ParentPane._flatView[$i].Name -eq $currentName) {
                    $this.ParentPane.SelectIndex($i)
                    break
                }
            }
        } else {
            # At root, show drives or root
            $this.ParentPane.Title = "Drives"
            $this.ParentPane._flatView.Clear()
            $this.ParentPane.Invalidate()
        }
        
        # Update current pane
        $this.CurrentPane.LoadDirectory($this.CurrentPath)
        $this.CurrentPane.Title = Split-Path $this.CurrentPath -Leaf
        if ($this.CurrentPane._flatView.Count -gt 0) {
            $this.CurrentPane.SelectIndex(0)
            if ($global:Logger) {
                $global:Logger.Debug("RangerFileTree: Selected first item in current pane")
            }
        } else {
            if ($global:Logger) {
                $global:Logger.Warning("RangerFileTree: No items in current directory")
            }
        }
        
        # Update preview pane
        $this.UpdatePreviewPane()
    }
    
    [void] UpdatePreviewPane() {
        $selected = $this.CurrentPane.GetSelectedNode()
        if (-not $selected) {
            $this.PreviewPane.Title = "Preview"
            $this.PreviewPane._flatView.Clear()
            $this.PreviewPane.Invalidate()
            return
        }
        
        if ($selected.IsDirectory) {
            # Show directory contents
            $this.PreviewPane.LoadDirectory($selected.FullPath)
            $this.PreviewPane.Title = $selected.Name
        } else {
            # Show file preview
            $this.PreviewPane.Title = "File: $($selected.Name)"
            $this.PreviewPane._flatView.Clear()
            
            # Could add file preview logic here (first N lines, file info, etc.)
            # For now, just show file info
            $info = [FileSystemNode]::new($selected.FullPath)
            $info.Name = "Size: $($selected.GetSizeString())"
            $this.PreviewPane._flatView.Add($info) | Out-Null
            
            $info2 = [FileSystemNode]::new($selected.FullPath)
            $info2.Name = "Modified: $($selected.LastModified.ToString('yyyy-MM-dd HH:mm'))"
            $this.PreviewPane._flatView.Add($info2) | Out-Null
            
            $this.PreviewPane.Invalidate()
        }
    }
    
    [void] OnBoundsChanged() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Calculate pane widths
        $totalWidth = $this.Width
        if ($totalWidth -le 0) {
            if ($global:Logger) {
                $global:Logger.Warning("RangerFileTree: Invalid width $totalWidth")
            }
            return
        }
        
        $leftWidth = [int]($totalWidth * $this.LeftPaneWidth)
        $centerWidth = [int]($totalWidth * $this.CenterPaneWidth)
        $rightWidth = $totalWidth - $leftWidth - $centerWidth
        
        if ($global:Logger) {
            $global:Logger.Debug("  Pane widths: left=$leftWidth, center=$centerWidth, right=$rightWidth")
        }
        
        # Position panes
        $this.ParentPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        $this.CurrentPane.SetBounds($this.X + $leftWidth, $this.Y, $centerWidth, $this.Height)
        $this.PreviewPane.SetBounds($this.X + $leftWidth + $centerWidth, $this.Y, $rightWidth, $this.Height)
    }
    
    [string] OnRender() {
        # Debug rendering to ensure we're actually drawing
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnRender: Rendering with IsFocused=$($this.IsFocused)")
        }
        
        # Let base Container render children
        return ([Container]$this).OnRender()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Modifiers=$($key.Modifiers)")
            $global:Logger.Debug("  IsFocused: $($this.IsFocused)")
            $global:Logger.Debug("  CurrentPane IsFocused: $($this.CurrentPane.IsFocused)")
        }
        
        # Handle vim-style navigation keys
        if (-not $key.Modifiers) {
            switch ($key.KeyChar) {
                'h' {
                    # Navigate to parent directory (left)
                    $parentPath = Split-Path $this.CurrentPath -Parent
                    if ($parentPath) {
                        $this.NavigateToDirectory($parentPath)
                    }
                    return $true
                }
                'l' {
                    # Navigate into selected directory or open file (right)
                    $selected = $this.CurrentPane.GetSelectedNode()
                    if ($selected) {
                        if ($selected.IsDirectory) {
                            $this.NavigateToDirectory($selected.FullPath)
                        } else {
                            # Open file
                            if ($this.OnFileSelected) {
                                & $this.OnFileSelected $selected
                            }
                        }
                    }
                    return $true
                }
                'j' {
                    # Move down - create a synthetic down arrow key
                    $downKey = New-Object System.ConsoleKeyInfo -ArgumentList ([char]0, [System.ConsoleKey]::DownArrow, $false, $false, $false)
                    return $this.CurrentPane.HandleInput($downKey)
                }
                'k' {
                    # Move up - create a synthetic up arrow key
                    $upKey = New-Object System.ConsoleKeyInfo -ArgumentList ([char]0, [System.ConsoleKey]::UpArrow, $false, $false, $false)
                    return $this.CurrentPane.HandleInput($upKey)
                }
                '.' {
                    # Toggle hidden files
                    # TODO: Implement hidden file toggle
                    return $true
                }
            }
        }
        
        # Also handle arrow keys for compatibility
        switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                # Navigate to parent directory
                $parentPath = Split-Path $this.CurrentPath -Parent
                if ($parentPath) {
                    $this.NavigateToDirectory($parentPath)
                }
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                # Navigate into selected directory
                $selected = $this.CurrentPane.GetSelectedNode()
                if ($selected -and $selected.IsDirectory) {
                    $this.NavigateToDirectory($selected.FullPath)
                }
                return $true
            }
        }
        
        # Let current pane handle other input
        return $this.CurrentPane.HandleInput($key)
    }
    
    [void] OnGotFocus() {
        ([UIElement]$this).OnGotFocus()
        # Don't automatically focus child pane - we'll handle input and delegate as needed
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnGotFocus: Got focus")
        }
    }
    
    [void] Focus() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.Focus: Setting focus")
        }
        
        # Call base Focus to set IsFocused = true
        ([UIElement]$this).Focus()
        
        # Don't focus child panes - we'll handle the input routing ourselves
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.Focus: IsFocused = $($this.IsFocused)")
        }
    }
}


####\_Backup/20250726_003635/Components/SearchableListBox.ps1
# SearchableListBox.ps1 - ListBox with built-in search/filter functionality
# High-performance search with real-time filtering

class SearchableListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [System.Collections.ArrayList]$_filteredItems
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [string]$SearchQuery = ""
    [bool]$ShowSearchBox = $true
    [bool]$CaseSensitive = $false
    [bool]$UseRegex = $false
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnItemActivated = {}
    
    # Search configuration
    [int]$MinSearchLength = 0  # Start filtering immediately
    [bool]$SearchInDescription = $false
    [scriptblock]$SearchFilter = $null  # Custom filter function
    
    # Visual settings
    [string]$SearchPrompt = "Search: "
    [string]$NoResultsText = "No items found"
    [string]$SearchIcon = ""  # Search icon
    [char[]]$ExcludedSearchKeys = @('n', 'e', 'd')  # Keys that should not trigger search mode
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_searchBoxHeight = 3
    hidden [bool]$_searchMode = $false
    hidden [int]$_lastFilteredCount = -1
    hidden [System.Collections.Generic.HashSet[string]]$_highlightCache
    hidden [hashtable]$_colors = @{}
    
    SearchableListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this._filteredItems = [System.Collections.ArrayList]::new()
        $this._highlightCache = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.ApplyFilter()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'background' = $this.Theme.GetBgColor("background")
                'search' = $this.Theme.GetColor("search")
                'highlight' = $this.Theme.GetColor("highlight")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.ApplyFilter()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.ApplyFilter()
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $this.Items.Remove($item) | Out-Null
        $this.ApplyFilter()
        $this.EnsureSelectionValid()
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._filteredItems.Count) {
            return $this._filteredItems[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._filteredItems.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] SetSearchQuery([string]$query) {
        if ($this.SearchQuery -ne $query) {
            $this.SearchQuery = $query
            $this.ApplyFilter()
            $this.SelectedIndex = 0  # Reset to top when search changes
            $this.ScrollOffset = 0
            $this.Invalidate()
        }
    }
    
    [void] ClearSearch() {
        $this.SetSearchQuery("")
    }
    
    [void] EnterSearchMode() {
        $this._searchMode = $true
        $this.Invalidate()
    }
    
    [void] ExitSearchMode() {
        $this._searchMode = $false
        $this.Invalidate()
    }
    
    [void] ToggleSearchMode() {
        $this._searchMode = -not $this._searchMode
        $this.Invalidate()
    }
    
    # Internal methods
    [void] ApplyFilter() {
        $this._filteredItems.Clear()
        $this._highlightCache.Clear()
        
        # If no search query, show all items
        if ([string]::IsNullOrEmpty($this.SearchQuery) -or $this.SearchQuery.Length -lt $this.MinSearchLength) {
            foreach ($item in $this.Items) {
                $this._filteredItems.Add($item) | Out-Null
            }
        } else {
            # Apply filtering - optimize by pre-calculating normalized query
            $normalizedQuery = if ($this.CaseSensitive) { $this.SearchQuery } else { $this.SearchQuery.ToLower() }
            foreach ($item in $this.Items) {
                if ($this.MatchesSearchOptimized($item, $this.SearchQuery, $normalizedQuery)) {
                    $this._filteredItems.Add($item) | Out-Null
                }
            }
        }
        
        $this._lastFilteredCount = $this._filteredItems.Count
        $this.EnsureSelectionValid()
    }
    
    # Optimized version that avoids repeated ToLower() calls
    [bool] MatchesSearchOptimized($item, [string]$query, [string]$normalizedQuery) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity using pre-normalized query
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $normalizedQuery  # Use pre-normalized query
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                return $false
            }
        } else {
            return $searchText.Contains($query)
        }
    }

    [bool] MatchesSearch($item, [string]$query) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $query.ToLower()
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                # Invalid regex, fall back to simple contains
                return $searchText -like "*$query*"
            }
        } else {
            # Simple contains search
            return $searchText -like "*$query*"
        }
    }
    
    [string] GetSearchableText($item) {
        if ($item -eq $null) {
            return ""
        }
        
        # If item has a specific string representation method
        if ($item.PSObject.Methods['ToString'] -and $item.ToString() -ne $item.GetType().FullName) {
            return $item.ToString()
        }
        
        # If it's a hashtable or PSObject, try common text properties
        if ($item -is [hashtable]) {
            $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
            foreach ($prop in $textProps) {
                if ($item.ContainsKey($prop) -and $item[$prop]) {
                    return $item[$prop].ToString()
                }
            }
            # Fall back to all values if SearchInDescription is enabled
            if ($this.SearchInDescription) {
                return ($item.Values -join ' ')
            }
        }
        
        # Try common properties for objects
        $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
        foreach ($prop in $textProps) {
            $value = $item.PSObject.Properties[$prop]
            if ($value -and $value.Value) {
                return $value.Value.ToString()
            }
        }
        
        # Fall back to string conversion
        return $item.ToString()
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this._filteredItems.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this._filteredItems.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $contentHeight = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        if ($this.ShowSearchBox) {
            $contentHeight -= $this._searchBoxHeight
        }
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $contentHeight) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 2048  # SearchableListBox with search box and items
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $bgColor = $this._colors['background']
        $searchColor = if ($this._colors['search']) { $this._colors['search'] } else { $normalColor }
        $highlightColor = if ($this._colors['highlight']) { $this._colors['highlight'] } else { "`e[38;2;255;255;0m" }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = [Math]::Max(1, $this.Width - ($this.ShowBorder ? 2 : 0))
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = if ($contentWidth -le 0) { "" } else { $titleText.PadRight($contentWidth).Substring(0, $contentWidth) }
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = if ($this.Width -le 0) { "" } else { $titleText.PadRight($this.Width).Substring(0, $this.Width) }
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Search box
        if ($this.ShowSearchBox) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($searchColor)
            
            $searchText = "$($this.SearchIcon) $($this.SearchPrompt)$($this.SearchQuery)"
            if ($this._searchMode) {
                $searchText += "|"  # Cursor indicator
            }
            
            $searchLine = if ($contentWidth -le 0) { "" } else { $searchText.PadRight($contentWidth).Substring(0, $contentWidth) }
            $sb.Append($searchLine)
            $contentY++
            $contentHeight--
            
            # Search box separator
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($borderColor)
            $sb.Append([StringCache]::GetVTHorizontal($contentWidth))
            $contentY++
            $contentHeight--
            
            # Side borders for search area
            if ($this.ShowBorder) {
                for ($y = $contentY - 2; $y -lt $contentY; $y++) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._filteredItems.Count)
        
        if ($this._filteredItems.Count -eq 0) {
            # Fill all empty lines first
            for ($i = 0; $i -lt $visibleLines; $i++) {
                $y = $contentY + $i
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($contentWidth))
                
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
            
            # No results message centered in the content area
            if ($visibleLines -gt 0) {
                $noResultsY = $contentY + [int]($visibleLines / 2)
                $messageX = $this.X + ($this.ShowBorder ? 1 : 0) + [Math]::Max(0, [int](($contentWidth - $this.NoResultsText.Length) / 2))
                $sb.Append([VT]::MoveTo($messageX, $noResultsY))
                $sb.Append($normalColor)
                $sb.Append($bgColor)
                $sb.Append($this.NoResultsText)
            }
        } else {
            # Render items
            for ($i = $startIndex; $i -lt $endIndex; $i++) {
                $item = $this._filteredItems[$i]
                $y = $contentY + ($i - $startIndex)
                
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                    $sb.Append($bgColor)
                }
                
                # Get display text
                $displayText = if ($this.ItemRenderer) {
                    & $this.ItemRenderer $item
                } else {
                    $this.GetSearchableText($item)
                }
                
                # Highlight search terms
                if (-not [string]::IsNullOrEmpty($this.SearchQuery) -and $displayText) {
                    $displayText = $this.HighlightSearchTerms($displayText, $highlightColor, $normalColor)
                }
                
                # Pad and truncate to fit
                if ($displayText.Length -gt $contentWidth) {
                    $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
                }
                $displayLine = if ($contentWidth -le 0) { "" } else { $displayText.PadRight($contentWidth).Substring(0, $contentWidth) }
                $sb.Append($displayLine)
                
                # Side borders
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [string] HighlightSearchTerms([string]$text, [string]$highlightColor, [string]$normalColor) {
        if ([string]::IsNullOrEmpty($this.SearchQuery)) {
            return $text
        }
        
        # Simple highlighting - replace matches with colored versions
        try {
            $query = $this.SearchQuery
            if (-not $this.CaseSensitive) {
                # Case-insensitive replacement
                return [regex]::Replace($text, [regex]::Escape($query), "$highlightColor`$0$normalColor", [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
            } else {
                return $text.Replace($query, "$highlightColor$query$normalColor")
            }
        } catch {
            # If highlighting fails, return original text
            return $text
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        # Search mode input
        if ($this._searchMode) {
            switch ($key.Key) {
                ([System.ConsoleKey]::Escape) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Backspace) {
                    if ($this.SearchQuery.Length -gt 0) {
                        $this.SetSearchQuery($this.SearchQuery.Substring(0, $this.SearchQuery.Length - 1))
                    }
                    $handled = $true
                }
                default {
                    if ($key.KeyChar -ge 32 -and $key.KeyChar -lt 127) {  # Printable characters
                        $this.SetSearchQuery($this.SearchQuery + $key.KeyChar)
                        $handled = $true
                    }
                }
            }
        } else {
            # Normal navigation mode
            switch ($key.Key) {
                ([System.ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this._filteredItems.Count - 1) {
                        $this.SelectedIndex++
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::PageUp) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::PageDown) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Min($this._filteredItems.Count - 1, $this.SelectedIndex + $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::Home) {
                    $this.SelectedIndex = 0
                    $handled = $true
                }
                ([System.ConsoleKey]::End) {
                    $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
                    $handled = $true
                }
                ([System.ConsoleKey]::F3) {
                    $this.ToggleSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    if ($this.OnItemActivated -and $this._filteredItems.Count -gt 0 -and $this.SelectedIndex -ge 0) {
                        & $this.OnItemActivated $this.GetSelectedItem()
                    }
                    $handled = $true
                }
            }
            
            # Character-based search activation (exclude shortcut keys)
            if (-not $handled -and $key.KeyChar -ge 32 -and $key.KeyChar -lt 127 -and $key.KeyChar -notin $this.ExcludedSearchKeys) {
                $this.SetSearchQuery([string]$key.KeyChar)
                $this.EnterSearchMode()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._searchMode = $false  # Exit search mode when losing focus
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/TabContainer.ps1
# TabContainer.ps1 - Fast tab-based screen switching
# Core component for PRAXIS multi-screen management

class TabContainer : Container {
    [System.Collections.Generic.List[TabItem]]$Tabs
    [int]$ActiveTabIndex = 0
    [int]$TabBarHeight = 2
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_tabCache = @{}
    hidden [string]$_cachedTabBar = ""
    hidden [bool]$_tabBarInvalid = $true
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TabContainer() : base() {
        $this.Tabs = [System.Collections.Generic.List[TabItem]]::new()
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'tab.background' = $this.Theme.GetBgColor("tab.background")
                'tab.active.background' = $this.Theme.GetBgColor("tab.active.background")
                'tab.active.foreground' = $this.Theme.GetColor("tab.active.foreground")
                'tab.active.accent' = $this.Theme.GetColor("tab.active.accent")
                'tab.foreground' = $this.Theme.GetColor("tab.foreground")
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Propagate to all tabs
        foreach ($tab in $this.Tabs) {
            if ($tab.Content -and $tab.Content -is [Screen]) {
                $tab.Content.OnThemeChanged()
            }
        }
    }
    
    # Add a new tab
    [void] AddTab([string]$title, [UIElement]$content) {
        $tab = [TabItem]::new()
        $tab.Title = $title
        $tab.Content = $content
        $tab.ShortcutKey = $this.Tabs.Count + 1  # 1-9 shortcuts
        
        # Initialize the content if it's a Screen
        if ($content -is [Screen] -and $global:ServiceContainer) {
            $content.Initialize($global:ServiceContainer)
            # Tab content should draw their own background
            $content.DrawBackground = $true
        }
        
        $this.Tabs.Add($tab)
        $this._dataVersion++  # Increment on tab change
        $this._tabBarInvalid = $true
        
        # Set as active if first tab
        if ($this.Tabs.Count -eq 1) {
            # Force activation of first tab by temporarily setting ActiveTabIndex to -1
            $oldIndex = $this.ActiveTabIndex
            $this.ActiveTabIndex = -1
            $this.ActivateTab(0)
            # If ActivateTab failed, restore the index
            if ($this.ActiveTabIndex -eq -1) {
                $this.ActiveTabIndex = $oldIndex
            }
        } else {
            # Position but don't add to children yet
            $this.PositionContent($content, $false)
        }
        
        $this.Invalidate()
    }
    
    # Switch to a specific tab
    [void] ActivateTab([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Tabs.Count) { return }
        
        # Don't switch if already on this tab
        if ($index -eq $this.ActiveTabIndex) { return }
        
        $this._dataVersion++  # Increment on tab activation change
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.ActivateTab: Switching from tab $($this.ActiveTabIndex) to tab $index")
        }
        
        # Store old content reference
        $oldContent = $null
        
        # Deactivate current
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $oldTab = $this.Tabs[$this.ActiveTabIndex]
            if ($oldTab.Content) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Removing old tab content: $($oldTab.Title)")
                }
                $oldContent = $oldTab.Content
                $this.RemoveChild($oldTab.Content)
            }
        }
        
        # Activate new
        $this.ActiveTabIndex = $index
        $newTab = $this.Tabs[$index]
        if ($newTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Adding new tab content: $($newTab.Title)")
                $global:Logger.Debug("TabContainer: Content type: $($newTab.Content.GetType().Name)")
                $global:Logger.Debug("TabContainer: Container bounds: X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
            }
            $this.PositionContent($newTab.Content, $true)
            $this.AddChild($newTab.Content)
            if ($newTab.Content -is [Screen]) {
                # Tab content should draw its own background to clear old content
                $newTab.Content.DrawBackground = $true
                $newTab.Content.SetBackgroundColor([VT]::Reset())
                $newTab.Content.OnActivated()
            }
            # Force the new content to invalidate
            $newTab.Content.Invalidate()
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: New content bounds: X=$($newTab.Content.X) Y=$($newTab.Content.Y) W=$($newTab.Content.Width) H=$($newTab.Content.Height)")
            }
        }
        
        # Now safely deactivate old content after UI tree is updated
        if ($oldContent -and $oldContent -is [Screen]) {
            $oldContent.OnDeactivated()
        }
        
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Force parent to redraw completely to clear any artifacts
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
    }
    
    # Position content below tab bar
    hidden [void] PositionContent([UIElement]$content, [bool]$isActive) {
        # Only set bounds if we have valid dimensions
        if ($this.Width -gt 0 -and $this.Height -gt $this.TabBarHeight) {
            $content.SetBounds(
                $this.X,
                $this.Y + $this.TabBarHeight,
                $this.Width,
                $this.Height - $this.TabBarHeight
            )
        }
    }
    
    # Layout management
    [void] OnBoundsChanged() {
        # Update tab bar cache
        $this._tabBarInvalid = $true
        
        # Update active content bounds
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $activeTab = $this.Tabs[$this.ActiveTabIndex]
            if ($activeTab.Content) {
                $this.PositionContent($activeTab.Content, $true)
            }
        }
    }
    
    # Render the tab container
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: tabBarInvalid=$($this._tabBarInvalid), Children.Count=$($this.Children.Count)")
        }
        
        $sb = Get-PooledStringBuilder 2048
        
        # Render tab bar
        if ($this._tabBarInvalid) {
            $this.RebuildTabBar()
        }
        $sb.Append($this._cachedTabBar)
        
        # Render active content (base class handles children)
        $baseRender = ([Container]$this).OnRender()
        $sb.Append($baseRender)
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: Children.Count = $($this.Children.Count), baseRender.Length = $($baseRender.Length)")
            if ($this.Children.Count -gt 0) {
                $global:Logger.Debug("TabContainer.OnRender: First child type = $($this.Children[0].GetType().Name)")
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Build the tab bar
    hidden [void] RebuildTabBar() {
        $sb = Get-PooledStringBuilder 1024
        
        # Tab bar background
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this._colors['tab.background'])
        $sb.Append([StringCache]::GetSpaces($this.Width))
        
        # Draw tabs
        $x = $this.X + 1
        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {
            $tab = $this.Tabs[$i]
            $title = $tab.Title
            
            # Add shortcut hint if applicable
            if ($tab.ShortcutKey -ge 1 -and $tab.ShortcutKey -le 9) {
                $title = "$($tab.ShortcutKey):$title"
            }
            
            # Calculate tab width
            $tabWidth = $title.Length + 4  # Padding
            
            # Don't draw if it would overflow
            if (($x + $tabWidth) -gt ($this.X + $this.Width - 1)) {
                break
            }
            
            $sb.Append([VT]::MoveTo($x, $this.Y))
            
            # Tab styling
            if ($i -eq $this.ActiveTabIndex) {
                # Active tab
                $sb.Append($this._colors['tab.active.background'])
                $sb.Append($this._colors['tab.active.foreground'])
                $sb.Append(" $title ")
                
                # Bottom accent line
                $sb.Append([VT]::MoveTo($x, $this.Y + 1))
                $sb.Append($this._colors['tab.active.accent'])
                $sb.Append([StringCache]::GetHorizontalLine($tabWidth - 2))
            } else {
                # Inactive tab
                $sb.Append($this._colors['tab.background'])
                $sb.Append($this._colors['tab.foreground'])
                $sb.Append(" $title ")
            }
            
            $x += $tabWidth + 1
        }
        
        # Reset and draw separator line
        $sb.Append([VT]::Reset())
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append($this._colors['border'])
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        $sb.Append([VT]::Reset())
        
        $this._cachedTabBar = $sb.ToString()
        Return-PooledStringBuilder $sb
        $this._tabBarInvalid = $false
    }
    
    # Handle keyboard input
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Debug logging removed for performance
        
        # Check TabContainer shortcuts FIRST before passing to children
        
        # Number keys for quick tab switching
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            $tabIndex = [int]$key.KeyChar - [int][char]'1'
            if ($tabIndex -lt $this.Tabs.Count) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Switching to tab $($tabIndex + 1)")
                }
                $this.ActivateTab($tabIndex)
                return $true
            }
        }
        
        # Ctrl+Tab / Ctrl+Shift+Tab for cycling
        if ($key.Key -eq [System.ConsoleKey]::Tab -and 
            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.PreviousTab()
            } else {
                $this.NextTab()
            }
            return $true
        }
        
        # Alt+Left/Right for navigation
        if ($key.Modifiers -band [System.ConsoleModifiers]::Alt) {
            if ($key.Key -eq [System.ConsoleKey]::LeftArrow) {
                $this.PreviousTab()
                return $true
            } elseif ($key.Key -eq [System.ConsoleKey]::RightArrow) {
                $this.NextTab()
                return $true
            }
        }
        
        # Route to active tab's content if tab switching didn't handle it
        $activeTab = $this.GetActiveTab()
        if ($activeTab -and $activeTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Routing input to active tab content: $($activeTab.Content.GetType().Name)")
            }
            if ($activeTab.Content.HandleInput($key)) {
                return $true
            }
        }
        
        # No one handled it
        return $false
    }
    
    # Navigation helpers
    [void] NextTab() {
        if ($this.Tabs.Count -gt 0) {
            $next = ($this.ActiveTabIndex + 1) % $this.Tabs.Count
            $this.ActivateTab($next)
        }
    }
    
    [void] PreviousTab() {
        if ($this.Tabs.Count -gt 0) {
            $prev = $this.ActiveTabIndex - 1
            if ($prev -lt 0) { $prev = $this.Tabs.Count - 1 }
            $this.ActivateTab($prev)
        }
    }
    
    # Get active tab
    [TabItem] GetActiveTab() {
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            return $this.Tabs[$this.ActiveTabIndex]
        }
        return $null
    }
}

# Tab item class
class TabItem {
    [string]$Title = "Tab"
    [UIElement]$Content = $null
    [int]$ShortcutKey = 0
}


####\_Backup/20250726_003635/Components/TextBox.ps1
# TextBox.ps1 - Fast text input component
# Adapted from AxiomPhoenix with string-based rendering

class TextBox : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [bool]$ShowBorder = $true
    [bool]$ShowCursor = $true
    [scriptblock]$OnChange = {}
    [scriptblock]$OnSubmit = {}
    
    hidden [int]$_scrollOffset = 0
    hidden [string]$_cachedRender = ""
    hidden [bool]$_needsRender = $true
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TextBox() : base() {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3  # Border + content + border
    }
    
    [void] OnInitialize() {
        if ($this.ServiceContainer) {
            $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
            if ($this.Theme) {
                $this.Theme.Subscribe({ $this.OnThemeChanged() })
                $this.OnThemeChanged()
            }
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'input.focused.border' = $this.Theme.GetColor("input.focused.border")
                'input.border' = $this.Theme.GetColor("input.border")
                'input.background' = $this.Theme.GetBgColor("input.background")
                'input.foreground' = $this.Theme.GetColor("input.foreground")
                'input.placeholder' = $this.Theme.GetColor("input.placeholder")
            }
        }
        $this._dataVersion++  # Increment for theme change
        $this._needsRender = $true
        $this.Invalidate()
    }
    
    [string] OnRender() {
        if (-not $this._needsRender) {
            return $this._cachedRender
        }
        
        $sb = Get-PooledStringBuilder 512  # TextBox typically needs moderate capacity
        
        # Colors based on focus state
        $borderColor = if ($this.IsFocused) {
            $this._colors['input.focused.border']
        } else {
            $this._colors['input.border']
        }
        $bgColor = $this._colors['input.background']
        $fgColor = $this._colors['input.foreground']
        $placeholderColor = $this._colors['input.placeholder']
        
        # Content area
        $contentY = $this.Y + 1
        $contentStartX = $this.X + 1
        $contentWidth = $this.Width - 2
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            
            # Middle line with content
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append([VT]::V())
            
            # Clear content area
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            # Right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + 2))
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        } else {
            # Just clear the content area
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
            $contentY = $this.Y
            $contentStartX = $this.X
            $contentWidth = $this.Width
        }
        
        # Render text or placeholder
        $sb.Append([VT]::MoveTo($contentStartX, $contentY))
        
        if ($this.Text.Length -eq 0 -and -not [string]::IsNullOrEmpty($this.Placeholder)) {
            # Show placeholder
            $sb.Append($placeholderColor)
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth)
            } else {
                $this.Placeholder
            }
            $sb.Append($placeholderText)
        } else {
            # Calculate scroll offset to keep cursor in view
            if ($this.CursorPosition -lt $this._scrollOffset) {
                $this._scrollOffset = $this.CursorPosition
            } elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
            }
            
            # Draw visible portion of text
            $sb.Append($fgColor)
            if ($this.Text.Length -gt $this._scrollOffset) {
                $len = [Math]::Min($contentWidth, $this.Text.Length - $this._scrollOffset)
                $visibleText = $this.Text.Substring($this._scrollOffset, $len)
                $sb.Append($visibleText)
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this.ShowCursor) {
                $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                    $cursorX = $contentStartX + $cursorScreenPos
                    $sb.Append([VT]::MoveTo($cursorX, $contentY))
                    
                    # Reverse video for cursor
                    $charUnderCursor = if ($this.CursorPosition -lt $this.Text.Length) {
                        $this.Text[$this.CursorPosition]
                    } else {
                        ' '
                    }
                    
                    $sb.Append($bgColor)  # Swap colors for cursor
                    if ($this._colors['input.foreground']) {
                        # Create a background color from foreground color
                        $sb.Append("`e[48;2;255;255;255m")  # White background for cursor
                    }
                    $sb.Append($charUnderCursor)
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._needsRender = $false
        return $this._cachedRender
    }
    
    [void] OnGotFocus() {
        $this.ShowCursor = $true
        $this._dataVersion++  # Increment for focus change
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnGotFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [void] OnLostFocus() {
        $this.ShowCursor = $false
        $this._dataVersion++  # Increment for focus change
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnLostFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $oldText = $this.Text
            
            switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                    $this._dataVersion++  # Increment for cursor move
                }
            }
            ([System.ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                    $this._dataVersion++  # Increment for cursor move
                }
            }
            ([System.ConsoleKey]::Home) {
                $this.CursorPosition = 0
                $this._dataVersion++  # Increment for cursor move
            }
            ([System.ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
                $this._dataVersion++  # Increment for cursor move
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            ([System.ConsoleKey]::Enter) {
                try {
                    if ($this.OnSubmit) {
                        & $this.OnSubmit $this.Text
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("TextBox.HandleInput: Error executing OnSubmit handler - $($_.Exception.Message)")
                    }
                }
            }
            ([System.ConsoleKey]::Tab) {
                # Don't handle Tab - let parent handle focus navigation
                $handled = $false
            }
            ([System.ConsoleKey]::Escape) {
                # Don't handle Escape - let parent handle it
                $handled = $false
            }
            default {
                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
            if ($handled) {
                # Increment version if text was modified
                if ($oldText -ne $this.Text) {
                    $this._dataVersion++
                }
                
                # Call OnChange if text was modified
                if ($oldText -ne $this.Text -and $this.OnChange) {
                    try {
                        & $this.OnChange $this.Text
                    } catch {
                        if ($global:Logger) {
                            $global:Logger.Error("TextBox.HandleInput: Error executing OnChange handler - $($_.Exception.Message)")
                        }
                    }
                }
                $this._needsRender = $true
                $this.Invalidate()
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TextBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Helper methods
    [void] SetText([string]$text) {
        if ($text.Length -le $this.MaxLength) {
            $this.Text = $text
            $this.CursorPosition = $text.Length
            $this._dataVersion++  # Increment on text change
            $this._needsRender = $true
            $this.Invalidate()
        }
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this._scrollOffset = 0
        $this._needsRender = $true
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/TreeView.ps1
# TreeView.ps1 - Hierarchical tree view component based on ALCAR patterns
# Fast string-based rendering with expand/collapse functionality

class TreeNode {
    [string]$Id
    [object]$Data
    [TreeNode]$Parent
    [System.Collections.ArrayList]$Children
    [bool]$IsExpanded = $true
    [int]$Level = 0
    [string]$DisplayText
    
    TreeNode() {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
    }
    
    TreeNode([string]$displayText) {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
        $this.DisplayText = $displayText
    }
    
    TreeNode([string]$displayText, [object]$data) {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
        $this.DisplayText = $displayText
        $this.Data = $data
    }
    
    [void] AddChild([TreeNode]$child) {
        $child.Parent = $this
        $this.Children.Add($child) | Out-Null
        $this.UpdateLevels()
    }
    
    [void] RemoveChild([TreeNode]$child) {
        $this.Children.Remove($child)
        $child.Parent = $null
    }
    
    [void] UpdateLevels() {
        # Recursively update all child levels
        foreach ($child in $this.Children) {
            $child.Level = $this.Level + 1
            $child.UpdateLevels()
        }
    }
    
    [bool] HasChildren() {
        return $this.Children.Count -gt 0
    }
}

class TreeView : UIElement {
    [System.Collections.ArrayList]$Nodes
    [System.Collections.ArrayList]$_flatView  # Flattened display view
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnNodeExpanded = {}
    [scriptblock]$OnNodeCollapsed = {}
    
    # Visual settings
    [string]$ExpandedIcon = ""
    [string]$CollapsedIcon = ""
    [string]$LeafIcon = ""
    [int]$IndentSize = 2
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TreeView() : base() {
        $this.Nodes = [System.Collections.ArrayList]::new()
        $this._flatView = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.RebuildFlatView()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [TreeNode] AddRootNode([string]$displayText) {
        $node = [TreeNode]::new($displayText)
        $node.Level = 0
        $this.Nodes.Add($node) | Out-Null
        $this._dataVersion++  # Increment on data change
        $this.RebuildFlatView()
        return $node
    }
    
    [TreeNode] AddRootNode([string]$displayText, [object]$data) {
        $node = [TreeNode]::new($displayText, $data)
        $node.Level = 0
        $this.Nodes.Add($node) | Out-Null
        $this._dataVersion++  # Increment on data change
        $this.RebuildFlatView()
        return $node
    }
    
    [void] Clear() {
        $this.Nodes.Clear()
        $this._flatView.Clear()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on data change
        $this.Invalidate()
    }
    
    [TreeNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SetSelectedNode([TreeNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].Id -eq $node.Id) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] ToggleExpanded([TreeNode]$node) {
        if (-not $node.HasChildren()) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        $this.RebuildFlatView()
        
        # Fire events
        if ($node.IsExpanded -and $this.OnNodeExpanded) {
            & $this.OnNodeExpanded $node
        } elseif (-not $node.IsExpanded -and $this.OnNodeCollapsed) {
            & $this.OnNodeCollapsed $node
        }
        
        # Maintain selection on the same node
        $this.SetSelectedNode($node)
    }
    
    [void] ExpandAll() {
        $this.SetAllExpanded($true)
    }
    
    [void] CollapseAll() {
        $this.SetAllExpanded($false)
    }
    
    [void] SetAllExpanded([bool]$expanded) {
        foreach ($node in $this.Nodes) {
            $this.SetNodeExpanded($node, $expanded)
        }
        $this.RebuildFlatView()
        $this.Invalidate()
    }
    
    [void] SetNodeExpanded([TreeNode]$node, [bool]$expanded) {
        if ($node.HasChildren()) {
            $node.IsExpanded = $expanded
        }
        foreach ($child in $node.Children) {
            $this.SetNodeExpanded($child, $expanded)
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        foreach ($node in $this.Nodes) {
            $this.AddNodeToFlatView($node)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([TreeNode]$node) {
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 4096  # TreeView can have many nodes
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render tree nodes
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for selected item
            if ($i -eq $this.SelectedIndex) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Indentation
            $line += [StringCache]::GetSpaces($node.Level * $this.IndentSize)
            
            # Tree icon
            if ($node.HasChildren()) {
                $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
            } else {
                $line += $this.LeafIcon + " "
            }
            
            # Node text
            $line += $node.DisplayText
            
            # Pad and truncate to fit
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            if ($this.ShowBorder) {
                # Side borders
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3  # Approximate visible lines
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3  # Approximate visible lines
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $node = $this.GetSelectedNode()
                if ($node -and $node.HasChildren()) {
                    $this.ToggleExpanded($node)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Spacebar) {
                $node = $this.GetSelectedNode()
                if ($node -and $node.HasChildren()) {
                    $this.ToggleExpanded($node)
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\_Backup/20250726_003635/Components/VerticalSplit.ps1
# VerticalSplit.ps1 - Fast vertical layout component for PRAXIS

class VerticalSplit : Container {
    [UIElement]$TopPane
    [UIElement]$BottomPane
    [int]$SplitRatio = 50  # Percentage for top pane (0-100)
    [int]$MinPaneHeight = 3
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedTopHeight = 0
    hidden [int]$_cachedBottomHeight = 0
    hidden [int]$_cachedBottomY = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastSplitRatio = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    VerticalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    [void] SetTopPane([UIElement]$pane) {
        if ($this.TopPane) {
            $this.RemoveChild($this.TopPane)
        }
        $this.TopPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetBottomPane([UIElement]$pane) {
        if ($this.BottomPane) {
            $this.RemoveChild($this.BottomPane)
        }
        $this.BottomPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastHeight -eq $this.Height -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalHeight = $this.Height
        $topHeight = [int](($totalHeight * $this.SplitRatio) / 100)
        $topHeight = [Math]::Max($this.MinPaneHeight, [Math]::Min($topHeight, $totalHeight - $this.MinPaneHeight))
        $bottomHeight = $totalHeight - $topHeight
        $bottomY = $this.Y + $topHeight
        
        # Update top pane
        if ($this.TopPane) {
            $this.TopPane.SetBounds($this.X, $this.Y, $this.Width, $topHeight)
        }
        
        # Update bottom pane
        if ($this.BottomPane) {
            $this.BottomPane.SetBounds($this.X, $bottomY, $this.Width, $bottomHeight)
        }
        
        # Cache the layout
        $this._cachedTopHeight = $topHeight
        $this._cachedBottomHeight = $bottomHeight
        $this._cachedBottomY = $bottomY
        $this._lastHeight = $this.Height
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 1024
        
        # Render children
        if ($this.TopPane -and $this.TopPane.Visible) {
            $sb.Append($this.TopPane.Render())
        }
        
        if ($this.BottomPane -and $this.BottomPane.Visible) {
            $sb.Append($this.BottomPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedTopHeight -gt 0) {
            $borderColor = $this._colors['border']
            $sb.Append([VT]::MoveTo($this.X, $this._cachedBottomY - 1))
            $sb.Append($borderColor)
            $sb.Append([StringCache]::GetHorizontalLine($this.Width))
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.TopPane -and $this.TopPane.IsFocused) {
            if ($this.TopPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.BottomPane -and $this.BottomPane.IsFocused) {
            if ($this.BottomPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetTopFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetBottomFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetTopPane() { return $this.TopPane }
    [UIElement] GetBottomPane() { return $this.BottomPane }
    
    # Focus management
    [void] FocusTopPane() {
        if ($this.TopPane -and $this.TopPane.IsFocusable) {
            $this.TopPane.Focus()
        }
    }
    
    [void] FocusBottomPane() {
        if ($this.BottomPane -and $this.BottomPane.IsFocusable) {
            $this.BottomPane.Focus()
        }
    }
}


####\_Backup/20250726_003635/Core/DocumentBuffer.ps1
# DocumentBuffer.ps1 - Model class for text editor content
# Implements Buffer/View separation - this class knows nothing about UI

class DocumentBuffer {
    # Text content storage (Phase 1: ArrayList, Phase 3: Gap Buffer)
    hidden [System.Collections.ArrayList]$Lines
    
    # Command-based undo/redo system
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [int]$_maxUndoHistory = 1000
    
    # File state
    [string]$FilePath = ""
    [bool]$IsModified = $false
    [datetime]$LastModified = [datetime]::MinValue
    
    # Change tracking for render optimization
    hidden [System.Collections.Generic.HashSet[int]]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Events for UI updates
    [scriptblock]$OnContentChanged = {}
    [scriptblock]$OnModifiedStateChanged = {}
    
    DocumentBuffer() {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null  # Always have at least one empty line
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    DocumentBuffer([string]$filePath) {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.FilePath = $filePath
        $this.LoadFromFile($filePath)
    }
    
    # --- Public API for TextEditorScreen ---
    
    [string] GetLine([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Lines.Count) {
            return ""
        }
        return $this.Lines[$index]
    }
    
    [int] GetLineCount() {
        return $this.Lines.Count
    }
    
    [bool] IsLineDirty([int]$line) {
        return $this._allLinesDirty -or $this._dirtyLines.Contains($line)
    }
    
    [void] ClearDirtyLines() {
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
    }
    
    [void] ExecuteCommand([object]$command) {
        $command.Execute($this)
        $this.AddToUndoStack($command)
        $this.SetModified($true)
        $this.NotifyContentChanged()
    }
    
    [bool] CanUndo() {
        return $this._undoStack.Count -gt 0
    }
    
    [bool] CanRedo() {
        return $this._redoStack.Count -gt 0
    }
    
    [void] ClearUndoHistory() {
        $this._undoStack.Clear()
        $this._redoStack.Clear()
    }
    
    [void] Undo() {
        if ($this._undoStack.Count -eq 0) { return }
        
        try {
            $command = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            $command.Undo($this)
            $this._redoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this._allLinesDirty = $true  # Mark all lines dirty after undo
            $this.NotifyContentChanged()
        } catch {
            # If undo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Undo failed: $($_.Exception.Message)")
            }
            # Don't add the failed command to redo stack
        }
    }
    
    [void] Redo() {
        if ($this._redoStack.Count -eq 0) { return }
        
        try {
            $command = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            $command.Execute($this)
            $this._undoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this._allLinesDirty = $true  # Mark all lines dirty after redo
            $this.NotifyContentChanged()
        } catch {
            # If redo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Redo failed: $($_.Exception.Message)")
            }
            # Don't add the failed command to undo stack
        }
    }
    
    [void] LoadFromFile([string]$filePath) {
        if (-not (Test-Path $filePath)) {
            # File doesn't exist, start with empty content
            $this.Lines.Clear()
            $this.Lines.Add("") | Out-Null
            $this.SetModified($false)
            return
        }
        
        try {
            $content = Get-Content $filePath -Raw
            if ($content) {
                $lineArray = $content -split "`r?`n"
                $this.Lines.Clear()
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
                # Ensure we always have at least one line
                if ($this.Lines.Count -eq 0) {
                    $this.Lines.Add("") | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.SetModified($false)
            $this.LastModified = (Get-Item $filePath).LastWriteTime
            $this._allLinesDirty = $true
        } catch {
            throw "Failed to load file '$filePath': $($_.Exception.Message)"
        }
    }
    
    [void] SaveToFile([string]$filePath = "") {
        if ([string]::IsNullOrEmpty($filePath)) {
            $saveFilePath = $this.FilePath
        } else {
            $saveFilePath = $filePath
        }
        if ([string]::IsNullOrEmpty($saveFilePath)) {
            throw "No file path specified for save"
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $saveFilePath -Value $content -NoNewline
            $this.FilePath = $saveFilePath
            $this.SetModified($false)
            $this.LastModified = [datetime]::Now
        } catch {
            throw "Failed to save file '$saveFilePath': $($_.Exception.Message)"
        }
    }
    
    # --- Internal Text Manipulation Methods (Called by Commands) ---
    
    [void] InsertTextAt([int]$line, [int]$col, [string]$text) {
        if ($line -lt 0) { return }
        $this.EnsureLineExists($line)
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $this.Lines[$line] = $currentLine.Insert($col, $text)
        $this._dirtyLines.Add($line) | Out-Null
    }
    
    [void] DeleteTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $line -ge $this.Lines.Count) { return }
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $length = [Math]::Min($length, $currentLine.Length - $col)
        if ($length -gt 0) {
            $this.Lines[$line] = $currentLine.Remove($col, $length)
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] InsertNewlineAt([int]$line, [int]$col) {
        if ($line -lt 0) { return }
        $this.EnsureLineExists($line)
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        
        $leftPart = $currentLine.Substring(0, $col)
        $rightPart = $currentLine.Substring($col)
        
        $this.Lines[$line] = $leftPart
        $this.Lines.Insert($line + 1, $rightPart)
        
        # Mark affected lines as dirty
        $this._dirtyLines.Add($line) | Out-Null
        $this._dirtyLines.Add($line + 1) | Out-Null
        # All lines after the insert point shift, so mark all dirty
        $this._allLinesDirty = $true
    }
    
    [void] JoinLinesAt([int]$line, [string]$separator = "") {
        if ($line -lt 0 -or $line -ge $this.Lines.Count -or $line + 1 -ge $this.Lines.Count) {
            return  # Can't join if invalid line or no next line
        }
        
        $currentLine = $this.Lines[$line]
        $nextLine = $this.Lines[$line + 1]
        $this.Lines[$line] = $currentLine + $separator + $nextLine
        $this.Lines.RemoveAt($line + 1)
        
        # Mark affected line as dirty
        $this._dirtyLines.Add($line) | Out-Null
        # All lines after the removal shift, so mark all dirty
        $this._allLinesDirty = $true
    }
    
    [string] GetTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $line -ge $this.Lines.Count) { return "" }
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $length = [Math]::Min($length, $currentLine.Length - $col)
        if ($length -le 0) {
            return ""
        }
        return $currentLine.Substring($col, $length)
    }
    
    # --- Private Helper Methods ---
    
    hidden [void] EnsureLineExists([int]$line) {
        while ($this.Lines.Count -le $line) {
            $this.Lines.Add("") | Out-Null
        }
    }
    
    hidden [void] AddToUndoStack([object]$command) {
        $this._undoStack.Add($command) | Out-Null
        if ($this._undoStack.Count -gt $this._maxUndoHistory) {
            $this._undoStack.RemoveAt(0)
        }
        # A new action clears the redo stack
        $this._redoStack.Clear()
    }
    
    hidden [void] SetModified([bool]$modified) {
        if ($this.IsModified -ne $modified) {
            $this.IsModified = $modified
            if ($this.OnModifiedStateChanged) {
                & $this.OnModifiedStateChanged $modified
            }
        }
    }
    
    hidden [void] NotifyContentChanged() {
        if ($this.OnContentChanged) {
            & $this.OnContentChanged
        }
    }
}


####\_Backup/20250726_003635/Core/EditorCommands.ps1
# EditorCommands.ps1 - Command Pattern implementation for text editor
# Provides robust undo/redo system using Command Pattern design

# Base interface for all editor commands
class IEditorCommand {
    [void] Execute([object]$buffer) { 
        throw "Execute method must be implemented by derived classes"
    }
    [void] Undo([object]$buffer) { 
        throw "Undo method must be implemented by derived classes"
    }
    [string] GetDescription() {
        return $this.GetType().Name
    }
}

# Command for inserting text at a specific position
class InsertTextCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$Text
    
    InsertTextCommand([int]$line, [int]$col, [string]$text) {
        $this.Line = $line
        $this.Col = $col
        $this.Text = $text
    }
    
    [void] Execute([object]$buffer) {
        $buffer.InsertTextAt($this.Line, $this.Col, $this.Text)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.DeleteTextAt($this.Line, $this.Col, $this.Text.Length)
    }
    
    [string] GetDescription() {
        return "Insert '$($this.Text)' at ($($this.Line),$($this.Col))"
    }
}

# Command for deleting text at a specific position
class DeleteTextCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$DeletedText  # Stores the text that was deleted for undo
    [int]$Length
    
    DeleteTextCommand([int]$line, [int]$col, [string]$deletedText) {
        $this.Line = $line
        $this.Col = $col
        $this.DeletedText = $deletedText
        $this.Length = $deletedText.Length
    }
    
    [void] Execute([object]$buffer) {
        $buffer.DeleteTextAt($this.Line, $this.Col, $this.Length)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.InsertTextAt($this.Line, $this.Col, $this.DeletedText)
    }
    
    [string] GetDescription() {
        return "Delete '$($this.DeletedText)' at ($($this.Line),$($this.Col))"
    }
}

# Command for inserting a new line
class InsertNewlineCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$SplitRightText = ""  # Text moved to new line when splitting
    
    InsertNewlineCommand([int]$line, [int]$col, [string]$splitRightText = "") {
        $this.Line = $line
        $this.Col = $col
        $this.SplitRightText = $splitRightText
    }
    
    [void] Execute([object]$buffer) {
        $buffer.InsertNewlineAt($this.Line, $this.Col)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.JoinLinesAt($this.Line, $this.SplitRightText)
    }
    
    [string] GetDescription() {
        return "Insert newline at ($($this.Line),$($this.Col))"
    }
}

# Command for joining two lines (opposite of newline)
class JoinLinesCommand : IEditorCommand {
    [int]$Line
    [string]$JoinedText  # Text from the next line that was joined
    
    JoinLinesCommand([int]$line, [string]$joinedText) {
        $this.Line = $line
        $this.JoinedText = $joinedText
    }
    
    [void] Execute([object]$buffer) {
        $buffer.JoinLinesAt($this.Line, "")
    }
    
    [void] Undo([object]$buffer) {
        # Find the split position and insert newline
        $currentLine = $buffer.GetLine($this.Line)
        $splitPos = $currentLine.Length - $this.JoinedText.Length
        $buffer.InsertNewlineAt($this.Line, $splitPos)
    }
    
    [string] GetDescription() {
        return "Join lines at $($this.Line)"
    }
}

# Composite command for grouping multiple commands into one undo unit
class CompositeCommand : IEditorCommand {
    [System.Collections.ArrayList]$Commands
    [string]$Description
    
    CompositeCommand([string]$description) {
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.Description = $description
    }
    
    [void] AddCommand([object]$command) {
        $this.Commands.Add($command) | Out-Null
    }
    
    [void] Execute([object]$buffer) {
        foreach ($command in $this.Commands) {
            $command.Execute($buffer)
        }
    }
    
    [void] Undo([object]$buffer) {
        # Undo in reverse order
        for ($i = $this.Commands.Count - 1; $i -ge 0; $i--) {
            $this.Commands[$i].Undo($buffer)
        }
    }
    
    [string] GetDescription() {
        return $this.Description
    }
}


####\_Backup/20250726_003635/Core/GapBuffer.ps1
# GapBuffer.ps1 - High-performance text buffer for editing operations
# Uses a gap buffer data structure for optimal performance on typical editing patterns

class GapBuffer {
    # Internal buffer with gap
    hidden [char[]]$_buffer
    hidden [int]$_gapStart
    hidden [int]$_gapEnd
    hidden [int]$_capacity
    
    # Buffer growth parameters
    hidden [int]$_initialCapacity = 1024
    hidden [double]$_growthFactor = 1.5
    hidden [int]$_minGapSize = 128
    
    # Statistics for debugging/optimization
    [int]$InsertCount = 0
    [int]$DeleteCount = 0
    [int]$MoveCount = 0
    [int]$GrowCount = 0
    
    GapBuffer() {
        $this._capacity = $this._initialCapacity
        $this._buffer = [char[]]::new($this._capacity)
        $this._gapStart = 0
        $this._gapEnd = $this._capacity
    }
    
    GapBuffer([int]$initialCapacity) {
        $this._capacity = [Math]::Max($initialCapacity, $this._minGapSize)
        $this._buffer = [char[]]::new($this._capacity)
        $this._gapStart = 0
        $this._gapEnd = $this._capacity
    }
    
    GapBuffer([string]$text) {
        $textLength = $text.Length
        $this._capacity = [Math]::Max($textLength + $this._minGapSize, $this._initialCapacity)
        $this._buffer = [char[]]::new($this._capacity)
        
        # Copy text to buffer
        if ($textLength -gt 0) {
            [array]::Copy($text.ToCharArray(), 0, $this._buffer, 0, $textLength)
        }
        
        $this._gapStart = $textLength
        $this._gapEnd = $this._capacity
    }
    
    # --- Public Properties ---
    
    [int] GetLength() {
        return $this._capacity - ($this._gapEnd - $this._gapStart)
    }
    
    [int] GetCapacity() {
        return $this._capacity
    }
    
    [int] GetGapSize() {
        return $this._gapEnd - $this._gapStart
    }
    
    # --- Core Operations ---
    
    [void] MoveGapTo([int]$position) {
        if ($position -lt 0 -or $position -gt $this.GetLength()) {
            throw "Position $position is out of range (0-$($this.GetLength()))"
        }
        
        if ($position -eq $this._gapStart) {
            return  # Gap is already at the correct position
        }
        
        $this.MoveCount++
        
        if ($position -lt $this._gapStart) {
            # Move gap left - shift text right
            $moveSize = $this._gapStart - $position
            $sourceStart = $position
            $destStart = $this._gapEnd - $moveSize
            
            [array]::Copy($this._buffer, $sourceStart, $this._buffer, $destStart, $moveSize)
            
            $this._gapStart = $position
            $this._gapEnd -= $moveSize
        } else {
            # Move gap right - shift text left
            $moveSize = $position - $this._gapStart
            $sourceStart = $this._gapEnd
            $destStart = $this._gapStart
            
            [array]::Copy($this._buffer, $sourceStart, $this._buffer, $destStart, $moveSize)
            
            $this._gapStart = $position
            $this._gapEnd += $moveSize
        }
    }
    
    [void] EnsureGapSize([int]$minSize) {
        $currentGapSize = $this._gapEnd - $this._gapStart
        if ($currentGapSize -ge $minSize) {
            return  # Gap is already large enough
        }
        
        # Calculate new capacity
        $currentLength = $this.GetLength()
        $neededCapacity = $currentLength + $minSize
        $newCapacity = [Math]::Max([int]($this._capacity * $this._growthFactor), $neededCapacity)
        
        $this.GrowCount++
        
        # Create new buffer
        $newBuffer = [char[]]::new($newCapacity)
        
        # Copy text before gap
        if ($this._gapStart -gt 0) {
            [array]::Copy($this._buffer, 0, $newBuffer, 0, $this._gapStart)
        }
        
        # Copy text after gap
        $textAfterGap = $this._capacity - $this._gapEnd
        if ($textAfterGap -gt 0) {
            $newGapEnd = $newCapacity - $textAfterGap
            [array]::Copy($this._buffer, $this._gapEnd, $newBuffer, $newGapEnd, $textAfterGap)
            $this._gapEnd = $newGapEnd
        } else {
            $this._gapEnd = $newCapacity
        }
        
        $this._buffer = $newBuffer
        $this._capacity = $newCapacity
    }
    
    # --- Text Operations ---
    
    [void] Insert([int]$position, [char]$char) {
        $this.MoveGapTo($position)
        $this.EnsureGapSize(1)
        
        $this._buffer[$this._gapStart] = $char
        $this._gapStart++
        $this.InsertCount++
    }
    
    [void] Insert([int]$position, [string]$text) {
        if ([string]::IsNullOrEmpty($text)) {
            return
        }
        
        $this.MoveGapTo($position)
        $this.EnsureGapSize($text.Length)
        
        $chars = $text.ToCharArray()
        [array]::Copy($chars, 0, $this._buffer, $this._gapStart, $chars.Length)
        $this._gapStart += $chars.Length
        $this.InsertCount++
    }
    
    [void] Delete([int]$position, [int]$count = 1) {
        if ($count -le 0) {
            return
        }
        
        $length = $this.GetLength()
        if ($position -lt 0 -or $position -ge $length) {
            return  # Position out of bounds
        }
        
        # Clamp count to available characters
        $count = [Math]::Min($count, $length - $position)
        if ($count -le 0) {
            return
        }
        
        $this.MoveGapTo($position)
        
        # Expand gap to include deleted characters
        $this._gapEnd += $count
        $this.DeleteCount++
    }
    
    [char] GetChar([int]$position) {
        $length = $this.GetLength()
        if ($position -lt 0 -or $position -ge $length) {
            return [char]0  # Return null character for out of bounds
        }
        
        if ($position -lt $this._gapStart) {
            return $this._buffer[$position]
        } else {
            return $this._buffer[$position + ($this._gapEnd - $this._gapStart)]
        }
    }
    
    [string] GetText([int]$start, [int]$count) {
        $length = $this.GetLength()
        if ($start -lt 0 -or $start -ge $length -or $count -le 0) {
            return ""
        }
        
        # Clamp count to available characters
        $count = [Math]::Min($count, $length - $start)
        $chars = [char[]]::new($count)
        
        for ($i = 0; $i -lt $count; $i++) {
            $chars[$i] = $this.GetChar($start + $i)
        }
        
        return [string]::new($chars)
    }
    
    [string] GetText() {
        return $this.GetText(0, $this.GetLength())
    }
    
    [string] GetSubstring([int]$start, [int]$length) {
        return $this.GetText($start, $length)
    }
    
    # --- Advanced Operations ---
    
    [void] Clear() {
        $this._gapStart = 0
        $this._gapEnd = $this._capacity
        
        # Optional: Clear the buffer for security
        [array]::Clear($this._buffer, 0, $this._capacity)
    }
    
    [void] SetText([string]$text) {
        $this.Clear()
        if (-not [string]::IsNullOrEmpty($text)) {
            $this.Insert(0, $text)
        }
    }
    
    [int] IndexOf([char]$char, [int]$startIndex = 0) {
        $length = $this.GetLength()
        for ($i = $startIndex; $i -lt $length; $i++) {
            if ($this.GetChar($i) -eq $char) {
                return $i
            }
        }
        return -1
    }
    
    [int] IndexOf([string]$text, [int]$startIndex = 0) {
        if ([string]::IsNullOrEmpty($text)) {
            return -1
        }
        
        $length = $this.GetLength()
        $textLength = $text.Length
        
        for ($i = $startIndex; $i -le $length - $textLength; $i++) {
            $match = $true
            for ($j = 0; $j -lt $textLength; $j++) {
                if ($this.GetChar($i + $j) -ne $text[$j]) {
                    $match = $false
                    break
                }
            }
            if ($match) {
                return $i
            }
        }
        return -1
    }
    
    [int] LastIndexOf([char]$char, [int]$startIndex = -1) {
        $length = $this.GetLength()
        if ($startIndex -eq -1) {
            $startIndex = $length - 1
        }
        
        for ($i = $startIndex; $i -ge 0; $i--) {
            if ($this.GetChar($i) -eq $char) {
                return $i
            }
        }
        return -1
    }
    
    # --- Debugging and Statistics ---
    
    [hashtable] GetStatistics() {
        return @{
            Length = $this.GetLength()
            Capacity = $this._capacity
            GapSize = $this.GetGapSize()
            GapStart = $this._gapStart
            GapEnd = $this._gapEnd
            InsertCount = $this.InsertCount
            DeleteCount = $this.DeleteCount
            MoveCount = $this.MoveCount
            GrowCount = $this.GrowCount
            Efficiency = if ($this.MoveCount -gt 0) { 
                [Math]::Round(($this.InsertCount + $this.DeleteCount) / [double]$this.MoveCount, 2) 
            } else { 
                "N/A" 
            }
        }
    }
    
    [void] ResetStatistics() {
        $this.InsertCount = 0
        $this.DeleteCount = 0
        $this.MoveCount = 0
        $this.GrowCount = 0
    }
    
    [string] ToString() {
        return $this.GetText()
    }
    
    # --- Validation (for debugging) ---
    
    [bool] ValidateStructure() {
        if ($this._gapStart -lt 0 -or $this._gapStart -gt $this._capacity) {
            return $false
        }
        if ($this._gapEnd -lt $this._gapStart -or $this._gapEnd -gt $this._capacity) {
            return $false
        }
        if ($this._capacity -le 0) {
            return $false
        }
        return $true
    }
}


####\_Backup/20250726_003635/Core/GapBufferDocumentBuffer.ps1
# GapBufferDocumentBuffer.ps1 - High-performance document buffer using Gap Buffer
# Drop-in replacement for DocumentBuffer with identical public interface but better performance

class GapBufferDocumentBuffer {
    # Gap buffer for high-performance text storage
    hidden [GapBuffer]$_gapBuffer
    
    # Line index tracking for efficient line operations
    hidden [System.Collections.ArrayList]$_lineStarts
    hidden [bool]$_lineIndexDirty = $true
    
    # Command-based undo/redo system  
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [int]$_maxUndoHistory = 1000
    
    # File state
    [string]$FilePath = ""
    [bool]$IsModified = $false
    [datetime]$LastModified = [datetime]::MinValue
    
    # Change tracking for render optimization
    hidden [System.Collections.Generic.HashSet[int]]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Events for UI updates
    [scriptblock]$OnContentChanged = {}
    [scriptblock]$OnModifiedStateChanged = {}
    
    # Performance tracking
    [int]$LineIndexRebuildCount = 0
    
    GapBufferDocumentBuffer() {
        $this._gapBuffer = [GapBuffer]::new()
        $this._gapBuffer.Insert(0, "`n")  # Start with one empty line
        $this._lineStarts = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.BuildLineIndex()
        $this.UpdateLinesProperty()
    }
    
    GapBufferDocumentBuffer([string]$filePath) {
        $this._gapBuffer = [GapBuffer]::new()
        $this._lineStarts = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.FilePath = $filePath
        $this.LoadFromFile($filePath)
        $this.UpdateLinesProperty()
    }
    
    # --- Line Index Management ---
    
    hidden [void] BuildLineIndex() {
        $this._lineStarts.Clear()
        $this._lineStarts.Add(0) | Out-Null  # First line starts at position 0
        
        $length = $this._gapBuffer.GetLength()
        for ($i = 0; $i -lt $length; $i++) {
            if ($this._gapBuffer.GetChar($i) -eq "`n") {
                $this._lineStarts.Add($i + 1) | Out-Null
            }
        }
        
        $this._lineIndexDirty = $false
        $this.LineIndexRebuildCount++
    }
    
    hidden [void] EnsureLineIndex() {
        if ($this._lineIndexDirty) {
            $this.BuildLineIndex()
        }
    }
    
    hidden [void] InvalidateLineIndex() {
        $this._lineIndexDirty = $true
        $this._allLinesDirty = $true
    }
    
    # --- Public API for TextEditorScreen (Compatible with DocumentBuffer) ---
    
    [string] GetLine([int]$index) {
        $this.EnsureLineIndex()
        
        if ($index -lt 0 -or $index -ge $this._lineStarts.Count) {
            return ""
        }
        
        $lineStart = $this._lineStarts[$index]
        
        # Find line end
        if ($index -eq $this._lineStarts.Count - 1) {
            # Last line - goes to end of buffer
            $lineEnd = $this._gapBuffer.GetLength()
        } else {
            # Line ends at the position before next line start (excluding the newline)
            $lineEnd = $this._lineStarts[$index + 1] - 1
        }
        
        $lineLength = $lineEnd - $lineStart
        if ($lineLength -le 0) {
            return ""
        }
        
        return $this._gapBuffer.GetText($lineStart, $lineLength)
    }
    
    [int] GetLineCount() {
        $this.EnsureLineIndex()
        return $this._lineStarts.Count
    }
    
    [bool] IsLineDirty([int]$line) {
        return $this._allLinesDirty -or $this._dirtyLines.Contains($line)
    }
    
    [void] ClearDirtyLines() {
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
    }
    
    [void] ExecuteCommand([object]$command) {
        $command.Execute($this)
        $this.AddToUndoStack($command)
        $this.SetModified($true)
        $this.NotifyContentChanged()
    }
    
    [bool] CanUndo() {
        return $this._undoStack.Count -gt 0
    }
    
    [bool] CanRedo() {
        return $this._redoStack.Count -gt 0
    }
    
    [void] ClearUndoHistory() {
        $this._undoStack.Clear()
        $this._redoStack.Clear()
    }
    
    [void] Undo() {
        if ($this._undoStack.Count -eq 0) { return }
        
        try {
            $command = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            $command.Undo($this)
            $this._redoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this.InvalidateLineIndex()
            $this.NotifyContentChanged()
        } catch {
            # If undo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Undo failed: $($_.Exception.Message)")
            }
        }
    }
    
    [void] Redo() {
        if ($this._redoStack.Count -eq 0) { return }
        
        try {
            $command = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            $command.Execute($this)
            $this._undoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this.InvalidateLineIndex()
            $this.NotifyContentChanged()
        } catch {
            # If redo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Redo failed: $($_.Exception.Message)")
            }
        }
    }
    
    [void] LoadFromFile([string]$filePath) {
        if (-not (Test-Path $filePath)) {
            # File doesn't exist, start with empty content
            $this._gapBuffer.SetText("`n")
            $this.InvalidateLineIndex()
            $this.SetModified($false)
            return
        }
        
        try {
            $content = Get-Content $filePath -Raw
            if ($content) {
                # Ensure content ends with newline for consistent line handling
                if (-not $content.EndsWith("`n")) {
                    $content += "`n"
                }
                $this._gapBuffer.SetText($content)
            } else {
                $this._gapBuffer.SetText("`n")
            }
            
            $this.InvalidateLineIndex()
            $this.SetModified($false)
            $this.LastModified = (Get-Item $filePath).LastWriteTime
        } catch {
            throw "Failed to load file '$filePath': $($_.Exception.Message)"
        }
    }
    
    [void] SaveToFile([string]$filePath = "") {
        if ([string]::IsNullOrEmpty($filePath)) {
            $saveFilePath = $this.FilePath
        } else {
            $saveFilePath = $filePath
        }
        if ([string]::IsNullOrEmpty($saveFilePath)) {
            throw "No file path specified for save"
        }
        
        try {
            $content = $this._gapBuffer.GetText()
            # Remove trailing newline for cleaner file output
            if ($content.EndsWith("`n")) {
                $content = $content.Substring(0, $content.Length - 1)
            }
            Set-Content -Path $saveFilePath -Value $content -NoNewline
            $this.FilePath = $saveFilePath
            $this.SetModified($false)
            $this.LastModified = [datetime]::Now
        } catch {
            throw "Failed to save file '$saveFilePath': $($_.Exception.Message)"
        }
    }
    
    # --- Internal Text Manipulation Methods (Called by Commands) ---
    
    [void] InsertTextAt([int]$line, [int]$col, [string]$text) {
        if ($line -lt 0) { return }
        if ([string]::IsNullOrEmpty($text)) { return }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            $this._gapBuffer.Insert($position, $text)
            $this.InvalidateLineIndex()
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] DeleteTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $length -le 0) { return }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            $this._gapBuffer.Delete($position, $length)
            $this.InvalidateLineIndex()
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] InsertNewlineAt([int]$line, [int]$col) {
        if ($line -lt 0) { return }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            $this._gapBuffer.Insert($position, "`n")
            $this.InvalidateLineIndex()
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] JoinLinesAt([int]$line, [string]$separator = "") {
        $this.EnsureLineIndex()
        if ($line -lt 0 -or $line -ge $this._lineStarts.Count - 1) {
            return  # Can't join if invalid line or no next line
        }
        
        # Find the newline between the lines and delete it
        $nextLineStart = $this._lineStarts[$line + 1]
        $newlinePos = $nextLineStart - 1
        
        $this._gapBuffer.Delete($newlinePos, 1)
        
        # Insert separator if provided
        if (-not [string]::IsNullOrEmpty($separator)) {
            $this._gapBuffer.Insert($newlinePos, $separator)
        }
        
        $this.InvalidateLineIndex()
        $this._dirtyLines.Add($line) | Out-Null
    }
    
    [string] GetTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $length -le 0) { return "" }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            return $this._gapBuffer.GetText($position, $length)
        }
        return ""
    }
    
    # --- Helper Methods ---
    
    hidden [int] GetBufferPosition([int]$line, [int]$col) {
        $this.EnsureLineIndex()
        
        if ($line -lt 0 -or $line -ge $this._lineStarts.Count) {
            return -1
        }
        
        $lineStart = $this._lineStarts[$line]
        $position = $lineStart + $col
        
        # Clamp position to line bounds
        if ($line -eq $this._lineStarts.Count - 1) {
            # Last line - clamp to buffer end
            $maxPos = $this._gapBuffer.GetLength()
            $position = [Math]::Min($position, $maxPos)
        } else {
            # Clamp to line end (before newline)
            $lineEnd = $this._lineStarts[$line + 1] - 1
            $position = [Math]::Min($position, $lineEnd)
        }
        
        return $position
    }
    
    hidden [void] AddToUndoStack([object]$command) {
        $this._undoStack.Add($command) | Out-Null
        if ($this._undoStack.Count -gt $this._maxUndoHistory) {
            $this._undoStack.RemoveAt(0)
        }
        # A new action clears the redo stack
        $this._redoStack.Clear()
    }
    
    hidden [void] SetModified([bool]$modified) {
        if ($this.IsModified -ne $modified) {
            $this.IsModified = $modified
            if ($this.OnModifiedStateChanged) {
                & $this.OnModifiedStateChanged $modified
            }
        }
        # Update Lines property for compatibility
        $this.UpdateLinesProperty()
    }
    
    hidden [void] NotifyContentChanged() {
        if ($this.OnContentChanged) {
            & $this.OnContentChanged
        }
    }
    
    # --- Performance and Debugging ---
    
    [hashtable] GetStatistics() {
        $gapStats = $this._gapBuffer.GetStatistics()
        return @{
            GapBuffer = $gapStats
            LineCount = $this.GetLineCount()
            LineIndexRebuildCount = $this.LineIndexRebuildCount
            LineIndexDirty = $this._lineIndexDirty
            UndoStackSize = $this._undoStack.Count
            RedoStackSize = $this._redoStack.Count
            DirtyLinesCount = $this._dirtyLines.Count
            AllLinesDirty = $this._allLinesDirty
        }
    }
    
    [void] ResetStatistics() {
        $this._gapBuffer.ResetStatistics()
        $this.LineIndexRebuildCount = 0
    }
    
    # For compatibility with ArrayList-based DocumentBuffer
    [System.Collections.ArrayList] get_Lines() {
        # Return a virtual ArrayList-like interface
        $linesList = [System.Collections.ArrayList]::new()
        $lineCount = $this.GetLineCount()
        for ($i = 0; $i -lt $lineCount; $i++) {
            $linesList.Add($this.GetLine($i)) | Out-Null
        }
        return $linesList
    }
    
    # PowerShell property syntax for Lines
    [System.Collections.ArrayList]$Lines = $null
    
    hidden [void] UpdateLinesProperty() {
        $this.Lines = $this.get_Lines()
    }
}


####\_Backup/20250726_003635/Core/IEditorCommand.ps1
# IEditorCommand.ps1 - Interface for editor commands
# Separate interface to avoid circular dependencies

# Base interface for all editor commands
class IEditorCommand {
    [void] Execute([DocumentBuffer]$buffer) { 
        throw "Execute method must be implemented by derived classes"
    }
    [void] Undo([DocumentBuffer]$buffer) { 
        throw "Undo method must be implemented by derived classes"
    }
    [string] GetDescription() {
        return $this.GetType().Name
    }
}


####\_Backup/20250726_003635/Core/ScreenManager.ps1
# ScreenManager.ps1 - Manages screen lifecycle and rendering
# Optimized for minimal overhead

class ScreenManager {
    hidden [System.Collections.Generic.Stack[Screen]]$_screenStack
    hidden [Screen]$_activeScreen = $null
    hidden [bool]$_needsRender = $true
    hidden [System.ConsoleKeyInfo]$_lastKey
    hidden [ServiceContainer]$_services
    hidden [ShortcutManager]$_shortcutManager
    hidden [bool]$_exitRequested = $false
    
    # Performance tracking
    hidden [System.Diagnostics.Stopwatch]$_renderTimer
    hidden [int]$_frameCount = 0
    hidden [double]$_lastFPS = 0
    
    # Double buffering
    hidden [string]$_lastContent = ""
    
    ScreenManager([ServiceContainer]$services) {
        $this._screenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this._services = $services
        $this._renderTimer = [System.Diagnostics.Stopwatch]::new()
        
        # Get ShortcutManager if available
        $this._shortcutManager = $services.GetService('ShortcutManager')
    }
    
    # Push a new screen
    [void] Push([Screen]$screen) {
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Push: Pushing screen $($screen.GetType().Name)")
        }
        
        # Deactivate current
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
            $this._activeScreen.OnDeactivated()
        }
        
        try {
            # Initialize and activate new screen
            $screen.Initialize($this._services)
            
            # Ensure we have valid console dimensions
            $width = [Math]::Max([Console]::WindowWidth, 80)
            $height = [Math]::Max([Console]::WindowHeight, 24)
            $screen.SetBounds(0, 0, $width, $height)
            
            if ($global:Logger) {
                $global:Logger.Debug("ScreenManager.Push: Set screen bounds to (0,0,$width,$height)")
            }
            
            $this._screenStack.Push($screen)
            $this._activeScreen = $screen
            $this._activeScreen.Active = $true
            $this._activeScreen.OnActivated()
            
            # Clear last content to force redraw on screen change
            $this._lastContent = ""
            $this._needsRender = $true
            
            if ($global:Logger) {
                $global:Logger.Info("ScreenManager.Push: Successfully pushed $($screen.GetType().Name), Active=$($this._activeScreen.Active)")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ScreenManager.Push: Error pushing screen - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
            throw
        }
    }
    
    # Pop current screen
    [Screen] Pop() {
        if ($this._screenStack.Count -eq 0) { return $null }
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Pop: Stack count before pop = $($this._screenStack.Count)")
        }
        
        $popped = $this._screenStack.Pop()
        if ($popped) {
            $popped.Active = $false
            $popped.OnDeactivated()
        }
        
        # Activate previous screen if any
        if ($this._screenStack.Count -gt 0) {
            $this._activeScreen = $this._screenStack.Peek()
            if ($this._activeScreen) {
                if ($global:Logger) {
                    $global:Logger.Debug("ScreenManager.Pop: Activating previous screen: $($this._activeScreen.GetType().Name)")
                }
                try {
                    $this._activeScreen.Active = $true
                    $this._activeScreen.OnActivated()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ScreenManager.Pop: Error activating previous screen - $_")
                        $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
                    }
                }
            } else {
                if ($global:Logger) {
                    $global:Logger.Error("ScreenManager.Pop: Previous screen is null!")
                }
            }
        } else {
            $this._activeScreen = $null
        }
        
        # Clear last content to force redraw
        $this._lastContent = ""
        $this._needsRender = $true
        return $popped
    }
    
    # Replace current screen
    [void] Replace([Screen]$screen) {
        if ($this._screenStack.Count -gt 0) {
            $this.Pop() | Out-Null
        }
        $this.Push($screen)
    }
    
    # Get active screen
    [Screen] GetActiveScreen() {
        return $this._activeScreen
    }
    
    # Main run loop
    [void] Run() {
        # Initial setup
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Run: Starting main loop")
            if ($this._activeScreen) {
                $global:Logger.Info("Active screen: $($this._activeScreen.GetType().Name)")
                $global:Logger.Info("Active screen.Active: $($this._activeScreen.Active)")
            } else {
                $global:Logger.Info("Active screen: null")
            }
            $global:Logger.Flush()
        }
        
        # Track window size
        $lastWidth = [Console]::WindowWidth
        $lastHeight = [Console]::WindowHeight
        
        # Set needsRender to true to ensure first frame renders
        $this._needsRender = $true
        
        try {
            while ($this._activeScreen -and $this._activeScreen.Active -and -not $this._exitRequested) {
                if ($global:Logger -and $this._frameCount % 100 -eq 0) {
                    $global:Logger.Debug("ScreenManager: In main loop iteration, activeScreen = " + $(if ($this._activeScreen) { $this._activeScreen.GetType().Name } else { "null" }))
                    $global:Logger.Debug("ScreenManager: needsRender = $($this._needsRender), frameCount = $($this._frameCount)")
                }
                
                # Check for window resize
                $currentWidth = [Console]::WindowWidth
                $currentHeight = [Console]::WindowHeight
                if ($currentWidth -ne $lastWidth -or $currentHeight -ne $lastHeight) {
                    $lastWidth = $currentWidth
                    $lastHeight = $currentHeight
                    
                    # Update screen bounds
                    if ($this._activeScreen) {
                        $this._activeScreen.SetBounds(0, 0, $currentWidth, $currentHeight)
                        $this._needsRender = $true
                        
                        if ($global:Logger) {
                            $global:Logger.Debug("ScreenManager: Window resized to ${currentWidth}x${currentHeight}")
                        }
                    }
                }
                
                # Handle terminal resize
                if ([Console]::WindowWidth -ne $this._activeScreen.Width -or 
                    [Console]::WindowHeight -ne $this._activeScreen.Height) {
                    $this.HandleResize()
                }
                
                # Render if needed
                if ($this._needsRender -or $this._activeScreen._cacheInvalid) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ScreenManager: Rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                    $this.Render()
                } else {
                    # Log occasionally why we're not rendering
                    if ($this._frameCount % 100 -eq 0 -and $global:Logger) {
                        $global:Logger.Debug("ScreenManager: Not rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                }
                
                # Handle input
                try {
                    # Check if running in test mode
                    if ($env:PRAXIS_TEST_MODE) {
                        if ($global:Logger) {
                            $global:Logger.Debug("Running in test mode - skipping input")
                        }
                        Start-Sleep -Milliseconds 100
                        continue
                    }
                    
                    if ([Console]::KeyAvailable) {
                        $key = [Console]::ReadKey($true)
                        $this._lastKey = $key
                        $handled = $false
                        
                        # Log key press for debugging
                        if ($global:Logger) {
                            $global:Logger.Debug("Key pressed: $($key.Key) Char: '$($key.KeyChar)' Modifiers: $($key.Modifiers)")
                        }
                        
                        # PARENT-DELEGATED INPUT MODEL - Simple routing only
                        $handled = $false
                        
                        # 1. Check ShortcutManager for global shortcuts first
                        if ($this._shortcutManager) {
                            # Get the actual active screen (e.g., ProjectsScreen within MainScreen's TabContainer)
                            $currentScreenType = ""
                            if ($this._activeScreen) {
                                if ($this._activeScreen.GetType().Name -eq "MainScreen" -and $this._activeScreen.TabContainer) {
                                    $activeTab = $this._activeScreen.TabContainer.GetActiveTab()
                                    if ($activeTab -and $activeTab.Content) {
                                        $currentScreenType = $activeTab.Content.GetType().Name
                                    }
                                } else {
                                    $currentScreenType = $this._activeScreen.GetType().Name
                                }
                            }
                            
                            $currentContext = if ($this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) { "CommandPalette" } else { "" }
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($key.Key) Char='$($key.KeyChar)' ScreenType=$currentScreenType Context=$currentContext")
                            }
                            
                            $handled = $this._shortcutManager.HandleKeyPress($key, $currentScreenType, $currentContext)
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager handled=$handled")
                            }
                        }
                        
                        # 2. Command Palette override (when visible) - only if not handled by shortcuts
                        if (-not $handled -and $this._activeScreen -and $this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) {
                            $handled = $this._activeScreen.CommandPalette.HandleInput($key)
                            if ($global:Logger) {
                                $global:Logger.Debug("Key routed to CommandPalette")
                            }
                        }
                        # 3. Fallback to hardcoded shortcuts if ShortcutManager not available
                        elseif (-not $this._shortcutManager) {
                            if ($key.KeyChar -eq '/' -or $key.KeyChar -eq ':') {
                                # Show command palette
                                if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
                                    $this._activeScreen.CommandPalette.Show()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Command palette opened")
                                    }
                                }
                            } 
                            elseif ($key.Key -eq [System.ConsoleKey]::Tab) {
                                # Handle Tab navigation via parent delegation
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                            elseif ($key.Modifiers -band [System.ConsoleModifiers]::Control) {
                                # Ctrl+Q for quit
                                if ($key.Key -eq [System.ConsoleKey]::Q) {
                                    $this.RequestExit()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Quit application")
                                    }
                                }
                            }
                            # Ctrl+Arrows for focus navigation
                            elseif ($key.Key -eq [System.ConsoleKey]::RightArrow -or $key.Key -eq [System.ConsoleKey]::LeftArrow) {
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                        }
                        
                        # 4. Tab navigation (if not handled above)
                        if (-not $handled -and $key.Key -eq [System.ConsoleKey]::Tab -and $this._activeScreen) {
                            $handled = $this.HandleTabNavigation($key)
                        }
                        
                        # 5. If not handled by global shortcuts, let screen handle it
                        if (-not $handled -and $this._activeScreen) {
                            try {
                                $handled = $this._activeScreen.HandleInput($key)
                                if ($handled -and $global:Logger) {
                                    $global:Logger.Debug("Key handled by screen: $($this._activeScreen.GetType().Name)")
                                }
                            } catch {
                                if ($global:Logger) {
                                    $global:Logger.LogException($_.Exception, "Error in screen input handling")
                                }
                            }
                        }
                        
                        if ($handled) {
                            $this._needsRender = $true
                        }
                        
                        # Emergency exit (Ctrl+Esc)
                        if ($key.Key -eq [System.ConsoleKey]::Escape -and 
                            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
                            break  # Ctrl+Esc to exit
                        }
                    } else {
                        # Small sleep to prevent CPU spinning
                        Start-Sleep -Milliseconds 10
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.LogException($_.Exception, "Error in input handling")
                    }
                    
                    # In non-interactive mode, just sleep
                    Start-Sleep -Milliseconds 50
                    
                    # Check if we should exit (for testing)
                    if ($env:PRAXIS_TEST_MODE) {
                        break
                    }
                }
            }
        } finally {
            # Cleanup
            [Console]::CursorVisible = $true
            [Console]::Clear()
            [Console]::SetCursorPosition(0, 0)
        }
    }
    
    # Render current screen
    hidden [void] Render() {
        $this._renderTimer.Restart()
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Render: Starting render")
        }
        
        # Get rendered content
        $content = $this._activeScreen.Render()
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Render: Content length = $($content.Length)")
        }
        
        # Always write to console
        [Console]::CursorVisible = $false
        [Console]::SetCursorPosition(0, 0)
        [Console]::Write($content)
        
        $this._renderTimer.Stop()
        $this._frameCount++
        
        # Update FPS every second
        if ($this._frameCount % 60 -eq 0) {
            $this._lastFPS = 1000.0 / $this._renderTimer.ElapsedMilliseconds
        }
        
        $this._needsRender = $false
    }
    
    # Handle terminal resize
    hidden [void] HandleResize() {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        # Update all screens in stack
        foreach ($screen in $this._screenStack) {
            $screen.SetBounds(0, 0, $newWidth, $newHeight)
        }
        
        # Clear and force full redraw
        [Console]::Clear()
        $this._lastContent = ""  # Force full redraw on next render
        $this._needsRender = $true
    }
    
    # Request render on next frame
    [void] RequestRender() {
        $this._needsRender = $true
    }
    
    # Parent-delegated Tab navigation
    [bool] HandleTabNavigation([System.ConsoleKeyInfo]$key) {
        # Find the deepest focused element
        $focused = $this.FindDeepestFocusedElement($this._activeScreen)
        if ($global:Logger) {
            $global:Logger.Debug("HandleTabNavigation: Focused element = " + $(if ($focused) { $focused.GetType().Name } else { "null" }))
        }
        
        if (-not $focused) {
            # No focus, try to focus first focusable element
            if ($global:Logger) {
                $global:Logger.Debug("HandleTabNavigation: No focused element, focusing first")
            }
            $this._activeScreen.FocusFirst()
            return $true
        }
        
        # Ask the parent to handle navigation
        if ($focused.Parent) {
            $isReverse = ($key.Modifiers -band [System.ConsoleModifiers]::Shift) -or 
                         ($key.Key -eq [System.ConsoleKey]::LeftArrow)
            
            if ($global:Logger) {
                $global:Logger.Debug("HandleTabNavigation: Parent = $($focused.Parent.GetType().Name), Reverse = $isReverse")
            }
            
            if ($isReverse) {
                $focused.Parent.FocusPreviousChild($focused)
            } else {
                $focused.Parent.FocusNextChild($focused)
            }
            
            if ($global:Logger) {
                $direction = if ($isReverse) { "reverse" } else { "forward" }
                $global:Logger.Debug("Tab navigation: $direction via parent delegation")
            }
            return $true
        }
        
        return $false
    }
    
    # Find the deepest focused element in the tree
    [UIElement] FindDeepestFocusedElement([UIElement]$root) {
        if (-not $root) { return $null }
        
        if ($root.IsFocused) {
            # Check if any child is focused (go deeper)
            foreach ($child in $root.Children) {
                $deeper = $this.FindDeepestFocusedElement($child)
                if ($deeper) { return $deeper }
            }
            return $root
        }
        
        # Not focused, check children
        foreach ($child in $root.Children) {
            $found = $this.FindDeepestFocusedElement($child)
            if ($found) { return $found }
        }
        
        return $null
    }
    
    # Get current FPS
    [double] GetFPS() {
        return $this._lastFPS
    }
    
    # Request application exit
    [void] RequestExit() {
        $this._exitRequested = $true
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
        }
    }
    
    # Show command palette
    [void] ShowCommandPalette() {
        if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
            $this._activeScreen.CommandPalette.Show()
        }
    }
}

# Global screen manager instance
$global:ScreenManager = $null


####\_Backup/20250726_003635/Core/ServiceContainer.ps1
# ServiceContainer.ps1 - Lightweight dependency injection
# Simplified from AxiomPhoenix for PRAXIS

class ServiceContainer {
    hidden [hashtable]$_services = @{}
    hidden [hashtable]$_factories = @{}
    
    # Register a service instance
    [void] Register([string]$name, [object]$instance) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $instance) {
            throw "Service instance cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._services[$name] = $instance
    }
    
    # Register a factory for lazy initialization
    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$singleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $factory) {
            throw "Factory cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._factories[$name] = @{
            Factory = $factory
            Singleton = $singleton
            Instance = $null
        }
    }
    
    # Get a service by name
    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        
        # Check eager instances first
        if ($this._services.ContainsKey($name)) {
            return $this._services[$name]
        }
        
        # Check factories
        if ($this._factories.ContainsKey($name)) {
            $factory = $this._factories[$name]
            
            # Return cached singleton if available
            if ($factory.Singleton -and $null -ne $factory.Instance) {
                return $factory.Instance
            }
            
            # Create new instance
            $instance = & $factory.Factory $this
            
            # Cache if singleton
            if ($factory.Singleton) {
                $factory.Instance = $instance
            }
            
            return $instance
        }
        
        throw "Service '$name' not found. Available: $($this.GetServiceNames() -join ', ')"
    }
    
    # Get all registered service names
    [string[]] GetServiceNames() {
        $names = @()
        $names += $this._services.Keys
        $names += $this._factories.Keys
        return $names | Sort-Object
    }
    
    # Cleanup all services
    [void] Cleanup() {
        # Dispose any IDisposable services
        $allInstances = @()
        $allInstances += $this._services.Values
        $allInstances += $this._factories.Values | Where-Object { $_.Instance } | ForEach-Object { $_.Instance }
        
        foreach ($instance in $allInstances) {
            if ($instance -is [System.IDisposable]) {
                try {
                    $instance.Dispose()
                } catch {
                    # Ignore disposal errors
                }
            }
        }
        
        $this._services.Clear()
        $this._factories.Clear()
    }
}

# Global service container instance
$global:ServiceContainer = [ServiceContainer]::new()


####\_Backup/20250726_003635/Core/StringBuilderPool.ps1
# StringBuilderPool.ps1 - Pool for reusing StringBuilder instances to reduce memory allocations

class StringBuilderPool {
    static [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]$Pool = [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]::new()
    static [int]$MaxPoolSize = 50
    static [int]$MaxCapacity = 16384  # 16KB max capacity before discarding
    static [int]$CreatedCount = 0
    static [int]$ReusedCount = 0
    
    # Get a StringBuilder from the pool or create new one
    static [System.Text.StringBuilder] Get() {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()  # Clear but keep capacity
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new()
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Get a StringBuilder with initial capacity
    static [System.Text.StringBuilder] Get([int]$initialCapacity) {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()
            if ($sb.Capacity -lt $initialCapacity) {
                $sb.Capacity = $initialCapacity
            }
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new($initialCapacity)
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Return StringBuilder to pool for reuse
    static [void] Return([System.Text.StringBuilder]$sb) {
        if (-not $sb) { return }
        
        # Don't pool if too large (prevents memory bloat)
        if ($sb.Capacity -gt [StringBuilderPool]::MaxCapacity) {
            return
        }
        
        # Don't pool if we're at max capacity
        if ([StringBuilderPool]::Pool.Count -ge [StringBuilderPool]::MaxPoolSize) {
            return
        }
        
        $sb.Clear()
        [StringBuilderPool]::Pool.Enqueue($sb)
    }
    
    # Get pool statistics for debugging
    static [hashtable] GetStats() {
        return @{
            PoolSize = [StringBuilderPool]::Pool.Count
            MaxPoolSize = [StringBuilderPool]::MaxPoolSize
            Created = [StringBuilderPool]::CreatedCount
            Reused = [StringBuilderPool]::ReusedCount
            ReuseRate = if ([StringBuilderPool]::CreatedCount -eq 0) { 0 } else { 
                [Math]::Round(([StringBuilderPool]::ReusedCount / ([StringBuilderPool]::CreatedCount + [StringBuilderPool]::ReusedCount)) * 100, 2)
            }
        }
    }
    
    # Clear the pool (useful for testing or cleanup)
    static [void] Clear() {
        while ([StringBuilderPool]::Pool.TryDequeue([ref]$null)) {
            # Empty the queue
        }
    }
}

# Global helper functions for easier access
function Get-PooledStringBuilder {
    param([int]$initialCapacity = 256)
    
    if ($initialCapacity -gt 0) {
        return [StringBuilderPool]::Get($initialCapacity)
    } else {
        return [StringBuilderPool]::Get()
    }
}

function Return-PooledStringBuilder {
    param([System.Text.StringBuilder]$StringBuilder)
    [StringBuilderPool]::Return($StringBuilder)
}

function Get-StringBuilderPoolStats {
    return [StringBuilderPool]::GetStats()
}


####\_Backup/20250726_003635/Core/StringCache.ps1
# StringCache.ps1 - Pre-cached strings for common rendering patterns
# Optimizes string multiplication operations that allocate frequently

class StringCache {
    # Cache for space strings of various lengths
    static [hashtable]$Spaces = @{}
    
    # Cache for horizontal line strings
    static [hashtable]$HLines = @{}
    
    # Cache for VT100 horizontal sequences (populated later)
    static [hashtable]$VTHorizontal = @{}
    
    # Maximum cached length
    static [int]$MaxCacheLength = 200
    
    # Initialize the cache with common sizes
    static [void] Initialize() {
        # Pre-populate common sizes for spaces
        for ($i = 1; $i -le [StringCache]::MaxCacheLength; $i++) {
            [StringCache]::Spaces[$i] = " " * $i
        }
        
        # Pre-populate common sizes for horizontal lines
        for ($i = 1; $i -le [StringCache]::MaxCacheLength; $i++) {
            [StringCache]::HLines[$i] = "" * $i
        }
        
        # VT100 horizontal sequences will be populated after VT is loaded
    }
    
    # Get spaces of specified width
    static [string] GetSpaces([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength) {
            return [StringCache]::Spaces[$width]
        }
        # For larger widths, build dynamically
        return " " * $width
    }
    
    # Get horizontal lines of specified width
    static [string] GetHorizontalLine([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength) {
            return [StringCache]::HLines[$width]
        }
        # For larger widths, build dynamically
        return "" * $width
    }
    
    # Get VT100 horizontal sequence of specified width
    static [string] GetVTHorizontal([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength -and [StringCache]::VTHorizontal.ContainsKey($width)) {
            return [StringCache]::VTHorizontal[$width]
        }
        # For larger widths, build dynamically using fallback
        return "" * $width
    }
    
    # Get repeated character string
    static [string] GetRepeatedChar([char]$char, [int]$count) {
        if ($count -le 0) { return "" }
        if ($char -eq ' ' -and $count -le [StringCache]::MaxCacheLength) {
            return [StringCache]::Spaces[$count]
        }
        if ($char -eq '' -and $count -le [StringCache]::MaxCacheLength) {
            return [StringCache]::HLines[$count]
        }
        # For other characters or large counts, build dynamically
        return [string]$char * $count
    }
}

# Initialize the cache on module load
[StringCache]::Initialize()


####\_Backup/20250726_003635/Core/VT100.ps1
# VT100/ANSI Core for BOLT-AXIOM with True Color Support

class VT {
    # Cursor movement (ANSI uses 1-based coordinates)
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    
    # Screen control
    static [string] Clear() { return "`e[H`e[2J" }  # Clear screen and home
    static [string] ClearLine() { return "`e[K" }
    static [string] Home() { return "`e[H" }      # Just home position
    static [string] ClearToEnd() { return "`e[J" }  # Clear from cursor to end
    
    # Basic styles
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Dim() { return "`e[2m" }
    
    # 24-bit True Color
    static [string] RGB([int]$r, [int]$g, [int]$b) { 
        return "`e[38;2;$r;$g;$($b)m" 
    }
    static [string] RGBBG([int]$r, [int]$g, [int]$b) { 
        return "`e[48;2;$r;$g;$($b)m" 
    }
    
    # Wireframe color palette (true color)
    static [string] Border() { return [VT]::RGB(0, 255, 255) }      # Cyan
    static [string] BorderDim() { return [VT]::RGB(0, 128, 128) }   # Dark cyan
    static [string] BorderActive() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Text() { return [VT]::RGB(192, 192, 192) }      # Light gray
    static [string] TextDim() { return [VT]::RGB(128, 128, 128) }   # Gray
    static [string] TextBright() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Accent() { return [VT]::RGB(0, 255, 0) }        # Green
    static [string] Warning() { return [VT]::RGB(255, 255, 0) }     # Yellow
    static [string] Error() { return [VT]::RGB(255, 0, 0) }         # Red
    static [string] Selected() { return [VT]::RGB(255, 255, 255) + [VT]::RGBBG(0, 64, 128) } # White on dark blue
    
    # Box drawing - single lines for speed
    static [string] TL() { return "" }     # Top left
    static [string] TR() { return "" }     # Top right
    static [string] BL() { return "" }     # Bottom left
    static [string] BR() { return "" }     # Bottom right
    static [string] H() { return "" }      # Horizontal
    static [string] V() { return "" }      # Vertical
    static [string] Cross() { return "" }  # Cross
    static [string] T() { return "" }      # T down
    static [string] B() { return "" }      # T up
    static [string] L() { return "" }      # T right
    static [string] R() { return "" }      # T left
    
    # Double lines for emphasis
    static [string] DTL() { return "" }
    static [string] DTR() { return "" }
    static [string] DBL() { return "" }
    static [string] DBR() { return "" }
    static [string] DH() { return "" }
    static [string] DV() { return "" }
}

# Layout measurement helpers
class Measure {
    static [int] TextWidth([string]$text) {
        # Remove ANSI sequences for accurate measurement
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        return $clean.Length
    }
    
    static [string] Truncate([string]$text, [int]$maxWidth) {
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        if ($clean.Length -le $maxWidth) { return $text }
        return $clean.Substring(0, $maxWidth - 3) + "..."
    }
    
    static [string] Pad([string]$text, [int]$width, [string]$align = "Left") {
        $textWidth = [Measure]::TextWidth($text)
        if ($textWidth -ge $width) { return [Measure]::Truncate($text, $width) }
        
        $padding = $width - $textWidth
        switch ($align) {
            "Left" { return $text + [StringCache]::GetSpaces($padding) }
            "Right" { return [StringCache]::GetSpaces($padding) + $text }
            "Center" { 
                $left = [int]($padding / 2)
                $right = $padding - $left
                return [StringCache]::GetSpaces($left) + $text + [StringCache]::GetSpaces($right)
            }
        }
        return $text
    }
}


####\_Backup/20250726_003635/Models/BaseAction.ps1
# BaseAction.ps1 - Base class for Visual Macro Factory actions
# Defines the contract for all macro actions with explicit data dependencies

class BaseAction {
    [string]$Name
    [string]$Description
    [string]$Category
    [string]$Icon = ""
    
    # Declares what variables this action NEEDS from the Macro Context
    # Format: @{ Name="fieldName"; Type="Field"; Description="Field to analyze" }
    [hashtable[]]$Consumes = @()
    
    # Declares what variables this action CREATES  
    # Format: @{ Name="outputDb"; Type="Database"; Description="Result database" }
    [hashtable[]]$Produces = @()
    
    # Whether this action can accept custom IDEA@ commands
    [bool]$AllowsCustomCommands = $false
    
    BaseAction() {
        # Override in derived classes
    }
    
    # Generates the final IDEAScript code using the provided context
    [string] RenderScript([hashtable]$macroContext) {
        throw "RenderScript must be implemented by derived class: $($this.GetType().Name)"
    }
    
    # Get display text for UI lists
    [string] GetDisplayText() {
        return "$($this.Icon) $($this.Name)"
    }
    
    # Get detailed description with requirements
    [string] GetDetailedDescription() {
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine($this.Description)
        
        if ($this.Consumes.Count -gt 0) {
            $sb.AppendLine("`nRequires:")
            foreach ($req in $this.Consumes) {
                $sb.AppendLine("   $($req.Name) ($($req.Type)): $($req.Description)")
            }
        }
        
        if ($this.Produces.Count -gt 0) {
            $sb.AppendLine("`nProduces:")
            foreach ($prod in $this.Produces) {
                $sb.AppendLine("   $($prod.Name) ($($prod.Type)): $($prod.Description)")
            }
        }
        
        return $sb.ToString()
    }
    
    # Validate that required context variables are available
    [bool] ValidateContext([hashtable]$macroContext) {
        foreach ($requirement in $this.Consumes) {
            if (-not $macroContext.ContainsKey($requirement.Name)) {
                return $false
            }
        }
        return $true
    }
    
    # Get list of missing context variables
    [string[]] GetMissingContext([hashtable]$macroContext) {
        $missing = @()
        foreach ($requirement in $this.Consumes) {
            if (-not $macroContext.ContainsKey($requirement.Name)) {
                $missing += $requirement.Name
            }
        }
        return $missing
    }
}


####\_Backup/20250726_003635/Models/Command.ps1
# Command.ps1 - Model for storing reusable command strings
# Used in Command Library for quick access and clipboard copying

class Command : BaseModel {
    [string]$Title = ""
    [string]$Description = ""
    [string[]]$Tags = @()
    [string]$Group = ""
    [string]$CommandText = ""  # REQUIRED - the actual command to copy
    [datetime]$Created = [datetime]::Now
    [datetime]$LastUsed = [datetime]::MinValue
    [int]$UseCount = 0
    
    Command() : base() {
        # Base constructor handles Id generation
    }
    
    Command([string]$commandText) : base() {
        $this.CommandText = $commandText
    }
    
    Command([string]$title, [string]$commandText) : base() {
        $this.Title = $title
        $this.CommandText = $commandText
    }
    
    # Validation - CommandText is required
    [bool] IsValid() {
        return -not [string]::IsNullOrWhiteSpace($this.CommandText)
    }
    
    # Update usage statistics when command is used
    [void] RecordUsage() {
        $this.LastUsed = [datetime]::Now
        $this.UseCount++
    }
    
    # Get display text for lists
    [string] GetDisplayText() {
        $displayText = ""
        
        # Add group prefix if present
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $displayText += "[$($this.Group)] "
        }
        
        # Add title or truncated command text
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $displayText += $this.Title
        } else {
            # Use first 50 chars of command text as fallback
            $commandPreview = $this.CommandText
            if ($commandPreview.Length -gt 50) {
                $commandPreview = $commandPreview.Substring(0, 47) + "..."
            }
            $displayText += $commandPreview
        }
        
        return $displayText
    }
    
    # Get searchable text for filtering
    [string] GetSearchableText() {
        $searchText = @()
        
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $searchText += $this.Title
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Description)) {
            $searchText += $this.Description
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $searchText += $this.Group
        }
        
        if ($this.Tags -and $this.Tags.Count -gt 0) {
            $searchText += ($this.Tags -join " ")
        }
        
        # Always include command text in search
        $searchText += $this.CommandText
        
        return ($searchText -join " ")
    }
    
    # Get detailed text for display in dialogs
    [string] GetDetailText() {
        $details = @()
        
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $details += "Title: $($this.Title)"
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Description)) {
            $details += "Description: $($this.Description)"
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $details += "Group: $($this.Group)"
        }
        
        if ($this.Tags -and $this.Tags.Count -gt 0) {
            $details += "Tags: $($this.Tags -join ', ')"
        }
        
        $details += "Command: $($this.CommandText)"
        
        if ($this.UseCount -gt 0) {
            $details += "Used: $($this.UseCount) times, last: $($this.LastUsed.ToString('yyyy-MM-dd HH:mm'))"
        }
        
        return ($details -join "`n")
    }
    
    # Convert to hashtable for JSON serialization
    [hashtable] ToHashtable() {
        return @{
            Id = $this.Id
            Title = $this.Title
            Description = $this.Description
            Tags = $this.Tags
            Group = $this.Group
            CommandText = $this.CommandText
            Created = $this.Created.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK")
            LastUsed = if ($this.LastUsed -eq [datetime]::MinValue) { $null } else { $this.LastUsed.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK") }
            UseCount = $this.UseCount
        }
    }
    
    # Create from hashtable (for JSON deserialization)
    static [Command] FromHashtable([hashtable]$data) {
        $command = [Command]::new()
        
        $command.Id = $data.Id
        $command.Title = $data.Title ?? ""
        $command.Description = $data.Description ?? ""
        $command.Tags = $data.Tags ?? @()
        $command.Group = $data.Group ?? ""  
        $command.CommandText = $data.CommandText ?? ""
        $command.UseCount = $data.UseCount ?? 0
        
        if ($data.Created) {
            $command.Created = [datetime]::Parse($data.Created)
        }
        
        if ($data.LastUsed) {
            $command.LastUsed = [datetime]::Parse($data.LastUsed)
        } else {
            $command.LastUsed = [datetime]::MinValue
        }
        
        return $command
    }
}


####\_Backup/20250726_003635/Models/Project.ps1
# Project Model - Enhanced project definition based on PMC pattern

class Project : BaseModel {
    [string]$FullProjectName
    [string]$Nickname
    [string]$ID1
    [string]$ID2
    [DateTime]$DateAssigned
    [DateTime]$BFDate
    [DateTime]$DateDue
    [string]$Note
    [string]$CAAPath
    [string]$RequestPath
    [string]$T2020Path
    [decimal]$CumulativeHrs
    [DateTime]$ClosedDate
    
    # Audit Information
    [string]$AuditType
    [string]$AuditProgram
    [string]$AuditCase
    [DateTime]$AuditStartDate
    [DateTime]$AuditPeriodFrom
    [DateTime]$AuditPeriodTo
    
    # Additional Audit Periods
    [DateTime]$AuditPeriod1Start
    [DateTime]$AuditPeriod1End
    [DateTime]$AuditPeriod2Start
    [DateTime]$AuditPeriod2End
    [DateTime]$AuditPeriod3Start
    [DateTime]$AuditPeriod3End
    [DateTime]$AuditPeriod4Start
    [DateTime]$AuditPeriod4End
    [DateTime]$AuditPeriod5Start
    [DateTime]$AuditPeriod5End
    
    # Client Information
    [string]$ClientID  # TPNum
    [string]$Address
    [string]$City
    [string]$Province
    [string]$PostalCode
    [string]$Country
    [string]$ShipToAddress
    
    # Auditor Information
    [string]$AuditorName
    [string]$AuditorPhone
    [string]$AuditorTL
    [string]$AuditorTLPhone
    
    # Contact Information
    [string]$Contact1Name
    [string]$Contact1Phone
    [string]$Contact1Ext
    [string]$Contact1Address
    [string]$Contact1Title
    [string]$Contact2Name
    [string]$Contact2Phone
    [string]$Contact2Ext
    [string]$Contact2Address
    [string]$Contact2Title
    
    # System Information
    [string]$AccountingSoftware1
    [string]$AccountingSoftware1Other
    [string]$AccountingSoftware1Type
    [string]$AccountingSoftware2
    [string]$AccountingSoftware2Other
    [string]$AccountingSoftware2Type
    
    # Other Information
    [DateTime]$RequestDate
    [string]$FXInfo
    [string]$Comments
    
    # Status tracking (not from Excel)
    [string]$Status = "Active"
    
    # Default constructor
    Project() : base() {
        $this.FullProjectName = ""
        $this.Nickname = ""
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Project([string]$fullName, [string]$nickname) : base() {
        $this.FullProjectName = $fullName
        $this.Nickname = $nickname
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Legacy constructor for backward compatibility
    Project([string]$name) : base() {
        $this.FullProjectName = $name
        $this.Nickname = $name
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
}


####\_Backup/20250726_003635/Models/Subtask.ps1
# Subtask.ps1 - Subtask model extending the Task system

class Subtask : BaseModel {
    [string]$ParentTaskId  # Links to parent Task.Id
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [int]$SortOrder = 0  # For ordering subtasks within parent
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    # Estimated and actual time tracking
    [int]$EstimatedMinutes = 0
    [int]$ActualMinutes = 0
    
    Subtask() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Subtask([string]$parentTaskId) : base() {
        $this.ParentTaskId = $parentTaskId
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[]" }
            ([TaskStatus]::Cancelled) { return "[]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "" }
            ([TaskPriority]::Medium) { return "" }
            ([TaskPriority]::High) { return "" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
    
    [string] GetDurationDisplay() {
        if ($this.EstimatedMinutes -eq 0) {
            return ""
        }
        
        $estimated = $this.FormatMinutes($this.EstimatedMinutes)
        if ($this.ActualMinutes -gt 0) {
            $actual = $this.FormatMinutes($this.ActualMinutes)
            return "$actual / $estimated"
        } else {
            return "~$estimated"
        }
    }
    
    [string] FormatMinutes([int]$minutes) {
        if ($minutes -lt 60) {
            return "$($minutes)m"
        } elseif ($minutes -lt 480) {  # Less than 8 hours
            $hours = [Math]::Floor($minutes / 60)
            $mins = $minutes % 60
            if ($mins -eq 0) {
                return "$($hours)h"
            } else {
                return "$($hours)h$($mins)m"
            }
        } else {
            $hours = [Math]::Round($minutes / 60.0, 1)
            return "$($hours)h"
        }
    }
    
    [bool] IsCompleted() {
        return $this.Status -eq [TaskStatus]::Completed
    }
    
    [bool] IsInProgress() {
        return $this.Status -eq [TaskStatus]::InProgress
    }
    
    [bool] IsPending() {
        return $this.Status -eq [TaskStatus]::Pending
    }
}


####\_Backup/20250726_003635/Models/Task.ps1
# Task.ps1 - Task model

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

class Task : BaseModel {
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [string]$ProjectId = ""
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    Task() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[]" }
            ([TaskStatus]::Cancelled) { return "[]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "" }
            ([TaskPriority]::Medium) { return "" }
            ([TaskPriority]::High) { return "" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
}


####\_Backup/20250726_003635/Models/TimeCode.ps1
# TimeCode Model - Non-project time codes (vacation, admin, etc.)

class TimeCode : BaseModel {
    [string]$ID2               # 3-5 character code (e.g., "VAC", "SICK", "ADMIN")
    [string]$Description       # Optional description for display
    [bool]$IsActive           # Whether this code is currently in use
    [int]$DisplayOrder        # For sorting common codes to top
    
    TimeCode() : base() {
        $this.IsActive = $true
        $this.DisplayOrder = 999  # Default to bottom
    }
    
    TimeCode([string]$id2) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = ""
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    TimeCode([string]$id2, [string]$description) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = $description
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    [string] GetDisplayName() {
        if ($this.Description) {
            return "$($this.ID2) - $($this.Description)"
        }
        return $this.ID2
    }
    
    # Static method to get common time codes
    static [TimeCode[]] GetCommonCodes() {
        return @(
            [TimeCode]::new("VAC", "Vacation"),
            [TimeCode]::new("SICK", "Sick Leave"),
            [TimeCode]::new("STAT", "Statutory Holiday"),
            [TimeCode]::new("ADMIN", "Administration"),
            [TimeCode]::new("TRAIN", "Training"),
            [TimeCode]::new("MTG", "Meetings"),
            [TimeCode]::new("PD", "Professional Development")
        )
    }
}


####\_Backup/20250726_003635/Models/TimeEntry.ps1
# TimeEntry Model - Universal time tracking for projects and non-project codes

class TimeEntry : BaseModel {
    [string]$WeekEndingFriday  # Friday date in yyyyMMdd format
    [string]$Name              # Project name or empty for non-project
    [string]$ID1               # Project ID1 or empty for non-project
    [string]$ID2               # Project ID2 or non-project code (3-5 chars)
    [decimal]$Monday
    [decimal]$Tuesday
    [decimal]$Wednesday
    [decimal]$Thursday
    [decimal]$Friday
    [decimal]$Total            # Calculated total for the week
    [string]$FiscalYear       # Format: "2024-2025" (Apr 1 2024 - Mar 31 2025)
    
    TimeEntry() : base() {
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    TimeEntry([string]$weekEndingFriday, [string]$id2) : base() {
        $this.WeekEndingFriday = $weekEndingFriday
        $this.ID2 = $id2
        $this.Name = ""
        $this.ID1 = ""
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    [void] CalculateTotal() {
        $this.Total = $this.Monday + $this.Tuesday + $this.Wednesday + $this.Thursday + $this.Friday
    }
    
    [void] CalculateFiscalYear() {
        if (-not $this.WeekEndingFriday) {
            $fridayDate = [DateTime]::Now
            while ($fridayDate.DayOfWeek -ne [DayOfWeek]::Friday) {
                $fridayDate = $fridayDate.AddDays(1)
            }
            $this.WeekEndingFriday = $fridayDate.ToString("yyyyMMdd")
        }
        
        $date = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        
        # Fiscal year runs April 1 - March 31
        if ($date.Month -ge 4) {
            # April through December - fiscal year starts this calendar year
            $fiscalStart = $date.Year
        } else {
            # January through March - fiscal year started last calendar year
            $fiscalStart = $date.Year - 1
        }
        
        $this.FiscalYear = "$fiscalStart-$($fiscalStart + 1)"
    }
    
    [bool] IsProjectEntry() {
        # Non-project entries have 3-5 character ID2 codes
        return $this.ID2.Length -gt 5
    }
    
    [DateTime] GetWeekStartMonday() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return $fridayDate.AddDays(-4)  # Monday is 4 days before Friday
    }
    
    [string] GetWeekDisplayString() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return "Week ending " + $fridayDate.ToString("MM/dd/yyyy")
    }
}


####\_Backup/20250726_003635/Screens/CommandEditDialog.ps1
# CommandEditDialog.ps1 - Dialog for creating and editing commands
# Handles all CRUD operations for command library entries

class CommandEditDialog : Screen {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [TextBox]$TagsBox
    [TextBox]$GroupBox
    [TextBox]$CommandBox
    [Button]$SaveButton
    [Button]$CancelButton
    [Command]$Command
    [CommandService]$CommandService
    [scriptblock]$OnSave
    
    CommandEditDialog() : base() {
        $this.Title = "Command Editor"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        
        # Create title field
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Placeholder = "Optional: Display name for the command"
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description field
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Optional: What this command does"
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create tags field
        $this.TagsBox = [TextBox]::new()
        $this.TagsBox.Placeholder = "Optional: Comma-separated tags (git, powershell, etc.)"
        $this.TagsBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TagsBox)
        
        # Create group field
        $this.GroupBox = [TextBox]::new()
        $this.GroupBox.Placeholder = "Optional: Category/group name"
        $this.GroupBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.GroupBox)
        
        # Create command field
        $this.CommandBox = [TextBox]::new()
        $this.CommandBox.Placeholder = "REQUIRED: The command text to copy to clipboard"
        $this.CommandBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        $dialog = $this
        $this.SaveButton.OnClick = { $dialog.SaveCommand() }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = { $dialog.Cancel() }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.TitleBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        if ($this.Width -le 0 -or $this.Height -le 0) { return }
        
        # Position components vertically with some spacing
        $margin = 2
        $fieldHeight = 3
        $spacing = 1
        $currentY = $margin
        
        # Title field
        if ($this.TitleBox) {
            $this.TitleBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Description field
        if ($this.DescriptionBox) {
            $this.DescriptionBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Tags field
        if ($this.TagsBox) {
            $this.TagsBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Group field
        if ($this.GroupBox) {
            $this.GroupBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Command field
        if ($this.CommandBox) {
            $this.CommandBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing * 2
        }
        
        # Buttons at bottom
        $buttonWidth = 10
        $buttonHeight = 3
        $buttonY = $this.Height - $buttonHeight - 1
        
        if ($this.SaveButton) {
            $this.SaveButton.SetBounds($this.Width - $buttonWidth * 2 - 3, $buttonY, $buttonWidth, $buttonHeight)
        }
        
        if ($this.CancelButton) {
            $this.CancelButton.SetBounds($this.Width - $buttonWidth - 1, $buttonY, $buttonWidth, $buttonHeight)
        }
    }
    
    [void] SetCommand([Command]$command) {
        $this.Command = $command
        
        if ($command) {
            # Editing existing command
            $this.Title = "Edit Command"
            $this.TitleBox.SetText($command.Title)
            $this.DescriptionBox.SetText($command.Description)
            $this.TagsBox.SetText(($command.Tags -join ", "))
            $this.GroupBox.SetText($command.Group)
            $this.CommandBox.SetText($command.CommandText)
        } else {
            # Creating new command
            $this.Title = "Add Command"
            $this.TitleBox.SetText("")
            $this.DescriptionBox.SetText("")
            $this.TagsBox.SetText("")
            $this.GroupBox.SetText("")
            $this.CommandBox.SetText("")
        }
    }
    
    [void] SaveCommand() {
        try {
            # Check if required components are initialized
            if (-not $this.CommandBox) {
                if ($global:Logger) {
                    $global:Logger.Error("CommandBox is null")
                }
                return
            }
            
            if (-not $this.CommandService) {
                if ($global:Logger) {
                    $global:Logger.Error("CommandService is null")
                }
                return
            }
            
            # Validate required field
            $commandText = $this.CommandBox.Text.Trim()
            if ([string]::IsNullOrWhiteSpace($commandText)) {
                # Show error or just return - command text is required
                if ($global:Logger) {
                    $global:Logger.Warning("Command text is required")
                }
                return
            }
            
            # Parse tags
            $tagsText = $this.TagsBox.Text.Trim()
            $tags = @()
            if (-not [string]::IsNullOrWhiteSpace($tagsText)) {
                $tags = $tagsText -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
            }
            
            if ($this.Command) {
                # Update existing command
                $this.Command.Title = $this.TitleBox.Text.Trim()
                $this.Command.Description = $this.DescriptionBox.Text.Trim()
                $this.Command.Tags = $tags
                $this.Command.Group = $this.GroupBox.Text.Trim()
                $this.Command.CommandText = $commandText
                
                $success = $this.CommandService.UpdateCommand($this.Command)
                if (-not $success) {
                    if ($global:Logger) {
                        $global:Logger.Error("Failed to update command")
                    }
                    return
                }
            } else {
                # Create new command
                $this.Command = $this.CommandService.AddCommand(
                    $this.TitleBox.Text.Trim(),
                    $this.DescriptionBox.Text.Trim(),
                    $tags,
                    $this.GroupBox.Text.Trim(),
                    $commandText
                )
            }
            
            # Call save callback
            if ($this.OnSave) {
                & $this.OnSave $this.Command
            }
            
            # Close dialog
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandEditDialog.SaveCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] Cancel() {
        # Close dialog by popping from screen stack
        if ($global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Handle Ctrl+S to save
        if ($key.Key -eq [System.ConsoleKey]::S -and $key.Modifiers -band [System.ConsoleModifiers]::Control) {
            $this.SaveCommand()
            return $true
        }
        
        # Handle Escape to cancel
        if ($key.Key -eq [System.ConsoleKey]::Escape) {
            $this.Cancel()
            return $true
        }
        
        return $false
    }
    
    # Labels will be shown via placeholder text for now
    
    [string] GetHelpText() {
        return @"
Command Editor Help:

Ctrl+S    - Save command
Escape    - Cancel and close
Tab       - Navigate between fields

Fields:
- Title: Optional display name
- Description: Optional description  
- Tags: Optional comma-separated tags
- Group: Optional category/group
- Command: REQUIRED - text to copy to clipboard

Only the Command field is required. All others are optional.
"@
    }
}


####\_Backup/20250726_003635/Screens/CommandLibraryScreen.ps1
# CommandLibraryScreen.ps1 - Command library management screen
# Browse, search, and manage reusable command strings with clipboard copy

class CommandLibraryScreen : Screen {
    [SearchableListBox]$CommandList
    [CommandService]$CommandService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    CommandLibraryScreen() : base() {
        $this.Title = "Command Library"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Create command list using SearchableListBox
        $this.CommandList = [SearchableListBox]::new()
        $this.CommandList.Title = "Commands"
        $this.CommandList.ShowBorder = $true
        $this.CommandList.SearchPrompt = "Search commands... (t:tag d:desc g:group +and |or)"
        
        # Set custom search filter for advanced syntax
        $this.CommandList.SearchFilter = {
            param($command, $query)
            return $this.CommandService.SearchCommands($query) -contains $command
        }.GetNewClosure()
        
        # Custom renderer for commands
        $this.CommandList.ItemRenderer = {
            param($command)
            if (-not $command) { return "" }
            
            $displayText = $command.GetDisplayText()
            
            # Add usage count if > 0
            if ($command.UseCount -gt 0) {
                $displayText += " $($command.UseCount)"
            }
            
            return $displayText
        }
        
        # Handle selection changes
        $this.CommandList.OnSelectionChanged = {
            # Could update UI state here if needed
        }
        
        $this.CommandList.Initialize($this.ServiceContainer)
        $this.AddChild($this.CommandList)
        
        # Load commands
        $this.LoadCommands()
        
        # Register shortcuts
        $this.RegisterShortcuts()
        
        # Set initial focus to command list
        if ($this.CommandList) {
            $this.CommandList.Focus()
        }
    }
    
    [void] LoadCommands() {
        $commands = $this.CommandService.GetAllCommands()
        $this.CommandList.SetItems($commands)
    }
    
    [void] FilterCommands() {
        # Apply any active search filter
        # SearchableListBox handles its own filtering, so this is just for refresh
        $this.CommandList.Invalidate()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.new"
            Name = "New Command"
            Description = "Create a new command"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.NewCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.edit"
            Name = "Edit Command"
            Description = "Edit the selected command"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.EditCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.delete"
            Name = "Delete Command"
            Description = "Delete the selected command"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.DeleteCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.copy"
            Name = "Copy Command"
            Description = "Copy selected command to clipboard"
            Key = [System.ConsoleKey]::Enter
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.CopySelectedCommand() }.GetNewClosure()
        })
    }
    
    [void] NewCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.NewCommand: Called via shortcut")
        }
        try {
            $screen = [CommandEditDialog]::new()
            $screen.Initialize($this.ServiceContainer)
            
            $screen.SetCommand($null)  # New command
            $screen.OnSave = {
                param($command)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($screen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.NewCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] EditCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.EditCommand: Called via shortcut")
        }
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if (-not $selectedCommand) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen.EditCommand: No command selected")
            }
            return 
        }
        
        try {
            $screen = [CommandEditDialog]::new()
            $screen.Initialize($this.ServiceContainer)
            
            $screen.SetCommand($selectedCommand)
            $screen.OnSave = {
                param($command)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($screen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.EditCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] DeleteCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.DeleteCommand: Called via shortcut")
        }
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if (-not $selectedCommand) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen.DeleteCommand: No command selected")
            }
            return 
        }
        
        try {
            # Show confirmation dialog
            $confirmScreen = [ConfirmationDialog]::new()
            $confirmScreen.Initialize($this.ServiceContainer)
            $confirmScreen.SetTitle("Delete Command")
            $confirmScreen.SetMessage("Are you sure you want to delete this command?`n`n$($selectedCommand.GetDisplayText())")
            $confirmScreen.OnConfirm = {
                $this.CommandService.DeleteCommand($selectedCommand.Id)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($confirmScreen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.DeleteCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] CopySelectedCommand() {
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if ($selectedCommand) {
            try {
                $this.CommandService.CopyToClipboard($selectedCommand.Id)
                
                # Show brief confirmation (could be a toast notification)
                if ($global:Logger) {
                    $global:Logger.Info("Copied to clipboard: $($selectedCommand.GetDisplayText())")
                }
                
                # Refresh the list to show updated usage count
                $this.LoadCommands()
                $this.FilterCommands()
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("Failed to copy command: $($_.Exception.Message)")
                }
            }
        }
    }
    
    # Search help removed - SearchableListBox should handle this
    
    # HandleInput removed - using ShortcutManager instead
    
    [void] OnBoundsChanged() {
        if ($this.Width -le 0 -or $this.Height -le 0) { return }
        
        # CommandLibraryScreen has a single CommandList that takes the full area
        if ($this.CommandList) {
            $this.CommandList.SetBounds(0, 0, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Set focus when screen becomes active
        if ($this.CommandList) {
            $this.CommandList.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Route to ShortcutManager for screen-specific shortcuts
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if ($shortcutManager) {
            return $shortcutManager.HandleKeyPress($keyInfo, $this.GetType().Name, "")
        }
        return $false
    }
    
    [string] GetHelpText() {
        return @"
Command Library Help:

Enter         - Copy selected command to clipboard
n             - Add new command
e             - Edit selected command  
d             - Delete selected command
Escape        - Return to main menu
Tab           - Navigate between elements

Search supports advanced syntax:
  t:tag d:desc g:group +and |or
"@
    }
}


####\_Backup/20250726_003635/Screens/ConfirmationDialog.ps1
# ConfirmationDialog.ps1 - Generic confirmation dialog using BaseDialog

class ConfirmationDialog : BaseDialog {
    [string]$Message
    [string]$ConfirmText = "Yes"
    [string]$CancelText = "No"
    
    ConfirmationDialog() : base("Confirm") {
        $this.Message = "Are you sure?"
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    ConfirmationDialog([string]$message) : base("Confirm") {
        $this.Message = $message
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    [void] InitializeContent() {
        # Base dialog handles button creation, we just need to update button texts if needed
        if ($this.PrimaryButton -and $this.ConfirmText -ne "Yes") {
            $this.PrimaryButton.Text = $this.ConfirmText
        }
        
        if ($this.SecondaryButton -and $this.CancelText -ne "No") {
            $this.SecondaryButton.Text = $this.CancelText
        }
        
        # No additional content controls needed for simple confirmation
        # The message is rendered directly in the dialog
    }
    
    [void] OnActivated() {
        ([BaseDialog]$this).OnActivated()
        # Override to focus on cancel button by default (safer)
        if ($this.SecondaryButton) {
            $this.SecondaryButton.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on message
        $messageLines = $this.Message -split "`n"
        $maxLineLength = ($messageLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $this.DialogWidth = [Math]::Max(40, $maxLineLength + 8)
        $this.DialogHeight = 10 + $messageLines.Count
        
        # Let base class handle the rest
        ([BaseDialog]$this).OnBoundsChanged()
    }
    
    # Override HandleScreenInput to add Y/N shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Y/N shortcuts specific to confirmation dialog
        switch ($key.Key) {
            ([System.ConsoleKey]::Y) {
                if ($key.KeyChar -eq 'Y' -or $key.KeyChar -eq 'y') {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::N) {
                if ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n') {
                    $this.HandleSecondaryAction()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render the base dialog (overlay, box, title, buttons)
        $baseRender = ([BaseDialog]$this).OnRender()
        $sb.Append($baseRender)
        
        # Add our custom content - the message and hint
        if ($this._dialogBounds -and $this._dialogBounds.Count -gt 0) {
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Draw warning icon in title
            $title = "  Confirm "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($this.Theme.GetColor("warning"))
            $sb.Append($title)
            
            # Draw message
            $messageLines = $this.Message -split "`n"
            $messageY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $messageLines) {
                $lineX = $x + [int](($w - $line.Length) / 2)
                $sb.Append([VT]::MoveTo($lineX, $messageY))
                $sb.Append($line)
                $messageY++
            }
            
            # Draw hint
            $hint = "[Y/N] or use Tab to select"
            $hintX = $x + [int](($w - $hint.Length) / 2)
            $sb.Append([VT]::MoveTo($hintX, $y + $h - 2))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append($hint)
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\_Backup/20250726_003635/Screens/DashboardScreen.ps1
# DashboardScreen.ps1 - Ultra-complex dashboard to stress-test layout system
# Layout: Main HorizontalSplit -> Left: Project overview, Right: VerticalSplit -> Top: Task metrics, Bottom: GridPanel with action buttons

class DashboardScreen : Screen {
    # Main layout structure
    [HorizontalSplit]$MainLayout
    [VerticalSplit]$RightLayout
    [GridPanel]$ActionGrid
    [HorizontalSplit]$TopRightLayout
    [VerticalSplit]$MetricsLayout
    
    # Left pane components (Project Overview)
    [ListBox]$ProjectList
    [ListBox]$RecentActivity
    [VerticalSplit]$LeftLayout
    
    # Top-right pane components (Task Metrics & Charts)
    [ListBox]$TaskList
    [ListBox]$PriorityBreakdown
    [ListBox]$StatusChart
    [GridPanel]$MetricBoxes
    
    # Bottom-right pane (Action buttons)
    [Button]$NewProjectBtn
    [Button]$NewTaskBtn
    [Button]$ExportBtn
    [Button]$SettingsBtn
    [Button]$RefreshBtn
    [Button]$HelpBtn
    [Button]$ReportsBtn
    [Button]$ArchiveBtn
    
    # Services
    [ProjectService]$ProjectService
    [TaskService]$TaskService
    [EventBus]$EventBus
    
    # Data for complex displays
    hidden [array]$_projectStats
    hidden [array]$_taskMetrics
    hidden [array]$_recentActivities
    hidden [bool]$_isLoading = $false
    hidden [hashtable]$_loadingProgress = @{
        Projects = 0
        Tasks = 0
        Activity = 0
        Metrics = 0
    }
    
    DashboardScreen() : base() {
        $this.Title = "PRAXIS Dashboard"
    }
    
    [void] OnInitialize() {
        Write-Host "Initializing ultra-complex dashboard..."
        
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to data loading events for background updates
        $this.SetupEventHandlers()
        
        # Create the incredibly complex nested layout structure
        $this.BuildMasterLayout()
        $this.BuildLeftPane()
        $this.BuildRightPane()
        
        # Show initial loading state
        $this.ShowLoadingState()
        
        # Start background data loading (non-blocking)
        $this.StartBackgroundDataLoad()
        
        Write-Host "Dashboard initialized with maximum complexity!"
    }
    
    [void] BuildMasterLayout() {
        Write-Host "Building master layout structure..."
        
        # Main horizontal split: 40% left (projects), 60% right (tasks & actions)
        $this.MainLayout = [HorizontalSplit]::new()
        $this.MainLayout.SetSplitRatio(40)
        $this.MainLayout.ShowBorder = $false
        $this.MainLayout.Initialize($global:ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Left side: Vertical split for project list + recent activity
        $this.LeftLayout = [VerticalSplit]::new()
        $this.LeftLayout.SetSplitRatio(65)  # 65% project list, 35% recent activity
        $this.LeftLayout.ShowBorder = $false
        $this.LeftLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetLeftPane($this.LeftLayout)
        
        # Right side: Vertical split for task metrics + action buttons
        $this.RightLayout = [VerticalSplit]::new()
        $this.RightLayout.SetSplitRatio(75)  # 75% metrics, 25% buttons
        $this.RightLayout.ShowBorder = $false
        $this.RightLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetRightPane($this.RightLayout)
    }
    
    [void] BuildLeftPane() {
        Write-Host "Building left pane with project overview..."
        
        # Top-left: Project List with statistics
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = " Project Overview"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { " OVERDUE" } elseif ($daysLeft -lt 7) { "  DUE SOON" } elseif ($daysLeft -lt 30) { " $daysLeft days" } else { " $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        $this.ProjectList.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetTopPane($this.ProjectList)
        
        # Bottom-left: Recent Activity Feed
        $this.RecentActivity = [ListBox]::new()
        $this.RecentActivity.Title = " Recent Activity"
        $this.RecentActivity.ShowBorder = $true
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "" }
                "TaskCompleted" { "" }
                "TaskCreated" { "" }
                "ProjectUpdated" { "" }
                default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
        $this.RecentActivity.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetBottomPane($this.RecentActivity)
    }
    
    [void] BuildRightPane() {
        Write-Host "Building right pane with metrics and controls..."
        
        # Top-right: Another horizontal split for task metrics
        $this.TopRightLayout = [HorizontalSplit]::new()
        $this.TopRightLayout.SetSplitRatio(50)  # Equal split for metrics
        $this.TopRightLayout.ShowBorder = $false
        $this.TopRightLayout.Initialize($global:ServiceContainer)
        
        # Nested vertical split in the left side of top-right
        $this.MetricsLayout = [VerticalSplit]::new()
        $this.MetricsLayout.SetSplitRatio(50)
        $this.MetricsLayout.ShowBorder = $false
        $this.MetricsLayout.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetLeftPane($this.MetricsLayout)
        
        # Task List (top of metrics)
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = " Active Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }
                "Medium" { "" }
                "Low" { "" }
                default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }
                "Done" { "" }
                "Blocked" { "" }
                default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetTopPane($this.TaskList)
        
        # Priority Breakdown (bottom of metrics)
        $this.PriorityBreakdown = [ListBox]::new()
        $this.PriorityBreakdown.Title = " Priority Distribution"
        $this.PriorityBreakdown.ShowBorder = $true
        $this.PriorityBreakdown.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetBottomPane($this.PriorityBreakdown)
        
        # Status Chart (right side of top-right)
        $this.StatusChart = [ListBox]::new()
        $this.StatusChart.Title = " Status Overview"
        $this.StatusChart.ShowBorder = $true
        $this.StatusChart.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetRightPane($this.StatusChart)
        
        # Set the complex top layout
        $this.RightLayout.SetTopPane($this.TopRightLayout)
        
        # Bottom-right: Action button grid (4x2 = 8 buttons)
        $this.ActionGrid = [GridPanel]::new(4)  # 4 columns
        $this.ActionGrid.ShowBorder = $true
        $this.ActionGrid.CellSpacing = 1
        $this.ActionGrid.Initialize($global:ServiceContainer)
        
        # Create all the action buttons with cool icons and actions
        $this.CreateActionButtons()
        
        $this.RightLayout.SetBottomPane($this.ActionGrid)
    }
    
    [void] CreateActionButtons() {
        Write-Host "Creating interactive action buttons..."
        
        # Capture $this reference for use in button handlers
        $dashboardRef = $this
        
        # Button 1: New Project
        $this.NewProjectBtn = [Button]::new(" New Project")
        $this.NewProjectBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Project button clicked")
            }
            # Create new project dialog
            $dialog = [NewProjectDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewProjectBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewProjectBtn)
        
        # Button 2: New Task
        $this.NewTaskBtn = [Button]::new(" New Task")
        $this.NewTaskBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Task button clicked")
            }
            # Create new task dialog
            $dialog = [NewTaskDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewTaskBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewTaskBtn)
        
        # Button 3: Export Data
        $this.ExportBtn = [Button]::new(" Export")
        $this.ExportBtn.OnClick = { 
            Write-Host "Dashboard: Exporting data..."
            # TODO: Implement export functionality
        }.GetNewClosure()
        $this.ExportBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ExportBtn)
        
        # Button 4: Settings
        $this.SettingsBtn = [Button]::new("  Settings")
        $this.SettingsBtn.OnClick = { 
            Write-Host "Dashboard: Opening settings..."
            # TODO: Switch to settings screen
        }.GetNewClosure()
        $this.SettingsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.SettingsBtn)
        
        # Button 5: Refresh Data
        $this.RefreshBtn = [Button]::new(" Refresh")
        $this.RefreshBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Refresh button clicked - reloading all data")
            }
            $dashboardRef.ShowLoadingState()
            $dashboardRef.StartBackgroundDataLoad()
        }.GetNewClosure()
        $this.RefreshBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.RefreshBtn)
        
        # Button 6: Help
        $this.HelpBtn = [Button]::new(" Help")
        $helpBtnRef = $this.HelpBtn
        $this.HelpBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Help button clicked")
            }
            # Change button text to show it was clicked
            $helpBtnRef.Text = " Clicked!"
            $helpBtnRef.Invalidate()
            # TODO: Show help dialog
        }.GetNewClosure()
        $this.HelpBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.HelpBtn)
        
        # Button 7: Reports
        $this.ReportsBtn = [Button]::new(" Reports")
        $this.ReportsBtn.OnClick = { 
            Write-Host "Dashboard: Generating reports..."
            # TODO: Generate analytics reports
        }.GetNewClosure()
        $this.ReportsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ReportsBtn)
        
        # Button 8: Archive
        $this.ArchiveBtn = [Button]::new(" Archive")
        $this.ArchiveBtn.OnClick = { 
            Write-Host "Dashboard: Managing archives..."
            # TODO: Archive management
        }.GetNewClosure()
        $this.ArchiveBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ArchiveBtn)
    }
    
    [void] LoadAllData() {
        Write-Host "Loading complex dashboard data..."
        
        # Load project data with statistics
        $projects = @()
        if ($this.ProjectService) {
            $allProjects = $this.ProjectService.GetAllProjects()
            $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
        }
        
        # Add some demo projects if empty
        if ($projects.Count -eq 0) {
            $projects = @(
                @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
            )
        }
        
        $this.ProjectList.SetItems($projects)
        
        # Load task data with complex metrics
        $tasks = @()
        if ($this.TaskService) {
            $allTasks = $this.TaskService.GetAllTasks()
            $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
        }
        
        # Add demo tasks if empty
        if ($tasks.Count -eq 0) {
            $tasks = @(
                @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
            )
        }
        
        $this.TaskList.SetItems($tasks)
        
        # Generate priority breakdown with visual charts
        $priorityStats = @(
            " High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
            " Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
            " Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
            ""
            "Progress Overview:"
            " 60% Complete"
            "Active: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count) tasks"
            "Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count) tasks"
        )
        $this.PriorityBreakdown.SetItems($priorityStats)
        
        # Create status chart with ASCII visualization
        $completedTasks = if ($this.TaskService) { 
            @($this.TaskService.GetAllTasks() | Where-Object { $_.Status -eq "Done" }).Count
        } else { 8 }
        
        $totalTasks = $completedTasks + $tasks.Count
        $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
        
        $statusData = @(
            " Project Health Dashboard"
            ""
            "Completion Rate: $completionRate%"
            "[$('' * [int]($completionRate/10))$('' * (10 - [int]($completionRate/10)))]"
            ""
            " Completed: $completedTasks"
            " In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
            " Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
            " Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            ""
            " Productivity Score: $(Get-Random -Minimum 75 -Maximum 98)%"
        )
        $this.StatusChart.SetItems($statusData)
        
        # Create realistic recent activity feed
        $this.LoadRecentActivity()
        
        Write-Host "Dashboard data loaded successfully!"
    }
    
    [void] LoadRecentActivity() {
        $activities = @(
            @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
            @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
            @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
            @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
            @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            @{ Type = "TaskCreated"; Message = "Created performance task"; Time = "1 day ago" }
            @{ Type = "ProjectCreated"; Message = "Initialized Testing Framework"; Time = "2 days ago" }
        )
        
        $this.RecentActivity.SetItems($activities)
    }
    
    [void] SetupEventHandlers() {
        # Subscribe to background data loading completion events
        $dashboardRef = $this
        
        $this.EventBus.Subscribe('dashboard.data.projects.loaded', {
            param($sender, $data)
            if ($data.Projects) {
                $dashboardRef.ProjectList.SetItems($data.Projects)
                $dashboardRef._loadingProgress.Projects = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.tasks.loaded', {
            param($sender, $data)
            if ($data.Tasks) {
                $dashboardRef.TaskList.SetItems($data.Tasks)
                $dashboardRef._loadingProgress.Tasks = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.activity.loaded', {
            param($sender, $data)
            if ($data.Activities) {
                $dashboardRef.RecentActivity.SetItems($data.Activities)
                $dashboardRef._loadingProgress.Activity = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.metrics.loaded', {
            param($sender, $data)
            if ($data.PriorityStats) {
                $dashboardRef.PriorityBreakdown.SetItems($data.PriorityStats)
            }
            if ($data.StatusData) {
                $dashboardRef.StatusChart.SetItems($data.StatusData)
            }
            $dashboardRef._loadingProgress.Metrics = 100
            $dashboardRef.UpdateLoadingStatus()
        }.GetNewClosure())
    }
    
    [void] ShowLoadingState() {
        # Display loading indicators in each component
        $loadingProjects = @(
            " Loading project data...",
            "   Please wait..."
        )
        $this.ProjectList.SetItems($loadingProjects)
        
        $loadingTasks = @(
            " Loading task list...",
            "   Fetching from database..."
        )
        $this.TaskList.SetItems($loadingTasks)
        
        $loadingActivity = @(
            " Loading recent activity...",
            "   Analyzing events..."
        )
        $this.RecentActivity.SetItems($loadingActivity)
        
        $loadingMetrics = @(
            " Calculating metrics...",
            "   Processing data..."
        )
        $this.PriorityBreakdown.SetItems($loadingMetrics)
        $this.StatusChart.SetItems($loadingMetrics)
    }
    
    [void] StartBackgroundDataLoad() {
        if ($this._isLoading) {
            Write-Host "Data loading already in progress"
            return
        }
        
        $this._isLoading = $true
        $this._loadingProgress = @{
            Projects = 0
            Tasks = 0
            Activity = 0
            Metrics = 0
        }
        
        # Use PowerShell jobs for true background loading
        $projService = $this.ProjectService
        $taskSvc = $this.TaskService
        $evtBus = $this.EventBus
        
        # Load projects in background
        $projectJob = Start-Job -ScriptBlock {
            param($service, $evtBus)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 800
            
            $projects = @()
            if ($service) {
                $allProjects = $service.GetAllProjects()
                $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
            }
            
            if ($projects.Count -eq 0) {
                $projects = @(
                    @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                    @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                    @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                    @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
                )
            }
            
            # Process projects
            foreach ($project in $projects) {
                $project.ClosedDate = if ($project.ClosedDate) { $project.ClosedDate } else { [DateTime]::MinValue }
                $project.DateDue = if ($project.DateDue) { $project.DateDue } else { [DateTime]::Now.AddDays(30) }
            }
            
            return $projects
        } -ArgumentList $projService, $evtBus
        
        # Load tasks in background
        $taskJob = Start-Job -ScriptBlock {
            param($service)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 1200
            
            $tasks = @()
            if ($service) {
                $allTasks = $service.GetAllTasks()
                $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
            }
            
            if ($tasks.Count -eq 0) {
                $tasks = @(
                    @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                    @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                    @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                    @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
                )
            }
            
            return $tasks
        } -ArgumentList $taskSvc
        
        # Monitor jobs and publish events when complete
        $monitorJob = Start-Job -ScriptBlock {
            param($projectJob, $taskJob, $evtBus)
            
            # Wait for project job
            $projects = Receive-Job -Job $projectJob -Wait
            $evtBus.Publish('dashboard.data.projects.loaded', @{ Projects = $projects })
            
            # Wait for task job
            $tasks = Receive-Job -Job $taskJob -Wait
            $evtBus.Publish('dashboard.data.tasks.loaded', @{ Tasks = $tasks })
            
            # Generate metrics based on loaded data
            Start-Sleep -Milliseconds 500
            
            $priorityStats = @(
                " High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
                " Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
                " Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
                ""
                "Progress Overview:"
                " 60% Complete"
            )
            
            $completedTasks = @($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $totalTasks = $tasks.Count + $completedTasks
            $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
            
            $statusData = @(
                " Project Health Dashboard"
                ""
                "Completion Rate: $completionRate%"
                "[$('' * [int]($completionRate/10))$('' * (10 - [int]($completionRate/10)))]"
                ""
                " Completed: $completedTasks"
                " In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
                " Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
                " Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            )
            
            $evtBus.Publish('dashboard.data.metrics.loaded', @{ 
                PriorityStats = $priorityStats
                StatusData = $statusData 
            })
            
            # Load activity data
            Start-Sleep -Milliseconds 300
            $activities = @(
                @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
                @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
                @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
                @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
                @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            )
            
            $evtBus.Publish('dashboard.data.activity.loaded', @{ Activities = $activities })
            
            # Clean up jobs
            Remove-Job -Job $projectJob -Force
            Remove-Job -Job $taskJob -Force
            
        } -ArgumentList $projectJob, $taskJob, $evtBus
        
        # Set up item renderers that will be used when data loads
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { " OVERDUE" } elseif ($daysLeft -lt 7) { "  DUE SOON" } elseif ($daysLeft -lt 30) { " $daysLeft days" } else { " $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }
                "Medium" { "" }
                "Low" { "" }
                default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }
                "Done" { "" }
                "Blocked" { "" }
                default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "" }
                "TaskCompleted" { "" }
                "TaskCreated" { "" }
                "ProjectUpdated" { "" }
                default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
    }
    
    [void] UpdateLoadingStatus() {
        # Check if all data has loaded
        $totalProgress = ($this._loadingProgress.Projects + $this._loadingProgress.Tasks + 
                         $this._loadingProgress.Activity + $this._loadingProgress.Metrics) / 4
        
        if ($totalProgress -eq 100) {
            $this._isLoading = $false
            Write-Host "Dashboard data fully loaded!"
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Set initial focus to ProjectList
        if ($this.ProjectList) {
            $this.ProjectList.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Update the main layout to fill the entire screen
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Handle dashboard-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::F5) {
                $this.ShowLoadingState()
                $this.StartBackgroundDataLoad()
                Write-Host "Dashboard refresh started!"
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.ShowLoadingState()
                    $this.StartBackgroundDataLoad()
                    Write-Host "Dashboard data reload started!"
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        return $false
    }
    
}


####\_Backup/20250726_003635/Screens/EditProjectDialog.ps1
# EditProjectDialog.ps1 - Dialog for editing existing projects

class EditProjectDialog : BaseDialog {
    [Project]$Project
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$ID1Box
    [TextBox]$ID2Box
    [TextBox]$NoteBox
    [TextBox]$CAAPathBox
    [TextBox]$RequestPathBox
    [TextBox]$T2020PathBox
    [TextBox]$DueDateBox
    
    EditProjectDialog([Project]$project) : base("Edit Project") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 22
    }
    
    [void] InitializeContent() {
        # Create all project input fields with current values
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Text = $this.Project.FullProjectName
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Text = $this.Project.Nickname
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [TextBox]::new()
        $this.ID1Box.Text = $this.Project.ID1
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [TextBox]::new()
        $this.ID2Box.Text = $this.Project.ID2
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NoteBox = [TextBox]::new()
        $this.NoteBox.Text = $this.Project.Note
        $this.NoteBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NoteBox, 5)
        
        $this.CAAPathBox = [TextBox]::new()
        $this.CAAPathBox.Text = $this.Project.CAAPath
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [TextBox]::new()
        $this.RequestPathBox.Text = $this.Project.RequestPath
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [TextBox]::new()
        $this.T2020PathBox.Text = $this.Project.T2020Path
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Text = $this.Project.DateDue.ToString("MM/dd/yyyy")
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action (Save)
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = $dialog.Project.DateDue
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Keep original date if parsing fails
                    }
                }
                
                # Update project properties
                $dialog.Project.FullProjectName = $dialog.NameBox.Text
                $dialog.Project.Nickname = $dialog.NicknameBox.Text
                $dialog.Project.ID1 = $dialog.ID1Box.Text
                $dialog.Project.ID2 = $dialog.ID2Box.Text
                $dialog.Project.Note = $dialog.NoteBox.Text
                $dialog.Project.CAAPath = $dialog.CAAPathBox.Text
                $dialog.Project.RequestPath = $dialog.RequestPathBox.Text
                $dialog.Project.T2020Path = $dialog.T2020PathBox.Text
                $dialog.Project.DateDue = $dueDate
                $dialog.Project.UpdatedAt = [DateTime]::Now
                
                # Save via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    $projectService.SaveProject($dialog.Project)
                }
                
                # Publish event if EventBus available
                if ($dialog.EventBus) {
                    $dialog.EventBus.Publish([EventNames]::ProjectUpdated, @{ 
                        Project = $dialog.Project 
                    })
                    
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'EditProjectDialog'
                        Action = 'Save'
                        Data = $dialog.Project
                    })
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action (Cancel)
        $this.OnSecondary = {
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'EditProjectDialog'
                    Action = 'Cancel'
                })
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields (same as NewProjectDialog)
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 2)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 2)
        $currentY += 2
        
        $this.NoteBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
    }
}


####\_Backup/20250726_003635/Screens/EditTaskDialog.ps1
# EditTaskDialog.ps1 - Dialog for editing existing tasks

class EditTaskDialog : Screen {
    [Task]$Task
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$StatusList
    [ListBox]$PriorityList
    [TextBox]$ProgressBox
    [Button]$SaveButton
    [Button]$CancelButton
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    EditTaskDialog([Task]$task) : base() {
        $this.Title = "Edit Task"
        $this.Task = $task
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Text = $this.Task.Title
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Text = $this.Task.Description
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create status list
        $this.StatusList = [ListBox]::new()
        $this.StatusList.Title = "Status"
        $this.StatusList.ShowBorder = $true
        $this.StatusList.Initialize($global:ServiceContainer)
        $this.StatusList.SetItems(@(
            @{Name="Pending"; Value=[TaskStatus]::Pending},
            @{Name="In Progress"; Value=[TaskStatus]::InProgress},
            @{Name="Completed"; Value=[TaskStatus]::Completed},
            @{Name="Cancelled"; Value=[TaskStatus]::Cancelled}
        ))
        $this.StatusList.ItemRenderer = { param($item) $item.Name }
        # Select current status
        for ($i = 0; $i -lt $this.StatusList.Items.Count; $i++) {
            if ($this.StatusList.Items[$i].Value -eq $this.Task.Status) {
                $this.StatusList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.StatusList)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.Initialize($global:ServiceContainer)
        $this.PriorityList.SetItems(@(
            @{Name="Low"; Value=[TaskPriority]::Low},
            @{Name="Medium"; Value=[TaskPriority]::Medium},
            @{Name="High"; Value=[TaskPriority]::High}
        ))
        $this.PriorityList.ItemRenderer = { param($item) $item.Name }
        # Select current priority
        for ($i = 0; $i -lt $this.PriorityList.Items.Count; $i++) {
            if ($this.PriorityList.Items[$i].Value -eq $this.Task.Priority) {
                $this.PriorityList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.PriorityList)
        
        # Create progress textbox
        $this.ProgressBox = [TextBox]::new()
        $this.ProgressBox.Text = $this.Task.Progress.ToString()
        $this.ProgressBox.Placeholder = "0-100"
        $this.ProgressBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProgressBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        # Capture dialog reference
        $dialog = $this
        $this.SaveButton.OnClick = {
            if ($dialog.TitleBox.Text.Trim()) {
                $selectedStatus = $dialog.StatusList.GetSelectedItem()
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $progress = 0
                if ([int]::TryParse($dialog.ProgressBox.Text, [ref]$progress)) {
                    $progress = [Math]::Max(0, [Math]::Min(100, $progress))
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave @{
                        Title = $dialog.TitleBox.Text
                        Description = $dialog.DescriptionBox.Text
                        Status = if ($selectedStatus) { $selectedStatus.Value } else { $dialog.Task.Status }
                        Priority = if ($selectedPriority) { $selectedPriority.Value } else { $dialog.Task.Priority }
                        Progress = $progress
                    }
                }
            }
        }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($this.OnCancel) {
                    & $this.OnCancel
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $focused = $this.FindFocused()
                if ($focused -eq $this.SaveButton) {
                    & $this.SaveButton.OnClick
                } elseif ($focused -eq $this.CancelButton) {
                    & $this.CancelButton.OnClick
                }
                return $true
            }
        }
        
        # Let base class handle other keys (like Tab navigation)
        return ([Screen]$this).HandleInput($key)
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 65
        $dialogHeight = 22
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.TitleBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        $this.DescriptionBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        
        $this.StatusList.SetBounds($centerX + 2, $centerY + 10, 20, 6)
        $this.PriorityList.SetBounds($centerX + 24, $centerY + 10, 20, 5)
        $this.ProgressBox.SetBounds($centerX + 46, $centerY + 10, 16, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 17
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on title box
        $this.TitleBox.Focus()
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " Edit Task "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Title:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Description:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 9))
            $sb.Append("Status:")
            
            $sb.Append([VT]::MoveTo($x + 24, $y + 9))
            $sb.Append("Priority:")
            
            $sb.Append([VT]::MoveTo($x + 46, $y + 9))
            $sb.Append("Progress (%):")
            
            # Draw task info
            $sb.Append([VT]::MoveTo($x + 2, $y + 16))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append("Created: " + $this.Task.CreatedAt.ToString("yyyy-MM-dd HH:mm"))
            if ($this.Task.DueDate -ne [DateTime]::MinValue) {
                $sb.Append(" | Due: " + $this.Task.DueDate.ToString("yyyy-MM-dd"))
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\_Backup/20250726_003635/Screens/EventBusMonitor.ps1
# EventBusMonitor.ps1 - Dialog for monitoring EventBus activity

class EventBusMonitor : Screen {
    [TextBox]$InfoDisplay
    [Button]$RefreshButton
    [Button]$ToggleHistoryButton
    [Button]$ToggleDebugButton
    [Button]$ClearHistoryButton
    [Button]$CloseButton
    [EventBus]$EventBus
    hidden [System.Timers.Timer]$RefreshTimer
    
    EventBusMonitor() : base() {
        $this.Title = "EventBus Monitor"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create info display
        $this.InfoDisplay = [TextBox]::new()
        $this.InfoDisplay.ReadOnly = $true
        $this.InfoDisplay.ShowBorder = $true
        $this.InfoDisplay.Text = "Loading EventBus information..."
        $this.InfoDisplay.Initialize($global:ServiceContainer)
        $this.AddChild($this.InfoDisplay)
        
        # Create buttons
        $this.RefreshButton = [Button]::new("Refresh")
        $this.RefreshButton.OnClick = { $this.RefreshInfo() }
        $this.RefreshButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.RefreshButton)
        
        $this.ToggleHistoryButton = [Button]::new("Toggle History")
        $this.ToggleHistoryButton.OnClick = { $this.ToggleHistory() }
        $this.ToggleHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleHistoryButton)
        
        $this.ToggleDebugButton = [Button]::new("Toggle Debug")
        $this.ToggleDebugButton.OnClick = { $this.ToggleDebug() }
        $this.ToggleDebugButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleDebugButton)
        
        $this.ClearHistoryButton = [Button]::new("Clear History")
        $this.ClearHistoryButton.OnClick = { $this.ClearHistory() }
        $this.ClearHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ClearHistoryButton)
        
        $this.CloseButton = [Button]::new("Close")
        $this.CloseButton.IsDefault = $true
        $this.CloseButton.OnClick = { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        $this.CloseButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CloseButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        })
        $this.BindKey('r', { $this.RefreshInfo() })
        $this.BindKey('h', { $this.ToggleHistory() })
        $this.BindKey('d', { $this.ToggleDebug() })
        $this.BindKey('c', { $this.ClearHistory() })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        
        # Initial refresh
        $this.RefreshInfo()
        
        # Focus on close button
        $this.CloseButton.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout components
        $padding = 2
        $buttonHeight = 3
        $buttonWidth = 20
        $buttonSpacing = 2
        
        # Info display takes most of the space
        $this.InfoDisplay.SetBounds(
            $this.X + $padding,
            $this.Y + $padding,
            $this.Width - ($padding * 2),
            $this.Height - $buttonHeight - ($padding * 3)
        )
        
        # Buttons at the bottom
        $totalButtonWidth = ($buttonWidth * 5) + ($buttonSpacing * 4)
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - $padding
        
        $this.RefreshButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleHistoryButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleDebugButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 2, $buttonY, $buttonWidth, $buttonHeight)
        $this.ClearHistoryButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 3, $buttonY, $buttonWidth, $buttonHeight)
        $this.CloseButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 4, $buttonY, $buttonWidth, $buttonHeight)
    }
    
    [void] RefreshInfo() {
        if (-not $this.EventBus) { return }
        
        $report = $this.EventBus.GetDebugReport()
        
        # Add recent history if enabled
        if ($this.EventBus.EnableHistory) {
            $history = $this.EventBus.GetEventHistory()
            if ($history.Count -gt 0) {
                $report += "`n`nRecent Events:`n"
                $recent = $history | Select-Object -Last 10
                foreach ($event in $recent) {
                    $report += "  $($event.Timestamp.ToString('HH:mm:ss')) - $($event.EventName)`n"
                }
            }
        }
        
        # Add keyboard shortcuts
        $report += "`n`nKeyboard Shortcuts:`n"
        $report += "  [R] Refresh  [H] Toggle History  [D] Toggle Debug`n"
        $report += "  [C] Clear History  [Esc] Close"
        
        $this.InfoDisplay.Text = $report
        $this.InfoDisplay.Invalidate()
    }
    
    [void] ToggleHistory() {
        if ($this.EventBus) {
            $this.EventBus.EnableHistory = -not $this.EventBus.EnableHistory
            $this.RefreshInfo()
        }
    }
    
    [void] ToggleDebug() {
        if ($this.EventBus) {
            $this.EventBus.EnableDebugLogging = -not $this.EventBus.EnableDebugLogging
            $this.RefreshInfo()
        }
    }
    
    [void] ClearHistory() {
        if ($this.EventBus) {
            $this.EventBus.ClearHistory()
            $this.RefreshInfo()
        }
    }
    
    [void] FocusNext() {
        $focusableChildren = @($this.RefreshButton, $this.ToggleHistoryButton, 
                              $this.ToggleDebugButton, $this.ClearHistoryButton, 
                              $this.CloseButton)
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        # Move to next
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\_Backup/20250726_003635/Screens/ExcelImportScreen.ps1
# ExcelImportScreen.ps1 - Excel import screen using PRAXIS patterns

class ExcelImportScreen : Screen {
    [FastFileTree]$FileTree
    [ListBox]$PreviewList
    [Button]$ImportButton
    [Button]$BackButton
    [ProgressBar]$ImportProgress
    [string]$SelectedFile
    [hashtable]$ImportedData
    [string]$StatusMessage = "Select an Excel file to import (SVI-CAS worksheet)"
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$StatusBarHeight = 1
    hidden [int]$ProgressHeight = 3
    
    ExcelImportScreen() : base() {
        $this.Title = "Excel Import"
    }
    
    [void] OnInitialize() {
        # Create file tree for Excel file selection
        $this.FileTree = [FastFileTree]::new()
        $this.FileTree.ShowBorder = $true
        $this.FileTree.Title = "Select Excel File"
        $this.FileTree.FileExtensions = @('.xlsx', '.xlsm', '.xls')
        $this.FileTree.ShowSize = $true
        $this.AddChild($this.FileTree)
        
        # Start with current directory
        $this.FileTree.LoadDirectory((Get-Location).Path)
        
        # Create preview list
        $this.PreviewList = [ListBox]::new()
        $this.PreviewList.Title = "Import Preview"
        $this.PreviewList.ShowBorder = $true
        $this.AddChild($this.PreviewList)
        
        # Create progress bar (initially hidden)
        $this.ImportProgress = [ProgressBar]::new()
        $this.ImportProgress.IsVisible = $false
        $this.AddChild($this.ImportProgress)
        
        # Create buttons
        $screen = $this  # Capture reference for closures
        
        $this.ImportButton = [Button]::new("Import")
        $this.ImportButton.IsEnabled = $false
        $this.ImportButton.OnClick = { $screen.StartImport() }.GetNewClosure()
        $this.AddChild($this.ImportButton)
        
        $this.BackButton = [Button]::new("Back")
        $this.BackButton.OnClick = { 
            $screen.ServiceContainer.GetService('ScreenManager').PopScreen() 
        }.GetNewClosure()
        $this.AddChild($this.BackButton)
        
        # Set up file selection handler
        $this.FileTree.OnFileSelected = {
            param($filePath)
            if ($filePath -match '\.xls[xm]?$') {
                $screen.SelectedFile = $filePath
                $screen.StatusMessage = "Selected: $(Split-Path $filePath -Leaf)"
                $screen.ImportButton.IsEnabled = $true
                $screen.PreviewFile()
                $screen.Invalidate()
            }
        }.GetNewClosure()
        
        # Key bindings
        $this.AddKeyBinding([ConsoleKey]::Escape, { 
            $this.ServiceContainer.GetService('ScreenManager').PopScreen() 
        })
        $this.AddKeyBinding([ConsoleKey]::I, { 
            if ($this.ImportButton.IsEnabled) { $this.StartImport() } 
        })
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.FileTree) { return }
        
        # Calculate layout
        $fileTreeHeight = [Math]::Floor(($this.Height - $this.StatusBarHeight - $this.ButtonHeight - 2) * 0.5)
        $previewHeight = $this.Height - $fileTreeHeight - $this.StatusBarHeight - $this.ButtonHeight - 2
        
        # Position file tree at top
        $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $fileTreeHeight)
        
        # Position preview list below file tree
        $previewY = $this.Y + $fileTreeHeight + 1
        $this.PreviewList.SetBounds($this.X, $previewY, $this.Width, $previewHeight)
        
        # Position progress bar over preview area when visible
        if ($this.ImportProgress.IsVisible) {
            $progressY = $previewY + [Math]::Floor($previewHeight / 2) - 1
            $this.ImportProgress.SetBounds($this.X + 4, $progressY, $this.Width - 8, $this.ProgressHeight)
        }
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - $this.StatusBarHeight
        $buttonWidth = 12
        $this.ImportButton.SetBounds($this.X + $this.Width - ($buttonWidth * 2) - 4, $buttonY, $buttonWidth, 3)
        $this.BackButton.SetBounds($this.X + $this.Width - $buttonWidth - 2, $buttonY, $buttonWidth, 3)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus on file tree
        if ($this.FileTree) {
            $this.FileTree.Focus()
        }
    }
    
    [void] PreviewFile() {
        if (-not $this.SelectedFile) { return }
        
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("File: $(Split-Path $this.SelectedFile -Leaf)")
        $this.PreviewList.AddItem("Path: $($this.SelectedFile)")
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("This will import data from the 'SVI-CAS' worksheet")
        $this.PreviewList.AddItem("Press 'Import' to continue...")
    }
    
    [void] StartImport() {
        if (-not $this.SelectedFile) { return }
        
        $this.ImportButton.IsEnabled = $false
        $this.ImportProgress.IsVisible = $true
        $this.ImportProgress.Value = 0
        $this.StatusMessage = "Importing from Excel..."
        $this.OnBoundsChanged()  # Reposition progress bar
        $this.Invalidate()
        
        try {
            # Get Excel import service
            $excelService = $this.ServiceContainer.GetService('ExcelImportService')
            if (-not $excelService) {
                throw "Excel import service not available"
            }
            
            # Import data
            $this.ImportProgress.Value = 20
            $this.StatusMessage = "Reading Excel file..."
            $this.Invalidate()
            
            $this.ImportedData = $excelService.ImportFromExcel($this.SelectedFile)
            
            $this.ImportProgress.Value = 50
            $this.StatusMessage = "Processing data..."
            $this.Invalidate()
            
            # Display preview
            $this.ShowImportPreview()
            
            $this.ImportProgress.Value = 80
            $this.StatusMessage = "Creating project..."
            $this.Invalidate()
            
            # Create project from imported data
            $project = $excelService.CreateProjectFromImport($this.ImportedData)
            
            # Save project
            $projectService = $this.ServiceContainer.GetService('ProjectService')
            $projectService.CreateProject($project)
            
            $this.ImportProgress.Value = 100
            $this.StatusMessage = "Import completed successfully! Project ID2: $($project.ID2)"
            $this.Invalidate()
            
            # Show success and return to projects screen after delay
            Start-Sleep -Seconds 2
            $screenManager = $this.ServiceContainer.GetService('ScreenManager')
            $screenManager.PopScreen()
            
            # Fire event to refresh projects list
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Publish([EventNames]::ProjectCreated, $this, @{ Project = $project })
            }
        }
        catch {
            $this.StatusMessage = "Import failed: $_"
            $this.ImportProgress.IsVisible = $false
            $this.ImportButton.IsEnabled = $true
            $this.OnBoundsChanged()  # Reset layout
            $this.Invalidate()
        }
    }
    
    [void] ShowImportPreview() {
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("=== IMPORTED DATA PREVIEW ===")
        $this.PreviewList.AddItem("")
        
        # Core project info
        if ($this.ImportedData.CASCase) {
            $this.PreviewList.AddItem("ID2 (CAS Case#): $($this.ImportedData.CASCase)")
        }
        if ($this.ImportedData.TPName) {
            $this.PreviewList.AddItem("TP Name: $($this.ImportedData.TPName)")
        }
        if ($this.ImportedData.TPNum) {
            $this.PreviewList.AddItem("TP Number: $($this.ImportedData.TPNum)")
        }
        if ($this.ImportedData.AuditType) {
            $this.PreviewList.AddItem("Audit Type: $($this.ImportedData.AuditType)")
        }
        
        # Address
        if ($this.ImportedData.Address -or $this.ImportedData.City) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("ADDRESS:")
            if ($this.ImportedData.Address) {
                $this.PreviewList.AddItem("  $($this.ImportedData.Address)")
            }
            if ($this.ImportedData.City -or $this.ImportedData.Province) {
                $this.PreviewList.AddItem("  $($this.ImportedData.City), $($this.ImportedData.Province) $($this.ImportedData.PostalCode)")
            }
        }
        
        # Auditor info
        if ($this.ImportedData.AuditorName) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("AUDITOR:")
            $this.PreviewList.AddItem("  $($this.ImportedData.AuditorName) - $($this.ImportedData.AuditorPhone)")
            if ($this.ImportedData.AuditorTL) {
                $this.PreviewList.AddItem("  Team Lead: $($this.ImportedData.AuditorTL)")
            }
        }
        
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("Press 'Import' to create project...")
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base screen first
        $null = $sb.Append(([Screen]$this).OnRender())
        
        # Render status bar at bottom
        $statusY = $this.Y + $this.Height - 1
        $null = $sb.Append($this.VT.MoveTo($this.X, $statusY))
        $null = $sb.Append($this.ThemeManager.GetCached('StatusBar'))
        $null = $sb.Append(' ' * $this.Width)  # Clear line
        $null = $sb.Append($this.VT.MoveTo($this.X + 2, $statusY))
        $null = $sb.Append($this.StatusMessage)
        $null = $sb.Append($this.VT.Reset)
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\_Backup/20250726_003635/Screens/FileBrowserScreen.ps1
# FileBrowserScreen - File browser using FastFileTree component
# Proper PRAXIS architecture implementation

class FileBrowserScreen : Screen {
    [RangerFileTree]$FileTree
    [scriptblock]$FileSelectedCallback = $null  # Callback for file selection
    
    FileBrowserScreen() : base() {
        $this.Title = "File Browser - [h/]Back [j/]Down [k/]Up [l/]Enter [.]Hidden"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnInitialize: Starting initialization")
        }
        
        # Create and configure the ranger-style file tree
        $this.FileTree = [RangerFileTree]::new()
        $this.FileTree.CurrentPath = (Get-Location).Path
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen: Created RangerFileTree with path: $($this.FileTree.CurrentPath)")
            $global:Logger.Debug("FileBrowserScreen: FileTree IsFocusable: $($this.FileTree.IsFocusable)")
        }
        
        # Add the file tree as a child component BEFORE initializing
        # This ensures Parent is set correctly
        $this.AddChild($this.FileTree)
        
        # Initialize the FileTree with the service container
        $this.FileTree.Initialize($this.ServiceContainer)
        
        # Set up event handlers
        $screen = $this  # Capture reference for closures
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($screen.FileSelectedCallback) {
                & $screen.FileSelectedCallback $node.FullPath
            } else {
                # Default behavior: open text editor for files
                $screen.OpenFileInEditor($node.FullPath)
            }
        }.GetNewClosure()
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnInitialize: Completed, Children.Count=$($this.Children.Count)")
        }
    }
    
    [void] OnBoundsChanged() {
        # Call base implementation
        ([Screen]$this).OnBoundsChanged()
        
        # Set the file tree to fill the entire screen
        if ($this.FileTree -and $this.Width -gt 0 -and $this.Height -gt 0) {
            $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
            
            if ($global:Logger) {
                $global:Logger.Debug("FileBrowserScreen.OnBoundsChanged: Set FileTree bounds to ($($this.X),$($this.Y),$($this.Width),$($this.Height))")
            }
        } elseif ($global:Logger) {
            $global:Logger.Warning("FileBrowserScreen.OnBoundsChanged: Invalid bounds - FileTree=$($this.FileTree -ne $null), Width=$($this.Width), Height=$($this.Height)")
        }
    }
    
    [void] OpenFileInEditor([string]$filePath) {
        if (-not $filePath -or -not (Test-Path $filePath)) {
            return
        }
        
        $item = Get-Item $filePath -ErrorAction SilentlyContinue
        if ($item -and -not $item.PSIsContainer) {
            # It's a file, open in text editor
            try {
                $editorType = [type]"TextEditorScreen"
                if ($editorType) {
                    $editor = $editorType::new($filePath)
                    
                    # Get screen manager and push the editor
                    $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Push($editor)
                }
            } catch {
                # TextEditorScreen not available
                if ($global:Logger) {
                    $global:Logger.Info("TextEditor not available for file: $filePath")
                }
            }
        }
    }
    
    # Override OnActivated to ensure FileTree gets focus
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnActivated: Screen activated")
            $global:Logger.Debug("  Children.Count = $($this.Children.Count)")
        }
        
        # Use FocusFirst to focus the first focusable child (should be FileTree)
        $this.FocusFirst()
        
        if ($global:Logger) {
            # Check what got focused
            $focusedChild = $this.FindFocusedChild()
            if ($focusedChild) {
                $global:Logger.Debug("  Focused child: $($focusedChild.GetType().Name)")
                $global:Logger.Debug("  Focused child IsFocused: $($focusedChild.IsFocused)")
            } else {
                $global:Logger.Debug("  No focused child found after FocusFirst()!")
                # Try direct focus as fallback
                if ($this.FileTree) {
                    $global:Logger.Debug("  Attempting direct FileTree.Focus()")
                    $this.FileTree.Focus()
                    # Check again
                    $focusedChild = $this.FindFocusedChild()
                    if ($focusedChild) {
                        $global:Logger.Debug("  After direct focus: Found $($focusedChild.GetType().Name)")
                    } else {
                        $global:Logger.Debug("  Still no focused child!")
                    }
                }
            }
        }
    }
    
    # Override HandleInput to debug input routing
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)'")
            $global:Logger.Debug("  FileTree.IsFocused = $($this.FileTree.IsFocused)")
        }
        
        # Call base implementation
        return ([Screen]$this).HandleInput($key)
    }
}


####\_Backup/20250726_003635/Screens/FilePickerDialog.ps1
# FilePickerDialog.ps1 - File selection dialog using FastFileTree
# Modal dialog for selecting files or directories

class FilePickerDialog : Screen {
    [FastFileTree]$FileTree
    [Button]$SelectButton
    [Button]$CancelButton
    [TextBox]$PathBox
    
    # Configuration
    [string]$InitialPath = ""
    [string]$Filter = "*"
    [bool]$AllowDirectories = $false
    [bool]$AllowFiles = $true
    [bool]$MustExist = $true
    [string]$DialogTitle = "Select File"
    
    # Results
    [string]$SelectedPath = ""
    [bool]$DialogResult = $false
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    # Layout
    hidden [int]$_treeHeight = 20
    hidden [int]$_dialogWidth = 80
    hidden [int]$_dialogHeight = 25
    
    FilePickerDialog() : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $PWD.Path
    }
    
    FilePickerDialog([string]$initialPath) : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $initialPath
    }
    
    [void] OnInitialize() {
        # Calculate dialog position (centered)
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        # Path input box at top
        $this.PathBox = [TextBox]::new()
        $this.PathBox.Placeholder = "Enter path or navigate below"
        $this.PathBox.Text = $this.InitialPath
        $this.PathBox.SetBounds([int]$centerX + 2, [int]$centerY + 2, $this._dialogWidth - 4, 3)
        $this.PathBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.PathBox)
        
        # File tree in the middle
        $this.FileTree = [FastFileTree]::new($this.InitialPath)
        $this.FileTree.Title = $this.DialogTitle
        $this.FileTree.Filter = $this.Filter
        $this.FileTree.ShowBorder = $true
        $this.FileTree.SetBounds([int]$centerX + 2, [int]$centerY + 6, $this._dialogWidth - 4, $this._treeHeight)
        $this.FileTree.Initialize($global:ServiceContainer)
        
        # Set up events
        $dialogRef = $this
        $this.FileTree.OnSelectionChanged = {
            $selected = $dialogRef.FileTree.GetSelectedNode()
            if ($selected) {
                $dialogRef.PathBox.Text = $selected.FullPath
                $dialogRef.UpdateButtonStates()
            }
        }.GetNewClosure()
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($dialogRef.IsValidSelection($node)) {
                $dialogRef.SelectedPath = $node.FullPath
                $dialogRef.DialogResult = $true
                $dialogRef.Active = $false
            }
        }.GetNewClosure()
        
        $this.AddChild($this.FileTree)
        
        # Buttons at bottom
        $buttonY = [int]$centerY + 6 + $this._treeHeight + 1
        $buttonWidth = 15
        $buttonSpacing = 2
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = [int]$centerX + (($this._dialogWidth - $totalButtonWidth) / 2)
        
        $this.SelectButton = [Button]::new("Select")
        $this.SelectButton.IsDefault = $true
        $this.SelectButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, 3)
        $this.SelectButton.OnClick = {
            $dialogRef.SelectFile()
        }.GetNewClosure()
        $this.SelectButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SelectButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, 3)
        $this.CancelButton.OnClick = {
            $dialogRef.SelectedPath = ""
            $dialogRef.DialogResult = $false
            $dialogRef.Active = $false
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.FileTree.Focus()
        
        # Update button states
        $this.UpdateButtonStates()
    }
    
    [void] UpdateButtonStates() {
        $selected = $this.FileTree.GetSelectedNode()
        $isValid = $this.IsValidSelection($selected)
        
        # Enable/disable select button based on selection
        # Note: Button doesn't have Enabled property in current implementation
        # This is a placeholder for when we add that functionality
        
        # Update button text to reflect what will happen
        if ($selected) {
            if ($selected.IsDirectory) {
                $this.SelectButton.Text = if ($this.AllowDirectories) { "Select Folder" } else { "Enter" }
            } else {
                $this.SelectButton.Text = "Select File"
            }
        } else {
            $this.SelectButton.Text = "Select"
        }
        $this.SelectButton.Invalidate()
    }
    
    [bool] IsValidSelection([FileSystemNode]$node) {
        if ($node -eq $null) {
            return $false
        }
        
        # Check if selection type is allowed
        if ($node.IsDirectory -and -not $this.AllowDirectories) {
            return $false
        }
        
        if (-not $node.IsDirectory -and -not $this.AllowFiles) {
            return $false
        }
        
        # Check if file exists (if required)
        if ($this.MustExist -and -not (Test-Path $node.FullPath)) {
            return $false
        }
        
        return $true
    }
    
    [void] SelectFile() {
        $selected = $this.FileTree.GetSelectedNode()
        
        if ($selected -and $this.IsValidSelection($selected)) {
            $this.SelectedPath = $selected.FullPath
            $this.DialogResult = $true
            
            # Fire event
            if ($this.OnFileSelected) {
                & $this.OnFileSelected $selected.FullPath
            }
            
            $this.Active = $false
        } elseif ($selected -and $selected.IsDirectory -and -not $this.AllowDirectories) {
            # Navigate into directory instead of selecting it
            $this.FileTree.NavigateToSelected()
            $this.PathBox.Text = $this.FileTree.RootPath
        } else {
            # Try to use path from text box
            $pathFromBox = $this.PathBox.Text.Trim()
            if ($pathFromBox -and (Test-Path $pathFromBox)) {
                $this.SelectedPath = $pathFromBox
                $this.DialogResult = $true
                
                if ($this.OnFileSelected) {
                    & $this.OnFileSelected $pathFromBox
                }
                
                $this.Active = $false
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Dialog is positioned manually in OnInitialize
        # This could be enhanced to support resizing
    }
    
    [string] OnRender() {
        # Draw dark overlay background
        $sb = Get-PooledStringBuilder 2048
        
        # Semi-transparent background overlay
        $overlayColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.overlay") } else { "`e[48;2;0;0;0m" }
        
        for ($y = 0; $y -lt [Console]::WindowHeight; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayColor)
            $sb.Append([StringCache]::GetSpaces([Console]::WindowWidth))
        }
        
        # Dialog border
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("dialog.border") } else { "`e[38;2;100;100;100m" }
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.background") } else { "`e[48;2;40;40;40m" }
        
        # Draw dialog background
        for ($y = 0; $y -lt $this._dialogHeight; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this._dialogWidth))
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::TR())
        
        for ($y = 1; $y -lt $this._dialogHeight - 1; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            $sb.Append([VT]::MoveTo([int]$centerX + $this._dialogWidth - 1, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $this._dialogHeight - 1))
        $sb.Append($borderColor)
        $sb.Append([VT]::BL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::BR())
        
        # Title
        if ($this.DialogTitle) {
            $sb.Append([VT]::MoveTo([int]$centerX + 2, [int]$centerY))
            $titleColor = if ($this.Theme) { $this.Theme.GetColor("dialog.title") } else { "`e[38;2;255;255;255m" }
            $sb.Append($titleColor)
            $sb.Append(" $($this.DialogTitle) ")
        }
        
        $sb.Append([VT]::Reset())
        
        # Render children on top
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                $this.SelectedPath = ""
                $this.DialogResult = $false
                $this.Active = $false
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.PathBox.IsFocused) {
                    # Try to navigate to path in text box
                    $path = $this.PathBox.Text.Trim()
                    if ($path -and (Test-Path $path)) {
                        if (Test-Path $path -PathType Container) {
                            $this.FileTree.LoadDirectory($path)
                            $this.FileTree.Focus()
                        } else {
                            # It's a file, select it
                            $this.SelectedPath = $path
                            $this.DialogResult = $true
                            $this.Active = $false
                        }
                    }
                    return $true
                }
                # Let other controls handle Enter
                break
            }
            ([System.ConsoleKey]::Tab) {
                # Cycle focus between controls
                if ($this.PathBox.IsFocused) {
                    $this.FileTree.Focus()
                } elseif ($this.FileTree.IsFocused) {
                    $this.SelectButton.Focus()
                } elseif ($this.SelectButton.IsFocused) {
                    $this.CancelButton.Focus()
                } else {
                    $this.PathBox.Focus()
                }
                return $true
            }
        }
        
        # Let base Screen handle other input
        return ([Screen]$this).HandleInput($key)
    }
}


####\_Backup/20250726_003635/Screens/FindReplaceDialog.ps1
# FindReplaceDialog.ps1 - Find and replace functionality for text editor
# Provides search and replace capabilities with various options

class FindReplaceDialog : BaseDialog {
    # UI Controls
    [TextBox]$FindTextBox
    [TextBox]$ReplaceTextBox
    [Button]$FindNextButton
    [Button]$FindPreviousButton
    [Button]$ReplaceButton
    [Button]$ReplaceAllButton
    
    # Search options (could be checkboxes in future)
    [bool]$MatchCase = $false
    [bool]$WholeWord = $false
    [bool]$RegexMode = $false
    
    # Search state
    hidden [int]$_lastFoundLine = -1
    hidden [int]$_lastFoundColumn = -1
    hidden [string]$_lastSearchTerm = ""
    
    # Reference to the text editor
    hidden [object]$_textEditor
    hidden [object]$_buffer
    
    # Callback for when dialog closes
    [scriptblock]$OnClose = {}
    
    FindReplaceDialog([object]$textEditor) : base("Find & Replace", 70, 16) {
        $this._textEditor = $textEditor
        $this._buffer = $textEditor._buffer
        
        # Configure dialog buttons
        $this.PrimaryButtonText = "Find Next"
        $this.SecondaryButtonText = "Close"
    }
    
    [void] InitializeContent() {
        # Find text box
        $this.FindTextBox = [TextBox]::new()
        $this.FindTextBox.Placeholder = "Text to find..."
        $this.FindTextBox.Width = 50
        $this.AddContentControl($this.FindTextBox, 1)
        
        # Replace text box  
        $this.ReplaceTextBox = [TextBox]::new()
        $this.ReplaceTextBox.Placeholder = "Replace with..."
        $this.ReplaceTextBox.Width = 50
        $this.AddContentControl($this.ReplaceTextBox, 2)
        
        # Find buttons
        $this.FindNextButton = [Button]::new("Find Next")
        $this.FindNextButton.OnClick = {
            $this.FindNext()
        }.GetNewClosure()
        $this.AddContentControl($this.FindNextButton, 3)
        
        $this.FindPreviousButton = [Button]::new("Find Previous")
        $this.FindPreviousButton.OnClick = {
            $this.FindPrevious()
        }.GetNewClosure()
        $this.AddContentControl($this.FindPreviousButton, 4)
        
        # Replace buttons
        $this.ReplaceButton = [Button]::new("Replace")
        $this.ReplaceButton.OnClick = {
            $this.ReplaceNext()
        }.GetNewClosure()
        $this.AddContentControl($this.ReplaceButton, 5)
        
        $this.ReplaceAllButton = [Button]::new("Replace All")
        $this.ReplaceAllButton.OnClick = {
            $this.ReplaceAll()
        }.GetNewClosure()
        $this.AddContentControl($this.ReplaceAllButton, 6)
        
        # Set initial focus to find text box
        $this.FindTextBox.Focus()
        
        # Pre-populate with selected text if available
        if ($this._textEditor.HasSelection) {
            $selectedText = $this.GetSelectedText()
            if ($selectedText -and $selectedText.Length -lt 100) {
                $this.FindTextBox.SetText($selectedText)
            }
        }
    }
    
    [string] GetSelectedText() {
        if (-not $this._textEditor.HasSelection) {
            return ""
        }
        
        $bounds = $this._textEditor.GetSelectionBounds()
        if ($bounds.StartY -eq $bounds.EndY) {
            # Single line selection
            $line = $this._buffer.GetLine($bounds.StartY)
            return $line.Substring($bounds.StartX, $bounds.EndX - $bounds.StartX)
        } else {
            # Multi-line selection - just return first line for simplicity
            $line = $this._buffer.GetLine($bounds.StartY)
            return $line.Substring($bounds.StartX)
        }
    }
    
    [void] HandlePrimaryAction() {
        # Primary action is Find Next
        $this.FindNext()
    }
    
    [void] HandleSecondaryAction() {
        # Secondary action is Close
        if ($this.OnClose) {
            & $this.OnClose
        }
        $this.CloseDialog()
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Handle F3 for Find Next
        if ($key.Key -eq [System.ConsoleKey]::F3) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.FindPrevious()
            } else {
                $this.FindNext()
            }
            return $true
        }
        
        # Handle Ctrl+H for Replace
        if ($key.Key -eq [System.ConsoleKey]::H -and ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            $this.ReplaceNext()
            return $true
        }
        
        # Let base class handle other keys
        return ([BaseDialog]$this).HandleScreenInput($key)
    }
    
    [void] FindNext() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        # Start search from current cursor position or after last found position
        $startLine = $this._textEditor.CursorY
        $startCol = $this._textEditor.CursorX
        
        # If we're searching for the same term and found it before, start after the last find
        if ($searchTerm -eq $this._lastSearchTerm -and $this._lastFoundLine -ge 0) {
            $startLine = $this._lastFoundLine
            $startCol = $this._lastFoundColumn + $searchTerm.Length
        }
        
        $result = $this.SearchForward($searchTerm, $startLine, $startCol)
        $this.HandleSearchResult($result, $searchTerm)
    }
    
    [void] FindPrevious() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        # Start search from current cursor position or before last found position
        $startLine = $this._textEditor.CursorY
        $startCol = $this._textEditor.CursorX
        
        # If we're searching for the same term and found it before, start before the last find
        if ($searchTerm -eq $this._lastSearchTerm -and $this._lastFoundLine -ge 0) {
            $startLine = $this._lastFoundLine
            $startCol = $this._lastFoundColumn - 1
        }
        
        $result = $this.SearchBackward($searchTerm, $startLine, $startCol)
        $this.HandleSearchResult($result, $searchTerm)
    }
    
    [hashtable] SearchForward([string]$searchTerm, [int]$startLine, [int]$startCol) {
        $lineCount = $this._buffer.GetLineCount()
        
        # Search from starting position to end of document
        for ($line = $startLine; $line -lt $lineCount; $line++) {
            $lineText = $this._buffer.GetLine($line)
            $searchStart = if ($line -eq $startLine) { $startCol } else { 0 }
            
            $index = $this.FindInLine($lineText, $searchTerm, $searchStart)
            if ($index -ge 0) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                }
            }
        }
        
        # Wrap around - search from beginning to start position
        for ($line = 0; $line -lt $startLine; $line++) {
            $lineText = $this._buffer.GetLine($line)
            $searchEnd = if ($line -eq $startLine - 1) { $startCol } else { $lineText.Length }
            
            $index = $this.FindInLine($lineText, $searchTerm, 0)
            if ($index -ge 0 -and $index -lt $searchEnd) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                    Wrapped = $true
                }
            }
        }
        
        return @{ Found = $false }
    }
    
    [hashtable] SearchBackward([string]$searchTerm, [int]$startLine, [int]$startCol) {
        # Search from starting position to beginning of document
        for ($line = $startLine; $line -ge 0; $line--) {
            $lineText = $this._buffer.GetLine($line)
            $searchEnd = if ($line -eq $startLine) { $startCol } else { $lineText.Length }
            
            $index = $this.FindInLineBackward($lineText, $searchTerm, $searchEnd)
            if ($index -ge 0) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                }
            }
        }
        
        # Wrap around - search from end to start position
        $lineCount = $this._buffer.GetLineCount()
        for ($line = $lineCount - 1; $line -gt $startLine; $line--) {
            $lineText = $this._buffer.GetLine($line)
            
            $index = $this.FindInLineBackward($lineText, $searchTerm, $lineText.Length)
            if ($index -ge 0) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                    Wrapped = $true
                }
            }
        }
        
        return @{ Found = $false }
    }
    
    [int] FindInLine([string]$line, [string]$searchTerm, [int]$startIndex) {
        if ($this.MatchCase) {
            return $line.IndexOf($searchTerm, $startIndex)
        } else {
            return $line.ToLower().IndexOf($searchTerm.ToLower(), $startIndex)
        }
    }
    
    [int] FindInLineBackward([string]$line, [string]$searchTerm, [int]$endIndex) {
        if ($endIndex -le 0) { return -1 }
        
        $searchableText = $line.Substring(0, $endIndex)
        if ($this.MatchCase) {
            return $searchableText.LastIndexOf($searchTerm)
        } else {
            return $searchableText.ToLower().LastIndexOf($searchTerm.ToLower())
        }
    }
    
    [void] HandleSearchResult([hashtable]$result, [string]$searchTerm) {
        if ($result.Found) {
            # Move cursor to found position
            $this._textEditor.CursorY = $result.Line
            $this._textEditor.CursorX = $result.Column
            $this._textEditor.EnsureCursorVisible()
            
            # Select the found text
            $this._textEditor.StartSelection()
            $this._textEditor.SelectionStartX = $result.Column
            $this._textEditor.SelectionStartY = $result.Line
            $this._textEditor.SelectionEndX = $result.Column + $searchTerm.Length
            $this._textEditor.SelectionEndY = $result.Line
            $this._textEditor.CursorX = $result.Column + $searchTerm.Length
            
            # Update last found position
            $this._lastFoundLine = $result.Line
            $this._lastFoundColumn = $result.Column
            $this._lastSearchTerm = $searchTerm
            
            # Set status message
            $wrapMsg = if ($result.Wrapped) { " (wrapped)" } else { "" }
            $this._textEditor.StatusMessage = "Found at line $($result.Line + 1), column $($result.Column + 1)$wrapMsg"
        } else {
            $this._textEditor.StatusMessage = "Text not found: '$searchTerm'"
            $this._lastFoundLine = -1
            $this._lastFoundColumn = -1
        }
        
        $this._textEditor.Invalidate()
    }
    
    [void] ReplaceNext() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        $replaceText = $this.ReplaceTextBox.Text
        
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        # If we have a selection that matches the search term, replace it
        if ($this._textEditor.HasSelection) {
            $selectedText = $this.GetSelectedText()
            $matchesSearch = if ($this.MatchCase) { 
                $selectedText -eq $searchTerm 
            } else { 
                $selectedText.ToLower() -eq $searchTerm.ToLower() 
            }
            
            if ($matchesSearch) {
                # Replace the selected text
                $this._textEditor.SaveDocumentState()
                $this._textEditor.DeleteSelection()
                if ($replaceText) {
                    $this._textEditor._buffer.InsertTextAt($this._textEditor.CursorY, $this._textEditor.CursorX, $replaceText)
                    $this._textEditor.CursorX += $replaceText.Length
                }
                $this._textEditor._buffer.IsModified = $true
                $this._textEditor._allLinesDirty = $true
                $this._textEditor.Invalidate()
                $this._textEditor.StatusMessage = "Replaced 1 occurrence"
                
                # Find next occurrence
                $this.FindNext()
                return
            }
        }
        
        # No selection or selection doesn't match - just find next
        $this.FindNext()
    }
    
    [void] ReplaceAll() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        $replaceText = $this.ReplaceTextBox.Text
        
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        $this._textEditor.SaveDocumentState()
        $replacements = 0
        $lineCount = $this._buffer.GetLineCount()
        
        # Search through all lines
        for ($line = 0; $line -lt $lineCount; $line++) {
            $lineText = $this._buffer.GetLine($line)
            $originalText = $lineText
            
            # Keep replacing until no more matches in this line
            $modified = $false
            do {
                $index = $this.FindInLine($lineText, $searchTerm, 0)
                if ($index -ge 0) {
                    # Replace the occurrence
                    $before = $lineText.Substring(0, $index)
                    $after = $lineText.Substring($index + $searchTerm.Length)
                    $lineText = $before + $replaceText + $after
                    $replacements++
                    $modified = $true
                } else {
                    break
                }
            } while ($true)
            
            # Update the line if it was modified
            if ($modified) {
                $this._buffer.Lines[$line] = $lineText
            }
        }
        
        if ($replacements -gt 0) {
            $this._buffer.IsModified = $true
            $this._textEditor._allLinesDirty = $true
            $this._textEditor.Invalidate()
            $this._textEditor.StatusMessage = "Replaced $replacements occurrence(s)"
        } else {
            $this._textEditor.StatusMessage = "No occurrences found to replace"
        }
    }
    
    # Override OnRender to add field labels
    [string] OnRender() {
        # Get base dialog rendering first
        $baseRender = ([BaseDialog]$this).OnRender()
        
        # Add field labels over the dialog content
        $sb = [System.Text.StringBuilder]::new($baseRender)
        
        if ($this._dialogBounds.Count -gt 0) {
            $dialogX = $this._dialogBounds.X
            $dialogY = $this._dialogBounds.Y
            $labelColor = $this.Theme.GetColor("dialog.text")
            
            # Add labels for each field
            $fieldY = $dialogY + $this.DialogPadding
            
            # Find label
            $sb.Append([VT]::MoveTo($dialogX + 2, $fieldY))
            $sb.Append($labelColor)
            $sb.Append("Find:")
            $fieldY += 4
            
            # Replace label  
            $sb.Append([VT]::MoveTo($dialogX + 2, $fieldY))
            $sb.Append("Replace:")
            
            # Add status about search options if any are enabled
            if ($this.MatchCase -or $this.WholeWord -or $this.RegexMode) {
                $options = @()
                if ($this.MatchCase) { $options += "Match Case" }
                if ($this.WholeWord) { $options += "Whole Word" }
                if ($this.RegexMode) { $options += "Regex" }
                
                $sb.Append([VT]::MoveTo($dialogX + 2, $dialogY + $this.DialogHeight - 4))
                $sb.Append("Options: $($options -join ', ')")
            }
        }
        
        return $sb.ToString()
    }
}


####\_Backup/20250726_003635/Screens/MainScreen.ps1
# MainScreen.ps1 - Main screen with tab container

class MainScreen : Screen {
    [TabContainer]$TabContainer
    [CommandPalette]$CommandPalette
    [EventBus]$EventBus
    hidden [string]$TabChangedSubscription
    
    MainScreen() : base() {
        $this.Title = "PRAXIS"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to tab change events  
        if ($this.EventBus) {
            # Use string directly to avoid potential class loading issues
            $this.TabChangedSubscription = $this.EventBus.Subscribe('navigation.tabChanged', {
                param($sender, $eventData)
                if ($eventData.TabIndex -ne $null -and $this.TabContainer) {
                    $this.TabContainer.ActivateTab($eventData.TabIndex)
                    $this.RequestRender()
                }
            }.GetNewClosure())
        }
        
        # Create tab container
        $this.TabContainer = [TabContainer]::new()
        $this.TabContainer.Initialize($global:ServiceContainer)
        $this.AddChild($this.TabContainer)
        
        # Add real screens as tabs
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Adding tabs to TabContainer")
        }
        
        $projectsScreen = [ProjectsScreen]::new()
        $this.TabContainer.AddTab("Projects", $projectsScreen)
        
        $taskScreen = [TaskScreen]::new()
        $this.TabContainer.AddTab("Tasks", $taskScreen)
        
        $timeEntryScreen = [TimeEntryScreen]::new()
        $this.TabContainer.AddTab("Time", $timeEntryScreen)
        
        $fileBrowserScreen = [FileBrowserScreen]::new()
        $this.TabContainer.AddTab("Files", $fileBrowserScreen)
        
        $textEditorScreen = [TextEditorScreenNew]::new()
        $this.TabContainer.AddTab("Editor", $textEditorScreen)
        
        $commandLibraryScreen = [CommandLibraryScreen]::new()
        $this.TabContainer.AddTab("Commands", $commandLibraryScreen)
        
        $macroFactoryScreen = [VisualMacroFactoryScreen]::new()
        $this.TabContainer.AddTab("Macro Factory", $macroFactoryScreen)
        
        $settingsScreen = [SettingsScreen]::new()
        $this.TabContainer.AddTab("Settings", $settingsScreen)
        
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Added $($this.TabContainer.Tabs.Count) tabs")
        }
        
        # Create command palette (overlay)
        $this.CommandPalette = [CommandPalette]::new()
        $this.CommandPalette.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandPalette)
        
        # Ensure bounds are set if we already have them
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $this.OnBoundsChanged()
        }
        
        # Key bindings now handled by GetShortcutBindings() method
    }
    
    
    [void] OnBoundsChanged() {
        if ($this.TabContainer) {
            $this.TabContainer.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
        if ($this.CommandPalette) {
            # Command palette uses full screen for centering
            $this.CommandPalette.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure bounds are set
        if ($this.Width -eq 0 -or $this.Height -eq 0) {
            $this.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
        }
        
        # Activate the active tab's content screen
        if ($this.TabContainer) {
            $activeTab = $this.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                # Screens are not focusable - call OnActivated instead
                if ($activeTab.Content -is [Screen]) {
                    $activeTab.Content.OnActivated()
                } else {
                    $activeTab.Content.Focus()
                }
            }
        }
    }
    
    # Override to handle global shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Global shortcuts
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Q) {
                # Only handle Q for quit if Ctrl is pressed
                # This prevents conflict with child screens using 'q'
                if ($keyInfo.Modifiers -eq [System.ConsoleModifiers]::Control) {
                    $this.Active = $false  # Exit the main loop
                    return $true
                }
            }
            # Remove Escape handling - let child screens handle it
        }
        
        # Let TabContainer handle tab switching shortcuts (numbers, Ctrl+Tab, etc)
        # This is safe because TabContainer is not focusable, so it won't be in the normal input chain
        if ($this.TabContainer) {
            return $this.TabContainer.HandleInput($keyInfo)
        }
        
        return $false
    }
}


####\_Backup/20250726_003635/Screens/NewProjectDialog.ps1
# NewProjectDialog.ps1 - Dialog for creating new projects (refactored to use BaseDialog)

class NewProjectDialog : BaseDialog {
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$ID1Box
    [TextBox]$ID2Box
    [TextBox]$NotesBox
    [TextBox]$CAAPathBox
    [TextBox]$RequestPathBox
    [TextBox]$T2020PathBox
    [TextBox]$DueDateBox
    
    NewProjectDialog() : base("New Project") {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 22
    }
    
    [void] InitializeContent() {
        # Create all project input fields
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [TextBox]::new()
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [TextBox]::new()
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NotesBox = [TextBox]::new()
        $this.NotesBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NotesBox, 5)
        
        $this.CAAPathBox = [TextBox]::new()
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [TextBox]::new()
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [TextBox]::new()
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.DueDateBox.Text = ([DateTime]::Now.AddDays(42)).ToString("MM/dd/yyyy")
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = [DateTime]::Now.AddDays(42)
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Use default if parsing fails
                        $dueDate = [DateTime]::Now.AddDays(42)
                    }
                }
                
                $projectData = @{
                    FullProjectName = $dialog.NameBox.Text
                    Nickname = if ($dialog.NicknameBox.Text.Trim()) { $dialog.NicknameBox.Text } else { $dialog.NameBox.Text }
                    ID1 = $dialog.ID1Box.Text
                    ID2 = $dialog.ID2Box.Text
                    Note = $dialog.NotesBox.Text
                    CAAPath = $dialog.CAAPathBox.Text
                    RequestPath = $dialog.RequestPathBox.Text
                    T2020Path = $dialog.T2020PathBox.Text
                    DateDue = $dueDate
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create project via service
                    $projectService = $global:ServiceContainer.GetService("ProjectService")
                    if ($projectService) {
                        # Create project with full data
                        $newProject = $projectService.AddProject($projectData.FullProjectName, $projectData.Nickname)
                        
                        # Update additional properties
                        $newProject.ID1 = $projectData.ID1
                        $newProject.ID2 = $projectData.ID2
                        $newProject.Note = $projectData.Note
                        $newProject.CAAPath = $projectData.CAAPath
                        $newProject.RequestPath = $projectData.RequestPath
                        $newProject.T2020Path = $projectData.T2020Path
                        $newProject.DateDue = $projectData.DateDue
                        
                        # Save the updated project
                        $projectService.SaveProject($newProject)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::ProjectCreated, @{ 
                            Project = $newProject 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewProjectDialog'
                        Action = 'Create'
                        Data = $projectData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $projectData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewProjectDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 2)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 2)
        $currentY += 2
        
        $this.NotesBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
    }
}


####\_Backup/20250726_003635/Screens/NewTaskDialog.ps1
# NewTaskDialog.ps1 - Dialog for creating new tasks (refactored to use BaseDialog)

class NewTaskDialog : BaseDialog {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$PriorityList
    
    NewTaskDialog() : base("New Task", 50, 18) {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.AddContentControl($this.TitleBox, 1)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.AddContentControl($this.DescriptionBox, 2)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.SetItems(@("Low", "Medium", "High"))
        $this.PriorityList.SelectIndex(1)  # Default to Medium
        $this.AddContentControl($this.PriorityList, 3)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.TitleBox.Text.Trim()) {
                # Get selected priority
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $priority = switch ($selectedPriority) {
                    "Low" { [TaskPriority]::Low }
                    "High" { [TaskPriority]::High }
                    default { [TaskPriority]::Medium }
                }
                
                $taskData = @{
                    Title = $dialog.TitleBox.Text.Trim()
                    Description = $dialog.DescriptionBox.Text.Trim()
                    Priority = $priority
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create task via service
                    $taskService = $global:ServiceContainer.GetService("TaskService")
                    if ($taskService) {
                        $newTask = $taskService.CreateTask($taskData)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::TaskCreated, @{ 
                            Task = $newTask 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewTaskDialog'
                        Action = 'Create'
                        Data = $taskData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $taskData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewTaskDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for task dialog controls
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        
        # Title box
        $this.TitleBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 2, 
            $controlWidth, 
            3
        )
        
        # Description box
        $this.DescriptionBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 6, 
            $controlWidth, 
            3
        )
        
        # Priority list
        $this.PriorityList.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 10, 
            $controlWidth, 
            5
        )
    }
}


####\_Backup/20250726_003635/Screens/NumberInputDialog.ps1
# NumberInputDialog.ps1 - Simple dialog for numeric input

class NumberInputDialog : Screen {
    [string]$Prompt
    [decimal]$DefaultValue
    [decimal]$MinValue
    [decimal]$MaxValue
    [bool]$AllowDecimals
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    NumberInputDialog([string]$prompt) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = 0
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    NumberInputDialog([string]$prompt, [decimal]$defaultValue) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue.ToString()
        $this.InputBox.Placeholder = if ($this.AllowDecimals) { "0.00" } else { "0" }
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            $value = [decimal]0
            if ([decimal]::TryParse($dialog.InputBox.Text, [ref]$value)) {
                # Validate range
                if ($value -lt $dialog.MinValue) {
                    $value = $dialog.MinValue
                } elseif ($value -gt $dialog.MaxValue) {
                    $value = $dialog.MaxValue
                }
                
                # Round if no decimals allowed
                if (-not $dialog.AllowDecimals) {
                    $value = [Math]::Round($value)
                }
                
                if ($dialog.OnSubmit) {
                    & $dialog.OnSubmit $value
                }
            }
            # If parse fails, don't submit
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box
        $this.InputBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 11 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
            
            # Draw constraints if any
            $constraintY = $y + 2 + $promptLines.Count + 4
            $sb.Append([VT]::MoveTo($x + 2, $constraintY))
            $sb.Append($this.Theme.GetColor("disabled"))
            $constraints = @()
            if ($this.MinValue -ne [decimal]::MinValue) {
                $constraints += "Min: $($this.MinValue)"
            }
            if ($this.MaxValue -ne [decimal]::MaxValue) {
                $constraints += "Max: $($this.MaxValue)"
            }
            if (-not $this.AllowDecimals) {
                $constraints += "Integers only"
            }
            if ($constraints.Count -gt 0) {
                $sb.Append($constraints -join " | ")
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\_Backup/20250726_003635/Screens/ProjectDetailScreen.ps1
# ProjectDetailScreen - Detailed project view with time tracking information
# Redesigned to follow PRAXIS architecture standards using DockPanel and components

class ProjectDetailScreen : Screen {
    [Project]$Project = $null
    [System.Collections.ArrayList]$TimeEntries
    
    # PRAXIS Architecture Components
    [DockPanel]$MainLayout
    [ListBox]$ProjectInfoPanel
    [DataGrid]$WeeklySummaryGrid  
    [DataGrid]$TimeEntriesGrid
    
    # Services
    [ThemeManager]$ThemeManager
    [EventBus]$EventBus
    
    ProjectDetailScreen() : base() {
        $this.Title = "Project Details"
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    ProjectDetailScreen([Project]$project) : base() {
        $this.Title = "Project Details - $($project.Nickname)"
        $this.Project = $project
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services through proper dependency injection
        $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Load time entries if we have a project
        if ($this.Project) {
            $this.LoadTimeEntries()
        }
        
        # Create main DockPanel layout
        $this.MainLayout = [DockPanel]::new()
        $this.MainLayout.Initialize($this.ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Create project info panel (top section)
        $this.CreateProjectInfoPanel()
        
        # Create weekly summary grid (middle section)
        $this.CreateWeeklySummaryGrid()
        
        # Create time entries grid (fill remaining space)
        $this.CreateTimeEntriesGrid()
        
        # Update title
        if ($this.Project) {
            $this.Title = "Project Details - $($this.Project.Nickname)"
        }
        
        # Populate data
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
    }
    
    [void] CreateProjectInfoPanel() {
        $this.ProjectInfoPanel = [ListBox]::new()
        $this.ProjectInfoPanel.Initialize($this.ServiceContainer)
        $this.ProjectInfoPanel.ShowBorder = $true
        $this.ProjectInfoPanel.Title = "Project Information"
        $this.ProjectInfoPanel.IsFocusable = $false  # Read-only display
        
        # Dock to top with a specific height
        $this.MainLayout.SetChildDock($this.ProjectInfoPanel, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.ProjectInfoPanel, 35)  # Allow plenty of space for all fields
        $this.MainLayout.AddChild($this.ProjectInfoPanel)
    }
    
    [void] CreateWeeklySummaryGrid() {
        $this.WeeklySummaryGrid = [DataGrid]::new()
        $this.WeeklySummaryGrid.Initialize($this.ServiceContainer)
        $this.WeeklySummaryGrid.ShowHeader = $true
        $this.WeeklySummaryGrid.ShowBorder = $true
        $this.WeeklySummaryGrid.Title = "Weekly Hours Summary"
        $this.WeeklySummaryGrid.IsFocusable = $false  # Read-only display
        
        # Set up columns for weekly summary
        $columns = @(
            @{ Name = "WeekOf"; Header = "Week of"; Width = 12; Getter = { param($item) $item.WeekOf } }
            @{ Name = "Monday"; Header = "Mon"; Width = 7; Getter = { param($item) $item.Monday.ToString("F1") } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 7; Getter = { param($item) $item.Tuesday.ToString("F1") } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 7; Getter = { param($item) $item.Wednesday.ToString("F1") } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 7; Getter = { param($item) $item.Thursday.ToString("F1") } }
            @{ Name = "Friday"; Header = "Fri"; Width = 7; Getter = { param($item) $item.Friday.ToString("F1") } }
            @{ Name = "Total"; Header = "Total"; Width = 8; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.WeeklySummaryGrid.SetColumns($columns)
        
        # Dock to top (after project info) with a specific height
        $this.MainLayout.SetChildDock($this.WeeklySummaryGrid, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.WeeklySummaryGrid, 8)  # Weekly summary doesn't need much space
        $this.MainLayout.AddChild($this.WeeklySummaryGrid)
    }
    
    [void] CreateTimeEntriesGrid() {
        $this.TimeEntriesGrid = [DataGrid]::new()
        $this.TimeEntriesGrid.Initialize($this.ServiceContainer)
        $this.TimeEntriesGrid.ShowHeader = $true
        $this.TimeEntriesGrid.ShowBorder = $true
        $this.TimeEntriesGrid.Title = "Time Entries - [A]dd [E]dit [D]elete [R]efresh"
        $this.TimeEntriesGrid.IsFocusable = $true  # Interactive
        
        # Set up columns for time entries
        $screen = $this  # Capture reference for closure
        $columns = @(
            @{ Name = "Date"; Header = "Date"; Width = 12; Getter = { param($item) $screen.FormatDate($item.Date) }.GetNewClosure() }
            @{ Name = "Hours"; Header = "Hours"; Width = 8; Getter = { param($item) [double]::Parse($item.Total).ToString("F2") } }
            @{ Name = "Description"; Header = "Description"; Width = 40; Getter = { param($item) if ($item.Description) { $item.Description } else { "No description" } } }
        )
        $this.TimeEntriesGrid.SetColumns($columns)
        
        # Set up selection changed handler
        $screen = $this  # Capture reference for closure
        $this.TimeEntriesGrid.OnSelectionChanged = {
            # Handle selection changes if needed
        }.GetNewClosure()
        
        # Fill remaining space
        $this.MainLayout.SetChildDock($this.TimeEntriesGrid, [DockPosition]::Fill)
        $this.MainLayout.AddChild($this.TimeEntriesGrid)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus the time entries grid which is the main interactive component
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # DockPanel handles layout automatically
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] LoadTimeEntries() {
        # This would load time entries from the tracker system
        # For now, creating sample data based on the tracker.txt structure
        $this.TimeEntries.Clear()
        
        # Sample time entries (in production, this would load from actual data)
        $sampleEntries = @(
            @{
                Date = "20241201"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = "8.00"
                TueHours = ""
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "8.00"
                Description = "Initial project setup and requirements gathering"
            },
            @{
                Date = "20241202"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = "6.50"
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "6.50"
                Description = "Development work on core features"
            },
            @{
                Date = "20241203"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = ""
                WedHours = "7.25"
                ThuHours = ""
                FriHours = ""
                Total = "7.25"
                Description = "Testing and bug fixes"
            }
        )
        
        foreach ($entry in $sampleEntries) {
            $this.TimeEntries.Add([PSCustomObject]$entry) | Out-Null
        }
    }
    
    [void] PopulateProjectInfo() {
        if (-not $this.Project -or -not $this.ProjectInfoPanel) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: Project type = $($this.Project.GetType().Name)")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: AuditType = '$($this.Project.AuditType)'")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: ClientID = '$($this.Project.ClientID)'")
        }
        
        $infoItems = [System.Collections.ArrayList]::new()
        
        # === BASIC PROJECT INFORMATION ===
        $infoItems.Add("=== PROJECT IDENTIFICATION ===") | Out-Null
        $infoItems.Add("Nickname: $($this.Project.Nickname)") | Out-Null
        $infoItems.Add("Full Name: $($this.Project.FullProjectName)") | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen: Showing $($infoItems.Count) items so far")
        }
        
        # IDs
        if ($this.Project.ID1) {
            $infoItems.Add("Client Code (ID1): $($this.Project.ID1)") | Out-Null
        }
        if ($this.Project.ID2) {
            $infoItems.Add("CAS Case# (ID2): $($this.Project.ID2)") | Out-Null
        }
        if ($this.Project.ClientID) {
            $infoItems.Add("Client ID: $($this.Project.ClientID)") | Out-Null
        }
        
        # === AUDIT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDIT INFORMATION ===") | Out-Null
        if ($this.Project.AuditType) {
            $infoItems.Add("Audit Type: $($this.Project.AuditType)") | Out-Null
        }
        if ($this.Project.AuditProgram) {
            $infoItems.Add("Audit Program: $($this.Project.AuditProgram)") | Out-Null
        }
        if ($this.Project.AuditCase) {
            $infoItems.Add("Audit Case: $($this.Project.AuditCase)") | Out-Null
        }
        
        # Audit Dates
        if ($this.Project.AuditStartDate -and $this.Project.AuditStartDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Start Date: $($this.FormatDate($this.Project.AuditStartDate))") | Out-Null
        }
        if ($this.Project.AuditPeriodFrom -and $this.Project.AuditPeriodFrom -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period From: $($this.FormatDate($this.Project.AuditPeriodFrom))") | Out-Null
        }
        if ($this.Project.AuditPeriodTo -and $this.Project.AuditPeriodTo -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period To: $($this.FormatDate($this.Project.AuditPeriodTo))") | Out-Null
        }
        
        # Additional Audit Periods
        $hasAuditPeriods = $false
        for ($i = 1; $i -le 5; $i++) {
            $startProp = "AuditPeriod${i}Start"
            $endProp = "AuditPeriod${i}End"
            if ($this.Project.$startProp -ne [DateTime]::MinValue -or $this.Project.$endProp -ne [DateTime]::MinValue) {
                if (-not $hasAuditPeriods) {
                    $infoItems.Add("Additional Audit Periods:") | Out-Null
                    $hasAuditPeriods = $true
                }
                $start = if ($this.Project.$startProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$startProp) } else { "N/A" }
                $end = if ($this.Project.$endProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$endProp) } else { "N/A" }
                $infoItems.Add("  Period ${i}: $start to $end") | Out-Null
            }
        }
        
        # === PROJECT DATES ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== PROJECT DATES ===") | Out-Null
        if ($this.Project.RequestDate -and $this.Project.RequestDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Data Requested: $($this.FormatDate($this.Project.RequestDate))") | Out-Null
        }
        if ($this.Project.DateAssigned) {
            $infoItems.Add("Date Assigned: $($this.FormatDate($this.Project.DateAssigned))") | Out-Null
        }
        if ($this.Project.BFDate -and $this.Project.BFDate -ne [DateTime]::MinValue) {
            $infoItems.Add("BF Date: $($this.FormatDate($this.Project.BFDate))") | Out-Null
        }
        if ($this.Project.DateDue) {
            $infoItems.Add("Due Date: $($this.FormatDate($this.Project.DateDue))") | Out-Null
        }
        if ($this.Project.ClosedDate -and $this.Project.ClosedDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Completed: $($this.FormatDate($this.Project.ClosedDate))") | Out-Null
        }
        
        # === CLIENT LOCATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CLIENT LOCATION ===") | Out-Null
        if ($this.Project.Address) {
            $infoItems.Add("Address: $($this.Project.Address)") | Out-Null
        }
        if ($this.Project.City -or $this.Project.Province -or $this.Project.PostalCode) {
            $location = @()
            if ($this.Project.City) { $location += $this.Project.City }
            if ($this.Project.Province) { $location += $this.Project.Province }
            if ($this.Project.PostalCode) { $location += $this.Project.PostalCode }
            $infoItems.Add("City/Prov/Postal: $($location -join ', ')") | Out-Null
        }
        if ($this.Project.Country) {
            $infoItems.Add("Country: $($this.Project.Country)") | Out-Null
        }
        if ($this.Project.ShipToAddress) {
            $infoItems.Add("Ship To Address: $($this.Project.ShipToAddress)") | Out-Null
        }
        
        # === AUDITOR INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDITOR INFORMATION ===") | Out-Null
        if ($this.Project.AuditorName) {
            $infoItems.Add("Auditor: $($this.Project.AuditorName)") | Out-Null
        }
        if ($this.Project.AuditorPhone) {
            $infoItems.Add("Auditor Phone: $($this.Project.AuditorPhone)") | Out-Null
        }
        if ($this.Project.AuditorTL) {
            $infoItems.Add("Team Lead: $($this.Project.AuditorTL)") | Out-Null
        }
        if ($this.Project.AuditorTLPhone) {
            $infoItems.Add("Team Lead Phone: $($this.Project.AuditorTLPhone)") | Out-Null
        }
        
        # === CONTACT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CONTACT INFORMATION ===") | Out-Null
        # Contact 1
        if ($this.Project.Contact1Name) {
            $infoItems.Add("Contact 1:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact1Name)") | Out-Null
            if ($this.Project.Contact1Title) { $infoItems.Add("  Title: $($this.Project.Contact1Title)") | Out-Null }
            if ($this.Project.Contact1Phone) { 
                $phone = $this.Project.Contact1Phone
                if ($this.Project.Contact1Ext) { $phone += " x$($this.Project.Contact1Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact1Address) { $infoItems.Add("  Address: $($this.Project.Contact1Address)") | Out-Null }
        }
        # Contact 2
        if ($this.Project.Contact2Name) {
            $infoItems.Add("Contact 2:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact2Name)") | Out-Null
            if ($this.Project.Contact2Title) { $infoItems.Add("  Title: $($this.Project.Contact2Title)") | Out-Null }
            if ($this.Project.Contact2Phone) { 
                $phone = $this.Project.Contact2Phone
                if ($this.Project.Contact2Ext) { $phone += " x$($this.Project.Contact2Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact2Address) { $infoItems.Add("  Address: $($this.Project.Contact2Address)") | Out-Null }
        }
        
        # === SYSTEM INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== SYSTEM INFORMATION ===") | Out-Null
        if ($this.Project.AccountingSoftware1) {
            $sw1 = $this.Project.AccountingSoftware1
            if ($this.Project.AccountingSoftware1Other) { $sw1 += " ($($this.Project.AccountingSoftware1Other))" }
            if ($this.Project.AccountingSoftware1Type) { $sw1 += " - $($this.Project.AccountingSoftware1Type)" }
            $infoItems.Add("Accounting Software 1: $sw1") | Out-Null
        }
        if ($this.Project.AccountingSoftware2) {
            $sw2 = $this.Project.AccountingSoftware2
            if ($this.Project.AccountingSoftware2Other) { $sw2 += " ($($this.Project.AccountingSoftware2Other))" }
            if ($this.Project.AccountingSoftware2Type) { $sw2 += " - $($this.Project.AccountingSoftware2Type)" }
            $infoItems.Add("Accounting Software 2: $sw2") | Out-Null
        }
        
        # === STATUS AND TOTALS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== STATUS AND HOURS ===") | Out-Null
        $status = if ($this.Project.Status) { $this.Project.Status } else { "Active" }
        $infoItems.Add("Status: $status") | Out-Null
        
        # Show cumulative hours from Excel import
        if ($this.Project.CumulativeHrs -gt 0) {
            $infoItems.Add("Cumulative Hours (from import): $($this.Project.CumulativeHrs.ToString('F2'))") | Out-Null
        }
        
        $totalHours = $this.CalculateTotalHours()
        $infoItems.Add("Total Hours (tracked): $($totalHours.ToString('F2'))") | Out-Null
        
        # === FILE PATHS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== FILE PATHS ===") | Out-Null
        if ($this.Project.CAAPath) {
            $infoItems.Add("CAA Path: $($this.Project.CAAPath)") | Out-Null
        }
        if ($this.Project.RequestPath) {
            $infoItems.Add("Request Path: $($this.Project.RequestPath)") | Out-Null
        }
        if ($this.Project.T2020Path) {
            $infoItems.Add("T2020 Path: $($this.Project.T2020Path)") | Out-Null
        }
        
        # === ADDITIONAL INFORMATION ===
        if ($this.Project.FXInfo -or $this.Project.Comments -or $this.Project.Note) {
            $infoItems.Add("") | Out-Null
            $infoItems.Add("=== ADDITIONAL INFORMATION ===") | Out-Null
            
            if ($this.Project.FXInfo) {
                $infoItems.Add("FX Info: $($this.Project.FXInfo)") | Out-Null
            }
            if ($this.Project.Comments) {
                $infoItems.Add("Comments: $($this.Project.Comments)") | Out-Null
            }
            if ($this.Project.Note) {
                $infoItems.Add("Notes: $($this.Project.Note)") | Out-Null
            }
        }
        
        $this.ProjectInfoPanel.SetItems($infoItems)
    }
    
    [void] PopulateWeeklySummary() {
        if (-not $this.WeeklySummaryGrid) {
            return
        }
        
        $weeklyData = $this.CalculateWeeklySummary()
        $this.WeeklySummaryGrid.SetItems($weeklyData)
    }
    
    [void] PopulateTimeEntries() {
        if (-not $this.TimeEntriesGrid) {
            return
        }
        
        # Sort entries by date (most recent first)
        $sortedEntries = $this.TimeEntries | Sort-Object { [DateTime]::ParseExact($_.Date, "yyyyMMdd", $null) } -Descending
        $this.TimeEntriesGrid.SetItems($sortedEntries)
    }
    
    [string] FormatDate([string]$dateStr) {
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Not set"
        }
        
        try {
            if ($dateStr.Length -eq 8) {
                # YYYYMMDD format
                $date = [DateTime]::ParseExact($dateStr, "yyyyMMdd", $null)
                return $date.ToString("MM/dd/yyyy")
            } else {
                # Try parsing as DateTime
                $date = [DateTime]::Parse($dateStr)
                return $date.ToString("MM/dd/yyyy")
            }
        } catch {
            return $dateStr
        }
    }
    
    [string] FormatDate([DateTime]$date) {
        if ($date -eq [DateTime]::MinValue) {
            return "Not set"
        }
        return $date.ToString("MM/dd/yyyy")
    }
    
    [double] CalculateTotalHours() {
        $total = 0.0
        foreach ($entry in $this.TimeEntries) {
            try {
                $hours = [double]::Parse($entry.Total)
                $total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        return $total
    }
    
    [System.Collections.ArrayList] CalculateWeeklySummary() {
        $weeks = @{}
        
        foreach ($entry in $this.TimeEntries) {
            try {
                $entryDate = [DateTime]::ParseExact($entry.Date, "yyyyMMdd", $null)
                $monday = $entryDate.AddDays(-([int]$entryDate.DayOfWeek - 1))
                $weekKey = $monday.ToString("MM/dd/yyyy")
                
                if (-not $weeks.ContainsKey($weekKey)) {
                    $weeks[$weekKey] = @{
                        WeekOf = $weekKey
                        Monday = 0.0
                        Tuesday = 0.0
                        Wednesday = 0.0
                        Thursday = 0.0
                        Friday = 0.0
                        Total = 0.0
                    }
                }
                
                # Add hours to appropriate day
                $dayOfWeek = $entryDate.DayOfWeek.ToString()
                $hours = [double]::Parse($entry.Total)
                
                switch ($dayOfWeek) {
                    "Monday" { $weeks[$weekKey].Monday += $hours }
                    "Tuesday" { $weeks[$weekKey].Tuesday += $hours }
                    "Wednesday" { $weeks[$weekKey].Wednesday += $hours }
                    "Thursday" { $weeks[$weekKey].Thursday += $hours }
                    "Friday" { $weeks[$weekKey].Friday += $hours }
                }
                
                $weeks[$weekKey].Total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        
        $weeklyData = [System.Collections.ArrayList]::new()
        foreach ($week in $weeks.Values) {
            $weeklyData.Add([PSCustomObject]$week) | Out-Null
        }
        
        # Sort by week date (most recent first) and ensure ArrayList type
        $sortedData = $weeklyData | Sort-Object { [DateTime]::Parse($_.WeekOf) } -Descending
        $result = [System.Collections.ArrayList]::new()
        foreach ($item in $sortedData) {
            $result.Add($item) | Out-Null
        }
        return $result
    }
    
    [void] AddTimeEntry() {
        if (-not $this.Project) {
            return
        }
        
        # Create time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project)
        
        # Set up callback for when entry is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Add to local time entries collection
            $screen.TimeEntries.Add($timeEntryData) | Out-Null
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] EditSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.EditTimeEntry($selected)
    }
    
    [void] EditTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $this.Project -or -not $timeEntry) {
            return
        }
        
        # Create edit time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project, $timeEntry)
        
        # Set up callback for when entry is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Find and replace in local collection
            for ($i = 0; $i -lt $screen.TimeEntries.Count; $i++) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries[$i] = $timeEntryData
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] DeleteSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.DeleteTimeEntry($selected)
    }
    
    [void] DeleteTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $timeEntry) {
            return
        }
        
        # Show confirmation dialog
        $message = "Delete time entry for $($this.FormatDate($timeEntry.Date)) ($($timeEntry.Total) hours)?"
        $dialog = [ConfirmationDialog]::new($message)
        
        $screen = $this  # Capture reference for closure
        $dialog.OnConfirm = {
            # Remove from local collection
            for ($i = $screen.TimeEntries.Count - 1; $i -ge 0; $i--) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries.RemoveAt($i)
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] RefreshData() {
        # Reload time entries
        $this.LoadTimeEntries()
        
        # Refresh all displays
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
        
        # Focus the time entries grid
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle character shortcuts
        if ($keyInfo.KeyChar) {
            switch ($keyInfo.KeyChar) {
                'r' {
                    # Refresh/reload data
                    $this.RefreshData()
                    return $true
                }
                'a' {
                    # Add new time entry
                    $this.AddTimeEntry()
                    return $true
                }
                'e' {
                    # Edit selected time entry
                    $this.EditSelectedTimeEntry()
                    return $true
                }
                'd' {
                    # Delete selected time entry
                    $this.DeleteSelectedTimeEntry()
                    return $true
                }
            }
        }
        
        # Handle ESC to go back
        if ($keyInfo.Key -eq [System.ConsoleKey]::Escape) {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
            return $true
        }
        
        # Let base class handle other input (like tab switching and navigation)
        return $false
    }
}


####\_Backup/20250726_003635/Screens/ProjectsScreen.ps1
# ProjectsScreen.ps1 - Project management screen using DataGrid component

class ProjectsScreen : Screen {
    [DataGrid]$ProjectGrid
    # Buttons removed - using keyboard shortcuts only
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout - buttons removed
    
    ProjectsScreen() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to project created events with explicit closure
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe('project.created', {
                param($sender, $eventData)
                $screen.RefreshProjects()
                # Select the new project if provided
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe('command.executed', {
                param($sender, $eventData)
                if ($eventData.Target -eq 'ProjectsScreen') {
                    switch ($eventData.Command) {
                        'EditProject' { $screen.EditProject() }
                        'DeleteProject' { $screen.DeleteProject() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe('project.updated', {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe('project.deleted', {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create DataGrid with columns
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Projects"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowGridLines = $true
        
        # Define columns with proper formatting
        $columns = @(
            @{
                Name = "Status"
                Header = "Sts"
                Width = 3
                Getter = {
                    param($project)
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[]" } else { "[ ]" }
                }
            },
            @{
                Name = "FullProjectName"
                Header = "Project Name"
                Width = 0  # Flexible width - will auto-size
            },
            @{
                Name = "ID1"
                Header = "ID1"
                Width = 5
            },
            @{
                Name = "ID2"
                Header = "ID2"
                Width = 9
            },
            @{
                Name = "DateAssigned"
                Header = "Assigned"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            },
            @{
                Name = "DateDue"
                Header = "Due"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Buttons removed - use keyboard shortcuts instead
        # n - New Project
        # e - Edit Project
        # d - Delete Project
        # Enter - View Details
        
        # Load projects
        $this.LoadProjects()
        
        # Register screen-specific shortcuts with ShortcutManager
        $this.RegisterShortcuts()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("ProjectsScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.new"
            Name = "New Project"
            Description = "Create a new project"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.NewProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.edit"
            Name = "Edit Project"
            Description = "Edit the selected project"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.EditProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.delete"
            Name = "Delete Project"
            Description = "Delete the selected project"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.DeleteProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.refresh"
            Name = "Refresh"
            Description = "Refresh the project list"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.LoadProjects() }.GetNewClosure()
        })
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.RegisterShortcuts: Registered shortcuts for 'n', 'e', 'd', etc.")
        }
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnActivated: Screen activated with new focus system")
        }
        
        # Add defensive null checks
        try {
            # Focus the grid if it has items, otherwise the New button
            if ($global:Logger) {
                $projectGridNull = ($this.ProjectGrid -eq $null)
                $itemsCount = if ($this.ProjectGrid -and $this.ProjectGrid.Items) { $this.ProjectGrid.Items.Count } else { 0 }
                $global:Logger.Debug("ProjectsScreen focus check: ProjectGrid=$(!$projectGridNull), Items=$itemsCount")
            }
            
            if ($this.ProjectGrid) {
                $this.ProjectGrid.Focus()
            } else {
                if ($global:Logger) {
                    $global:Logger.Debug("ProjectsScreen: No focusable element found!")
                }
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ProjectsScreen.OnActivated: Error during focus - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Debug
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Grid takes full space now that buttons are removed
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $this.Height
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date
        $sorted = $activeProjects | Sort-Object DateDue
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        # Reload projects and update display
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.NewProject() called")
        }
        # Create new project dialog
        $dialog = [NewProjectDialog]::new()
        
        # EventBus will handle project creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                
                # Create nickname from name
                # Create project using single-parameter constructor
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                # Select the new project
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit project dialog
        $dialog = [EditProjectDialog]::new($selected)
        # Capture references
        $screen = $this
        $project = $selected
        $dialog.OnPrimary = {
            # Get the data from the dialog
            $projectData = @{
                FullProjectName = $dialog.NameBox.Text
                Nickname = $dialog.NicknameBox.Text
                Note = $dialog.NoteBox.Text
                DateDue = $dialog.DueDateBox.Text
            }
            
            # Update the project
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            # Save through service
            $screen.ProjectService.UpdateProject($project)
            
            # Publish project updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                # Fallback if EventBus not available
                $screen.LoadProjects()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Show confirmation dialog
            $message = "Are you sure you want to delete project '$($selected.FullProjectName)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            $dialog.OnConfirm = {
                # Delete the project
                $screen.ProjectService.DeleteProject($projectId)
                
                # Publish project deleted event
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    # Fallback if EventBus not available
                    $screen.LoadProjects()
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.ViewProjectDetails() called")
        }
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Create and show project detail screen
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    # Using parent-delegated focus model - Tab handled by ScreenManager/Container
    
    # Override HandleScreenInput instead of HandleInput to work with base Screen class
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Screen-specific shortcuts - only called as fallback by base Screen class
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'N' key pressed, calling NewProject")
                    }
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'E' key pressed, calling EditProject")
                    }
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'V' -or $key.KeyChar -eq 'v')) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadProjects()
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        # If no shortcut matched, return false (let base Screen handle it)
        return $false
    }
}


####\_Backup/20250726_003635/Screens/ProjectsScreenEnhanced.ps1
# ProjectsScreenEnhanced.ps1 - Project management screen with DataGrid

class ProjectsScreenEnhanced : Screen {
    [DataGrid]$ProjectGrid
    [Button]$NewButton
    [Button]$ViewButton
    [Button]$EditButton
    [Button]$DeleteButton
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    ProjectsScreenEnhanced() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to project created events
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe([EventNames]::ProjectCreated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe([EventNames]::ProjectUpdated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe([EventNames]::ProjectDeleted, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create project data grid
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Project List"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowHeader = $true
        $this.ProjectGrid.IsFocusable = $true
        
        # Define columns
        $columns = @(
            @{ 
                Name = "Status"
                Header = "Status"
                Width = 8
                Getter = { 
                    param($project) 
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[Done]" } 
                    else { "[Open]" }
                }
            }
            @{ 
                Name = "Name"
                Header = "Project Name"
                Width = 25
                Getter = { param($project) $project.Nickname }
            }
            @{ 
                Name = "ID1"
                Header = "ID1"
                Width = 10
                Getter = { 
                    param($project) 
                    if ($project.ID1) { $project.ID1 } else { "-" }
                }
            }
            @{ 
                Name = "ID2"
                Header = "ID2"
                Width = 15
                Getter = { 
                    param($project) 
                    if ($project.ID2) { $project.ID2 } else { "-" }
                }
            }
            @{ 
                Name = "Client"
                Header = "Client"
                Width = 20
                Getter = { 
                    param($project) 
                    if ($project.Name) { $project.Name } else { "-" }
                }
            }
            @{ 
                Name = "Assigned"
                Header = "Assigned"
                Width = 10
                Getter = { 
                    param($project) 
                    $project.DateAssigned.ToString("MM/dd/yy")
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Create buttons
        $screen = $this
        
        $this.NewButton = [Button]::new("New Project")
        $this.NewButton.IsDefault = $true
        $this.NewButton.OnClick = { $screen.NewProject() }.GetNewClosure()
        $this.NewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.NewButton)
        
        $this.ViewButton = [Button]::new("View Details")
        $this.ViewButton.OnClick = { $screen.ViewProjectDetails() }.GetNewClosure()
        $this.ViewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ViewButton)
        
        $this.EditButton = [Button]::new("Edit")
        $this.EditButton.OnClick = { $screen.EditProject() }.GetNewClosure()
        $this.EditButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.EditButton)
        
        $this.DeleteButton = [Button]::new("Delete")
        $this.DeleteButton.OnClick = { $screen.DeleteProject() }.GetNewClosure()
        $this.DeleteButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.DeleteButton)
        
        # Load projects
        $this.LoadProjects()
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus the grid if it has items, otherwise the New button
        if ($this.ProjectGrid -and $this.ProjectGrid.Items.Count -gt 0) {
            $this.ProjectGrid.Focus()
        } elseif ($this.NewButton) {
            $this.NewButton.Focus()
        }
    }
    
    [void] OnDeactivated() {
        ([Screen]$this).OnDeactivated()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes most space, buttons at bottom
        $buttonAreaHeight = $this.ButtonHeight + 2
        $gridHeight = $this.Height - $buttonAreaHeight
        
        # Project grid
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $gridHeight
        )
        
        # Buttons (horizontally arranged)
        $maxButtonWidth = 20
        $totalButtonWidth = ($maxButtonWidth * 4) + ($this.ButtonSpacing * 3)
        
        if ($this.Width -gt $totalButtonWidth) {
            $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $this.X
            $buttonWidth = [int](($this.Width - ($this.ButtonSpacing * 3)) / 4)
        }
        
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        
        $this.NewButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.ViewButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.EditButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 2,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.DeleteButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 3,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date (most urgent first), then by assigned date
        $sorted = $activeProjects | Sort-Object -Property @(
            @{Expression = { $_.ClosedDate -eq [DateTime]::MinValue }; Descending = $true}
            @{Expression = { ($_.DateDue - [DateTime]::Now).Days }}
            @{Expression = { $_.DateAssigned }}
        )
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        $dialog = [NewProjectDialog]::new()
        
        if (-not $this.EventBus) {
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $dialog = [EditProjectDialog]::new($selected)
        $screen = $this
        $project = $selected
        
        $dialog.OnSave = {
            param($projectData)
            
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            $screen.ProjectService.UpdateProject($project)
            
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                $screen.LoadProjects()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $message = "Are you sure you want to delete project '$($selected.Nickname)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            
            $dialog.OnConfirm = {
                $screen.ProjectService.DeleteProject($projectId)
                
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    $screen.LoadProjects()
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\_Backup/20250726_003635/Screens/QuickTimeEntryDialog.ps1
# QuickTimeEntryDialog - Simple time entry dialog

class QuickTimeEntryDialog : BaseDialog {
    [DateTime]$WeekFriday
    [TextBox]$ProjectBox
    [TextBox]$MondayBox
    [TextBox]$TuesdayBox
    [TextBox]$WednesdayBox
    [TextBox]$ThursdayBox
    [TextBox]$FridayBox
    [TimeTrackingService]$TimeService
    [scriptblock]$OnSave
    
    QuickTimeEntryDialog([DateTime]$weekFriday) : base("Quick Time Entry") {
        $this.WeekFriday = $weekFriday
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 30
    }
    
    [void] InitializeContent() {
        # Create all input fields
        $this.ProjectBox = [TextBox]::new()
        $this.ProjectBox.Placeholder = "Enter Project ID2 or Non-Project Code..."
        $this.AddContentControl($this.ProjectBox, 1)
        
        $this.MondayBox = [TextBox]::new()
        $this.MondayBox.Placeholder = "Monday Hours"
        $this.AddContentControl($this.MondayBox, 2)
        
        $this.TuesdayBox = [TextBox]::new()
        $this.TuesdayBox.Placeholder = "Tuesday Hours"
        $this.AddContentControl($this.TuesdayBox, 3)
        
        $this.WednesdayBox = [TextBox]::new()
        $this.WednesdayBox.Placeholder = "Wednesday Hours"
        $this.AddContentControl($this.WednesdayBox, 4)
        
        $this.ThursdayBox = [TextBox]::new()
        $this.ThursdayBox.Placeholder = "Thursday Hours"
        $this.AddContentControl($this.ThursdayBox, 5)
        
        $this.FridayBox = [TextBox]::new()
        $this.FridayBox.Placeholder = "Friday Hours"
        $this.AddContentControl($this.FridayBox, 6)
        
        # Set up save action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.ProjectBox.Text.Trim()) {
                $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
                
                $data = @{
                    WeekEndingFriday = $dialog.WeekFriday.ToString("yyyyMMdd")
                    ID2 = $dialog.ProjectBox.Text.Trim().ToUpper()
                    Monday = $dialog.ParseHours($dialog.MondayBox.Text)
                    Tuesday = $dialog.ParseHours($dialog.TuesdayBox.Text)
                    Wednesday = $dialog.ParseHours($dialog.WednesdayBox.Text)
                    Thursday = $dialog.ParseHours($dialog.ThursdayBox.Text)
                    Friday = $dialog.ParseHours($dialog.FridayBox.Text)
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave $data
                }
                
                $dialog.CloseDialog()
            }
        }.GetNewClosure()
    }
    
    [decimal] ParseHours([string]$text) {
        if ([string]::IsNullOrWhiteSpace($text)) { return 0 }
        $hours = 0
        if ([decimal]::TryParse($text, [ref]$hours)) {
            return $hours
        }
        return 0
    }
}


####\_Backup/20250726_003635/Screens/SettingsScreen.ps1
# SettingsScreen.ps1 - Settings management screen

class SettingsScreen : Screen {
    [ListBox]$CategoryList
    [DataGrid]$SettingsGrid
    [ConfigurationService]$ConfigService
    [hashtable[]]$CurrentSettings = @()
    [string]$CurrentCategory = ""
    [EventBus]$EventBus
    
    SettingsScreen() : base() {
        $this.Title = "Settings"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ConfigService = $global:ServiceContainer.GetService("ConfigurationService")
        if (-not $this.ConfigService) {
            $this.ConfigService = [ConfigurationService]::new()
            $global:ServiceContainer.Register("ConfigurationService", $this.ConfigService)
        }
        
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create category list
        $this.CategoryList = [ListBox]::new()
        $this.CategoryList.Title = "Categories"
        $this.CategoryList.ShowBorder = $true
        # Capture screen reference for callback
        $screen = $this
        $this.CategoryList.OnSelectionChanged = {
            $screen.LoadCategorySettings()
        }.GetNewClosure()
        $this.CategoryList.Initialize($global:ServiceContainer)
        $this.AddChild($this.CategoryList)
        
        # Create settings grid
        $this.SettingsGrid = [DataGrid]::new()
        $this.SettingsGrid.Title = "Settings"
        $this.SettingsGrid.ShowBorder = $true
        $this.SettingsGrid.Initialize($global:ServiceContainer)
        $this.SettingsGrid.SetColumns(@(
            @{Name="Setting"; Header="Setting"; Width=30},
            @{Name="Value"; Header="Value"; Width=20},
            @{Name="Type"; Header="Type"; Width=10}
        ))
        $this.AddChild($this.SettingsGrid)
        
        # Load categories
        $this.LoadCategories()
        
        # No more BindKey - use HandleScreenInput instead
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) { 
                $this.EditSetting()
                return $true
            }
        }
        
        switch ($key.KeyChar) {
            'e' { $this.EditSetting(); return $true }
            'r' { $this.ResetCategory(); return $true }
            'R' { $this.ResetAll(); return $true }
            's' { $this.SaveSettings(); return $true }
        }
        
        return $false
    }
    
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        $this.CategoryList.Focus()
        # Settings are loaded automatically when selection changes
    }
    
    [void] OnBoundsChanged() {
        # Split the width between category list and settings grid
        $categoryWidth = 25
        $gridWidth = [Math]::Max(10, $this.Width - $categoryWidth)
        
        # Set bounds for category list
        $this.CategoryList.SetBounds(
            $this.X,
            $this.Y,
            $categoryWidth,
            $this.Height
        )
        
        # Set bounds for settings grid
        $this.SettingsGrid.SetBounds(
            $this.X + $categoryWidth,
            $this.Y,
            $gridWidth,
            $this.Height
        )
    }
    
    [void] LoadCategories() {
        $config = $this.ConfigService.GetAll()
        $categories = @()
        
        foreach ($key in $config.Keys | Sort-Object) {
            if ($config[$key] -is [hashtable]) {
                $categories += @{
                    Name = $key
                    DisplayName = $this.FormatCategoryName($key)
                }
            }
        }
        
        $this.CategoryList.SetItems($categories)
        $this.CategoryList.ItemRenderer = { param($cat) $cat.DisplayName }
        
        if ($categories.Count -gt 0) {
            $this.CategoryList.SelectIndex(0)
            # LoadCategorySettings is now called automatically by OnSelectionChanged
        }
    }
    
    [void] LoadCategorySettings() {
        $selected = $this.CategoryList.GetSelectedItem()
        if (-not $selected) { return }
        
        $this.CurrentCategory = $selected.Name
        $categoryConfig = $this.ConfigService.Get($this.CurrentCategory)
        
        if ($categoryConfig -is [hashtable]) {
            $settings = @()
            
            foreach ($key in $categoryConfig.Keys | Sort-Object) {
                $value = $categoryConfig[$key]
                $type = $this.GetValueType($value)
                
                $settings += @{
                    Setting = $this.FormatSettingName($key)
                    Value = $this.FormatValue($value)
                    Type = $type
                    Key = $key
                    RawValue = $value
                }
            }
            
            $this.CurrentSettings = $settings
            $this.SettingsGrid.SetItems($settings)
            $this.SettingsGrid.Title = "Settings - $($selected.DisplayName)"
        }
    }
    
    [void] EditSetting() {
        if (-not $this.SettingsGrid.IsFocused) { return }
        
        $selected = $this.SettingsGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $path = "$($this.CurrentCategory).$($selected.Key)"
        $currentValue = $selected.RawValue
        
        # Create appropriate dialog based on type
        $dialog = $null
        
        # Special handling for theme selection
        if ($path -eq "Theme.CurrentTheme") {
            # Cycle through available themes
            $availableThemes = $this.ConfigService.Get("Theme.AvailableThemes", @("default", "matrix"))
            $currentIndex = $availableThemes.IndexOf($currentValue)
            $nextIndex = ($currentIndex + 1) % $availableThemes.Count
            $newValue = $availableThemes[$nextIndex]
            
            $this.ConfigService.Set($path, $newValue)
            
            # Apply theme immediately
            $themeManager = $global:ServiceContainer.GetService("ThemeManager")
            if ($themeManager) {
                $themeManager.SetTheme($newValue)
            }
            
            # Publish config changed event
            if ($this.EventBus) {
                $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                    Path = $path
                    OldValue = $currentValue
                    NewValue = $newValue
                    Category = $this.CurrentCategory
                })
            }
            
            $this.LoadCategorySettings()
            return
        }
        
        switch ($selected.Type) {
            "Boolean" {
                # Simple toggle
                $newValue = -not $currentValue
                $this.ConfigService.Set($path, $newValue)
                
                # Publish config changed event
                if ($this.EventBus) {
                    $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                        Path = $path
                        OldValue = $currentValue
                        NewValue = $newValue
                        Category = $this.CurrentCategory
                    })
                }
                
                $this.LoadCategorySettings()
                return
            }
            "Number" {
                # TODO: Create NumberInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("Number editing not yet implemented")
                }
            }
            "String" {
                # TODO: Create TextInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("String editing not yet implemented")
                }
            }
        }
    }
    
    [void] ResetCategory() {
        if (-not $this.CurrentCategory) { return }
        
        $message = "Reset all settings in '$($this.CurrentCategory)' to defaults?"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.OnConfirm = {
            $this.ConfigService.ResetSection($this.CurrentCategory)
            $this.LoadCategorySettings()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ResetAll() {
        $message = "Reset ALL settings to defaults?`n`nThis cannot be undone!"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.ConfirmText = "Reset All"
        $dialog.OnConfirm = {
            $this.ConfigService.Reset()
            $this.LoadCategories()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] SaveSettings() {
        $this.ConfigService.Save()
        if ($global:Logger) {
            $global:Logger.Info("Settings saved")
        }
    }
    
    
    hidden [string] FormatCategoryName([string]$name) {
        # Convert PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        return $formatted.Trim()
    }
    
    hidden [string] FormatSettingName([string]$name) {
        # Convert camelCase/PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        $formatted = $formatted.Substring(0,1).ToUpper() + $formatted.Substring(1)
        return $formatted.Trim()
    }
    
    hidden [string] FormatValue($value) {
        if ($value -eq $null) { return "<null>" }
        if ($value -is [bool]) { return $(if ($value) { "Yes" } else { "No" }) }
        if ($value -is [hashtable]) { return "<nested>" }
        if ($value -is [array]) { return "<array[$($value.Count)]>" }
        return $value.ToString()
    }
    
    hidden [string] GetValueType($value) {
        if ($value -eq $null) { return "Null" }
        if ($value -is [bool]) { return "Boolean" }
        if ($value -is [int] -or $value -is [long] -or $value -is [double]) { return "Number" }
        if ($value -is [string]) { return "String" }
        if ($value -is [hashtable]) { return "Object" }
        if ($value -is [array]) { return "Array" }
        return "Unknown"
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append(" [Tab]Navigate [Enter/E]Edit [R]Reset Category [Shift+R]Reset All [S]Save")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\_Backup/20250726_003635/Screens/SubtaskDialog.ps1
# SubtaskDialog - Dialog for adding/editing subtasks using BaseDialog

class SubtaskDialog : BaseDialog {
    [Task]$ParentTask = $null
    [Subtask]$Subtask = $null  # For editing existing subtasks
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$TitleTextBox
    [TextBox]$DescriptionTextBox
    [TextBox]$EstimatedTimeTextBox
    [TextBox]$ActualTimeTextBox
    [TextBox]$DueDateTextBox
    
    # Dropdowns (simplified as text for now)
    [TextBox]$PriorityTextBox
    [TextBox]$ProgressTextBox
    
    SubtaskDialog() : base("Add Subtask", 60, 24) {
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask) : base("Add Subtask - $($parentTask.Title)", 60, 24) {
        $this.ParentTask = $parentTask
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask, $subtask) : base("Edit Subtask", 60, 24) {
        $this.ParentTask = $parentTask
        $this.Subtask = $subtask
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Update Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.TitleTextBox = [TextBox]::new()
        $this.TitleTextBox.Title = "Title"
        $this.TitleTextBox.ShowBorder = $true
        $this.TitleTextBox.TabIndex = 1
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Title']) {
            $this.TitleTextBox.Text = $this.Subtask.Title
        }
        $this.AddContentControl($this.TitleTextBox)
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        $this.DescriptionTextBox.TabIndex = 2
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Description']) {
            $this.DescriptionTextBox.Text = $this.Subtask.Description
        }
        $this.AddContentControl($this.DescriptionTextBox)
        
        $this.PriorityTextBox = [TextBox]::new()
        $this.PriorityTextBox.Title = "Priority (Low/Medium/High)"
        $this.PriorityTextBox.ShowBorder = $true
        $this.PriorityTextBox.TabIndex = 3
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.Priority) {
            $this.PriorityTextBox.Text = $this.Subtask.Priority.ToString()
        } else {
            $this.PriorityTextBox.Text = "Medium"
        }
        $this.AddContentControl($this.PriorityTextBox)
        
        $this.ProgressTextBox = [TextBox]::new()
        $this.ProgressTextBox.Title = "Progress (0-100)"
        $this.ProgressTextBox.ShowBorder = $true
        $this.ProgressTextBox.TabIndex = 4
        
        if ($this.IsEditMode -and $this.Subtask) {
            $progress = if ($this.Subtask.PSObject.Properties['Progress']) { $this.Subtask.Progress } else { 0 }
            $this.ProgressTextBox.Text = $progress.ToString()
        } else {
            $this.ProgressTextBox.Text = "0"
        }
        $this.AddContentControl($this.ProgressTextBox)
        
        $this.EstimatedTimeTextBox = [TextBox]::new()
        $this.EstimatedTimeTextBox.Title = "Estimated Time (minutes)"
        $this.EstimatedTimeTextBox.ShowBorder = $true
        $this.EstimatedTimeTextBox.TabIndex = 5
        
        if ($this.IsEditMode -and $this.Subtask) {
            $estimated = if ($this.Subtask.PSObject.Properties['EstimatedMinutes']) { $this.Subtask.EstimatedMinutes } else { 0 }
            if ($estimated -gt 0) {
                $this.EstimatedTimeTextBox.Text = $estimated.ToString()
            }
        }
        $this.AddContentControl($this.EstimatedTimeTextBox)
        
        $this.ActualTimeTextBox = [TextBox]::new()
        $this.ActualTimeTextBox.Title = "Actual Time (minutes)"
        $this.ActualTimeTextBox.ShowBorder = $true
        $this.ActualTimeTextBox.TabIndex = 6
        
        if ($this.IsEditMode -and $this.Subtask) {
            $actual = if ($this.Subtask.PSObject.Properties['ActualMinutes']) { $this.Subtask.ActualMinutes } else { 0 }
            if ($actual -gt 0) {
                $this.ActualTimeTextBox.Text = $actual.ToString()
            }
        }
        $this.AddContentControl($this.ActualTimeTextBox)
        
        $this.DueDateTextBox = [TextBox]::new()
        $this.DueDateTextBox.Title = "Due Date (MM/DD/YYYY, optional)"
        $this.DueDateTextBox.ShowBorder = $true
        $this.DueDateTextBox.TabIndex = 7
        
        if ($this.IsEditMode -and $this.Subtask) {
            $dueDate = if ($this.Subtask.PSObject.Properties['DueDate']) { $this.Subtask.DueDate } else { [DateTime]::MinValue }
            if ($dueDate -ne [DateTime]::MinValue) {
                $this.DueDateTextBox.Text = $dueDate.ToString("MM/dd/yyyy")
            }
        }
        $this.AddContentControl($this.DueDateTextBox)
        
        # Set custom handlers for BaseDialog
        $dialog = $this
        $this.OnPrimary = {
            $dialog.HandleSave()
        }.GetNewClosure()
        
        $this.OnSecondary = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
            $dialog.CloseDialog()
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom layout: Stack inputs vertically
        $padding = $this.DialogPadding
        $shortInputHeight = 3
        $tallInputHeight = 4
        $currentY = $dialogY + $padding
        $inputWidth = $this.DialogWidth - ($padding * 2)
        
        # Title input
        $this.TitleTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $tallInputHeight
        )
        $currentY += $tallInputHeight + 1
        
        # Priority and Progress on same row
        $halfWidth = [int](($inputWidth - 2) / 2)
        $this.PriorityTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ProgressTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Estimated and Actual time on same row
        $this.EstimatedTimeTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ActualTimeTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Due date
        $this.DueDateTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create subtask data
        $subtaskData = $this.CreateSubtaskData()
        
        if ($this.OnSave) {
            & $this.OnSave $subtaskData
        }
        
        # Close dialog after successful save
        $this.CloseDialog()
    }
    
    [string] ValidateInputs() {
        # Validate title
        $title = $this.TitleTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($title)) {
            return "Title is required"
        }
        
        # Validate priority
        $priority = $this.PriorityTextBox.Text.Trim()
        if ($priority -notin @("Low", "Medium", "High")) {
            return "Priority must be Low, Medium, or High"
        }
        
        # Validate progress
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $progress = 0
        if (-not [string]::IsNullOrEmpty($progressStr)) {
            if (-not [int]::TryParse($progressStr, [ref]$progress) -or $progress -lt 0 -or $progress -gt 100) {
                return "Progress must be a number between 0 and 100"
            }
        }
        
        # Validate estimated time
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($estimatedStr)) {
            $estimated = 0
            if (-not [int]::TryParse($estimatedStr, [ref]$estimated) -or $estimated -lt 0) {
                return "Estimated time must be a positive number"
            }
        }
        
        # Validate actual time
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($actualStr)) {
            $actual = 0
            if (-not [int]::TryParse($actualStr, [ref]$actual) -or $actual -lt 0) {
                return "Actual time must be a positive number"
            }
        }
        
        # Validate due date
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($dueDateStr)) {
            try {
                [DateTime]::Parse($dueDateStr) | Out-Null
            } catch {
                return "Invalid due date format. Use MM/DD/YYYY"
            }
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateSubtaskData() {
        # Parse inputs
        $title = $this.TitleTextBox.Text.Trim()
        $description = $this.DescriptionTextBox.Text.Trim()
        $priorityStr = $this.PriorityTextBox.Text.Trim()
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        
        # Convert priority
        $priority = switch ($priorityStr) {
            "Low" { [TaskPriority]::Low }
            "High" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # Parse numbers
        $progress = if ([string]::IsNullOrEmpty($progressStr)) { 0 } else { [int]::Parse($progressStr) }
        $estimated = if ([string]::IsNullOrEmpty($estimatedStr)) { 0 } else { [int]::Parse($estimatedStr) }
        $actual = if ([string]::IsNullOrEmpty($actualStr)) { 0 } else { [int]::Parse($actualStr) }
        
        # Parse due date
        $dueDate = if ([string]::IsNullOrEmpty($dueDateStr)) {
            [DateTime]::MinValue
        } else {
            [DateTime]::Parse($dueDateStr)
        }
        
        # Create subtask data object
        $subtaskData = [PSCustomObject]@{
            Id = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Id']) { $this.Subtask.Id } else { [guid]::NewGuid().ToString() }
            } else { 
                [guid]::NewGuid().ToString() 
            }
            ParentTaskId = $this.ParentTask.Id
            Title = $title
            Description = $description
            Status = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Status']) { $this.Subtask.Status } else { [TaskStatus]::Pending }
            } else { 
                [TaskStatus]::Pending 
            }
            Priority = $priority
            Progress = $progress
            EstimatedMinutes = $estimated
            ActualMinutes = $actual
            DueDate = $dueDate
            IsEditMode = $this.IsEditMode
        }
        
        return $subtaskData
    }
    
    # Override HandleScreenInput to add Ctrl+Enter shortcut
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Ctrl+Enter shortcut for save
        if ($key.Key -eq [System.ConsoleKey]::Enter -and ($key.Modifiers -band [ConsoleModifiers]::Control)) {
            $this.HandleSave()
            return $true
        }
        
        return $false
    }
    
    # Legacy callback support
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
}


####\_Backup/20250726_003635/Screens/TaskScreen.ps1
# TaskScreen.ps1 - Task management screen using DataGrid

class TaskScreen : Screen {
    [DataGrid]$TaskGrid
    [TaskService]$TaskService
    [SubtaskService]$SubtaskService
    [ProjectService]$ProjectService
    [hashtable]$StatusColors
    [hashtable]$PriorityColors
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    hidden [bool]$ShowSubtasks = $true
    hidden [hashtable]$ProjectCache = @{}
    
    # Layout settings
    hidden [int]$StatusBarHeight = 2
    
    TaskScreen() : base() {
        $this.Title = "Tasks"
    }
    
    [void] OnInitialize() {
        # Get services using proper dependency injection
        $this.TaskService = $this.GetService("TaskService")
        if (-not $this.TaskService) {
            $this.TaskService = [TaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("TaskService", $this.TaskService)
            } else {
                $global:ServiceContainer.Register("TaskService", $this.TaskService)
            }
        }
        
        $this.SubtaskService = $this.GetService("SubtaskService")
        if (-not $this.SubtaskService) {
            $this.SubtaskService = [SubtaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            } else {
                $global:ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            }
        }
        
        $this.ProjectService = $this.GetService("ProjectService")
        $this.EventBus = $this.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to task created events
            $this.EventSubscriptions['TaskCreated'] = $this.EventBus.Subscribe('task.created', {
                param($sender, $eventData)
                $screen.LoadTasks()
                # Select the new task if provided
                if ($eventData.Task) {
                    for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                        if ($screen.TaskGrid.Items[$i].Id -eq $eventData.Task.Id) {
                            $screen.TaskGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe('command.executed', {
                param($sender, $eventData)
                if ($global:Logger) {
                    $global:Logger.Debug("TaskScreen: Received CommandExecuted event - Command: $($eventData.Command), Target: $($eventData.Target)")
                }
                if ($eventData.Target -eq 'TaskScreen') {
                    switch ($eventData.Command) {
                        'NewTask' { 
                            if ($global:Logger) {
                                $global:Logger.Debug("TaskScreen: Executing NewTask command")
                            }
                            $screen.NewTask() 
                        }
                        'EditTask' { $screen.EditTask() }
                        'DeleteTask' { $screen.DeleteTask() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to task updated events
            $this.EventSubscriptions['TaskUpdated'] = $this.EventBus.Subscribe('task.updated', {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
            
            # Subscribe to task deleted events
            $this.EventSubscriptions['TaskDeleted'] = $this.EventBus.Subscribe('task.deleted', {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
        }
        
        # Set up color mappings
        $this.StatusColors = @{
            [TaskStatus]::Pending = "foreground"
            [TaskStatus]::InProgress = "warning"
            [TaskStatus]::Completed = "success"
            [TaskStatus]::Cancelled = "disabled"
        }
        
        $this.PriorityColors = @{
            [TaskPriority]::Low = "success"
            [TaskPriority]::Medium = "warning"
            [TaskPriority]::High = "error"
        }
        
        # Create DataGrid with columns
        $this.TaskGrid = [DataGrid]::new()
        $this.TaskGrid.Title = "Tasks"
        $this.TaskGrid.ShowBorder = $true
        $this.TaskGrid.ShowGridLines = $true
        
        # Define columns
        $screen = $this
        $columns = @(
            @{
                Name = "Status"
                Header = "S"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no status shown in grid (shown in title instead)
                        return " "
                    }
                    switch ($item.Status) {
                        ([TaskStatus]::Pending) { return "P" }
                        ([TaskStatus]::InProgress) { return "W" }
                        ([TaskStatus]::Completed) { return "D" }
                        ([TaskStatus]::Cancelled) { return "X" }
                        default { return "?" }
                    }
                }
            },
            @{
                Name = "Priority"
                Header = "P"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no priority shown in grid
                        return " "
                    }
                    switch ($item.Priority) {
                        ([TaskPriority]::High) { return "H" }
                        ([TaskPriority]::Medium) { return "M" }
                        ([TaskPriority]::Low) { return "L" }
                        default { return " " }
                    }
                }
            },
            @{
                Name = "Title"
                Header = "Task"
                Width = 0  # Flexible width
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - show indented with status
                        $status = switch ($item.Status) {
                            ([TaskStatus]::Pending) { "[ ]" }
                            ([TaskStatus]::InProgress) { "[~]" }
                            ([TaskStatus]::Completed) { "[]" }
                            ([TaskStatus]::Cancelled) { "[]" }
                            default { "[?]" }
                        }
                        return "   $status $($item.Title)"
                    } else {
                        # Main task - include subtask count if any
                        $title = $item.Title
                        if ($screen.SubtaskService) {
                            $stats = $screen.SubtaskService.GetTaskStatistics($item.Id)
                            if ($stats.Total -gt 0) {
                                $title += " [$($stats.Completed)/$($stats.Total)]"
                            }
                        }
                        return $title
                    }
                }
            },
            @{
                Name = "Project"
                Header = "Project"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no project shown
                        return ""
                    }
                    if ($item.ProjectId -and $screen.ProjectService) {
                        # Cache project lookups for performance
                        if (-not $screen.ProjectCache.ContainsKey($item.ProjectId)) {
                            $project = $screen.ProjectService.GetProject($item.ProjectId)
                            if ($project) {
                                $screen.ProjectCache[$item.ProjectId] = $project.FullProjectName
                            } else {
                                $screen.ProjectCache[$item.ProjectId] = ""
                            }
                        }
                        return $screen.ProjectCache[$item.ProjectId]
                    }
                    return ""
                }
            },
            @{
                Name = "DueDate"
                Header = "Due"
                Width = 10
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no due date in grid
                        return ""
                    }
                    if ($item.DueDate -ne [DateTime]::MinValue) {
                        return $item.DueDate.ToString("yyyy-MM-dd")
                    }
                    return ""
                }
            },
            @{
                Name = "Tags"
                Header = "Tags"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no tags shown
                        return ""
                    }
                    if ($item.Tags -and $item.Tags.Count -gt 0) {
                        return ($item.Tags -join ",")
                    }
                    return ""
                }
            }
        )
        
        $this.TaskGrid.SetColumns($columns)
        $this.TaskGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.TaskGrid)
        
        # Load tasks
        $this.LoadTasks()
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        # Focus the grid
        if ($this.TaskGrid -and $this.TaskGrid.Items.Count -gt 0) {
            $this.TaskGrid.Focus()
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.OnActivated: Screen activated and focused grid")
        }
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes all space except status bar
        $gridHeight = $this.Height - $this.StatusBarHeight
        
        # Task grid
        $this.TaskGrid.SetBounds(
            $this.X,
            $this.Y,
            $this.Width,
            $gridHeight
        )
    }
    
    [void] LoadTasks() {
        $tasks = $this.TaskService.GetAllTasks()
        
        # Clear project cache for fresh lookups
        $this.ProjectCache.Clear()
        
        # Filter out deleted tasks
        $activeTasks = $tasks | Where-Object { -not $_.Deleted }
        
        # Sort by priority (high first), then status, then due date
        $sorted = $activeTasks | Sort-Object -Property `
            @{Expression = {$_.Priority}; Descending = $true},
            @{Expression = {$_.Status}; Ascending = $true},
            @{Expression = {if ($_.DueDate -eq [DateTime]::MinValue) { [DateTime]::MaxValue } else { $_.DueDate }}; Ascending = $true}
        
        if ($this.ShowSubtasks -and $this.SubtaskService) {
            # Create combined list with tasks and their subtasks
            $combinedItems = [System.Collections.ArrayList]::new()
            
            foreach ($task in $sorted) {
                $combinedItems.Add($task) | Out-Null
                
                # Add subtasks for this task
                $subtasks = $this.SubtaskService.GetSubtasksForTask($task.Id)
                foreach ($subtask in $subtasks) {
                    $combinedItems.Add($subtask) | Out-Null
                }
            }
            
            $this.TaskGrid.SetItems($combinedItems)
        } else {
            $this.TaskGrid.SetItems($sorted)
        }
    }
    
    [void] NewTask() {
        # Create new task dialog
        $dialog = [NewTaskDialog]::new()
        
        # EventBus will handle task creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($taskData)
                
                $task = $screen.TaskService.CreateTask($taskData)
                $screen.LoadTasks()
                
                # Select the new task
                for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                    if ($screen.TaskGrid.Items[$i].Id -eq $task.Id) {
                        $screen.TaskGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Edit subtask
            $this.EditSubtask($selected)
            return
        }
        
        # Create edit task dialog
        $dialog = [EditTaskDialog]::new($selected)
        # Capture references
        $screen = $this
        $task = $selected
        $dialog.OnSave = {
            param($taskData)
            
            # Update the task
            $task.Title = $taskData.Title
            $task.Description = $taskData.Description
            $task.Status = $taskData.Status
            $task.Priority = $taskData.Priority
            $task.Progress = $taskData.Progress
            $task.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.TaskService.UpdateTask($task)
            
            # Publish task updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskUpdated, @{ Task = $task })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # EditTaskDialog is not a BaseDialog, so we need to Pop manually
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # EditTaskDialog is not a BaseDialog, so we need to handle cancel
        $dialog.OnCancel = {
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
        $message = if ($isSubtask) {
            "Are you sure you want to delete this subtask?`n`n$($selected.Title)"
        } else {
            "Are you sure you want to delete this task?`n`n$($selected.Title)"
        }
        
        # Show confirmation dialog
        $dialog = [ConfirmationDialog]::new($message)
        # Capture references
        $screen = $this
        $itemId = $selected.Id
        $dialog.OnConfirm = {
            if ($isSubtask) {
                # Delete subtask
                $screen.SubtaskService.DeleteSubtask($itemId)
            } else {
                # Delete task (and all its subtasks)
                $screen.TaskService.DeleteTask($itemId)
            }
            
            # Publish task deleted event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskDeleted, @{ TaskId = $itemId })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CycleStatus() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Cycle through status values
        $newStatus = switch ($selected.Status) {
            ([TaskStatus]::Pending) { [TaskStatus]::InProgress }
            ([TaskStatus]::InProgress) { [TaskStatus]::Completed }
            ([TaskStatus]::Completed) { [TaskStatus]::Cancelled }
            ([TaskStatus]::Cancelled) { [TaskStatus]::Pending }
        }
        
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Update subtask
            $selected.Status = $newStatus
            $selected.UpdatedAt = [DateTime]::Now
            $this.SubtaskService.SaveSubtask($selected)
        } else {
            # Update task
            $this.TaskService.UpdateTaskStatus($selected.Id, $newStatus)
        }
        
        # Publish task status changed event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TaskStatusChanged, @{ 
                TaskId = $selected.Id
                OldStatus = $selected.Status
                NewStatus = $newStatus
            })
        } else {
            # Fallback if EventBus not available
            $this.LoadTasks()
        }
    }
    
    [void] AddSubtask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected -or -not $this.SubtaskService) { return }
        
        # Find the parent task (if selected item is a subtask, get its parent)
        $parentTask = $null
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Selected item is a subtask, find its parent
            $parentTask = $this.TaskService.GetTask($selected.ParentTaskId)
        } else {
            # Selected item is a task
            $parentTask = $selected
        }
        
        if (-not $parentTask) { return }
        
        # Create subtask dialog
        $dialog = [SubtaskDialog]::new($parentTask)
        
        # Set up callback for when subtask is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Create subtask using service
            $properties = @{
                ParentTaskId = $subtaskData.ParentTaskId
                Title = $subtaskData.Title
                Description = $subtaskData.Description
                Priority = $subtaskData.Priority
                Progress = $subtaskData.Progress
                EstimatedMinutes = $subtaskData.EstimatedMinutes
                ActualMinutes = $subtaskData.ActualMinutes
                DueDate = $subtaskData.DueDate
            }
            
            $screen.SubtaskService.CreateSubtask($properties)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ToggleSubtaskView() {
        $this.ShowSubtasks = -not $this.ShowSubtasks
        $this.LoadTasks()
    }
    
    [void] EditSubtask([PSCustomObject]$subtask) {
        if (-not $subtask -or -not $this.SubtaskService) { return }
        
        # Get parent task for context
        $parentTask = $this.TaskService.GetTask($subtask.ParentTaskId)
        if (-not $parentTask) { return }
        
        # Create subtask dialog for editing
        $dialog = [SubtaskDialog]::new($parentTask, $subtask)
        
        # Set up callback for when subtask is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Update the existing subtask
            $subtask.Title = $subtaskData.Title
            $subtask.Description = $subtaskData.Description
            $subtask.Status = $subtaskData.Status
            $subtask.Priority = $subtaskData.Priority
            $subtask.Progress = $subtaskData.Progress
            $subtask.EstimatedMinutes = $subtaskData.EstimatedMinutes
            $subtask.ActualMinutes = $subtaskData.ActualMinutes
            $subtask.DueDate = $subtaskData.DueDate
            $subtask.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.SubtaskService.SaveSubtask($subtask)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CyclePriority() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Don't cycle priority for subtasks in this view
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') { return }
        
        $this.TaskService.CyclePriority($selected.Id)
        $this.LoadTasks()
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Handle screen-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n')) {
                    $this.NewTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'E' -or $key.KeyChar -eq 'e')) {
                    $this.EditTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.EditTask()
                return $true
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Delete) {
                $this.DeleteTask()
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadTasks()
                    return $true
                }
            }
            ([System.ConsoleKey]::F5) {
                $this.LoadTasks()
                return $true
            }
            ([System.ConsoleKey]::S) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'S' -or $key.KeyChar -eq 's')) {
                    $this.CycleStatus()
                    return $true
                }
            }
            ([System.ConsoleKey]::P) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'P' -or $key.KeyChar -eq 'p')) {
                    $this.CyclePriority()
                    return $true
                }
            }
            ([System.ConsoleKey]::A) {
                if ($key.Modifiers -band [ConsoleModifiers]::Shift -and ($key.KeyChar -eq 'A')) {
                    # Shift+A to add subtask
                    $this.AddSubtask()
                    return $true
                }
            }
            ([System.ConsoleKey]::T) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'T' -or $key.KeyChar -eq 't')) {
                    # Toggle subtask view
                    $this.ToggleSubtaskView()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base (background and children)
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - $this.StatusBarHeight
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        
        # Status text
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY + 1))
        $sb.Append($this.Theme.GetColor("disabled"))
        
        $selected = $this.TaskGrid.GetSelectedItem()
        if ($selected) {
            # Show task details in status bar
            $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
            $type = if ($isSubtask) { "Subtask" } else { "Task" }
            $status = $selected.Status.ToString()
            $priority = $selected.Priority.ToString()
            $sb.Append("${type}: $($selected.Title) | Status: $status | Priority: $priority")
        } else {
            # Show help text with letter-based shortcuts
            $sb.Append("[N]ew [E]dit [D]elete [S]tatus [P]riority [A+Shift]Subtask [T]oggle [Tab]Navigate")
        }
        
        # Add legend for status/priority letters
        $sb.Append([VT]::MoveTo($this.X + $this.Width - 35, $statusY + 1))
        $sb.Append("S: P=Pending W=Working D=Done X=Cancel")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\_Backup/20250726_003635/Screens/TestScreen.ps1
# TestScreen.ps1 - Simple test screen to verify PRAXIS is working

class TestScreen : Screen {
    [string]$Message = "PRAXIS Test Screen"
    [int]$Counter = 0
    hidden [string]$_cachedContent = ""
    
    TestScreen() : base() {
        $this.Title = "Test"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnInitialize: $($this.Title)")
        }
        
        # No more BindKey - use HandleScreenInput instead
        
        # Don't rebuild content here - wait until we have bounds
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [System.ConsoleKey]::Spacebar) {
            $this.Counter++
            $this._cachedContent = ""  # Force re-render
            $this.RequestRender() 
            return $true
        }
        elseif ($key.KeyChar -eq 'q') {
            $this.Active = $false
            return $true
        }
        
        return $false
    }
    
    [void] OnThemeChanged() {
        ([Screen]$this).OnThemeChanged()
        $this._cachedContent = ""
        $this.RebuildContent()
    }
    
    [void] RebuildContent() {
        $sb = Get-PooledStringBuilder 512
        
        # Calculate absolute positions
        $absoluteCenterY = $this.Y + [int]($this.Height / 2)
        $absoluteCenterX = $this.X + [int](($this.Width - $this.Message.Length) / 2)
        
        # Title
        $sb.Append([VT]::MoveTo($absoluteCenterX, $absoluteCenterY - 2))
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append($this.Message)
        
        # Counter
        $counterText = "Counter: $($this.Counter)"
        $counterX = $this.X + [int](($this.Width - $counterText.Length) / 2)
        $sb.Append([VT]::MoveTo($counterX, $absoluteCenterY))
        $sb.Append($this.Theme.GetColor("foreground"))
        $sb.Append($counterText)
        
        # Instructions
        $instructionText = "Press SPACE to increment, Q to quit"
        $instructionX = $this.X + [int](($this.Width - $instructionText.Length) / 2)
        $sb.Append([VT]::MoveTo($instructionX, $absoluteCenterY + 2))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append($instructionText)
        
        # FPS counter (bottom right)
        if ($global:ScreenManager) {
            $fps = [Math]::Round($global:ScreenManager.GetFPS(), 1)
            $fpsText = "FPS: $fps"
            $sb.Append([VT]::MoveTo($this.X + $this.Width - $fpsText.Length - 2, $this.Y + $this.Height - 2))
            $sb.Append($this.Theme.GetColor("success"))
            $sb.Append($fpsText)
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedContent = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnRender: Bounds X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
        }
        
        # Check if we need to rebuild
        if ([string]::IsNullOrEmpty($this._cachedContent)) {
            $this.RebuildContent()
        }
        
        # Return base background + our content
        return ([Container]$this).OnRender() + $this._cachedContent
    }
}


####\_Backup/20250726_003635/Screens/TextEditorScreen.ps1
# TextEditorScreen - Multi-line text editor screen
# Proper PRAXIS architecture implementation

class TextEditorScreen : Screen {
    # Text content and cursor state
    [System.Collections.ArrayList]$Lines
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$FilePath = ""
    [bool]$Modified = $false
    [string]$StatusMessage = ""
    
    # Undo system - line-based grouping
    hidden [System.Collections.ArrayList]$_undoStates
    hidden [int]$_maxUndoStates = 25
    hidden [int]$_currentUndoIndex = -1
    hidden [int]$_maxFileSizeForUndo = 100KB
    hidden [bool]$_undoEnabled = $true
    
    # Auto-save on focus loss
    [bool]$AutoSaveOnFocusLoss = $true
    hidden [bool]$_lastFocusState = $true
    
    # PRAXIS service integration
    hidden [object]$ThemeManager
    hidden [object]$EventBus
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    # Mode system
    [bool]$InTextMode = $true  # Start in text mode
    
    TextEditorScreen() : base() {
        $this.Title = "Text Editor"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.IsFocusable = $true  # TextEditor itself is focusable
        $this.InitializeUndoSystem()
    }
    
    TextEditorScreen([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this.FilePath = $filePath
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true  # TextEditor itself is focusable
        $this.InitializeUndoSystem()
    }
    
    [void] InitializeUndoSystem() {
        $this._undoStates = [System.Collections.ArrayList]::new()
        # Save initial state
        $this.SaveUndoState()
    }
    
    [void] SaveUndoState() {
        if (-not $this._undoEnabled) { return }
        
        # Check file size limit
        $docSize = ($this.Lines | ForEach-Object { $_.Length } | Measure-Object -Sum).Sum
        if ($docSize -gt $this._maxFileSizeForUndo) {
            $this._undoEnabled = $false
            $this.StatusMessage = "Undo disabled - file too large"
            return
        }
        
        $state = @{
            Lines = $this.Lines.Clone()
            CursorX = $this.CursorX
            CursorY = $this.CursorY
            ScrollOffsetX = $this.ScrollOffsetX
            ScrollOffsetY = $this.ScrollOffsetY
        }
        
        # Remove any redo states if we're not at the end
        if ($this._currentUndoIndex -lt $this._undoStates.Count - 1) {
            $removeCount = $this._undoStates.Count - $this._currentUndoIndex - 1
            for ($i = 0; $i -lt $removeCount; $i++) {
                $this._undoStates.RemoveAt($this._undoStates.Count - 1)
            }
        }
        
        $this._undoStates.Add($state) | Out-Null
        $this._currentUndoIndex = $this._undoStates.Count - 1
        
        # Limit undo history
        if ($this._undoStates.Count -gt $this._maxUndoStates) {
            $this._undoStates.RemoveAt(0)
            $this._currentUndoIndex--
        }
        
        # Publish buffer state change event
        if ($this.EventBus) {
            try {
                $this.EventBus.Publish('editor.buffer.state-saved', @{
                    FilePath = $this.FilePath
                    UndoStates = $this._undoStates.Count
                    CurrentIndex = $this._currentUndoIndex
                })
            }
            catch {
                # Ignore event publishing errors to avoid disrupting editing
            }
        }
    }
    
    [void] PerformUndo() {
        if ($this._currentUndoIndex -le 0) { return }
        
        $this._currentUndoIndex--
        $state = $this._undoStates[$this._currentUndoIndex]
        
        $this.Lines = $state.Lines.Clone()
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] PerformRedo() {
        if ($this._currentUndoIndex -ge $this._undoStates.Count - 1) { return }
        
        $this._currentUndoIndex++
        $state = $this._undoStates[$this._currentUndoIndex]
        
        $this.Lines = $state.Lines.Clone()
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [bool] ShouldSaveUndoForLine() {
        # For line-based undo, save state when cursor moves to a different line
        # or if this is the very first edit
        if ($this._undoStates.Count -eq 0) { return $true }
        
        $lastState = $this._undoStates[$this._currentUndoIndex]
        return ($lastState.CursorY -ne $this.CursorY)
    }
    
    [void] OnApplicationFocusChanged([bool]$hasFocus) {
        # Called by PRAXIS framework when window focus changes
        if ($this._lastFocusState -and -not $hasFocus) {
            # Lost focus - trigger auto-save if enabled and file is modified
            if ($this.AutoSaveOnFocusLoss -and $this.Modified -and $this.FilePath) {
                $this.AutoSave()
            }
        }
        $this._lastFocusState = $hasFocus
    }
    
    [void] AutoSave() {
        try {
            $content = $this.Lines -join "`n"
            $autoSavePath = "$($this.FilePath).autosave"
            Set-Content -Path $autoSavePath -Value $content -NoNewline -ErrorAction Stop
            $this.StatusMessage = "Auto-saved on focus loss"
            if ($global:Logger) {
                $global:Logger.Debug("TextEditor: Auto-saved to $autoSavePath")
            }
        }
        catch {
            $this.StatusMessage = "Auto-save failed: $_"
            if ($global:Logger) {
                $global:Logger.Error("TextEditor: Auto-save failed: $_")
            }
        }
        $this.Invalidate()
    }
    
    [void] OnInitialize() {
        # Get PRAXIS services
        try {
            $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
            $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        }
        catch {
            if ($global:Logger) {
                $global:Logger.Warning("TextEditor: Could not get PRAXIS services: $_")
            }
        }
        
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        } elseif (-not $this.Lines.Count) {
            $this.Lines.Add("") | Out-Null
        }
        
        # Update title
        if ($this.FilePath) {
            $this.Title = "Text Editor - $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        
        # Subscribe to focus change events if EventBus is available
        if ($this.EventBus) {
            try {
                $this.EventBus.Subscribe('application.focus.changed', $this.OnApplicationFocusChanged.GetNewClosure())
            }
            catch {
                if ($global:Logger) {
                    $global:Logger.Warning("TextEditor: Could not subscribe to focus events: $_")
                }
            }
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # TextEditor itself is the focusable element
        $this.Focus()
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw -ErrorAction Stop
            if ($content) {
                $this.Lines.Clear()
                $lineArray = $content -split "`r?`n"
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.Modified = $false
            $this.StatusMessage = "File loaded: $([System.IO.Path]::GetFileName($this.FilePath))"
            
            # Publish file loaded event
            if ($this.EventBus) {
                try {
                    $this.EventBus.Publish('editor.file.loaded', @{
                        FilePath = $this.FilePath
                        LineCount = $this.Lines.Count
                    })
                }
                catch {
                    # Ignore event publishing errors
                }
            }
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
            if (-not $this.Lines.Count) {
                $this.Lines.Add("") | Out-Null
            }
        }
        $this.Invalidate()
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            # Open file browser for save location
            $this.OpenFileBrowser()
            return
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $this.FilePath -Value $content -NoNewline -ErrorAction Stop
            $this.Modified = $false
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($this.FilePath))"
            
            # Publish file saved event
            if ($this.EventBus) {
                try {
                    $this.EventBus.Publish('editor.file.saved', @{
                        FilePath = $this.FilePath
                        LineCount = $this.Lines.Count
                    })
                }
                catch {
                    # Ignore event publishing errors
                }
            }
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
        $this.Invalidate()
    }
    
    [void] OpenFileBrowser() {
        # Open file browser for file selection
        try {
            $fileBrowserType = [type]"FileBrowserScreen"
            if ($fileBrowserType) {
                $fileBrowser = $fileBrowserType::new()
                
                # Set up callback for file selection
                $editor = $this
                $fileBrowser.FileSelectedCallback = {
                    param($filePath)
                    if ($filePath -and (Test-Path $filePath)) {
                        $item = Get-Item $filePath -ErrorAction SilentlyContinue
                        if ($item -and -not $item.PSIsContainer) {
                            # File selected - either save current content or load new file
                            if ($editor.StatusMessage -eq "SELECT_SAVE_LOCATION") {
                                # Save current content to selected file
                                $editor.FilePath = $filePath
                                $editor.SaveFile()
                            } else {
                                # Load selected file
                                $editor.FilePath = $filePath
                                $editor.LoadFile()
                            }
                        }
                    }
                    
                    # Close the file browser
                    $screenManager = $editor.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Pop() | Out-Null
                }.GetNewClosure()
                
                # Push the file browser
                $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                $screenManager.Push($fileBrowser)
            }
        } catch {
            $this.StatusMessage = "FileBrowser not available"
            $this.Invalidate()
        }
    }
    
    # Override HandleScreenInput for text editor controls
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Clear status message on input (except for certain messages)
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Error") -and $this.StatusMessage -ne "SELECT_SAVE_LOCATION") {
            $this.StatusMessage = ""
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TextEditorScreen.HandleScreenInput: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' InTextMode=$($this.InTextMode)")
        }
        
        # ESC toggles between text mode and command mode
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $this.InTextMode = -not $this.InTextMode
            $this.StatusMessage = if ($this.InTextMode) { "TEXT MODE" } else { "COMMAND MODE" }
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: ESC pressed, InTextMode=$($this.InTextMode)")
            }
            $this.Invalidate()
            return $true
        }
        
        # In command mode, let number keys bubble up for tab switching
        if (-not $this.InTextMode -and $keyInfo.KeyChar -ge '1' -and $keyInfo.KeyChar -le '9') {
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: In command mode, not handling number key '$($keyInfo.KeyChar)'")
            }
            return $false  # Let parent handle tab switching
        }
        
        # Handle control key combinations
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::S) { 
                    $this.SaveFile()
                    return $true 
                }
                ([ConsoleKey]::O) { 
                    $this.OpenFileBrowser()
                    return $true 
                }
                ([ConsoleKey]::Z) {
                    if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {
                        $this.PerformRedo()
                    } else {
                        $this.PerformUndo()
                    }
                    return $true
                }
                ([ConsoleKey]::Y) {
                    $this.PerformRedo()
                    return $true
                }
                ([ConsoleKey]::Q) { 
                    if ($this.Modified) {
                        $this.StatusMessage = "Unsaved changes! Press Ctrl+Q again to quit"
                        $this.Invalidate()
                    } else {
                        $this.Active = $false
                    }
                    return $true
                }
            }
        }
        
        # Handle regular keys
        switch ($keyInfo.Key) {
            # Navigation
            ([ConsoleKey]::UpArrow) { $this.MoveCursor(0, -1); return $true }
            ([ConsoleKey]::DownArrow) { $this.MoveCursor(0, 1); return $true }
            ([ConsoleKey]::LeftArrow) { $this.MoveCursor(-1, 0); return $true }
            ([ConsoleKey]::RightArrow) { $this.MoveCursor(1, 0); return $true }
            ([ConsoleKey]::Home) { $this.CursorX = 0; $this.EnsureCursorVisible(); $this.Invalidate(); return $true }
            ([ConsoleKey]::End) { 
                if ($this.CursorY -lt $this.Lines.Count) {
                    $this.CursorX = $this.Lines[$this.CursorY].Length
                }
                $this.EnsureCursorVisible()
                $this.Invalidate()
                return $true
            }
            ([ConsoleKey]::PageUp) { $this.PageUp(); return $true }
            ([ConsoleKey]::PageDown) { $this.PageDown(); return $true }
            
            # Editing
            ([ConsoleKey]::Enter) { $this.InsertNewline(); return $true }
            ([ConsoleKey]::Backspace) { $this.Backspace(); return $true }
            ([ConsoleKey]::Delete) { $this.Delete(); return $true }
            ([ConsoleKey]::Tab) { $this.InsertTab(); return $true }
        }
        
        # Insert printable characters only in text mode
        if ($this.InTextMode -and $keyInfo.KeyChar -and [char]::IsControl($keyInfo.KeyChar) -eq $false) {
            $this.InsertChar($keyInfo.KeyChar)
            return $true
        }
        
        # Let base class handle other input (like tab switching)
        return $false
    }
    
    # Text editor specific methods
    [void] MoveCursor([int]$dx, [int]$dy) {
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.Lines.Count - 1, $this.CursorY + $dy))
        
        if ($dx -ne 0) {
            $this.CursorX = [Math]::Max(0, $this.CursorX + $dx)
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        } else {
            # Vertical movement - try to maintain column
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        }
        
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertChar([char]$char) {
        # Save undo state if this is the first edit on this line
        if ($this.ShouldSaveUndoForLine()) {
            $this.SaveUndoState()
        }
        
        $line = $this.Lines[$this.CursorY]
        $this.Lines[$this.CursorY] = $line.Insert($this.CursorX, $char)
        $this.CursorX++
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertNewline() {
        # Always save undo state before creating a new line
        $this.SaveUndoState()
        
        $line = $this.Lines[$this.CursorY]
        $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
        $after = if ($this.CursorX -lt $line.Length) { $line.Substring($this.CursorX) } else { "" }
        
        $this.Lines[$this.CursorY] = $before
        $this.Lines.Insert($this.CursorY + 1, $after)
        
        $this.CursorY++
        $this.CursorX = 0
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Backspace() {
        if ($this.CursorX -gt 0) {
            # Save undo state if this is first edit on this line
            if ($this.ShouldSaveUndoForLine()) {
                $this.SaveUndoState()
            }
            # Delete character before cursor
            $line = $this.Lines[$this.CursorY]
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Always save undo state before joining lines
            $this.SaveUndoState()
            # Join with previous line
            $prevLine = $this.Lines[$this.CursorY - 1]
            $currentLine = $this.Lines[$this.CursorY]
            $this.CursorX = $prevLine.Length
            $this.Lines[$this.CursorY - 1] = $prevLine + $currentLine
            $this.Lines.RemoveAt($this.CursorY)
            $this.CursorY--
        }
        
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Delete() {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.CursorX -lt $line.Length) {
            # Save undo state if this is first edit on this line
            if ($this.ShouldSaveUndoForLine()) {
                $this.SaveUndoState()
            }
            # Delete character at cursor
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX, 1)
        } elseif ($this.CursorY -lt $this.Lines.Count - 1) {
            # Always save undo state before joining lines
            $this.SaveUndoState()
            # Join with next line
            $nextLine = $this.Lines[$this.CursorY + 1]
            $this.Lines[$this.CursorY] = $line + $nextLine
            $this.Lines.RemoveAt($this.CursorY + 1)
        }
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] InsertTab() {
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
    
    [void] PageUp() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] PageDown() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Min($this.Lines.Count - 1, $this.CursorY + $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] EnsureCursorVisible() {
        $editorHeight = $this.Height - 6
        $editorWidth = $this.Width - $this.LineNumberWidth
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # When bounds change, ensure cursor is still visible
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096  # Text editor can have large content
        
        # Get theme colors
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
        $lineNumColor = if ($this.Theme) { $this.Theme.GetColor("linenumber") } else { $fgColor }
        $statusBg = if ($this.Theme) { $this.Theme.GetBgColor("status") } else { $bgColor }
        $statusFg = if ($this.Theme) { $this.Theme.GetColor("status.foreground") } else { $fgColor }
        $cursorBg = if ($this.Theme) { $this.Theme.GetBgColor("cursor") } else { $fgColor }
        
        # Calculate content area
        $contentHeight = $this.Height - 3  # Reserve space for title and status
        $contentWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartX = $this.X + ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartY = $this.Y + 1
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        # Draw title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        $titleText = $this.Title
        if ($this.Modified) { $titleText += " *" }
        $titleText = $titleText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($titleText)
        
        # Render text lines
        $endY = [Math]::Min($this.ScrollOffsetY + $contentHeight, $this.Lines.Count)
        for ($lineIdx = $this.ScrollOffsetY; $lineIdx -lt $endY; $lineIdx++) {
            $screenY = $contentStartY + ($lineIdx - $this.ScrollOffsetY)
            $line = $this.Lines[$lineIdx]
            
            # Draw line numbers if enabled
            if ($this.ShowLineNumbers) {
                $sb.Append([VT]::MoveTo($this.X, $screenY))
                $sb.Append($lineNumColor)
                $lineNum = ($lineIdx + 1).ToString().PadLeft($this.LineNumberWidth - 1) + " "
                $sb.Append($lineNum)
            }
            
            # Draw line content
            $sb.Append([VT]::MoveTo($contentStartX, $screenY))
            $sb.Append($fgColor)
            
            if ($line.Length -gt $this.ScrollOffsetX) {
                $visibleText = $line.Substring($this.ScrollOffsetX)
                if ($visibleText.Length -gt $contentWidth) {
                    $visibleText = $visibleText.Substring(0, $contentWidth)
                }
                $sb.Append($visibleText)
            }
        }
        
        # Draw cursor if this screen is focused
        if ($this.IsFocused) {
            $cursorScreenX = $contentStartX + ($this.CursorX - $this.ScrollOffsetX)
            $cursorScreenY = $contentStartY + ($this.CursorY - $this.ScrollOffsetY)
            
            # Only draw cursor if it's visible
            if ($cursorScreenX -ge $contentStartX -and $cursorScreenX -lt $contentStartX + $contentWidth -and
                $cursorScreenY -ge $contentStartY -and $cursorScreenY -lt $contentStartY + $contentHeight) {
                
                $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
                $sb.Append($cursorBg)
                
                # Get character under cursor
                $charUnderCursor = " "
                if ($this.CursorY -lt $this.Lines.Count) {
                    $line = $this.Lines[$this.CursorY]
                    if ($this.CursorX -lt $line.Length) {
                        $charUnderCursor = $line[$this.CursorX]
                    }
                }
                $sb.Append($charUnderCursor)
            }
        }
        
        # Draw status line
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        
        $statusText = ""
        if ($this.StatusMessage) {
            $statusText = $this.StatusMessage
        } else {
            $modeText = if ($this.InTextMode) { "[TEXT]" } else { "[COMMAND]" }
            $statusText = "$modeText Line $($this.CursorY + 1), Col $($this.CursorX + 1)"
            if ($this.FilePath) {
                $statusText += " | $([System.IO.Path]::GetFileName($this.FilePath))"
            }
        }
        $statusText = $statusText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($statusText)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\_Backup/20250726_003635/Screens/TextEditorScreenNew.ps1
# TextEditorScreenNew.ps1 - Refactored text editor with Buffer/View architecture
# Implements the professional architecture from the upgrade plan

class TextEditorScreenNew : Screen {
    # Buffer/View separation - DocumentBuffer or GapBufferDocumentBuffer handles all text logic
    hidden [object]$_buffer
    
    # Cursor and viewport state (UI concerns only)
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$StatusMessage = ""
    
    # Line-level render cache for performance
    hidden [hashtable]$_lineRenderCache
    hidden [hashtable]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Selection state for block selection
    [bool]$HasSelection = $false
    [int]$SelectionStartX = 0
    [int]$SelectionStartY = 0
    [int]$SelectionEndX = 0
    [int]$SelectionEndY = 0
    [bool]$InSelectionMode = $false
    
    # PRAXIS service integration
    hidden [object]$ThemeManager
    hidden [object]$EventBus
    
    # Proper undo system - tracks complete document state
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [bool]$_groupingInserts = $false
    hidden [datetime]$_lastActionTime = [datetime]::MinValue
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    [bool]$AutoSaveOnFocusLoss = $true
    
    # Clipboard system
    hidden [string]$_clipboard = ""
    
    TextEditorScreenNew() : base() {
        $this.Title = "Text Editor"
        $this._buffer = [GapBufferDocumentBuffer]::new()
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        
        # Initialize simple undo system
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        
        # Add some sample content for testing
        $this.AddSampleContent()
    }
    
    TextEditorScreenNew([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this._buffer = [GapBufferDocumentBuffer]::new($filePath)
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        $this.UpdateTitle()
    }
    
    TextEditorScreenNew([string]$filePath, [bool]$useGapBuffer) : base() {
        $this.Title = "Text Editor"
        if ($useGapBuffer) {
            $this._buffer = [GapBufferDocumentBuffer]::new($filePath)
        } else {
            $this._buffer = [DocumentBuffer]::new($filePath)
        }
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        $this.UpdateTitle()
    }
    
    [void] OnInitialize() {
        # Get PRAXIS services
        $this.ThemeManager = $this.ServiceContainer.GetService("ThemeManager")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
    }
    
    hidden [void] InitializeRenderCache() {
        $this._lineRenderCache = @{}
        $this._dirtyLines = @{}
    }
    
    hidden [void] SetupBufferEventHandlers() {
        # Buffer notifies us when content changes
        $screen = $this
        $this._buffer.OnContentChanged = {
            $screen.OnBufferContentChanged()
        }.GetNewClosure()
        
        $this._buffer.OnModifiedStateChanged = {
            param($isModified)
            $screen.OnBufferModifiedStateChanged($isModified)
        }.GetNewClosure()
    }
    
    hidden [void] OnBufferContentChanged() {
        # Mark lines dirty based on buffer's dirty tracking
        for ($i = 0; $i -lt $this._buffer.GetLineCount(); $i++) {
            if ($this._buffer.IsLineDirty($i)) {
                $this._dirtyLines[$i] = $true
            }
        }
        $this.Invalidate()
    }
    
    hidden [void] OnBufferModifiedStateChanged([bool]$isModified) {
        $this.UpdateTitle()
        $this.Invalidate()
    }
    
    hidden [void] UpdateTitle() {
        $fileName = if ($this._buffer.FilePath) { 
            [System.IO.Path]::GetFileName($this._buffer.FilePath) 
        } else { 
            "Untitled" 
        }
        $modifiedIndicator = if ($this._buffer.IsModified) { "*" } else { "" }
        $this.Title = "Text Editor - $fileName$modifiedIndicator"
    }
    
    hidden [void] AddSampleContent() {
        # Add some sample content to test the editor
        $sampleText = @"
Welcome to PRAXIS Text Editor!

This is the new Buffer/View architecture with:
 Gap Buffer for high-performance editing
 Line-level render caching for performance
 Block selection with visual highlighting
 Find/Replace with comprehensive search
 Professional copy/paste system

Try these features:
 Shift+Arrow keys for block selection
 Ctrl+C/X/V for copy/cut/paste
 Ctrl+F for find, Ctrl+H for replace
 Ctrl+U/R for undo/redo
 Ctrl+A to select all

The architecture is now professional-grade!
"@
        
        # Set the content using the buffer's proper interface
        # This bypasses the command system intentionally so it doesn't affect undo
        if ($this._buffer.GetType().Name -eq "GapBufferDocumentBuffer") {
            # Use GapBuffer's SetText method
            $this._buffer._gapBuffer.SetText($sampleText + "`n")
            $this._buffer.InvalidateLineIndex()
        } else {
            # Use DocumentBuffer's Lines property
            $this._buffer.Lines.Clear()
            $lines = $sampleText -split "`r?`n"
            foreach ($line in $lines) {
                $this._buffer.Lines.Add($line) | Out-Null
            }
        }
        
        # Clear the undo/redo stacks since this is initial content
        $this._buffer.ClearUndoHistory()
        $this._buffer.IsModified = $false
        
        $this._allLinesDirty = $true
    }
    
    # --- Input Handling - Translates keys to commands ---
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle special keys first
        if ($this.HandleSpecialKeys($keyInfo)) {
            return $true
        }
        
        # Handle character insertion
        if ($keyInfo.KeyChar -and -not [char]::IsControl($keyInfo.KeyChar)) {
            $this.InsertCharacter($keyInfo.KeyChar)
            return $true
        }
        
        return $false
    }
    
    hidden [bool] HandleSpecialKeys([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Backspace) {
                $this.HandleBackspace()
                return $true
            }
            ([System.ConsoleKey]::Delete) {
                $this.HandleDelete()
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $this.HandleEnter()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                $this.HandleTab()
                return $true
            }
            ([System.ConsoleKey]::LeftArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorLeft($extend)
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorRight($extend)
                return $true
            }
            ([System.ConsoleKey]::UpArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorUp($extend)
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorDown($extend)
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.MoveCursorHome($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.MoveCursorEnd($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::PageUp) {
                $this.MoveCursorPageUp($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::PageDown) {
                $this.MoveCursorPageDown($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
        }
        
        # Handle Ctrl combinations
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([System.ConsoleKey]::S) {
                    $this.SaveFile()
                    return $true
                }
                ([System.ConsoleKey]::O) {
                    $this.OpenFile()
                    return $true
                }
                ([System.ConsoleKey]::N) {
                    $this.NewFile()
                    return $true
                }
                ([System.ConsoleKey]::U) {
                    $this.UndoEdit()
                    return $true
                }
                ([System.ConsoleKey]::R) {
                    $this.RedoEdit()
                    return $true
                }
                ([System.ConsoleKey]::C) {
                    $this.CopySelection()
                    return $true
                }
                ([System.ConsoleKey]::X) {
                    $this.CutSelection()
                    return $true
                }
                ([System.ConsoleKey]::V) {
                    $this.PasteClipboard()
                    return $true
                }
                ([System.ConsoleKey]::A) {
                    $this.SelectAll()
                    return $true
                }
                ([System.ConsoleKey]::F) {
                    $this.ShowFindReplaceDialog()
                    return $true
                }
                ([System.ConsoleKey]::H) {
                    $this.ShowFindReplaceDialog()
                    return $true
                }
                ([System.ConsoleKey]::I) {
                    $this.ShowBufferInfo()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    # --- Text Editing Operations (Command Pattern) ---
    
    hidden [void] InsertCharacter([char]$char) {
        try {
            # Delete selection first if it exists (standard text editor behavior)
            if ($this.HasSelection) {
                $this.DeleteSelection()
            }
            
            # Check if we should group this insert with previous ones
            $now = [datetime]::Now
            $timeDiff = $now - $this._lastActionTime
            $shouldGroup = $this._groupingInserts -and $timeDiff.TotalMilliseconds -lt 1000
            
            if (-not $shouldGroup) {
                # Save complete document state before making changes
                $this.SaveDocumentState()
                $this._groupingInserts = $true
            }
            
            # Insert character
            $this._buffer.InsertTextAt($this.CursorY, $this.CursorX, [string]$char)
            $this.CursorX++
            $this._lastActionTime = $now
            
            # Mark as modified
            $this._buffer.IsModified = $true
            $this._allLinesDirty = $true
            if ($this._lineRenderCache) {
                $this._lineRenderCache.Clear()
            }
            
            $this.EnsureCursorVisible()
            $this.Invalidate()
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("InsertCharacter failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Character insertion failed"
        }
    }
    
    hidden [void] HandleBackspace() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
            return
        }
        
        # Stop grouping inserts when user starts deleting
        $this._groupingInserts = $false
        $this.SaveDocumentState()
        
        if ($this.CursorX -gt 0) {
            # Delete character before cursor
            $this._buffer.DeleteTextAt($this.CursorY, $this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Join with previous line
            $prevLineLength = $this._buffer.GetLine($this.CursorY - 1).Length
            $currentLineText = $this._buffer.GetLine($this.CursorY)
            $this._buffer.JoinLinesAt($this.CursorY - 1, "")
            $this.CursorY--
            $this.CursorX = $prevLineLength
        }
        
        $this._buffer.IsModified = $true
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    hidden [void] HandleDelete() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
            return
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        if ($this.CursorX -lt $currentLine.Length) {
            # Delete character at cursor
            $charToDelete = $this._buffer.GetTextAt($this.CursorY, $this.CursorX, 1)
            $command = [DeleteTextCommand]::new($this.CursorY, $this.CursorX, $charToDelete)
            $this._buffer.ExecuteCommand($command)
        } elseif ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            # Join with next line
            $nextLineText = $this._buffer.GetLine($this.CursorY + 1)
            $command = [JoinLinesCommand]::new($this.CursorY, $nextLineText)
            $this._buffer.ExecuteCommand($command)
        }
    }
    
    hidden [void] HandleEnter() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $rightText = $currentLine.Substring($this.CursorX)
        $command = [InsertNewlineCommand]::new($this.CursorY, $this.CursorX, $rightText)
        $this._buffer.ExecuteCommand($command)
        $this.CursorY++
        $this.CursorX = 0
        $this.EnsureCursorVisible()
        $this.ClearSelection()
    }
    
    hidden [void] HandleTab() {
        # Delete selection first if it exists
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        $spaces = " " * $this.TabWidth
        $command = [InsertTextCommand]::new($this.CursorY, $this.CursorX, $spaces)
        $this._buffer.ExecuteCommand($command)
        $this.CursorX += $this.TabWidth
        $this.EnsureCursorVisible()
    }
    
    # --- File Operations ---
    
    [void] SaveFile([string]$filePath = "") {
        try {
            if ([string]::IsNullOrEmpty($filePath)) {
                $filePath = $this._buffer.FilePath
            }
            if ([string]::IsNullOrEmpty($filePath)) {
                # TODO: Open file dialog
                $this.StatusMessage = "No file path specified"
                return
            }
            
            $this._buffer.SaveToFile($filePath)
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($filePath))"
            $this.UpdateTitle()
        } catch {
            $this.StatusMessage = "Error saving file: $($_.Exception.Message)"
        }
    }
    
    [void] OpenFile([string]$filePath = "") {
        # TODO: Implement file dialog
        $this.StatusMessage = "Open file not yet implemented"
    }
    
    [void] NewFile() {
        $this._buffer = [DocumentBuffer]::new()
        $this.SetupBufferEventHandlers()
        $this.CursorX = 0
        $this.CursorY = 0
        $this.ScrollOffsetX = 0
        $this.ScrollOffsetY = 0
        $this.ClearSelection()
        $this._allLinesDirty = $true
        $this._lineRenderCache.Clear()
        $this.UpdateTitle()
        $this.StatusMessage = "New file created"
        $this.Invalidate()
    }
    
    # --- Find/Replace Dialog ---
    
    [void] ShowFindReplaceDialog() {
        try {
            # Create the find/replace dialog
            $findDialog = [FindReplaceDialog]::new($this)
            
            # Set up callback for when dialog closes
            $editor = $this
            $findDialog.OnClose = {
                # Focus returns to editor when dialog closes
                $editor.Focus()
            }.GetNewClosure()
            
            # Push the dialog onto the screen stack
            $screenManager = $this.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Push($findDialog)
            } else {
                $this.StatusMessage = "Cannot open find dialog: ScreenManager not available"
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ShowFindReplaceDialog failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Error opening find dialog: $($_.Exception.Message)"
        }
    }
    
    # --- Buffer Information ---
    
    [void] ShowBufferInfo() {
        try {
            if ($this._buffer.GetType().Name -eq "GapBufferDocumentBuffer") {
                $stats = $this._buffer.GetStatistics()
                $gapStats = $stats.GapBuffer
                
                $info = @"
Gap Buffer Performance Statistics:

Buffer Info:
 Length: $($gapStats.Length) characters
 Capacity: $($gapStats.Capacity) characters  
 Gap Size: $($gapStats.GapSize) characters
 Gap Position: $($gapStats.GapStart)-$($gapStats.GapEnd)

Operations:
 Inserts: $($gapStats.InsertCount)
 Deletes: $($gapStats.DeleteCount)  
 Gap Moves: $($gapStats.MoveCount)
 Buffer Grows: $($gapStats.GrowCount)
 Efficiency: $($gapStats.Efficiency) ops/move

Document Info:
 Lines: $($stats.LineCount)
 Line Index Rebuilds: $($stats.LineIndexRebuildCount)
 Undo Stack: $($stats.UndoStackSize)
 Redo Stack: $($stats.RedoStackSize)
"@
            } else {
                $info = @"
ArrayList Document Buffer:

Buffer Info:
 Lines: $($this._buffer.GetLineCount())
 Total Characters: $($this._buffer.Lines | ForEach-Object { $_.Length } | Measure-Object -Sum | Select-Object -ExpandProperty Sum)
 Undo Stack: $($this._buffer._undoStack.Count)
 Redo Stack: $($this._buffer._redoStack.Count)

Note: Using basic ArrayList implementation.
Switch to GapBufferDocumentBuffer for better performance.
"@
            }
            
            $this.StatusMessage = "Buffer statistics shown. Press any key to continue editing."
            $this.Invalidate()
            
            # Simple info display in status - in a real implementation you might want a dialog
            if ($global:Logger) {
                $global:Logger.Info("Buffer Statistics:`n$info")
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ShowBufferInfo failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Error retrieving buffer information"
        }
    }
    
    # --- Undo/Redo ---
    
    [void] UndoEdit() {
        if ($this._undoStack.Count -eq 0) {
            $this.StatusMessage = "Nothing to undo"
            return
        }
        
        try {
            # Stop any current grouping
            $this._groupingInserts = $false
            
            # Save current document state for redo
            $currentState = $this.GetDocumentState()
            $this._redoStack.Add($currentState) | Out-Null
            
            # Get and apply previous state
            $previousState = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            
            $this.RestoreDocumentState($previousState)
            $this.StatusMessage = "Undo"
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("UndoEdit failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Undo failed"
        }
    }
    
    [void] RedoEdit() {
        if ($this._redoStack.Count -eq 0) {
            $this.StatusMessage = "Nothing to redo"
            return
        }
        
        try {
            # Stop any current grouping
            $this._groupingInserts = $false
            
            # Save current document state for undo
            $currentState = $this.GetDocumentState()
            $this._undoStack.Add($currentState) | Out-Null
            
            # Get and apply redo state
            $redoState = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            
            $this.RestoreDocumentState($redoState)
            $this.StatusMessage = "Redo"
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("RedoEdit failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Redo failed"
        }
    }
    
    hidden [void] SaveDocumentState() {
        $state = $this.GetDocumentState()
        $this._undoStack.Add($state) | Out-Null
        
        # Clear redo stack when new action is performed
        $this._redoStack.Clear()
        
        # Limit undo history
        if ($this._undoStack.Count -gt 50) {
            $this._undoStack.RemoveAt(0)
        }
    }
    
    hidden [hashtable] GetDocumentState() {
        # Create a deep copy of the document state
        $linesCopy = [System.Collections.ArrayList]::new()
        foreach ($line in $this._buffer.Lines) {
            $linesCopy.Add([string]$line) | Out-Null
        }
        
        return @{
            Lines = $linesCopy
            CursorX = $this.CursorX
            CursorY = $this.CursorY
            ScrollOffsetX = $this.ScrollOffsetX
            ScrollOffsetY = $this.ScrollOffsetY
            IsModified = $this._buffer.IsModified
        }
    }
    
    hidden [void] RestoreDocumentState([hashtable]$state) {
        # Restore the complete document state
        $this._buffer.Lines.Clear()
        foreach ($line in $state.Lines) {
            $this._buffer.Lines.Add([string]$line) | Out-Null
        }
        
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        $this._buffer.IsModified = $state.IsModified
        
        # Mark all lines dirty and refresh
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    
    # --- Selection and Clipboard (Stub implementations) ---
    
    hidden [void] ClearSelection() {
        $this.HasSelection = $false
        $this.InSelectionMode = $false
        $this.SelectionStartX = 0
        $this.SelectionStartY = 0
        $this.SelectionEndX = 0
        $this.SelectionEndY = 0
    }
    
    hidden [void] StartSelection() {
        $this.HasSelection = $true
        $this.InSelectionMode = $true
        $this.SelectionStartX = $this.CursorX
        $this.SelectionStartY = $this.CursorY
        $this.SelectionEndX = $this.CursorX
        $this.SelectionEndY = $this.CursorY
    }
    
    hidden [void] UpdateSelection() {
        if ($this.HasSelection) {
            $this.SelectionEndX = $this.CursorX
            $this.SelectionEndY = $this.CursorY
            $this._allLinesDirty = $true  # Selection changes require full redraw
            $this.Invalidate()
        }
    }
    
    hidden [void] DeleteSelection() {
        if (-not $this.HasSelection) {
            return
        }
        
        # Get normalized selection bounds
        $bounds = $this.GetSelectionBounds()
        
        # Save state for undo
        $this.SaveDocumentState()
        
        # Delete the selected text
        if ($bounds.StartY -eq $bounds.EndY) {
            # Single line selection
            $this._buffer.DeleteTextAt($bounds.StartY, $bounds.StartX, $bounds.EndX - $bounds.StartX)
        } else {
            # Multi-line selection - delete from end to start to preserve positions
            for ($y = $bounds.EndY; $y -ge $bounds.StartY; $y--) {
                if ($y -eq $bounds.EndY -and $y -eq $bounds.StartY) {
                    # Same line (shouldn't happen but safety check)
                    $this._buffer.DeleteTextAt($y, $bounds.StartX, $bounds.EndX - $bounds.StartX)
                } elseif ($y -eq $bounds.EndY) {
                    # Last line - delete from start to EndX
                    $this._buffer.DeleteTextAt($y, 0, $bounds.EndX)
                } elseif ($y -eq $bounds.StartY) {
                    # First line - delete from StartX to end, then join with next line
                    $line = $this._buffer.GetLine($y)
                    $this._buffer.DeleteTextAt($y, $bounds.StartX, $line.Length - $bounds.StartX)
                    # Remove the now-empty lines that were in between
                    for ($i = $bounds.EndY; $i -gt $bounds.StartY; $i--) {
                        $this._buffer.Lines.RemoveAt($i)
                    }
                    break  # We've handled the deletion
                }
            }
        }
        
        # Move cursor to selection start
        $this.CursorX = $bounds.StartX
        $this.CursorY = $bounds.StartY
        
        $this.ClearSelection()
        $this._buffer.IsModified = $true
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.Invalidate()
    }
    
    hidden [hashtable] GetSelectionBounds() {
        if (-not $this.HasSelection) {
            return @{ StartX = 0; StartY = 0; EndX = 0; EndY = 0 }
        }
        
        # Normalize selection (start should be before end)
        if ($this.SelectionStartY -lt $this.SelectionEndY -or 
            ($this.SelectionStartY -eq $this.SelectionEndY -and $this.SelectionStartX -le $this.SelectionEndX)) {
            return @{
                StartX = $this.SelectionStartX
                StartY = $this.SelectionStartY
                EndX = $this.SelectionEndX
                EndY = $this.SelectionEndY
            }
        } else {
            return @{
                StartX = $this.SelectionEndX
                StartY = $this.SelectionEndY
                EndX = $this.SelectionStartX
                EndY = $this.SelectionStartY
            }
        }
    }
    
    [void] CopySelection() {
        if (-not $this.HasSelection) {
            $this.StatusMessage = "No selection to copy"
            return
        }
        
        $bounds = $this.GetSelectionBounds()
        $copiedText = ""
        
        if ($bounds.StartY -eq $bounds.EndY) {
            # Single line selection
            $line = $this._buffer.GetLine($bounds.StartY)
            $copiedText = $line.Substring($bounds.StartX, $bounds.EndX - $bounds.StartX)
        } else {
            # Multi-line selection
            $lines = [System.Collections.ArrayList]::new()
            
            for ($y = $bounds.StartY; $y -le $bounds.EndY; $y++) {
                $line = $this._buffer.GetLine($y)
                if ($y -eq $bounds.StartY) {
                    # First line - from StartX to end
                    $lines.Add($line.Substring($bounds.StartX)) | Out-Null
                } elseif ($y -eq $bounds.EndY) {
                    # Last line - from start to EndX
                    $lines.Add($line.Substring(0, $bounds.EndX)) | Out-Null
                } else {
                    # Middle lines - entire line
                    $lines.Add($line) | Out-Null
                }
            }
            $copiedText = $lines -join "`n"
        }
        
        # Store in global clipboard
        if (-not $global:TuiClipboard) {
            $global:TuiClipboard = ""
        }
        $global:TuiClipboard = $copiedText
        $this._clipboard = $copiedText
        
        $this.StatusMessage = "Copied to clipboard"
    }
    
    [void] CutSelection() {
        if (-not $this.HasSelection) {
            $this.StatusMessage = "No selection to cut"
            return
        }
        
        # Copy first, then delete
        $this.CopySelection()
        $this.DeleteSelection()
        $this.StatusMessage = "Cut to clipboard"
    }
    
    [void] PasteClipboard() {
        # Get text from global clipboard or internal clipboard
        $textToPaste = ""
        if ($global:TuiClipboard) {
            $textToPaste = $global:TuiClipboard
        } elseif ($this._clipboard) {
            $textToPaste = $this._clipboard
        } else {
            $this.StatusMessage = "Clipboard is empty"
            return
        }
        
        # Delete any existing selection first
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        # Save state for undo
        $this.SaveDocumentState()
        
        # Insert the pasted text
        $lines = $textToPaste -split "`n"
        if ($lines.Count -eq 1) {
            # Single line paste
            $this._buffer.InsertTextAt($this.CursorY, $this.CursorX, $textToPaste)
            $this.CursorX += $textToPaste.Length
        } else {
            # Multi-line paste
            $currentLine = $this._buffer.GetLine($this.CursorY)
            $leftPart = $currentLine.Substring(0, $this.CursorX)
            $rightPart = $currentLine.Substring($this.CursorX)
            
            # Replace current line with first line of paste
            $this._buffer.Lines[$this.CursorY] = $leftPart + $lines[0]
            
            # Insert middle lines
            for ($i = 1; $i -lt $lines.Count - 1; $i++) {
                $this._buffer.Lines.Insert($this.CursorY + $i, $lines[$i])
            }
            
            # Insert last line and append remaining text
            if ($lines.Count -gt 1) {
                $lastLine = $lines[$lines.Count - 1] + $rightPart
                $this._buffer.Lines.Insert($this.CursorY + $lines.Count - 1, $lastLine)
                $this.CursorY += $lines.Count - 1
                $this.CursorX = $lines[$lines.Count - 1].Length
            }
        }
        
        $this._buffer.IsModified = $true
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.EnsureCursorVisible()
        $this.Invalidate()
        $this.StatusMessage = "Pasted from clipboard"
    }
    
    [void] SelectAll() {
        $this.StartSelection()
        
        # Set selection to entire document
        $this.SelectionStartX = 0
        $this.SelectionStartY = 0
        
        $lastLineIndex = $this._buffer.GetLineCount() - 1
        $this.SelectionEndY = $lastLineIndex
        $this.SelectionEndX = $this._buffer.GetLine($lastLineIndex).Length
        
        # Move cursor to end
        $this.CursorY = $this.SelectionEndY
        $this.CursorX = $this.SelectionEndX
        
        $this._allLinesDirty = $true
        $this.Invalidate()
        $this.StatusMessage = "Selected all text"
    }
    
    # --- Cursor Movement (Stub implementations) ---
    
    hidden [void] MoveCursorLeft([bool]$extend) {
        # Start selection if shift is held and no selection exists
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        if ($this.CursorX -gt 0) {
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            $this.CursorY--
            $this.CursorX = $this._buffer.GetLine($this.CursorY).Length
        }
        
        # Update or clear selection
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorRight([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        if ($this.CursorX -lt $currentLine.Length) {
            $this.CursorX++
        } elseif ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            $this.CursorY++
            $this.CursorX = 0
        }
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorUp([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        if ($this.CursorY -gt 0) {
            $this.CursorY--
            $prevLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Min($this.CursorX, $prevLine.Length)
        }
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorDown([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        if ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            $this.CursorY++
            $nextLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Min($this.CursorX, $nextLine.Length)
        }
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorHome([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $this.CursorX = 0
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorEnd([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $this.CursorX = $this._buffer.GetLine($this.CursorY).Length
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorPageUp([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $pageSize = $this.Height - 4
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        
        # Ensure cursor X is within bounds of the new line
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $this.CursorX = [Math]::Min($this.CursorX, $currentLine.Length)
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorPageDown([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $pageSize = $this.Height - 4
        $this.CursorY = [Math]::Min($this._buffer.GetLineCount() - 1, $this.CursorY + $pageSize)
        
        # Ensure cursor X is within bounds of the new line
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $this.CursorX = [Math]::Min($this.CursorX, $currentLine.Length)
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] ValidateCursorPosition() {
        # Ensure cursor is within valid bounds
        $lineCount = $this._buffer.GetLineCount()
        if ($lineCount -eq 0) {
            $this.CursorX = 0
            $this.CursorY = 0
            return
        }
        
        # Clamp cursor Y to valid range
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.CursorY, $lineCount - 1))
        
        # Clamp cursor X to current line length
        try {
            $currentLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Max(0, [Math]::Min($this.CursorX, $currentLine.Length))
        } catch {
            # If we can't get the line, reset cursor to safe position
            $this.CursorX = 0
            $this.CursorY = 0
        }
    }
    
    hidden [void] EnsureCursorVisible() {
        # Implement viewport scrolling to keep cursor visible
        $editorHeight = $this.Height - 2  # Account for status line
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        $editorWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
        
        # Ensure scroll offsets are valid
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY)
        $this.ScrollOffsetX = [Math]::Max(0, $this.ScrollOffsetX)
        
        $this.Invalidate()
    }
    
    # --- Optimized Rendering with Line-Level Caching ---
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Render with line caching for performance
        $this.RenderWithCache($sb)
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    hidden [void] RenderWithCache([System.Text.StringBuilder]$sb) {
        # Clear the entire screen area first with background color
        $bgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("background") } else { "" }
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        # Calculate editor area
        $editorHeight = $this.Height - 1  # Reserve bottom for status
        $editorWidth = $this.Width
        $lineNumWidth = if ($this.ShowLineNumbers) { $this.LineNumberWidth } else { 0 }
        $textWidth = $editorWidth - $lineNumWidth
        
        # Render visible lines with caching
        $startLine = $this.ScrollOffsetY
        $endLine = [Math]::Min($startLine + $editorHeight, $this._buffer.GetLineCount())
        
        for ($lineIndex = $startLine; $lineIndex -lt $endLine; $lineIndex++) {
            $y = $lineIndex - $startLine
            $renderLine = ""
            
            # Check if line needs re-rendering
            if ($this._allLinesDirty -or $this._dirtyLines.ContainsKey($lineIndex) -or -not $this._lineRenderCache.ContainsKey($lineIndex)) {
                # Render line from scratch
                $renderLine = $this.RenderLine($lineIndex, $lineNumWidth, $textWidth)
                $this._lineRenderCache[$lineIndex] = $renderLine
            } else {
                # Use cached version
                $renderLine = $this._lineRenderCache[$lineIndex]
            }
            
            # Output the line
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($renderLine)
        }
        
        # Clear dirty flags
        $this._buffer.ClearDirtyLines()
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
        
        # Render cursor if focused and visible
        if ($this.IsFocused) {
            $this.RenderCursor($sb, $lineNumWidth, $editorHeight)
        }
        
        # Render status line
        $statusY = $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $statusY))
        $statusColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("status") } else { "" }
        $statusBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("status") } else { "" }
        $sb.Append($statusBgColor)
        $sb.Append($statusColor)
        $statusText = $this.GetStatusText()
        $sb.Append($statusText.PadRight($this.Width).Substring(0, $this.Width))
    }
    
    hidden [string] RenderLine([int]$lineNumber, [int]$lineNumberWidth, [int]$textWidth) {
        $sb = [System.Text.StringBuilder]::new()
        
        # Get colors
        $textColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("normal") } else { "" }
        $lineNumColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("linenumber") } else { $textColor }
        $bgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("background") } else { "" }
        $selectionBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("selection") } else { "\e[0;7m" }
        $selectionTextColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("selection.text") } else { "" }
        
        # Apply background color
        $sb.Append($bgColor)
        
        # Line number
        if ($this.ShowLineNumbers) {
            $sb.Append($lineNumColor)
            $lineNumText = ($lineNumber + 1).ToString().PadLeft($lineNumberWidth - 1) + " "
            $sb.Append($lineNumText)
        }
        
        # Get line text and determine what's visible
        $lineText = $this._buffer.GetLine($lineNumber)
        $visibleText = $lineText
        if ($this.ScrollOffsetX -gt 0 -and $this.ScrollOffsetX -lt $lineText.Length) {
            $visibleText = $lineText.Substring($this.ScrollOffsetX)
        } elseif ($this.ScrollOffsetX -ge $lineText.Length) {
            $visibleText = ""
        }
        
        if ($visibleText.Length -gt $textWidth) {
            $visibleText = $visibleText.Substring(0, $textWidth)
        }
        
        # Check if this line has selection
        if ($this.HasSelection) {
            $bounds = $this.GetSelectionBounds()
            
            # Check if current line intersects with selection
            if ($lineNumber -ge $bounds.StartY -and $lineNumber -le $bounds.EndY) {
                # Line has selection - render with highlighting
                $this.RenderLineWithSelection($sb, $lineNumber, $visibleText, $textWidth, $bounds, $textColor, $selectionBgColor, $selectionTextColor)
            } else {
                # No selection on this line - render normally
                $sb.Append($textColor)
                $sb.Append($visibleText)
            }
        } else {
            # No selection at all - render normally
            $sb.Append($textColor)
            $sb.Append($visibleText)
        }
        
        # Pad to full width
        $totalRendered = $lineNumberWidth + $visibleText.Length
        if ($totalRendered -lt $this.Width) {
            $sb.Append($bgColor)  # Ensure padding uses background color
            $sb.Append([StringCache]::GetSpaces($this.Width - $totalRendered))
        }
        
        return $sb.ToString()
    }
    
    hidden [void] RenderLineWithSelection([System.Text.StringBuilder]$sb, [int]$lineNumber, [string]$visibleText, [int]$textWidth, [hashtable]$bounds, [string]$textColor, [string]$selectionBgColor, [string]$selectionTextColor) {
        if ($bounds.StartY -eq $bounds.EndY -and $bounds.StartY -eq $lineNumber) {
            # Single line selection
            $selStart = [Math]::Max(0, $bounds.StartX - $this.ScrollOffsetX)
            $selEnd = [Math]::Min($visibleText.Length, $bounds.EndX - $this.ScrollOffsetX)
            
            if ($selStart -ge 0 -and $selStart -lt $visibleText.Length) {
                # Before selection
                if ($selStart -gt 0) {
                    $sb.Append($textColor)
                    $sb.Append($visibleText.Substring(0, $selStart))
                }
                
                # Selection
                if ($selEnd -gt $selStart) {
                    $sb.Append($selectionBgColor)
                    $sb.Append($selectionTextColor)
                    $sb.Append($visibleText.Substring($selStart, $selEnd - $selStart))
                    $sb.Append($textColor)  # Reset to normal colors
                }
                
                # After selection
                if ($selEnd -lt $visibleText.Length) {
                    $sb.Append($visibleText.Substring($selEnd))
                }
            } else {
                # Selection not visible on this part of the line
                $sb.Append($textColor)
                $sb.Append($visibleText)
            }
        } elseif ($lineNumber -eq $bounds.StartY) {
            # First line of multi-line selection
            $selStart = [Math]::Max(0, $bounds.StartX - $this.ScrollOffsetX)
            
            if ($selStart -ge 0 -and $selStart -lt $visibleText.Length) {
                # Before selection
                if ($selStart -gt 0) {
                    $sb.Append($textColor)
                    $sb.Append($visibleText.Substring(0, $selStart))
                }
                
                # Selection from start to end of visible text
                $sb.Append($selectionBgColor)
                $sb.Append($selectionTextColor)
                $sb.Append($visibleText.Substring($selStart))
            } else {
                # Selection starts beyond visible area - whole line is selected
                $sb.Append($selectionBgColor)
                $sb.Append($selectionTextColor)
                $sb.Append($visibleText)
            }
        } elseif ($lineNumber -eq $bounds.EndY) {
            # Last line of multi-line selection
            $selEnd = [Math]::Min($visibleText.Length, $bounds.EndX - $this.ScrollOffsetX)
            
            if ($selEnd -gt 0) {
                # Selection from start to EndX
                $sb.Append($selectionBgColor)
                $sb.Append($selectionTextColor)
                $sb.Append($visibleText.Substring(0, $selEnd))
                $sb.Append($textColor)  # Reset colors
                
                # After selection
                if ($selEnd -lt $visibleText.Length) {
                    $sb.Append($visibleText.Substring($selEnd))
                }
            } else {
                # Selection ends before visible area - no selection on visible part
                $sb.Append($textColor)
                $sb.Append($visibleText)
            }
        } else {
            # Middle line of multi-line selection - entire line is selected
            $sb.Append($selectionBgColor)
            $sb.Append($selectionTextColor)
            $sb.Append($visibleText)
        }
    }
    
    hidden [void] RenderCursor([System.Text.StringBuilder]$sb, [int]$lineNumWidth, [int]$editorHeight) {
        # Check if cursor is within visible viewport
        if ($this.CursorY -lt $this.ScrollOffsetY -or $this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            return  # Cursor not visible
        }
        
        # Calculate cursor screen position
        $cursorScreenY = $this.Y + ($this.CursorY - $this.ScrollOffsetY)
        $cursorScreenX = $this.X + $lineNumWidth + ($this.CursorX - $this.ScrollOffsetX)
        
        # Ensure cursor X is within visible area
        $editorWidth = $this.Width - $lineNumWidth
        if ($this.CursorX -lt $this.ScrollOffsetX -or $this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            return  # Cursor not horizontally visible
        }
        
        # Get colors
        $cursorBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("cursor") } else { "\e[0;7m" }
        $cursorTextColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("cursor.text") } else { "" }
        
        # Get character under cursor
        $charUnderCursor = " "
        if ($this.CursorY -lt $this._buffer.GetLineCount()) {
            $currentLine = $this._buffer.GetLine($this.CursorY)
            if ($this.CursorX -lt $currentLine.Length) {
                $charUnderCursor = $currentLine[$this.CursorX]
            }
        }
        
        # Render cursor
        $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
        $sb.Append($cursorBgColor)
        $sb.Append($cursorTextColor)
        $sb.Append($charUnderCursor)
        
        # Reset colors
        $resetColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("normal") } else { "\e[0m" }
        $sb.Append($resetColor)
    }
    
    hidden [string] GetStatusText() {
        $line = $this.CursorY + 1
        $col = $this.CursorX + 1
        $total = $this._buffer.GetLineCount()
        $modified = if ($this._buffer.IsModified) { " [Modified]" } else { "" }
        $undoStatus = ""
        if ($this._buffer.CanUndo()) {
            $undoStatus += " [Undo]"
        }
        if ($this._buffer.CanRedo()) {
            $undoStatus += " [Redo]"
        }
        
        # Add buffer type indicator
        $bufferType = if ($this._buffer.GetType().Name -eq "GapBufferDocumentBuffer") { " [GapBuffer]" } else { " [ArrayList]" }
        
        # Add selection indicator
        $selectionStatus = if ($this.HasSelection) { " [Selection]" } else { "" }
        
        $status = "Line $line/$total, Col $col$modified$undoStatus$bufferType$selectionStatus"
        if ($this.StatusMessage) {
            $status += " | $($this.StatusMessage)"
        }
        
        return $status
    }
}


####\_Backup/20250726_003635/Screens/TextInputDialog.ps1
# TextInputDialog.ps1 - Simple dialog for text input

class TextInputDialog : Screen {
    [string]$Prompt
    [string]$DefaultValue
    [string]$Placeholder
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    TextInputDialog([string]$prompt) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = ""
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    TextInputDialog([string]$prompt, [string]$defaultValue) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue
        $this.InputBox.Placeholder = $this.Placeholder
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            if ($dialog.OnSubmit) {
                & $dialog.OnSubmit $dialog.InputBox.Text
            }
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box and select all text
        $this.InputBox.Focus()
        # TODO: Add SelectAll method to TextBox
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 10 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\_Backup/20250726_003635/Screens/TimeEntryDialog.ps1
# TimeEntryDialog - Dialog for adding/editing time entries
# Based on tracker.txt time tracking structure

class TimeEntryDialog : BaseDialog {
    [Project]$Project = $null
    [PSCustomObject]$TimeEntry = $null  # For editing existing entries
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$DateTextBox
    [TextBox]$HoursTextBox
    [TextBox]$DescriptionTextBox
    
    # Buttons
    [Button]$SaveButton
    [Button]$CancelButton
    
    # Callbacks
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    TimeEntryDialog() : base("Add Time Entry") {
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project) : base("Add Time Entry") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project, [PSCustomObject]$timeEntry) : base("Edit Time Entry") {
        $this.Project = $project
        $this.TimeEntry = $timeEntry
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.DateTextBox = [TextBox]::new()
        $this.DateTextBox.Title = "Date (MM/DD/YYYY)"
        $this.DateTextBox.ShowBorder = $true
        
        # Set default date to today
        if (-not $this.IsEditMode) {
            $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
        } else {
            # Convert from YYYYMMDD format to MM/dd/yyyy
            try {
                $entryDate = [DateTime]::ParseExact($this.TimeEntry.Date, "yyyyMMdd", $null)
                $this.DateTextBox.Text = $entryDate.ToString("MM/dd/yyyy")
            } catch {
                $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
            }
        }
        
        $this.HoursTextBox = [TextBox]::new()
        $this.HoursTextBox.Title = "Hours (e.g., 8.5)"
        $this.HoursTextBox.ShowBorder = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Total) {
            $this.HoursTextBox.Text = $this.TimeEntry.Total
        }
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Description) {
            $this.DescriptionTextBox.Text = $this.TimeEntry.Description
        }
        
        # Initialize components
        if ($this.ServiceContainer) {
            $this.DateTextBox.Initialize($this.ServiceContainer)
            $this.HoursTextBox.Initialize($this.ServiceContainer)
            $this.DescriptionTextBox.Initialize($this.ServiceContainer)
        }
        
        # Create buttons
        $saveText = if ($this.IsEditMode) { "Update Entry" } else { "Add Entry" }
        $this.SaveButton = [Button]::new($saveText)
        $this.SaveButton.IsDefault = $true
        $this.SaveButton.OnClick = { $this.HandleSave() }
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = { $this.HandleCancel() }
        
        if ($this.ServiceContainer) {
            $this.SaveButton.Initialize($this.ServiceContainer)
            $this.CancelButton.Initialize($this.ServiceContainer)
        }
        
        # Add children
        $this.AddChild($this.DateTextBox)
        $this.AddChild($this.HoursTextBox)
        $this.AddChild($this.DescriptionTextBox)
        $this.AddChild($this.SaveButton)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.DateTextBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Stack inputs vertically with buttons at bottom
        $margin = 2
        $buttonHeight = 3
        $inputHeight = 3
        $descriptionHeight = 5
        
        $currentY = $this.Y + $margin
        $inputWidth = $this.Width - ($margin * 2)
        
        # Date input
        $this.DateTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Hours input
        $this.HoursTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $descriptionHeight
        )
        $currentY += $descriptionHeight + 2
        
        # Buttons at bottom
        $buttonWidth = 15
        $buttonSpacing = 4
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - 1
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create time entry data
        $timeEntryData = $this.CreateTimeEntryData()
        
        if ($this.OnSave) {
            & $this.OnSave $timeEntryData
        }
    }
    
    [void] HandleCancel() {
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }
    
    [string] ValidateInputs() {
        # Validate date
        $dateStr = $this.DateTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Date is required"
        }
        
        try {
            [DateTime]::Parse($dateStr) | Out-Null
        } catch {
            return "Invalid date format. Use MM/DD/YYYY"
        }
        
        # Validate hours
        $hoursStr = $this.HoursTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($hoursStr)) {
            return "Hours is required"
        }
        
        $hours = 0.0
        if (-not [double]::TryParse($hoursStr, [ref]$hours) -or $hours -le 0) {
            return "Hours must be a positive number"
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateTimeEntryData() {
        # Parse and format date to YYYYMMDD
        $entryDate = [DateTime]::Parse($this.DateTextBox.Text.Trim())
        $internalDate = $entryDate.ToString("yyyyMMdd")
        
        # Parse hours
        $hours = [double]::Parse($this.HoursTextBox.Text.Trim())
        
        # Get day of week for hour distribution
        $dayOfWeek = $entryDate.DayOfWeek
        
        # Create time entry following tracker.txt structure
        $newTimeEntry = [PSCustomObject]@{
            Date = $internalDate
            Nickname = $this.Project.Nickname
            ID1 = if ($this.Project.ID1) { $this.Project.ID1 } else { "" }
            ID2 = $this.FormatID2($this.Project.ID2)
            MonHours = if ($dayOfWeek -eq "Monday") { $hours.ToString("F2") } else { "" }
            TueHours = if ($dayOfWeek -eq "Tuesday") { $hours.ToString("F2") } else { "" }
            WedHours = if ($dayOfWeek -eq "Wednesday") { $hours.ToString("F2") } else { "" }
            ThuHours = if ($dayOfWeek -eq "Thursday") { $hours.ToString("F2") } else { "" }
            FriHours = if ($dayOfWeek -eq "Friday") { $hours.ToString("F2") } else { "" }
            Total = $hours.ToString("F2")
            Description = $this.DescriptionTextBox.Text.Trim()
        }
        
        return $newTimeEntry
    }
    
    [string] FormatID2([string]$id2) {
        # Format ID2 with V0 prefix, S suffix, padded to 12 characters
        # Following tracker.txt format
        if ([string]::IsNullOrWhiteSpace($id2)) {
            return ""
        }
        
        $id2Text = $id2.Trim()
        $paddingNeeded = 12 - ($id2Text.Length + 2)
        
        if ($paddingNeeded > 0) {
            return "V" + ("0" * $paddingNeeded) + $id2Text + "S"
        } else {
            return "V" + $id2Text + "S"
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Enter) {
                if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.HandleSave()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleCancel()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                # Handle tab navigation between fields
                $focused = $this.FindFocused()
                if ($focused -eq $this.DateTextBox) {
                    $this.HoursTextBox.Focus()
                } elseif ($focused -eq $this.HoursTextBox) {
                    $this.DescriptionTextBox.Focus()
                } elseif ($focused -eq $this.DescriptionTextBox) {
                    $this.SaveButton.Focus()
                } else {
                    $this.DateTextBox.Focus()
                }
                return $true
            }
        }
        
        # Let base class handle other input
        return $false
    }
}


####\_Backup/20250726_003635/Screens/TimeEntryScreen.ps1
# TimeEntryScreen.ps1 - Time entry screen based on working ProjectsScreen

class TimeEntryScreen : Screen {
    [DataGrid]$TimeGrid
    [Button]$PrevWeekButton
    [Button]$NextWeekButton  
    [Button]$CurrentWeekButton
    [Button]$QuickEntryButton
    [DateTime]$CurrentWeekFriday
    [TimeTrackingService]$TimeService
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    TimeEntryScreen() : base() {
        $this.Title = "Time Entry"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
        $this.ProjectService = $this.ServiceContainer.GetService("ProjectService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Set current week
        $this.CurrentWeekFriday = $this.TimeService.GetCurrentWeekFriday()
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to time entry updates
            $this.EventSubscriptions['TimeEntryUpdated'] = $this.EventBus.Subscribe('timeentry.updated', {
                param($sender, $eventData)
                $screen.RefreshGrid()
            }.GetNewClosure())
        }
        
        # Create DataGrid with columns
        $this.TimeGrid = [DataGrid]::new()
        $this.TimeGrid.Title = $this.GetWeekTitle()
        $this.TimeGrid.ShowBorder = $true
        $this.TimeGrid.ShowGridLines = $true
        
        # Initialize the TimeGrid with ServiceContainer to get theme
        $this.TimeGrid.Initialize($this.ServiceContainer)
        
        # Define columns for time entry grid
        $columns = @(
            @{ Name = "Name"; Header = "Name"; Width = 30; Getter = { param($item) $item.Name } }
            @{ Name = "ID1"; Header = "ID1"; Width = 10; Getter = { param($item) $item.ID1 } }
            @{ Name = "ID2"; Header = "ID2"; Width = 15; Getter = { param($item) $item.ID2 } }
            @{ Name = "Monday"; Header = "Mon"; Width = 6; Getter = { param($item) if ($item.Monday -gt 0) { $item.Monday.ToString("F1") } else { "" } } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 6; Getter = { param($item) if ($item.Tuesday -gt 0) { $item.Tuesday.ToString("F1") } else { "" } } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 6; Getter = { param($item) if ($item.Wednesday -gt 0) { $item.Wednesday.ToString("F1") } else { "" } } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 6; Getter = { param($item) if ($item.Thursday -gt 0) { $item.Thursday.ToString("F1") } else { "" } } }
            @{ Name = "Friday"; Header = "Fri"; Width = 6; Getter = { param($item) if ($item.Friday -gt 0) { $item.Friday.ToString("F1") } else { "" } } }
            @{ Name = "Total"; Header = "Total"; Width = 7; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.TimeGrid.SetColumns($columns)
        $this.AddChild($this.TimeGrid)
        
        # Create navigation buttons
        $screen = $this  # Capture reference for closures
        
        $this.PrevWeekButton = [Button]::new("< Prev Week")
        $this.PrevWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.PrevWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.PrevWeekButton)
        
        $this.CurrentWeekButton = [Button]::new("Current Week")
        $this.CurrentWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.TimeService.GetCurrentWeekFriday()
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.CurrentWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.CurrentWeekButton)
        
        $this.NextWeekButton = [Button]::new("Next Week >")
        $this.NextWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.NextWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.NextWeekButton)
        
        $this.QuickEntryButton = [Button]::new("Quick Entry (Q)")
        $this.QuickEntryButton.IsDefault = $true
        $this.QuickEntryButton.OnClick = { $screen.ShowQuickEntry() }.GetNewClosure()
        $this.QuickEntryButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.QuickEntryButton)
        
        # Load initial data
        $this.RefreshGrid()
        
        # Focus the grid
        if ($this.TimeGrid.Items.Count -gt 0) {
            $this.TimeGrid.Focus()
        }
        
        # Register shortcuts
        $this.RegisterShortcuts()
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.TimeGrid) { return }
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Calculate layout
        $gridHeight = $this.Height - $this.ButtonHeight - 1
        
        # Position grid - use relative positioning within the screen bounds
        $this.TimeGrid.SetBounds(0, 0, $this.Width, $gridHeight)
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        $buttonWidth = 16
        $totalButtonWidth = ($buttonWidth * 4) + ($this.ButtonSpacing * 3)
        
        # Center buttons
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        $this.PrevWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.CurrentWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.NextWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.QuickEntryButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Refresh data when activated
        $this.RefreshGrid()
        if ($this.TimeGrid) {
            $this.TimeGrid.Focus()
        }
    }
    
    [string] GetWeekTitle() {
        $monday = $this.CurrentWeekFriday.AddDays(-4)
        return "Time Entry - Week of $($monday.ToString('MM/dd/yyyy')) to $($this.CurrentWeekFriday.ToString('MM/dd/yyyy'))"
    }
    
    [void] RefreshGrid() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Starting refresh for week $($this.CurrentWeekFriday.ToString('yyyyMMdd'))")
        }
        
        # Update title
        $this.TimeGrid.Title = $this.GetWeekTitle()
        
        # Get entries for current week
        $weekString = $this.CurrentWeekFriday.ToString("yyyyMMdd")
        $entries = $this.TimeService.GetWeekEntries($weekString)
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Got $($entries.Count) entries")
            if ($entries.Count -gt 0) {
                $global:Logger.Debug("TimeEntryScreen.RefreshGrid: First entry: Name=$($entries[0].Name) ID2=$($entries[0].ID2)")
            }
        }
        
        # Sort by: Projects first (by name), then non-projects (by ID2)
        $sorted = $entries | Sort-Object @(
            @{Expression = {if ($_.ID1 -eq "Internal") {1} else {0}}},
            @{Expression = {$_.Name}},
            @{Expression = {$_.ID2}}
        )
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: TimeGrid exists: $($this.TimeGrid -ne $null)")
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: TimeGrid bounds: ($($this.TimeGrid.X),$($this.TimeGrid.Y),$($this.TimeGrid.Width),$($this.TimeGrid.Height))")
        }
        
        # Clear and repopulate grid using proper DataGrid method
        $this.TimeGrid.SetItems($sorted)
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: After SetItems, TimeGrid.Items.Count = $($this.TimeGrid.Items.Count)")
        }
        
        $this.TimeGrid.Invalidate()
        $this.Invalidate()
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Refresh complete, invalidated grid and screen")
        }
    }
    
    [void] ShowQuickEntry() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Starting quick entry")
        }
        
        try {
            # Create quick entry dialog
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: CurrentWeekFriday = $($this.CurrentWeekFriday)")
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: QuickTimeEntryDialog type exists: $([QuickTimeEntryDialog] -as [type] -ne $null)")
            }
            
            # Try explicit casting
            $weekFriday = [DateTime]$this.CurrentWeekFriday
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: weekFriday type = $($weekFriday.GetType().Name), value = $weekFriday")
            }
            
            # Try workaround - create via Invoke-Expression or reflection
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Attempting workaround creation")
            }
            
            # Workaround attempt
            $dialog = New-Object QuickTimeEntryDialog -ArgumentList $weekFriday
            
            # Initialize dialog with ServiceContainer for theme
            $dialog.Initialize($this.ServiceContainer)
            
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Dialog created successfully")
            }
            
            $screen = $this
            $dialog.OnSave = {
                param($timeEntry)
                # Save the entry
                $screen.TimeService.UpdateTimeEntry($timeEntry)
                $screen.RefreshGrid()
            }.GetNewClosure()
            
            # Show dialog
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
                if ($global:Logger) {
                    $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Dialog pushed to ScreenManager")
                }
            }
        }
        catch {
            if ($global:Logger) {
                $global:Logger.Error("TimeEntryScreen.ShowQuickEntry: Error creating dialog: $_")
            }
        }
    }
    
    [void] EditSelectedEntry() {
        $selected = $this.TimeGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit dialog - TimeEntryDialog expects a Project parameter, not DateTime and ID2
        # For now, use the parameterless constructor
        $dialog = [TimeEntryDialog]::new()
        $dialog.OnSave = {
            $this.RefreshGrid()
        }.GetNewClosure()
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnRender: Starting render, Children.Count = $($this.Children.Count)")
            $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid exists = $($this.TimeGrid -ne $null)")
            if ($this.TimeGrid) {
                $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid.Items.Count = $($this.TimeGrid.Items.Count)")
                $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid bounds = ($($this.TimeGrid.X),$($this.TimeGrid.Y),$($this.TimeGrid.Width),$($this.TimeGrid.Height))")
            }
        }
        
        $result = ([Screen]$this).OnRender()
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnRender: Rendered content length = $($result.Length)")
        }
        return $result
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if ($shortcutManager) {
            $screen = $this
            
            # Q - Quick entry
            $quickAction = { $screen.ShowQuickEntry() }.GetNewClosure()
            
            $shortcutManager.RegisterShortcut(@{
                Id = "time.quick"
                Name = "Quick Entry"
                Description = "Quick time entry"
                KeyChar = 'q'
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = $quickAction
            })
            
            # E - Edit entry
            $shortcutManager.RegisterShortcut(@{
                Id = "time.edit"
                Name = "Edit Entry"
                Description = "Edit time entry"
                KeyChar = 'e'
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = { $screen.EditSelectedEntry() }.GetNewClosure()
            })
            
            # Left/Right arrows for week navigation
            $shortcutManager.RegisterShortcut(@{
                Id = "time.prevweek"
                Name = "Previous Week"
                Description = "Navigate to previous week"
                Key = [System.ConsoleKey]::LeftArrow
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = {
                    $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
                    $screen.RefreshGrid()
                }.GetNewClosure()
            })
            
            $shortcutManager.RegisterShortcut(@{
                Id = "time.nextweek"
                Name = "Next Week"
                Description = "Navigate to next week"
                Key = [System.ConsoleKey]::RightArrow
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = {
                    $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
                    $screen.RefreshGrid()
                }.GetNewClosure()
            })
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Let base handle first (for child components)
        if (([Screen]$this).HandleInput($key)) {
            return $true
        }
        
        # Handle screen-specific keys
        switch ($key.Key) {
            ([ConsoleKey]::Q) {
                if ($global:Logger) {
                    $global:Logger.Debug("TimeEntryScreen.HandleInput: Q key detected, calling ShowQuickEntry()")
                }
                $this.ShowQuickEntry()
                return $true
            }
            ([ConsoleKey]::E) {
                $this.EditSelectedEntry()
                return $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($key.Modifiers -eq [ConsoleModifiers]::None) {
                    $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(-7)
                    $this.RefreshGrid()
                    return $true
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($key.Modifiers -eq [ConsoleModifiers]::None) {
                    $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(7)
                    $this.RefreshGrid()
                    return $true
                }
            }
            ([ConsoleKey]::Enter) {
                $this.EditSelectedEntry()
                return $true
            }
        }
        
        return $false
    }
}


####\_Backup/20250726_003635/Screens/VisualMacroFactoryScreen.ps1
# VisualMacroFactoryScreen.ps1 - Visual macro builder for IDEA scripts
# Three-pane interface: Component Library | Macro Sequence | Context Panel

class VisualMacroFactoryScreen : Screen {
    # UI Components - Three panes
    [SearchableListBox]$ComponentLibrary      # Left pane
    [DataGrid]$MacroSequence                  # Center pane
    [DataGrid]$ContextPanel                   # Right pane
    
    # Services
    [MacroContextManager]$ContextManager
    [FunctionRegistry]$FunctionRegistry
    [CommandService]$CommandService
    [EventBus]$EventBus
    [ShortcutManager]$ShortcutManager
    
    # Available actions
    [System.Collections.ArrayList]$AvailableActions
    [int]$SelectedSequenceIndex = -1
    
    VisualMacroFactoryScreen() : base() {
        $this.Title = "Visual Macro Factory"
        $this.DrawBackground = $true
        $this.AvailableActions = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        $this.ShortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        
        # Initialize macro services
        $this.ContextManager = [MacroContextManager]::new()
        $this.FunctionRegistry = [FunctionRegistry]::new()
        $this.FunctionRegistry.SetCommandService($this.CommandService)
        $this.ContextManager.SetFunctionRegistry($this.FunctionRegistry)
        
        # Create UI components
        $this.CreateComponentLibrary()
        $this.CreateMacroSequence()
        $this.CreateContextPanel()
        
        # Register shortcuts
        $this.RegisterShortcuts()
    }
    
    [void] LoadAvailableActions() {
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.LoadAvailableActions: Starting to load actions")
        }
        
        # Load built-in actions
        $this.AvailableActions.Add([SummarizationAction]::new()) | Out-Null
        $this.AvailableActions.Add([AppendFieldAction]::new()) | Out-Null
        $this.AvailableActions.Add([ExportToExcelAction]::new()) | Out-Null
        
        # Add custom IDEA@ command action
        $this.AvailableActions.Add([CustomIdeaCommandAction]::new()) | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.LoadAvailableActions: Loaded $($this.AvailableActions.Count) actions")
        }
        
        # Populate the component library with the loaded actions
        $this.ComponentLibrary.SetItems($this.AvailableActions)
        
        # TODO: Load additional actions from Actions/ directory
    }
    
    [void] CreateComponentLibrary() {
        $this.ComponentLibrary = [SearchableListBox]::new()
        $this.ComponentLibrary.Title = " Component Library"
        $this.ComponentLibrary.ShowBorder = $true
        $this.ComponentLibrary.SearchPrompt = "Search actions... (category:core type:export)"
        
        # Custom renderer for actions
        $this.ComponentLibrary.ItemRenderer = {
            param($action)
            if (-not $action) { return "" }
            return $action.GetDisplayText()
        }
        
        # Handle double-click to add action
        $this.ComponentLibrary.OnItemActivated = {
            param($action)
            $this.AddActionToSequence($action)
        }.GetNewClosure()
        
        $this.ComponentLibrary.Initialize($this.ServiceContainer)
        $this.AddChild($this.ComponentLibrary)
        
        # Load available actions
        $this.LoadAvailableActions()
    }
    
    [void] CreateMacroSequence() {
        $this.MacroSequence = [DataGrid]::new()
        $this.MacroSequence.Title = " Macro Sequence"
        $this.MacroSequence.ShowBorder = $true
        
        # Define columns for macro sequence
        $columns = @(
            @{ Name = "Step"; Width = 6; Alignment = "Center" },
            @{ Name = "Action"; Width = 20; Alignment = "Left" },
            @{ Name = "Description"; Width = 30; Alignment = "Left" },
            @{ Name = "Status"; Width = 10; Alignment = "Center" }
        )
        $this.MacroSequence.SetColumns($columns)
        
        # Handle selection changes
        $this.MacroSequence.OnSelectionChanged = {
            $this.SelectedSequenceIndex = $this.MacroSequence.SelectedIndex
            $this.UpdateContextPanel()
        }.GetNewClosure()
        
        $this.MacroSequence.Initialize($this.ServiceContainer)
        $this.AddChild($this.MacroSequence)
    }
    
    [void] CreateContextPanel() {
        $this.ContextPanel = [DataGrid]::new()
        $this.ContextPanel.Title = " Macro Context"
        $this.ContextPanel.ShowBorder = $true
        
        # Define columns for context variables
        $columns = @(
            @{ Name = "Variable"; Width = 15; Alignment = "Left" },
            @{ Name = "Type"; Width = 10; Alignment = "Left" },
            @{ Name = "Value"; Width = 25; Alignment = "Left" },
            @{ Name = "Source"; Width = 15; Alignment = "Left" }
        )
        $this.ContextPanel.SetColumns($columns)
        
        $this.ContextPanel.Initialize($this.ServiceContainer)
        $this.AddChild($this.ContextPanel)
        
        # Initial context update
        $this.UpdateContextPanel()
        
        # Set initial focus to component library
        if ($this.ComponentLibrary) {
            $this.ComponentLibrary.Focus()
        }
    }
    
    [void] RegisterShortcuts() {
        if (-not $this.ShortcutManager) { return }
        
        # Delete: Remove selected action from sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_delete"
            Name = "Delete Action"
            Description = "Remove selected action from macro sequence"
            Key = [System.ConsoleKey]::Delete
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and $this.SelectedSequenceIndex -ge 0) {
                    $this.RemoveActionFromSequence($this.SelectedSequenceIndex)
                }
            }.GetNewClosure()
        })
        
        # Ctrl+Up: Move action up in sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_move_up"
            Name = "Move Action Up"
            Description = "Move selected action up in sequence"
            Key = [System.ConsoleKey]::UpArrow
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and $this.SelectedSequenceIndex -gt 0) {
                    $this.ContextManager.MoveAction($this.SelectedSequenceIndex, $this.SelectedSequenceIndex - 1)
                    $this.SelectedSequenceIndex--
                    $this.UpdateMacroSequence()
                    $this.UpdateContextPanel()
                }
            }.GetNewClosure()
        })
        
        # Ctrl+Down: Move action down in sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_move_down"
            Name = "Move Action Down"
            Description = "Move selected action down in sequence"
            Key = [System.ConsoleKey]::DownArrow
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and 
                    $this.SelectedSequenceIndex -ge 0 -and 
                    $this.SelectedSequenceIndex -lt $this.ContextManager.Actions.Count - 1) {
                    $this.ContextManager.MoveAction($this.SelectedSequenceIndex, $this.SelectedSequenceIndex + 1)
                    $this.SelectedSequenceIndex++
                    $this.UpdateMacroSequence()
                    $this.UpdateContextPanel()
                }
            }.GetNewClosure()
        })
        
        # F5: Generate and preview script
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_preview"
            Name = "Preview Script"
            Description = "Generate and preview the IDEAScript"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.PreviewGeneratedScript()
            }.GetNewClosure()
        })
        
        # Ctrl+S: Save macro
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_save"
            Name = "Save Macro"
            Description = "Save the current macro"
            Key = [System.ConsoleKey]::S
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.SaveMacro()
            }.GetNewClosure()
        })
        
        # Ctrl+O: Open macro
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_open"
            Name = "Open Macro"
            Description = "Open an existing macro"
            Key = [System.ConsoleKey]::O
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.OpenMacro()
            }.GetNewClosure()
        })
        
        # Ctrl+N: New macro (clear)
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_new"
            Name = "New Macro"
            Description = "Start a new macro (clear current)"
            Key = [System.ConsoleKey]::N
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.NewMacro()
            }.GetNewClosure()
        })
    }
    
    [void] AddActionToSequence([BaseAction]$action) {
        # Clone the action to avoid modifying the template
        $newAction = $action.GetType()::new()
        
        $this.ContextManager.AddAction($newAction)
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
        
        # Focus the macro sequence and select the new item
        $this.MacroSequence.Focus()
        $this.MacroSequence.SelectedIndex = $this.ContextManager.Actions.Count - 1
        $this.SelectedSequenceIndex = $this.MacroSequence.SelectedIndex
    }
    
    [void] RemoveActionFromSequence([int]$index) {
        $this.ContextManager.RemoveAction($index)
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
        
        # Adjust selection
        if ($this.SelectedSequenceIndex -ge $this.ContextManager.Actions.Count) {
            $this.SelectedSequenceIndex = $this.ContextManager.Actions.Count - 1
        }
        $this.MacroSequence.SelectedIndex = $this.SelectedSequenceIndex
    }
    
    [void] UpdateMacroSequence() {
        $rows = @()
        
        for ($i = 0; $i -lt $this.ContextManager.Actions.Count; $i++) {
            $action = $this.ContextManager.Actions[$i]
            $context = $this.ContextManager.GetContextAtStep($i)
            
            # Check if action requirements are met
            $isValid = $action.ValidateContext($context)
            $status = if ($isValid) { " Ready" } else { " Issues" }
            
            $rows += @{
                Step = ($i + 1).ToString()
                Action = $action.Name
                Description = $action.Description
                Status = $status
            }
        }
        
        $this.MacroSequence.SetItems($rows)
    }
    
    [void] UpdateContextPanel() {
        $rows = @()
        
        # Get context for the selected step (or full context if none selected)
        $context = if ($this.SelectedSequenceIndex -ge 0) {
            $this.ContextManager.GetContextAtStep($this.SelectedSequenceIndex)
        } else {
            $this.ContextManager.GetFullContext()
        }
        
        foreach ($varName in $context.Keys) {
            $varInfo = $context[$varName]
            $source = if ($varInfo.ContainsKey('ProducedBy')) { $varInfo.ProducedBy } else { "System" }
            
            $rows += @{
                Variable = $varName
                Type = $varInfo.Type
                Value = if ($varInfo.ContainsKey('Value')) { $varInfo.Value } else { "<undefined>" }
                Source = $source
            }
        }
        
        $this.ContextPanel.SetItems($rows)
        
        # Update title to show context step
        if ($this.SelectedSequenceIndex -ge 0) {
            $this.ContextPanel.Title = " Context at Step $($this.SelectedSequenceIndex + 1)"
        } else {
            $this.ContextPanel.Title = " Full Macro Context"
        }
    }
    
    [void] PreviewGeneratedScript() {
        try {
            $script = $this.ContextManager.GenerateScript()
            
            # TODO: Show script in a dialog or new screen
            # For now, just log the script
            if ($global:Logger) {
                $global:Logger.Info("Generated Script: $script")
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Script Generation Error: $($_.Exception.Message)")
            }
        }
    }
    
    [void] SaveMacro() {
        # TODO: Implement macro saving to file
        if ($global:Logger) {
            $global:Logger.Info("Save Macro: Not yet implemented")
        }
    }
    
    [void] OpenMacro() {
        # TODO: Implement macro loading from file
        if ($global:Logger) {
            $global:Logger.Info("Open Macro: Not yet implemented")
        }
    }
    
    [void] NewMacro() {
        $this.ContextManager.Clear()
        $this.SelectedSequenceIndex = -1
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
    }
    
    [void] OnBoundsChanged() {
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: Width=$($this.Width) Height=$($this.Height)")
        }
        
        if ($this.Width -le 0 -or $this.Height -le 0) { 
            if ($global:Logger) {
                $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: Skipping due to zero bounds")
            }
            return 
        }
        
        # Three-pane layout: 30% | 40% | 30%
        $leftWidth = [int]($this.Width * 0.3)
        $centerWidth = [int]($this.Width * 0.4)
        $rightWidth = $this.Width - $leftWidth - $centerWidth
        
        $contentHeight = $this.Height - 2  # Account for title
        
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: leftWidth=$leftWidth centerWidth=$centerWidth rightWidth=$rightWidth contentHeight=$contentHeight")
        }
        
        # Position Component Library (left pane)
        if ($this.ComponentLibrary) {
            $this.ComponentLibrary.SetBounds(0, 1, $leftWidth, $contentHeight)
        }
        
        # Position Macro Sequence (center pane)
        if ($this.MacroSequence) {
            $this.MacroSequence.SetBounds($leftWidth, 1, $centerWidth, $contentHeight)
        }
        
        # Position Context Panel (right pane)
        if ($this.ContextPanel) {
            $this.ContextPanel.SetBounds($leftWidth + $centerWidth, 1, $rightWidth, $contentHeight)
        }
    }
}


####\_Backup/20250726_003635/Services/CommandService.ps1
# CommandService.ps1 - Service for managing command library
# Handles JSON storage, CRUD operations, and clipboard functionality

class CommandService {
    [string]$DataPath
    [System.Collections.ArrayList]$Commands
    [Logger]$Logger
    
    CommandService() {
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/commands.json"
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.Logger = $global:Logger
        $this.LoadCommands()
    }
    
    # Load commands from JSON file
    [void] LoadCommands() {
        try {
            if (Test-Path $this.DataPath) {
                $jsonContent = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                $this.Commands.Clear()
                
                foreach ($commandData in $jsonContent) {
                    # Convert PSCustomObject to hashtable
                    $hashtable = @{}
                    $commandData.PSObject.Properties | ForEach-Object {
                        $hashtable[$_.Name] = $_.Value
                    }
                    $command = [Command]::FromHashtable($hashtable)
                    $this.Commands.Add($command) | Out-Null
                }
                
                if ($this.Logger) {
                    $this.Logger.Info("Loaded $($this.Commands.Count) commands from $($this.DataPath)")
                }
            } else {
                if ($this.Logger) {
                    $this.Logger.Info("No existing commands file found, starting with empty library")
                }
                # Add some default IDEA commands
                $this.CreateDefaultCommands()
            }
        } catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to load commands: $($_.Exception.Message)")
            }
        }
    }
    
    # Create default IDEA commands for new installations
    [void] CreateDefaultCommands() {
        # Add some common IDEA@ functions and commands
        $defaultCommands = @(
            @{
                Title = "@CurrentDate_YYYYMMDD"
                Description = "Returns current date in YYYYMMDD format"
                Tags = @("function", "date", "idea")
                Group = "Built-in Functions"
                CommandText = "@CurrentDate_YYYYMMDD"
            },
            @{
                Title = "@PromptForField"
                Description = "Prompts user to select a field from the current database"
                Tags = @("function", "field", "input", "idea")
                Group = "Built-in Functions"
                CommandText = "@PromptForField(`"Select field:`")"
            },
            @{
                Title = "Open Database"
                Description = "Opens a database file in IDEA"
                Tags = @("database", "open", "idea")
                Group = "Database Operations"
                CommandText = "Set db = Client.OpenDatabase(`"database.IMD`")"
            },
            @{
                Title = "Summarize by Field"
                Description = "Creates a summarization by specified field"
                Tags = @("summarize", "group", "analysis", "idea")
                Group = "Analysis"
                CommandText = "Set task = db.Summarization`nTask.AddFieldToSummarize `"FIELD_NAME`"`nTask.OutputDBName = `"Summary_Output`"`ndbName = task.Run()"
            },
            @{
                Title = "Export to Excel"
                Description = "Exports current database to Excel format"
                Tags = @("export", "excel", "output", "idea")
                Group = "Export"
                CommandText = "Set task = db.ExportToExcel`nTask.OutputFile = `"output.xlsx`"`nTask.Run()"
            }
        )
        
        foreach ($cmdData in $defaultCommands) {
            $command = $this.AddCommand($cmdData.Title, $cmdData.Description, $cmdData.Tags, $cmdData.Group, $cmdData.CommandText)
        }
        
        if ($this.Logger) {
            $this.Logger.Info("Created $($defaultCommands.Count) default IDEA commands")
        }
    }
    
    # Save commands to JSON file
    [void] SaveCommands() {
        try {
            $commandsData = @()
            foreach ($command in $this.Commands) {
                $commandsData += $command.ToHashtable()
            }
            
            $json = $commandsData | ConvertTo-Json -Depth 10
            $json | Set-Content $this.DataPath -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Saved $($this.Commands.Count) commands to $($this.DataPath)")
            }
        } catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save commands: $($_.Exception.Message)")
            }
        }
    }
    
    # Get all commands
    [System.Collections.ArrayList] GetAllCommands() {
        return $this.Commands
    }
    
    # Get command by ID
    [Command] GetCommand([string]$id) {
        foreach ($command in $this.Commands) {
            if ($command.Id -eq $id) {
                return $command
            }
        }
        return $null
    }
    
    # Add new command
    [Command] AddCommand([string]$commandText) {
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            throw "Command text is required"
        }
        
        $command = [Command]::new($commandText)
        $this.Commands.Add($command) | Out-Null
        $this.SaveCommands()
        
        if ($this.Logger) {
            $this.Logger.Info("Added new command: $($command.Id)")
        }
        
        return $command
    }
    
    # Add command with full details
    [Command] AddCommand([string]$title, [string]$description, [string[]]$tags, [string]$group, [string]$commandText) {
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            throw "Command text is required"
        }
        
        $command = [Command]::new()
        $command.Title = $title ?? ""
        $command.Description = $description ?? ""
        $command.Tags = $tags ?? @()
        $command.Group = $group ?? ""
        $command.CommandText = $commandText
        
        $this.Commands.Add($command) | Out-Null
        $this.SaveCommands()
        
        if ($this.Logger) {
            $this.Logger.Info("Added new command: $($command.GetDisplayText())")
        }
        
        return $command
    }
    
    # Update existing command
    [bool] UpdateCommand([Command]$command) {
        if (-not $command.IsValid()) {
            throw "Command text is required"
        }
        
        $existingIndex = -1
        for ($i = 0; $i -lt $this.Commands.Count; $i++) {
            if ($this.Commands[$i].Id -eq $command.Id) {
                $existingIndex = $i
                break
            }
        }
        
        if ($existingIndex -ge 0) {
            $this.Commands[$existingIndex] = $command
            $this.SaveCommands()
            
            if ($this.Logger) {
                $this.Logger.Info("Updated command: $($command.GetDisplayText())")
            }
            return $true
        }
        
        return $false
    }
    
    # Delete command
    [bool] DeleteCommand([string]$id) {
        for ($i = 0; $i -lt $this.Commands.Count; $i++) {
            if ($this.Commands[$i].Id -eq $id) {
                $command = $this.Commands[$i]
                $this.Commands.RemoveAt($i)
                $this.SaveCommands()
                
                if ($this.Logger) {
                    $this.Logger.Info("Deleted command: $($command.GetDisplayText())")
                }
                return $true
            }
        }
        
        return $false
    }
    
    # Copy command to clipboard and record usage
    [void] CopyToClipboard([string]$id) {
        $command = $this.GetCommand($id)
        if ($command) {
            try {
                Set-Clipboard -Value $command.CommandText
                $command.RecordUsage()
                $this.SaveCommands()
                
                if ($this.Logger) {
                    $this.Logger.Info("Copied command to clipboard: $($command.GetDisplayText())")
                }
            } catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to copy to clipboard: $($_.Exception.Message)")
                }
                throw "Failed to copy to clipboard: $($_.Exception.Message)"
            }
        } else {
            throw "Command not found: $id"
        }
    }
    
    # Search commands with enhanced syntax
    [System.Collections.ArrayList] SearchCommands([string]$query) {
        $results = [System.Collections.ArrayList]::new()
        
        if ([string]::IsNullOrWhiteSpace($query)) {
            # Return all commands if no query
            foreach ($command in $this.Commands) {
                $results.Add($command) | Out-Null
            }
            return $results
        }
        
        # Parse search query
        $searchCriteria = $this.ParseSearchQuery($query)
        
        foreach ($command in $this.Commands) {
            if ($this.MatchesSearchCriteria($command, $searchCriteria)) {
                $results.Add($command) | Out-Null
            }
        }
        
        return $results
    }
    
    # Parse search query into criteria
    hidden [hashtable] ParseSearchQuery([string]$query) {
        $criteria = @{
            DefaultSearch = @()
            TitleSearch = @()
            DescriptionSearch = @()
            TagSearch = @()
            GroupSearch = @()
            AndMode = $false
        }
        
        # Check for AND mode (+)
        if ($query -match '\+') {
            $criteria.AndMode = $true
        }
        
        # Split by spaces and process each term
        $terms = $query -split '\s+' | Where-Object { $_ -ne '' }
        
        foreach ($term in $terms) {
            if ($term -match '^(\+?)([tdg]):(.+)$') {
                $isAnd = $matches[1] -eq '+'
                $type = $matches[2]
                $searchTerm = $matches[3]
                
                # Handle OR within the search term (|)
                $searchValues = $searchTerm -split '\|'
                
                switch ($type) {
                    't' { $criteria.TagSearch += $searchValues }
                    'd' { $criteria.DescriptionSearch += $searchValues }
                    'g' { $criteria.GroupSearch += $searchValues }
                }
            } else {
                # Default search (title and general)
                $cleanTerm = $term -replace '^\+', ''
                $criteria.DefaultSearch += $cleanTerm
            }
        }
        
        return $criteria
    }
    
    # Check if command matches search criteria
    hidden [bool] MatchesSearchCriteria([Command]$command, [hashtable]$criteria) {
        $matches = @()
        
        # Default search (title and general text)
        if ($criteria.DefaultSearch.Count -gt 0) {
            $titleMatch = $false
            $generalMatch = $false
            
            foreach ($term in $criteria.DefaultSearch) {
                if ($command.Title -and $command.Title -match [regex]::Escape($term)) {
                    $titleMatch = $true
                }
                if ($command.GetSearchableText() -match [regex]::Escape($term)) {
                    $generalMatch = $true
                }
            }
            
            $matches += ($titleMatch -or $generalMatch)
        }
        
        # Tag search
        if ($criteria.TagSearch.Count -gt 0) {
            $tagMatch = $false
            $tagText = ($command.Tags -join ' ')
            
            foreach ($term in $criteria.TagSearch) {
                if ($tagText -match [regex]::Escape($term)) {
                    $tagMatch = $true
                    break
                }
            }
            
            $matches += $tagMatch
        }
        
        # Description search
        if ($criteria.DescriptionSearch.Count -gt 0) {
            $descMatch = $false
            
            foreach ($term in $criteria.DescriptionSearch) {
                if ($command.Description -and $command.Description -match [regex]::Escape($term)) {
                    $descMatch = $true
                    break
                }
            }
            
            $matches += $descMatch
        }
        
        # Group search
        if ($criteria.GroupSearch.Count -gt 0) {
            $groupMatch = $false
            
            foreach ($term in $criteria.GroupSearch) {
                if ($command.Group -and $command.Group -match [regex]::Escape($term)) {
                    $groupMatch = $true
                    break
                }
            }
            
            $matches += $groupMatch
        }
        
        # Return based on AND/OR logic
        if ($matches.Count -eq 0) {
            return $true  # No specific criteria, match all
        }
        
        if ($criteria.AndMode) {
            # AND: all criteria must match
            return ($matches | Where-Object { $_ -eq $false }).Count -eq 0
        } else {
            # OR: any criteria can match
            return ($matches | Where-Object { $_ -eq $true }).Count -gt 0
        }
    }
    
    # Get all unique groups
    [string[]] GetGroups() {
        $groups = @()
        foreach ($command in $this.Commands) {
            if (-not [string]::IsNullOrWhiteSpace($command.Group) -and $groups -notcontains $command.Group) {
                $groups += $command.Group
            }
        }
        return $groups | Sort-Object
    }
    
    # Get all unique tags
    [string[]] GetTags() {
        $tags = @()
        foreach ($command in $this.Commands) {
            foreach ($tag in $command.Tags) {
                if (-not [string]::IsNullOrWhiteSpace($tag) -and $tags -notcontains $tag) {
                    $tags += $tag
                }
            }
        }
        return $tags | Sort-Object
    }
}


####\_Backup/20250726_003635/Services/ConfigurationService.ps1
# ConfigurationService.ps1 - Configuration management with persistence

class ConfigurationService {
    hidden [string]$ConfigPath
    hidden [hashtable]$Config
    hidden [hashtable]$Defaults
    hidden [bool]$AutoSave = $true
    
    ConfigurationService() {
        $this.ConfigPath = Join-Path $global:PraxisRoot "_Config" "settings.json"
        $this.InitializeDefaults()
        $this.Load()
    }
    
    ConfigurationService([string]$configPath) {
        $this.ConfigPath = $configPath
        $this.InitializeDefaults()
        $this.Load()
    }
    
    hidden [void] InitializeDefaults() {
        $this.Defaults = @{
            Theme = @{
                CurrentTheme = "matrix"  # Changed to matrix as requested
                AvailableThemes = @("default", "matrix", "custom")
                CustomColors = @{
                    background = @(0, 0, 0)
                    foreground = @(0, 255, 0)
                    accent = @(0, 200, 0)
                    border = @(0, 100, 0)
                }
            }
            Editor = @{
                TabSize = 4
                WordWrap = $false
                ShowLineNumbers = $true
                HighlightCurrentLine = $true
                AutoSaveInterval = 0  # 0 = disabled, otherwise minutes
                SyntaxHighlighting = $true
            }
            FileBrowser = @{
                DefaultPath = (Get-Location).Path
                ShowHiddenFiles = $false
                IgnoredExtensions = @(".tmp", ".cache", ".log")
                SortBy = "Name"  # Name, Date, Size
                SortDescending = $false
                ShowFileSize = $true
                ShowModifiedDate = $false
            }
            UI = @{
                AnimationsEnabled = $true
                ShowScrollbars = $true
                CompactMode = $false
            }
            Projects = @{
                DefaultPath = Join-Path $global:PraxisRoot "_ProjectData"
                AutoSave = $true
                BackupEnabled = $true
                BackupCount = 5
            }
            Tasks = @{
                DefaultPriority = "Medium"
                ShowCompletedTasks = $true
                CompletedTaskRetention = 30  # days
            }
            Performance = @{
                EnableCaching = $true
                MaxCacheSize = 100  # MB
                RenderOptimization = $true
            }
            Logging = @{
                Level = "Info"
                MaxFileSize = 10  # MB
                MaxFiles = 5
            }
        }
    }
    
    [void] Load() {
        # Ensure config directory exists
        $configDir = Split-Path -Parent $this.ConfigPath
        if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir -Force | Out-Null
        }
        
        # Load config from file or use defaults
        if (Test-Path $this.ConfigPath) {
            try {
                $json = Get-Content -Path $this.ConfigPath -Raw
                $loaded = $json | ConvertFrom-Json -AsHashtable
                
                # Merge with defaults to ensure all keys exist
                $this.Config = $this.MergeHashtables($this.Defaults, $loaded)
                
                if ($global:Logger) {
                    $global:Logger.Info("Configuration loaded from: $($this.ConfigPath)")
                }
            } catch {
                Write-Warning "Failed to load configuration: $_"
                $this.Config = $this.Defaults.Clone()
            }
        } else {
            # No config file, use defaults and save
            $this.Config = $this.Defaults.Clone()
            $this.Save()
        }
    }
    
    [void] Save() {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $this.ConfigPath -Value $json -Encoding UTF8
            
            if ($global:Logger) {
                $global:Logger.Debug("Configuration saved to: $($this.ConfigPath)")
            }
        } catch {
            Write-Warning "Failed to save configuration: $_"
        }
    }
    
    # Deep merge hashtables, preserving structure
    hidden [hashtable] MergeHashtables([hashtable]$base, [hashtable]$overlay) {
        $result = $base.Clone()
        
        foreach ($key in $overlay.Keys) {
            if ($base.ContainsKey($key) -and $base[$key] -is [hashtable] -and $overlay[$key] -is [hashtable]) {
                # Recursively merge nested hashtables
                $result[$key] = $this.MergeHashtables($base[$key], $overlay[$key])
            } else {
                # Overlay value takes precedence
                $result[$key] = $overlay[$key]
            }
        }
        
        return $result
    }
    
    # Get configuration value with dot notation support
    [object] Get([string]$path) {
        return $this.Get($path, $null)
    }
    
    [object] Get([string]$path, $default) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $default
            }
        }
        
        return $current
    }
    
    # Set configuration value with dot notation support
    [void] Set([string]$path, $value) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            } elseif ($current[$part] -isnot [hashtable]) {
                # Path conflict - convert to hashtable
                $current[$part] = @{}
            }
            
            $current = $current[$part]
        }
        
        # Set the final value
        $lastPart = $parts[-1]
        $current[$lastPart] = $value
        
        # Auto-save if enabled
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Check if configuration key exists
    [bool] Has([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $false
            }
        }
        
        return $true
    }
    
    # Remove configuration key
    [void] Remove([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                # Path doesn't exist
                return
            }
        }
        
        # Remove the final key
        $lastPart = $parts[-1]
        if ($current -is [hashtable] -and $current.ContainsKey($lastPart)) {
            $current.Remove($lastPart)
            
            # Auto-save if enabled
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Reset to defaults
    [void] Reset() {
        $this.Config = $this.Defaults.Clone()
        $this.Save()
    }
    
    # Reset specific section to defaults
    [void] ResetSection([string]$section) {
        if ($this.Defaults.ContainsKey($section)) {
            $this.Config[$section] = $this.Defaults[$section].Clone()
            
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Get all configuration as hashtable
    [hashtable] GetAll() {
        return $this.Config.Clone()
    }
    
    # Import configuration from hashtable
    [void] Import([hashtable]$config) {
        $this.Config = $this.MergeHashtables($this.Defaults, $config)
        
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Export configuration to file
    [void] Export([string]$path) {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $path -Value $json -Encoding UTF8
        } catch {
            throw "Failed to export configuration: $_"
        }
    }
}


####\_Backup/20250726_003635/Services/EventBus.ps1
# EventBus Service for PRAXIS
# Based on AxiomPhoenix EventManager with adaptations for PRAXIS architecture
# Provides pub/sub event system for decoupled communication between components

class EventBus {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $false  # Disabled by default for performance
    [ServiceContainer]$ServiceContainer
    [bool]$EnableDebugLogging = $false  # Enable detailed event logging
    hidden [int]$TotalEventsPublished = 0
    hidden [int]$TotalHandlersCalled = 0
    
    EventBus() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.ServiceContainer = $container
        $logger = $container.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus initialized", "Info")
        }
    }
    
    # Subscribe to an event with a handler
    # Returns a subscription ID that can be used to unsubscribe
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            if ($global:Logger) {
                $global:Logger.Error("EventBus.Subscribe: Event name is null or empty")
                $global:Logger.Error("Stack trace: " + [System.Environment]::StackTrace)
            }
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("Handler cannot be null")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        $logger = $this.ServiceContainer.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus: Subscribed handler '$handlerId' to event '$eventName'", "Debug")
        }
        
        return $handlerId
    }
    
    # Subscribe with a weak reference to an object
    # Automatically unsubscribes if the object is garbage collected
    [string] SubscribeWeak([string]$eventName, [object]$target, [scriptblock]$handler) {
        $weakRef = [System.WeakReference]::new($target)
        $wrappedHandler = {
            param($sender, $eventData)
            $strongRef = $weakRef.Target
            if ($strongRef) {
                & $handler $sender $eventData
            } else {
                # Target has been garbage collected, unsubscribe
                $eventBus = $sender
                $eventBus.Unsubscribe($eventName, $args[0])
            }
        }.GetNewClosure()
        
        return $this.Subscribe($eventName, $wrappedHandler)
    }
    
    # Unsubscribe a specific handler
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
                
                $logger = $this.ServiceContainer.GetService('Logger')
                if ($logger) {
                    $logger.Log("EventBus: Unsubscribed handler '$handlerId' from event '$eventName'", "Debug")
                }
            }
        }
    }
    
    # Unsubscribe all handlers for an event
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Unsubscribed all $handlerCount handlers from event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event with optional data
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        # Add timestamp to event data
        $eventData['Timestamp'] = [DateTime]::Now
        $eventData['EventName'] = $eventName
        
        $this.TotalEventsPublished++
        
        # Debug logging
        if ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Publishing event '$eventName' with data: $($eventData | ConvertTo-Json -Compress)", "Debug")
            }
        }
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $this.AddToHistory($eventName, $eventData)
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            
            if ($this.EnableDebugLogging) {
                $debugLogger = $this.ServiceContainer.GetService('Logger')
                if ($debugLogger) {
                    $debugLogger.Log("EventBus: Found $($handlers.Count) handlers for event '$eventName'", "Debug")
                }
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    $this.TotalHandlersCalled++
                    
                    if ($this.EnableDebugLogging) {
                        $debugLogger = $this.ServiceContainer.GetService('Logger')
                        if ($debugLogger) {
                            $debugLogger.Log("EventBus: Calling handler '$($entry.Key)' for event '$eventName'", "Debug")
                        }
                    }
                    
                    # Call handler with EventBus as sender and eventData
                    & $handlerData.Handler $this $eventData
                }
                catch {
                    $logger = $this.ServiceContainer.GetService('Logger')
                    if ($logger) {
                        $logger.Log("EventBus: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)", "Error")
                    }
                }
            }
        }
        elseif ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: No handlers registered for event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event asynchronously (returns immediately)
    [void] PublishAsync([string]$eventName, [hashtable]$eventData = @{}) {
        $job = Start-Job -ScriptBlock {
            param($eventBus, $eventName, $eventData)
            $eventBus.Publish($eventName, $eventData)
        } -ArgumentList $this, $eventName, $eventData
        
        # Clean up job after completion
        Register-ObjectEvent -InputObject $job -EventName StateChanged -Action {
            if ($Event.SourceEventArgs.JobStateInfo.State -eq 'Completed') {
                Remove-Job -Job $Event.SourceEventArgs
                Unregister-Event -SourceIdentifier $Event.SourceIdentifier
            }
        } | Out-Null
    }
    
    # Add event to history
    hidden [void] AddToHistory([string]$eventName, [hashtable]$eventData) {
        # Sanitize event data to prevent circular references
        $sanitizedData = @{}
        foreach ($key in $eventData.Keys) {
            $value = $eventData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [double] -or 
                $value -is [bool] -or $value -is [datetime] -or $value -eq $null) {
                $sanitizedData[$key] = $value
            }
            elseif ($value.GetType().Name -eq 'UIElement' -or $value.GetType().BaseType.Name -eq 'UIElement') {
                # Handle UIElement without requiring the type to be loaded
                $name = if ($value.PSObject.Properties['Name']) { $value.Name } else { 'Unknown' }
                $sanitizedData[$key] = "[UIElement: $name]"
            }
            else {
                $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
            }
        }
        
        $historyEntry = @{
            EventName = $eventName
            EventData = $sanitizedData
            Timestamp = [DateTime]::Now
            HandlerCount = if ($this.EventHandlers.ContainsKey($eventName)) { 
                $this.EventHandlers[$eventName].Count 
            } else { 0 }
        }
        
        $this.EventHistory.Add($historyEntry)
        
        if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
            $this.EventHistory.RemoveAt(0)
        }
    }
    
    # Get event history
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory.Where({ $_.EventName -eq $eventName })
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    # Clear event history
    [void] ClearHistory() {
        $this.EventHistory.Clear()
    }
    
    # Get information about registered events
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
            TotalEventsPublished = $this.TotalEventsPublished
            TotalHandlersCalled = $this.TotalHandlersCalled
            EnableHistory = $this.EnableHistory
            EnableDebugLogging = $this.EnableDebugLogging
            HistorySize = $this.EventHistory.Count
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { 
                    @{
                        Id = $_
                        ExecutionCount = $handlers[$_].ExecutionCount
                        SubscribedAt = $handlers[$_].SubscribedAt
                    }
                }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
    
    # Get debug report
    [string] GetDebugReport() {
        $sb = [System.Text.StringBuilder]::new()
        $info = $this.GetEventInfo()
        
        $sb.AppendLine("EventBus Debug Report")
        $sb.AppendLine("====================")
        $sb.AppendLine("Total Events Published: $($info.TotalEventsPublished)")
        $sb.AppendLine("Total Handlers Called: $($info.TotalHandlersCalled)")
        $sb.AppendLine("Active Handlers: $($info.TotalHandlers)")
        $sb.AppendLine("History Enabled: $($info.EnableHistory)")
        $sb.AppendLine("Debug Logging: $($info.EnableDebugLogging)")
        $sb.AppendLine("History Size: $($info.HistorySize)/$($this.MaxHistorySize)")
        $sb.AppendLine("")
        $sb.AppendLine("Registered Events:")
        
        foreach ($eventName in $info.RegisteredEvents.Keys | Sort-Object) {
            $eventInfo = $info.RegisteredEvents[$eventName]
            $sb.AppendLine("  $eventName : $($eventInfo.HandlerCount) handler(s)")
            
            foreach ($handler in $eventInfo.Handlers) {
                $sb.AppendLine("    - $($handler.Id): $($handler.ExecutionCount) executions")
            }
        }
        
        return $sb.ToString()
    }
}

# Common Event Names (for consistency across the application)
class EventNames {
    # Project Events
    static [string]$ProjectCreated = 'project.created'
    static [string]$ProjectUpdated = 'project.updated'
    static [string]$ProjectDeleted = 'project.deleted'
    static [string]$ProjectSelected = 'project.selected'
    
    # Task Events
    static [string]$TaskCreated = 'task.created'
    static [string]$TaskUpdated = 'task.updated'
    static [string]$TaskDeleted = 'task.deleted'
    static [string]$TaskSelected = 'task.selected'
    static [string]$TaskStatusChanged = 'task.statusChanged'
    
    # Navigation Events
    static [string]$TabChanged = 'navigation.tabChanged'
    static [string]$ScreenChanged = 'navigation.screenChanged'
    static [string]$DialogOpened = 'navigation.dialogOpened'
    static [string]$DialogClosed = 'navigation.dialogClosed'
    
    # Application Events
    static [string]$AppInitialized = 'app.initialized'
    static [string]$AppShutdown = 'app.shutdown'
    static [string]$ThemeChanged = 'app.themeChanged'
    static [string]$ConfigChanged = 'app.configChanged'
    static [string]$RefreshRequested = 'app.refreshRequested'
    static [string]$DataChanged = 'app.dataChanged'
    
    # Command Events
    static [string]$CommandExecuted = 'command.executed'
    static [string]$CommandRegistered = 'command.registered'
    
    # UI Events
    static [string]$FocusChanged = 'ui.focusChanged'
    static [string]$SelectionChanged = 'ui.selectionChanged'
}

# Helper class for command registration
class CommandRegistration {
    static [void] RegisterCommand([string]$name, [string]$description, [scriptblock]$action) {
        $eventBus = $global:ServiceContainer.GetService('EventBus')
        if ($eventBus) {
            $eventBus.Publish([EventNames]::CommandRegistered, @{
                Name = $name
                Description = $description
                Action = $action
            })
        }
    }
}


####\_Backup/20250726_003635/Services/ExcelImportService.ps1
class ExcelImportService {
    $ServiceContainer
    [hashtable] $FieldMappings
    
    ExcelImportService() {
        $this.InitializeFieldMappings()
    }
    
    [void] Initialize($container) {
        $this.ServiceContainer = $container
    }
    
    [void] InitializeFieldMappings() {
        # Based on changes.txt mappings
        $this.FieldMappings = @{
            'RequestDate' = @{ Cell = 'W23'; Type = 'Date' }
            'AuditType' = @{ Cell = 'W78'; Type = 'String' }
            'AuditorName' = @{ Cell = 'W10'; Type = 'String' }
            'AuditorPhone' = @{ Cell = 'W12'; Type = 'String' }
            'AuditorTL' = @{ Cell = 'W15'; Type = 'String' }
            'AuditorTLPhone' = @{ Cell = 'W16'; Type = 'String' }
            'TPName' = @{ Cell = 'W3'; Type = 'String' }
            'TPNum' = @{ Cell = 'W4'; Type = 'String' }
            'Address' = @{ Cell = 'W5'; Type = 'String' }
            'City' = @{ Cell = 'W6'; Type = 'String' }
            'Province' = @{ Cell = 'W7'; Type = 'String' }
            'PostalCode' = @{ Cell = 'W8'; Type = 'String' }
            'Country' = @{ Cell = 'W9'; Type = 'String' }
            'AuditPeriodFrom' = @{ Cell = 'W27'; Type = 'Date' }
            'AuditPeriodTo' = @{ Cell = 'W28'; Type = 'Date' }
            'AuditPeriod1Start' = @{ Cell = 'W29'; Type = 'Date' }
            'AuditPeriod1End' = @{ Cell = 'W30'; Type = 'Date' }
            'AuditPeriod2Start' = @{ Cell = 'W31'; Type = 'Date' }
            'AuditPeriod2End' = @{ Cell = 'W32'; Type = 'Date' }
            'AuditPeriod3Start' = @{ Cell = 'W33'; Type = 'Date' }
            'AuditPeriod3End' = @{ Cell = 'W34'; Type = 'Date' }
            'AuditPeriod4Start' = @{ Cell = 'W35'; Type = 'Date' }
            'AuditPeriod4End' = @{ Cell = 'W36'; Type = 'Date' }
            'AuditPeriod5Start' = @{ Cell = 'W37'; Type = 'Date' }
            'AuditPeriod5End' = @{ Cell = 'W38'; Type = 'Date' }
            'Contact1Name' = @{ Cell = 'W54'; Type = 'String' }
            'Contact1Phone' = @{ Cell = 'W55'; Type = 'String' }
            'Contact1Ext' = @{ Cell = 'W56'; Type = 'String' }
            'Contact1Address' = @{ Cell = 'W57'; Type = 'String' }
            'Contact1Title' = @{ Cell = 'W58'; Type = 'String' }
            'Contact2Name' = @{ Cell = 'W59'; Type = 'String' }
            'Contact2Phone' = @{ Cell = 'W60'; Type = 'String' }
            'Contact2Ext' = @{ Cell = 'W61'; Type = 'String' }
            'Contact2Address' = @{ Cell = 'W62'; Type = 'String' }
            'Contact2Title' = @{ Cell = 'W63'; Type = 'String' }
            'AuditProgram' = @{ Cell = 'W72'; Type = 'String' }
            'AuditCase' = @{ Cell = 'W18'; Type = 'String' }
            'CASCase' = @{ Cell = 'W17'; Type = 'String' }  # Critical ID2 field
            'AuditStartDate' = @{ Cell = 'W24'; Type = 'Date' }
            'AccountingSoftware1' = @{ Cell = 'W98'; Type = 'String' }
            'AccountingSoftware1Other' = @{ Cell = 'W100'; Type = 'String' }
            'AccountingSoftware1Type' = @{ Cell = 'W101'; Type = 'String' }
            'AccountingSoftware2' = @{ Cell = 'W102'; Type = 'String' }
            'AccountingSoftware2Other' = @{ Cell = 'W104'; Type = 'String' }
            'AccountingSoftware2Type' = @{ Cell = 'W105'; Type = 'String' }
            'FXInfo' = @{ Cell = 'W129'; Type = 'String' }
            'ShipToAddress' = @{ Cell = 'W130'; Type = 'String' }
            'Comments' = @{ Cell = 'W108'; Type = 'String' }
        }
    }
    
    [hashtable] ImportFromExcel([string]$FilePath) {
        # Validate file exists
        if (-not (Test-Path $FilePath)) {
            throw "Excel file not found: $FilePath"
        }
        
        # Initialize COM objects
        $excel = $null
        $workbook = $null
        $importedData = @{}
        
        try {
            # Create Excel application
            $excel = New-Object -ComObject Excel.Application
            $excel.Visible = $false
            $excel.DisplayAlerts = $false
            
            # Open workbook
            $workbook = $excel.Workbooks.Open($FilePath, 0, $true) # ReadOnly
            
            # Try to find SVI-CAS worksheet
            $worksheet = $null
            try {
                $worksheet = $workbook.Worksheets.Item('SVI-CAS')
            }
            catch {
                # Use first worksheet if SVI-CAS not found
                $worksheet = $workbook.Worksheets.Item(1)
                Write-Warning "SVI-CAS worksheet not found, using first worksheet: $($worksheet.Name)"
            }
            
            # Extract data based on mappings
            foreach ($field in $this.FieldMappings.Keys) {
                $mapping = $this.FieldMappings[$field]
                try {
                    $cellValue = $worksheet.Range($mapping.Cell).Value2
                    
                    # Convert based on type
                    if ($null -ne $cellValue -and $cellValue -ne '') {
                        switch ($mapping.Type) {
                            'Date' {
                                if ($cellValue -is [double]) {
                                    $importedData[$field] = [DateTime]::FromOADate($cellValue)
                                }
                                else {
                                    $importedData[$field] = [DateTime]::Parse($cellValue.ToString())
                                }
                            }
                            'String' {
                                $importedData[$field] = $cellValue.ToString().Trim()
                            }
                            default {
                                $importedData[$field] = $cellValue
                            }
                        }
                    }
                }
                catch {
                    Write-Warning "Failed to extract $field from cell $($mapping.Cell): $_"
                }
            }
            
            return $importedData
        }
        finally {
            # Clean up COM objects
            if ($workbook) {
                try { $workbook.Close($false) } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($workbook) | Out-Null
            }
            if ($excel) {
                try { $excel.Quit() } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
            }
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
        }
    }
    
    [object] CreateProjectFromImport([hashtable]$ImportedData) {
        $projectService = $this.ServiceContainer.GetService('ProjectService')
        
        # Create new project with imported data
        $project = [Project]::new()
        
        # Map basic fields
        $project.FullProjectName = $ImportedData.TPName
        $project.Nickname = $ImportedData.TPName  # Can be changed later
        $project.ID2 = $ImportedData.CASCase  # CAS Case# is the ID2
        $project.ClientID = $ImportedData.TPNum
        $project.Status = 'Active'
        
        # Map audit information
        $project.AuditType = $ImportedData.AuditType
        $project.AuditProgram = $ImportedData.AuditProgram
        $project.AuditCase = $ImportedData.AuditCase
        $project.AuditStartDate = $ImportedData.AuditStartDate
        $project.AuditPeriodFrom = $ImportedData.AuditPeriodFrom
        $project.AuditPeriodTo = $ImportedData.AuditPeriodTo
        
        # Map additional audit periods
        $project.AuditPeriod1Start = $ImportedData.AuditPeriod1Start
        $project.AuditPeriod1End = $ImportedData.AuditPeriod1End
        $project.AuditPeriod2Start = $ImportedData.AuditPeriod2Start
        $project.AuditPeriod2End = $ImportedData.AuditPeriod2End
        $project.AuditPeriod3Start = $ImportedData.AuditPeriod3Start
        $project.AuditPeriod3End = $ImportedData.AuditPeriod3End
        $project.AuditPeriod4Start = $ImportedData.AuditPeriod4Start
        $project.AuditPeriod4End = $ImportedData.AuditPeriod4End
        $project.AuditPeriod5Start = $ImportedData.AuditPeriod5Start
        $project.AuditPeriod5End = $ImportedData.AuditPeriod5End
        
        # Map address information
        $project.Address = $ImportedData.Address
        $project.City = $ImportedData.City
        $project.Province = $ImportedData.Province
        $project.PostalCode = $ImportedData.PostalCode
        $project.Country = $ImportedData.Country
        $project.ShipToAddress = $ImportedData.ShipToAddress
        
        # Map auditor information
        $project.AuditorName = $ImportedData.AuditorName
        $project.AuditorPhone = $ImportedData.AuditorPhone
        $project.AuditorTL = $ImportedData.AuditorTL
        $project.AuditorTLPhone = $ImportedData.AuditorTLPhone
        
        # Map contact information directly to project fields
        $project.Contact1Name = $ImportedData.Contact1Name
        $project.Contact1Phone = $ImportedData.Contact1Phone
        $project.Contact1Ext = $ImportedData.Contact1Ext
        $project.Contact1Address = $ImportedData.Contact1Address
        $project.Contact1Title = $ImportedData.Contact1Title
        $project.Contact2Name = $ImportedData.Contact2Name
        $project.Contact2Phone = $ImportedData.Contact2Phone
        $project.Contact2Ext = $ImportedData.Contact2Ext
        $project.Contact2Address = $ImportedData.Contact2Address
        $project.Contact2Title = $ImportedData.Contact2Title
        
        # Map software information
        $project.AccountingSoftware1 = $ImportedData.AccountingSoftware1
        $project.AccountingSoftware1Other = $ImportedData.AccountingSoftware1Other
        $project.AccountingSoftware1Type = $ImportedData.AccountingSoftware1Type
        $project.AccountingSoftware2 = $ImportedData.AccountingSoftware2
        $project.AccountingSoftware2Other = $ImportedData.AccountingSoftware2Other
        $project.AccountingSoftware2Type = $ImportedData.AccountingSoftware2Type
        
        # Map additional fields
        $project.RequestDate = $ImportedData.RequestDate
        $project.FXInfo = $ImportedData.FXInfo
        $project.Comments = $ImportedData.Comments
        
        return $project
    }
}


####\_Backup/20250726_003635/Services/FunctionRegistry.ps1
# FunctionRegistry.ps1 - Registry for @functions used in Visual Macro Factory
# Integrates with CommandService to provide both built-in and custom @functions

class FunctionRegistry {
    [hashtable]$BuiltInFunctions = @{}
    [CommandService]$CommandService
    [Logger]$Logger
    
    FunctionRegistry() {
        $this.Logger = $global:Logger
        $this.RegisterBuiltInFunctions()
    }
    
    # Set the CommandService reference for accessing custom commands
    [void] SetCommandService([CommandService]$commandService) {
        $this.CommandService = $commandService
    }
    
    # Register built-in @functions
    [void] RegisterBuiltInFunctions() {
        # User input functions
        $this.BuiltInFunctions["PromptForField"] = @{
            Name = "PromptForField"
            Description = "Prompts user to select a field from the current database"
            Category = "User Input"
            Usage = "@PromptForField"
            Template = "@PromptForField"
        }
        
        $this.BuiltInFunctions["PromptForValue"] = @{
            Name = "PromptForValue"
            Description = "Prompts user for a text value"
            Category = "User Input"
            Usage = "@PromptForValue(""Enter value:"")"
            Template = "@PromptForValue(""Enter description"")"
        }
        
        $this.BuiltInFunctions["PromptForNumber"] = @{
            Name = "PromptForNumber"
            Description = "Prompts user for a numeric value"
            Category = "User Input"
            Usage = "@PromptForNumber(""Enter amount:"")"
            Template = "@PromptForNumber(""Enter description"")"
        }
        
        # System functions
        $this.BuiltInFunctions["CurrentDate_YYYYMMDD"] = @{
            Name = "CurrentDate_YYYYMMDD"
            Description = "Current date in YYYYMMDD format"
            Category = "System"
            Usage = "@CurrentDate_YYYYMMDD"
            Template = "@CurrentDate_YYYYMMDD"
        }
        
        $this.BuiltInFunctions["CurrentDate_MMDDYYYY"] = @{
            Name = "CurrentDate_MMDDYYYY"
            Description = "Current date in MM/DD/YYYY format"
            Category = "System"
            Usage = "@CurrentDate_MMDDYYYY"
            Template = "@CurrentDate_MMDDYYYY"
        }
        
        $this.BuiltInFunctions["CurrentUser"] = @{
            Name = "CurrentUser"
            Description = "Current Windows username"
            Category = "System"
            Usage = "@CurrentUser"
            Template = "@CurrentUser"
        }
        
        $this.BuiltInFunctions["CurrentTime_HHMMSS"] = @{
            Name = "CurrentTime_HHMMSS"
            Description = "Current time in HHMMSS format"
            Category = "System"
            Usage = "@CurrentTime_HHMMSS"
            Template = "@CurrentTime_HHMMSS"
        }
        
        # File functions
        $this.BuiltInFunctions["TempFile"] = @{
            Name = "TempFile"
            Description = "Generate a temporary file path"
            Category = "File"
            Usage = "@TempFile(.xlsx)"
            Template = "@TempFile(.xlsx)"
        }
    }
    
    # Get all available @functions (built-in + custom from CommandService)
    [hashtable[]] GetAllFunctions() {
        $functions = @()
        
        # Add built-in functions
        foreach ($func in $this.BuiltInFunctions.Values) {
            $functions += $func
        }
        
        # Add custom functions from CommandService if available
        if ($this.CommandService) {
            $customFunctions = $this.GetCustomFunctions()
            $functions += $customFunctions
        }
        
        return $functions
    }
    
    # Get custom @functions from CommandService
    [hashtable[]] GetCustomFunctions() {
        $functions = @()
        
        if (-not $this.CommandService) {
            return $functions
        }
        
        # Look for commands that define @functions
        foreach ($command in $this.CommandService.Commands) {
            # Check if command defines a @function (starts with @)
            if ($command.Command -match '^@(\w+)') {
                $funcName = $matches[1]
                $functions += @{
                    Name = $funcName
                    Description = $command.Description
                    Category = "Custom"
                    Usage = $command.Command
                    Template = $command.Command
                    Source = "CommandLibrary"
                    Tags = $command.Tags
                }
            }
            
            # Also check for commands tagged as functions
            if ($command.Tags -contains "function" -or $command.Tags -contains "@function") {
                $functions += @{
                    Name = $command.Name
                    Description = $command.Description
                    Category = "Custom"
                    Usage = $command.Command
                    Template = $command.Command
                    Source = "CommandLibrary"
                    Tags = $command.Tags
                }
            }
        }
        
        return $functions
    }
    
    # Search functions by name or description
    [hashtable[]] SearchFunctions([string]$query) {
        $allFunctions = $this.GetAllFunctions()
        $results = @()
        
        $query = $query.ToLower()
        
        foreach ($func in $allFunctions) {
            $name = $func.Name.ToLower()
            $desc = $func.Description.ToLower()
            
            if ($name.Contains($query) -or $desc.Contains($query)) {
                $results += $func
            }
        }
        
        return $results
    }
    
    # Get functions by category
    [hashtable[]] GetFunctionsByCategory([string]$category) {
        $allFunctions = $this.GetAllFunctions()
        $results = @()
        
        foreach ($func in $allFunctions) {
            if ($func.Category -eq $category) {
                $results += $func
            }
        }
        
        return $results
    }
    
    # Resolve @function at runtime (for script generation)
    [string] ResolveFunction([string]$functionCall, [hashtable]$context = @{}) {
        # This would be called during macro execution to replace @functions with actual values
        # For now, return the function call as-is for the IDEAScript to handle
        return $functionCall
    }
}


####\_Backup/20250726_003635/Services/Logger.ps1
# Logger.ps1 - Fast logging service adapted from AxiomPhoenix
# Optimized for speed - no console output, minimal file I/O

class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 100  # Smaller queue for faster flushing
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false  # Never log to console in TUI
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    hidden [System.Text.StringBuilder]$_buffer
    hidden [int]$_unflushedCount = 0
    hidden [int]$_flushThreshold = 10  # Flush every N messages
    
    Logger() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { (Get-Location).Path }
        $logDir = Join-Path $praxisDir "_Logs"
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        $this.LogPath = Join-Path $logDir "praxis.log"
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        $this._buffer = [System.Text.StringBuilder]::new(4096)  # Pre-allocate buffer
        
        # Check for debug mode
        if ($global:PraxisDebug -or $env:PRAXIS_DEBUG) {
            $this.MinimumLevel = "Debug"
        }
        
        # Rotate log if too large (>10MB)
        try {
            if ((Test-Path $this.LogPath) -and (Get-Item $this.LogPath).Length -gt 10MB) {
                $backupPath = $this.LogPath + ".old"
                Move-Item $this.LogPath $backupPath -Force -ErrorAction SilentlyContinue
            }
        } catch {
            # Ignore rotation errors
        }
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Fast level check
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        # Format timestamp efficiently
        $timestamp = [DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
        $levelPadded = $level.ToUpper().PadRight(7)
        
        # Build log line
        $logLine = "$timestamp [$levelPadded] $message"
        
        # Add to buffer instead of queue for speed
        $this._buffer.AppendLine($logLine)
        $this._unflushedCount++
        
        # Auto-flush on threshold or error/fatal
        if ($this._unflushedCount -ge $this._flushThreshold -or 
            $level -eq "Error" -or $level -eq "Fatal") {
            $this.Flush()
        }
    }
    
    [void] LogException([Exception]$exception, [string]$context = "") {
        $message = if ($context) { "$context - " } else { "" }
        $message += "$($exception.GetType().Name): $($exception.Message)"
        $this.Log($message, "Error")
        
        # Log stack trace as debug
        if ($exception.StackTrace) {
            $this.Log("Stack: $($exception.StackTrace -replace "`n", " ")", "Debug")
        }
    }
    
    [void] Flush() {
        if ($this._buffer.Length -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            # Write buffer to file in one operation
            [System.IO.File]::AppendAllText($this.LogPath, $this._buffer.ToString())
            $this._buffer.Clear()
            $this._unflushedCount = 0
        }
        catch {
            # Ignore logging errors to prevent crashes
        }
    }
    
    # Quick logging methods
    [void] Debug([string]$message) { $this.Log($message, "Debug") }
    [void] Info([string]$message) { $this.Log($message, "Info") }
    [void] Warning([string]$message) { $this.Log($message, "Warning") }
    [void] Error([string]$message) { $this.Log($message, "Error") }
    
    [void] Cleanup() {
        $this.Flush()
    }
}

# Global Write-Log function for compatibility
function global:Write-Log {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    if ($global:Logger) {
        $global:Logger.Log($Message, $Level)
    }
}


####\_Backup/20250726_003635/Services/MacroContextManager.ps1
# MacroContextManager.ps1 - Manages macro state and variable context
# The "smart conductor" that ensures temporal safety and handles name collisions

class MacroContextManager {
    [System.Collections.ArrayList]$Actions = [System.Collections.ArrayList]::new()
    [hashtable]$GlobalContext = @{}
    [Logger]$Logger
    [FunctionRegistry]$FunctionRegistry
    
    MacroContextManager() {
        $this.Logger = $global:Logger
        $this.InitializeGlobalContext()
    }
    
    # Set the FunctionRegistry reference
    [void] SetFunctionRegistry([FunctionRegistry]$functionRegistry) {
        $this.FunctionRegistry = $functionRegistry
    }
    
    # Initialize with common IDEA context variables
    [void] InitializeGlobalContext() {
        $this.GlobalContext = @{
            # Common IDEA database context
            "ActiveDatabase" = @{
                Type = "Database"
                Description = "Currently active database in IDEA"
                Available = $true
            }
            
            # System variables
            "CurrentUser" = @{
                Type = "String"
                Description = "Current Windows username"
                Available = $true
            }
            
            "CurrentDate" = @{
                Type = "Date"
                Description = "Current system date"
                Available = $true
            }
        }
    }
    
    # Add an action to the macro sequence
    [void] AddAction([BaseAction]$action) {
        $this.AddAction($action, $this.Actions.Count)
    }
    
    # Add an action at a specific position
    [void] AddAction([BaseAction]$action, [int]$position) {
        if ($position -lt 0 -or $position -gt $this.Actions.Count) {
            $position = $this.Actions.Count
        }
        
        $this.Actions.Insert($position, $action)
        $this.UpdateProducedVariables()
        
        if ($this.Logger) {
            $this.Logger.Debug("Added action '$($action.Name)' at position $position")
        }
    }
    
    # Remove an action from the sequence
    [void] RemoveAction([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Actions.Count) {
            $action = $this.Actions[$index]
            $this.Actions.RemoveAt($index)
            $this.UpdateProducedVariables()
            
            if ($this.Logger) {
                $this.Logger.Debug("Removed action '$($action.Name)' from position $index")
            }
        }
    }
    
    # Move an action to a different position
    [void] MoveAction([int]$fromIndex, [int]$toIndex) {
        if ($fromIndex -eq $toIndex -or 
            $fromIndex -lt 0 -or $fromIndex -ge $this.Actions.Count -or
            $toIndex -lt 0 -or $toIndex -ge $this.Actions.Count) {
            return
        }
        
        $action = $this.Actions[$fromIndex]
        $this.Actions.RemoveAt($fromIndex)
        
        # Adjust target index if we removed an item before it
        if ($fromIndex -lt $toIndex) {
            $toIndex--
        }
        
        $this.Actions.Insert($toIndex, $action)
        $this.UpdateProducedVariables()
        
        if ($this.Logger) {
            $this.Logger.Debug("Moved action '$($action.Name)' from $fromIndex to $toIndex")
        }
    }
    
    # Get the context available at a specific step (temporal safety)
    [hashtable] GetContextAtStep([int]$stepIndex) {
        $context = $this.GlobalContext.Clone()
        
        # Add variables produced by all previous actions
        for ($i = 0; $i -lt $stepIndex -and $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            foreach ($produced in $action.Produces) {
                $varName = $this.ResolveVariableName($produced.Name, $i)
                $context[$varName] = @{
                    Type = $produced.Type
                    Description = $produced.Description
                    ProducedBy = $action.Name
                    StepIndex = $i
                    Available = $true
                }
            }
        }
        
        return $context
    }
    
    # Get all variables available in the macro (for final context view)
    [hashtable] GetFullContext() {
        return $this.GetContextAtStep($this.Actions.Count)
    }
    
    # Resolve variable name with automatic collision handling
    [string] ResolveVariableName([string]$baseName, [int]$actionIndex) {
        $context = $this.GetContextAtStep($actionIndex)
        
        # If no collision, use base name
        if (-not $context.ContainsKey($baseName)) {
            return $baseName
        }
        
        # Handle collision by appending action name and counter
        $action = $this.Actions[$actionIndex]
        $actionName = $action.Name -replace '\s+', ''  # Remove spaces
        $suffix = 1
        
        do {
            $candidateName = "${baseName}_${actionName}_${suffix}"
            $suffix++
        } while ($context.ContainsKey($candidateName))
        
        return $candidateName
    }
    
    # Update all produced variables after sequence changes
    [void] UpdateProducedVariables() {
        # This ensures variable names are recalculated when actions are added/removed/moved
        # The actual resolution happens in GetContextAtStep, so no action needed here
        # But we could invalidate any cached contexts if we implement caching
    }
    
    # Validate that all actions have their required context
    [hashtable] ValidateMacro() {
        $validation = @{
            IsValid = $true
            Errors = @()
            Warnings = @()
        }
        
        for ($i = 0; $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            $availableContext = $this.GetContextAtStep($i)
            
            # Check if all required variables are available
            foreach ($requirement in $action.Consumes) {
                if (-not $availableContext.ContainsKey($requirement.Name)) {
                    $validation.IsValid = $false
                    $validation.Errors += "Step $($i + 1) ($($action.Name)): Missing required variable '$($requirement.Name)'"
                }
            }
        }
        
        return $validation
    }
    
    # Generate the final IDEAScript
    [string] GenerateScript() {
        $validation = $this.ValidateMacro()
        if (-not $validation.IsValid) {
            throw "Cannot generate script: Macro validation failed. Errors: $($validation.Errors -join '; ')"
        }
        
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine("' Generated by PRAXIS Visual Macro Factory")
        $sb.AppendLine("' Generated on: $(Get-Date)")
        $sb.AppendLine("' Total steps: $($this.Actions.Count)")
        $sb.AppendLine("")
        
        for ($i = 0; $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            $context = $this.GetContextAtStep($i + 1)  # Context after this action runs
            
            $sb.AppendLine("' Step $($i + 1): $($action.Name)")
            if ($action.Description) {
                $sb.AppendLine("' $($action.Description)")
            }
            $sb.AppendLine("")
            
            try {
                $actionScript = $action.RenderScript($context)
                $sb.AppendLine($actionScript)
            } catch {
                $sb.AppendLine("' ERROR generating script for $($action.Name): $($_.Exception.Message)")
            }
            
            $sb.AppendLine("")
        }
        
        return $sb.ToString()
    }
    
    # Clear all actions and reset context
    [void] Clear() {
        $this.Actions.Clear()
        $this.InitializeGlobalContext()
        
        if ($this.Logger) {
            $this.Logger.Debug("Cleared macro context")
        }
    }
    
    # Get summary of current macro
    [hashtable] GetSummary() {
        return @{
            ActionCount = $this.Actions.Count
            TotalVariables = $this.GetFullContext().Count
            IsValid = $this.ValidateMacro().IsValid
            Actions = $this.Actions | ForEach-Object { $_.Name }
        }
    }
}


####\_Backup/20250726_003635/Services/ProjectService.ps1
# ProjectService - Business logic for project management
# Lightweight service focusing on project-related operations

class ProjectService {
    hidden [System.Collections.ArrayList]$Projects = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile
    
    ProjectService() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PSScriptRoot }
        $this.DataFile = Join-Path $praxisDir "_ProjectData/projects.json"
        
        # Ensure directory exists
        $dataDir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        $this.LoadProjects()
    }
    
    [void] LoadProjects() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Projects.Clear()
                foreach ($projData in $data) {
                    # Handle both old and new format
                    if ($projData.PSObject.Properties['FullProjectName']) {
                        # New PMC format
                        $project = [Project]::new($projData.FullProjectName, $projData.Nickname)
                        $project.Id = $projData.Id
                        $project.ID1 = $projData.ID1 ?? ""
                        $project.ID2 = $projData.ID2 ?? ""
                        if ($projData.DateAssigned) { $project.DateAssigned = [DateTime]::Parse($projData.DateAssigned) }
                        if ($projData.BFDate) { $project.BFDate = [DateTime]::Parse($projData.BFDate) }
                        if ($projData.DateDue) { $project.DateDue = [DateTime]::Parse($projData.DateDue) }
                        $project.Note = $projData.Note ?? ""
                        $project.CAAPath = $projData.CAAPath ?? ""
                        $project.RequestPath = $projData.RequestPath ?? ""
                        $project.T2020Path = $projData.T2020Path ?? ""
                        $project.CumulativeHrs = $projData.CumulativeHrs ?? 0
                        if ($projData.ClosedDate -and $projData.ClosedDate -ne "0001-01-01T00:00:00") { 
                            $project.ClosedDate = [DateTime]::Parse($projData.ClosedDate) 
                        }
                        
                        # Load all the new fields
                        $project.Status = $projData.Status ?? "Active"
                        $project.ClientID = $projData.ClientID ?? ""
                        
                        # Audit fields
                        $project.AuditType = $projData.AuditType ?? ""
                        $project.AuditProgram = $projData.AuditProgram ?? ""
                        $project.AuditCase = $projData.AuditCase ?? ""
                        if ($projData.AuditStartDate -and $projData.AuditStartDate -ne "0001-01-01T00:00:00") {
                            $project.AuditStartDate = [DateTime]::Parse($projData.AuditStartDate)
                        }
                        if ($projData.AuditPeriodFrom -and $projData.AuditPeriodFrom -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodFrom = [DateTime]::Parse($projData.AuditPeriodFrom)
                        }
                        if ($projData.AuditPeriodTo -and $projData.AuditPeriodTo -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodTo = [DateTime]::Parse($projData.AuditPeriodTo)
                        }
                        
                        # Additional audit periods
                        for ($i = 1; $i -le 5; $i++) {
                            $startProp = "AuditPeriod${i}Start"
                            $endProp = "AuditPeriod${i}End"
                            if ($projData.$startProp -and $projData.$startProp -ne "0001-01-01T00:00:00") {
                                $project.$startProp = [DateTime]::Parse($projData.$startProp)
                            }
                            if ($projData.$endProp -and $projData.$endProp -ne "0001-01-01T00:00:00") {
                                $project.$endProp = [DateTime]::Parse($projData.$endProp)
                            }
                        }
                        
                        # Address fields
                        $project.Address = $projData.Address ?? ""
                        $project.City = $projData.City ?? ""
                        $project.Province = $projData.Province ?? ""
                        $project.PostalCode = $projData.PostalCode ?? ""
                        $project.Country = $projData.Country ?? ""
                        $project.ShipToAddress = $projData.ShipToAddress ?? ""
                        
                        # Auditor fields
                        $project.AuditorName = $projData.AuditorName ?? ""
                        $project.AuditorPhone = $projData.AuditorPhone ?? ""
                        $project.AuditorTL = $projData.AuditorTL ?? ""
                        $project.AuditorTLPhone = $projData.AuditorTLPhone ?? ""
                        
                        # Contact fields
                        $project.Contact1Name = $projData.Contact1Name ?? ""
                        $project.Contact1Phone = $projData.Contact1Phone ?? ""
                        $project.Contact1Ext = $projData.Contact1Ext ?? ""
                        $project.Contact1Address = $projData.Contact1Address ?? ""
                        $project.Contact1Title = $projData.Contact1Title ?? ""
                        $project.Contact2Name = $projData.Contact2Name ?? ""
                        $project.Contact2Phone = $projData.Contact2Phone ?? ""
                        $project.Contact2Ext = $projData.Contact2Ext ?? ""
                        $project.Contact2Address = $projData.Contact2Address ?? ""
                        $project.Contact2Title = $projData.Contact2Title ?? ""
                        
                        # Software fields
                        $project.AccountingSoftware1 = $projData.AccountingSoftware1 ?? ""
                        $project.AccountingSoftware1Other = $projData.AccountingSoftware1Other ?? ""
                        $project.AccountingSoftware1Type = $projData.AccountingSoftware1Type ?? ""
                        $project.AccountingSoftware2 = $projData.AccountingSoftware2 ?? ""
                        $project.AccountingSoftware2Other = $projData.AccountingSoftware2Other ?? ""
                        $project.AccountingSoftware2Type = $projData.AccountingSoftware2Type ?? ""
                        
                        # Other fields
                        if ($projData.RequestDate -and $projData.RequestDate -ne "0001-01-01T00:00:00") {
                            $project.RequestDate = [DateTime]::Parse($projData.RequestDate)
                        }
                        $project.FXInfo = $projData.FXInfo ?? ""
                        $project.Comments = $projData.Comments ?? ""
                        
                        $project.Deleted = $projData.Deleted ?? $false
                    } else {
                        # Legacy format
                        $project = [Project]::new($projData.Name)
                        $project.Id = $projData.Id
                        if ($projData.Description) { $project.Note = $projData.Description }
                    }
                    $this.Projects.Add($project) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load projects: $_"
            }
        }
        
        # Ensure default project exists
        if (-not ($this.Projects | Where-Object { $_.Nickname -eq "Default" })) {
            $default = [Project]::new("Default")
            $default.Note = "Default project for uncategorized tasks"
            $this.Projects.Add($default) | Out-Null
            $this.SaveProjects()
        }
    }
    
    [void] SaveProjects() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($project in $this.Projects) {
            $data += @{
                Id = $project.Id
                FullProjectName = $project.FullProjectName
                Nickname = $project.Nickname
                ID1 = $project.ID1
                ID2 = $project.ID2
                DateAssigned = $project.DateAssigned.ToString("yyyy-MM-ddTHH:mm:ss")
                BFDate = $project.BFDate.ToString("yyyy-MM-ddTHH:mm:ss")
                DateDue = $project.DateDue.ToString("yyyy-MM-ddTHH:mm:ss")
                Note = $project.Note
                CAAPath = $project.CAAPath
                RequestPath = $project.RequestPath
                T2020Path = $project.T2020Path
                CumulativeHrs = $project.CumulativeHrs
                ClosedDate = $project.ClosedDate.ToString("yyyy-MM-ddTHH:mm:ss")
                Deleted = $project.Deleted
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Project[]] GetAllProjects() {
        return $this.Projects.ToArray()
    }
    
    [Project] GetProject([string]$id) {
        return $this.Projects | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Project] GetProjectByName([string]$name) {
        return $this.Projects | Where-Object { $_.Nickname -eq $name -or $_.FullProjectName -eq $name } | Select-Object -First 1
    }
    
    [Project] AddProject([string]$name) {
        # Check if already exists
        $existing = $this.GetProjectByName($name)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($name)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([string]$fullName, [string]$nickname) {
        # Check if already exists
        $existing = $this.GetProjectByName($nickname)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($fullName, $nickname)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([Project]$project) {
        # Check if already exists by nickname
        $existing = $this.GetProjectByName($project.Nickname)
        if ($existing) {
            return $existing
        }
        
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [void] UpdateProject([Project]$project) {
        $this.SaveProjects()
    }
    
    [void] DeleteProject([string]$id) {
        $project = $this.GetProject($id)
        if ($project -and $project.Nickname -ne "Default") {
            $this.Projects.Remove($project)
            $this.SaveProjects()
        }
    }
    
    [hashtable[]] GetProjectsWithStats([object]$taskService) {
        $result = @()
        
        foreach ($project in $this.Projects) {
            $tasks = $taskService.GetTasksByProject($project.Nickname)
            $completed = ($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $total = $tasks.Count
            
            $result += @{
                Project = $project
                Name = $project.Nickname  # Use nickname for compatibility
                FullName = $project.FullProjectName
                TaskCount = $total
                CompletedCount = $completed
                Progress = if ($total -gt 0) { $completed / $total } else { 0 }
            }
        }
        
        return $result
    }
}


####\_Backup/20250726_003635/Services/ShortcutManager.ps1
# ShortcutManager.ps1 - Centralized keyboard shortcut management service

enum ShortcutScope {
    Global      # Available everywhere
    Screen      # Available in specific screen types
    Context     # Available in specific contexts (e.g., when dialog is open)
}

class ShortcutDefinition {
    [string]$Id
    [string]$Name
    [string]$Description
    [System.ConsoleKey]$Key
    [System.ConsoleModifiers]$Modifiers
    [char]$KeyChar
    [ShortcutScope]$Scope
    [string]$ScreenType  # For Screen scope
    [string]$Context     # For Context scope
    [scriptblock]$Action
    [bool]$Enabled = $true
    [int]$Priority = 0   # Higher priority shortcuts are checked first
    
    ShortcutDefinition() {}
    
    [bool] Matches([System.ConsoleKeyInfo]$keyInfo) {
        # Check if this shortcut matches the pressed key
        if ($this.Key -ne [System.ConsoleKey]::None) {
            if ($keyInfo.Key -ne $this.Key) {
                return $false
            }
            if ($this.Modifiers -ne [System.ConsoleModifiers]::None) {
                if (($keyInfo.Modifiers -band $this.Modifiers) -ne $this.Modifiers) {
                    return $false
                }
            }
            return $true
        }
        elseif ($this.KeyChar -ne [char]0) {
            # Character-based shortcut
            return $keyInfo.KeyChar -eq $this.KeyChar
        }
        return $false
    }
    
    [string] GetDisplayText() {
        $parts = @()
        
        if ($this.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        if ($this.Key -ne [System.ConsoleKey]::None) {
            $parts += $this.Key.ToString()
        }
        elseif ($this.KeyChar -ne [char]0) {
            $parts += $this.KeyChar.ToString()
        }
        
        return $parts -join "+"
    }
}

class ShortcutManager {
    hidden [System.Collections.Generic.List[ShortcutDefinition]]$Shortcuts
    hidden [Logger]$Logger
    hidden [EventBus]$EventBus
    
    ShortcutManager() {
        $this.Shortcuts = [System.Collections.Generic.List[ShortcutDefinition]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService('Logger')
        $this.EventBus = $container.GetService('EventBus')
        
        # Register default global shortcuts
        $this.RegisterDefaultShortcuts()
    }
    
    [void] RegisterDefaultShortcuts() {
        # Global shortcuts
        $this.RegisterShortcut(@{
            Id = "global.quit"
            Name = "Quit Application"
            Description = "Exit the application"
            Key = [System.ConsoleKey]::Q
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Global
            Priority = 100
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.RequestExit()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette"
            Name = "Command Palette"
            Description = "Open the command palette"
            KeyChar = ':'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette_alt"
            Name = "Command Palette (Alt)"
            Description = "Open the command palette"
            KeyChar = '/'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
    }
    
    [void] RegisterShortcut([hashtable]$definition) {
        $shortcut = [ShortcutDefinition]::new()
        
        # Map hashtable properties to object
        foreach ($key in $definition.Keys) {
            if ($null -ne $shortcut.PSObject.Properties[$key]) {
                $shortcut.$key = $definition[$key]
            }
        }
        
        # Validate required properties
        if ([string]::IsNullOrEmpty($shortcut.Id)) {
            throw "Shortcut ID is required"
        }
        if (-not $shortcut.Action) {
            throw "Shortcut action is required"
        }
        
        # Remove existing shortcut with same ID
        $this.UnregisterShortcut($shortcut.Id)
        
        # Add new shortcut
        $this.Shortcuts.Add($shortcut)
        
        # Sort by priority (descending)
        $this.Shortcuts.Sort({ param($a, $b) $b.Priority.CompareTo($a.Priority) })
        
        if ($this.Logger) {
            $this.Logger.Debug("Registered shortcut: $($shortcut.Id) - $($shortcut.GetDisplayText())")
        }
    }
    
    [void] UnregisterShortcut([string]$id) {
        $existing = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($existing) {
            $this.Shortcuts.Remove($existing) | Out-Null
        }
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen, [string]$currentContext) {
        if ($this.Logger) {
            $this.Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' Screen=$currentScreen Context=$currentContext")
            $this.Logger.Debug("ShortcutManager: Total shortcuts registered: $($this.Shortcuts.Count)")
        }
        
        # Find matching shortcuts
        $candidates = $this.Shortcuts | Where-Object {
            $_.Enabled -and $_.Matches($keyInfo)
        }
        
        if ($this.Logger -and $candidates.Count -gt 0) {
            $this.Logger.Debug("ShortcutManager: Found $($candidates.Count) matching shortcuts")
        }
        
        # Filter by scope
        $applicable = @()
        foreach ($shortcut in $candidates) {
            if ($this.Logger) {
                $this.Logger.Debug("Checking shortcut: $($shortcut.Id) Scope=$($shortcut.Scope) ScreenType=$($shortcut.ScreenType)")
            }
            
            switch ($shortcut.Scope) {
                ([ShortcutScope]::Global) {
                    $applicable += $shortcut
                }
                ([ShortcutScope]::Screen) {
                    if ($shortcut.ScreenType -eq $currentScreen -or 
                        [string]::IsNullOrEmpty($shortcut.ScreenType)) {
                        if ($this.Logger) {
                            $this.Logger.Debug("Screen shortcut matches: $($shortcut.Id)")
                        }
                        $applicable += $shortcut
                    }
                }
                ([ShortcutScope]::Context) {
                    if ($shortcut.Context -eq $currentContext -or
                        [string]::IsNullOrEmpty($shortcut.Context)) {
                        $applicable += $shortcut
                    }
                }
            }
        }
        
        # Execute the highest priority applicable shortcut
        if ($applicable.Count -gt 0) {
            $shortcut = $applicable[0]  # Already sorted by priority
            
            if ($this.Logger) {
                $this.Logger.Debug("Executing shortcut: $($shortcut.Id)")
            }
            
            # Publish event before execution
            if ($this.EventBus) {
                $this.EventBus.Publish('shortcut.executing', @{
                    ShortcutId = $shortcut.Id
                    Key = $keyInfo
                })
            }
            
            try {
                # Execute the action
                & $shortcut.Action
                
                # Publish success event
                if ($this.EventBus) {
                    $this.EventBus.Publish('shortcut.executed', @{
                        ShortcutId = $shortcut.Id
                        Key = $keyInfo
                    })
                }
                
                return $true
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Error executing shortcut $($shortcut.Id): $_")
                }
                return $false
            }
        }
        
        return $false
    }
    
    [ShortcutDefinition[]] GetShortcuts([ShortcutScope]$scope, [string]$screenType) {
        return $this.Shortcuts | Where-Object {
            $_.Scope -eq $scope -and
            ($_.ScreenType -eq $screenType -or [string]::IsNullOrEmpty($_.ScreenType))
        }
    }
    
    [ShortcutDefinition[]] GetAllShortcuts() {
        return $this.Shortcuts
    }
    
    [hashtable] GetShortcutMap() {
        # Returns a hashtable for easy display in UI
        $map = @{}
        
        foreach ($shortcut in $this.Shortcuts) {
            $key = $shortcut.GetDisplayText()
            if (-not $map.ContainsKey($key)) {
                $map[$key] = @()
            }
            $map[$key] += @{
                Name = $shortcut.Name
                Description = $shortcut.Description
                Scope = $shortcut.Scope
                ScreenType = $shortcut.ScreenType
            }
        }
        
        return $map
    }
    
    [void] EnableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $true
        }
    }
    
    [void] DisableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $false
        }
    }
    
    [string] GetShortcutHelp([ShortcutScope]$scope = [ShortcutScope]::Global, [string]$screenType = "") {
        $sb = [System.Text.StringBuilder]::new()
        $shortcutList = $this.GetShortcuts($scope, $screenType)
        
        if ($shortcutList.Count -gt 0) {
            $grouped = $shortcutList | Group-Object { $_.GetDisplayText() }
            
            foreach ($group in $grouped | Sort-Object Name) {
                $sb.AppendLine("$($group.Name):")
                foreach ($shortcut in $group.Group) {
                    $sb.AppendLine("  - $($shortcut.Name): $($shortcut.Description)")
                }
            }
        }
        
        return $sb.ToString()
    }
}


####\_Backup/20250726_003635/Services/SimpleShortcutHandler.ps1
# SimpleShortcutHandler.ps1 - Direct keyboard shortcuts via EventBus

class SimpleShortcutHandler {
    hidden [EventBus]$EventBus
    hidden [Logger]$Logger
    
    [void] Initialize([ServiceContainer]$container) {
        $this.EventBus = $container.GetService('EventBus')
        $this.Logger = $container.GetService('Logger')
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen) {
        # Only handle character keys when no modifiers are pressed
        if ($keyInfo.Modifiers -ne [System.ConsoleModifiers]::None) {
            return $false
        }
        
        $char = [char]::ToLower($keyInfo.KeyChar)
        
        # Handle shortcuts based on current screen
        switch ($currentScreen) {
            "ProjectsScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewProject', 'ProjectsScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditProject', 'ProjectsScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteProject', 'ProjectsScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshProjects', 'ProjectsScreen')
                        return $true
                    }
                    'v' {
                        $this.PublishCommand('ViewProject', 'ProjectsScreen')
                        return $true
                    }
                }
            }
            "TaskScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewTask', 'TaskScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditTask', 'TaskScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteTask', 'TaskScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshTasks', 'TaskScreen')
                        return $true
                    }
                }
            }
        }
        
        return $false
    }
    
    hidden [void] PublishCommand([string]$command, [string]$target) {
        if ($this.Logger) {
            $this.Logger.Debug("SimpleShortcutHandler: Publishing command $command for $target")
        }
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::CommandExecuted, @{
                Command = $command
                Target = $target
            })
        }
    }
}


####\_Backup/20250726_003635/Services/StateManager.ps1
# StateManager.ps1 - Fast, robust, PowerShell-native state management
# Based on AxiomPhoenix patterns with PRAXIS optimizations

class StateManager {
    # Core state storage - PowerShell hashtables for maximum speed
    hidden [hashtable]$_state = @{}
    hidden [hashtable]$_subscribers = @{}
    hidden [hashtable]$_indexes = @{}
    
    # Performance optimization
    hidden [System.Collections.Generic.Dictionary[string, object]]$_fastIndex
    hidden [bool]$_isDirty = $false
    hidden [datetime]$_lastSave = [datetime]::MinValue
    
    # Transaction support
    hidden [int]$_transactionDepth = 0
    hidden [bool]$_pendingSave = $false
    hidden [hashtable]$_transactionChanges = @{}
    
    # Event integration
    [EventBus]$EventBus
    [Logger]$Logger
    
    # Configuration
    [string]$StatePath = ""
    [bool]$AutoSave = $true
    [int]$AutoSaveIntervalMs = 5000
    [int]$MaxBackups = 5
    [bool]$EnableCompression = $true
    
    # Performance metrics
    hidden [int]$_getOperations = 0
    hidden [int]$_setOperations = 0
    hidden [datetime]$_lastStatsReset = [datetime]::Now
    
    StateManager() {
        $this._fastIndex = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.InitializeDefaultState()
    }
    
    [void] Initialize([ServiceContainer]$services) {
        try {
            # Get required services
            $this.EventBus = $services.GetService("EventBus")
            $this.Logger = $services.GetService("Logger")
            
            # Set default state path
            if ([string]::IsNullOrEmpty($this.StatePath)) {
                $praxisRoot = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PWD }
                $this.StatePath = Join-Path $praxisRoot "_State/application.json"
            }
            
            # Ensure state directory exists
            $stateDir = Split-Path $this.StatePath -Parent
            if (-not (Test-Path $stateDir)) {
                New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
            }
            
            # Load existing state
            $this.LoadState()
            
            # Start auto-save if enabled
            if ($this.AutoSave) {
                $this.StartAutoSave()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager initialized: Path=$($this.StatePath), AutoSave=$($this.AutoSave)")
            }
            
        } catch {
            $this.LogError("StateManager initialization failed", @{ Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== CORE STATE OPERATIONS ====================
    
    # FAST: Direct hashtable access with error handling
    [object] GetState([string]$key) {
        return $this.GetState($key, $null)
    }
    
    [object] GetState([string]$key, [object]$defaultValue) {
        if ([string]::IsNullOrEmpty($key)) {
            return $defaultValue
        }
        
        try {
            $this._getOperations++
            
            # Try fast index first (Dictionary lookup - microseconds)
            if ($this._fastIndex.ContainsKey($key)) {
                return $this._fastIndex[$key]
            }
            
            # Fall back to dot-notation path traversal
            $keys = $key -split '\.'
            $current = $this._state
            
            foreach ($k in $keys) {
                if ($current -eq $null -or -not $current.ContainsKey($k)) {
                    return $defaultValue
                }
                $current = $current[$k]
            }
            
            # Cache in fast index for next time
            $this._fastIndex[$key] = $current
            
            return if ($current -eq $null) { $defaultValue } else { $current }
            
        } catch {
            $this.LogError("GetState failed", @{ Key = $key; Error = $_.Exception.Message })
            return $defaultValue
        }
    }
    
    # FAST: Direct state updates with smart change detection
    [void] SetState([string]$key, [object]$value) {
        $this.SetState($key, $value, $true)
    }
    
    [void] SetState([string]$key, [object]$value, [bool]$publishEvents) {
        if ([string]::IsNullOrEmpty($key)) {
            return
        }
        
        try {
            $this._setOperations++
            
            # Fast equality check to avoid unnecessary updates
            $currentValue = $this.GetState($key)
            if ($this.AreEqual($currentValue, $value)) {
                return  # No change, skip update
            }
            
            # Store old value for events
            $oldValue = $currentValue
            
            # Update both storage mechanisms
            $this.SetStateInternal($key, $value)
            $this._fastIndex[$key] = $value
            
            # Track transaction changes
            if ($this._transactionDepth -gt 0) {
                $this._transactionChanges[$key] = @{ 
                    NewValue = $value
                    OldValue = $oldValue 
                }
            }
            
            # Mark as dirty and trigger save
            $this.MarkDirty()
            
            # Publish change events
            if ($publishEvents -and $this.EventBus) {
                $this.PublishStateChange($key, $value, $oldValue)
            }
            
        } catch {
            $this.LogError("SetState failed", @{ Key = $key; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== TRANSACTION SUPPORT ====================
    
    [void] BeginTransaction() {
        $this._transactionDepth++
        if ($this._transactionDepth -eq 1) {
            $this._transactionChanges.Clear()
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Transaction started")
            }
        }
    }
    
    [void] EndTransaction() {
        if ($this._transactionDepth -gt 0) {
            $this._transactionDepth--
            
            # Process all changes when transaction completes
            if ($this._transactionDepth -eq 0) {
                try {
                    # Batch save
                    if ($this._pendingSave) {
                        $this.SaveState()
                        $this._pendingSave = $false
                    }
                    
                    # Batch event publishing
                    if ($this._transactionChanges.Count -gt 0 -and $this.EventBus) {
                        $this.EventBus.Publish("State.TransactionComplete", @{
                            Changes = $this._transactionChanges
                            ChangeCount = $this._transactionChanges.Count
                        })
                    }
                    
                    if ($this.Logger) {
                        $this.Logger.Debug("StateManager: Transaction completed with $($this._transactionChanges.Count) changes")
                    }
                    
                } catch {
                    $this.LogError("Transaction completion failed", @{ Error = $_.Exception.Message })
                    throw
                } finally {
                    $this._transactionChanges.Clear()
                }
            }
        }
    }
    
    [void] RollbackTransaction() {
        if ($this._transactionDepth -gt 0) {
            try {
                # Restore all changed values to their original state
                foreach ($change in $this._transactionChanges.GetEnumerator()) {
                    $key = $change.Key
                    $oldValue = $change.Value.OldValue
                    
                    # Directly restore without triggering events or new transaction tracking
                    $this.SetStateInternal($key, $oldValue)
                    $this._fastIndex[$key] = $oldValue
                }
                
                if ($this.Logger) {
                    $this.Logger.Debug("StateManager: Transaction rolled back, $($this._transactionChanges.Count) changes reverted")
                }
                
            } catch {
                $this.LogError("Transaction rollback failed", @{ Error = $_.Exception.Message })
                throw
            } finally {
                $this._transactionChanges.Clear()
                $this._transactionDepth = 0
                $this._pendingSave = $false
            }
        }
    }
    
    # ==================== PERSISTENCE ====================
    
    [void] LoadState() {
        if (-not (Test-Path $this.StatePath)) {
            if ($this.Logger) {
                $this.Logger.Info("StateManager: No existing state file, using defaults")
            }
            return
        }
        
        try {
            $json = Get-Content $this.StatePath -Raw -ErrorAction Stop
            if ([string]::IsNullOrEmpty($json)) {
                return
            }
            
            $data = $json | ConvertFrom-Json -AsHashtable -ErrorAction Stop
            if ($data -and $data.ContainsKey("State")) {
                $this._state = $data.State
                $this.RebuildFastIndex()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager: State loaded successfully from $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to load state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            
            # Try to load from backup
            $this.LoadFromBackup()
        }
    }
    
    [void] SaveState() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Create backup before save
            $this.CreateBackup()
            
            # Prepare data for serialization
            $data = @{
                State = $this._state
                Metadata = @{
                    Version = "1.0.0"
                    SavedAt = [datetime]::Now.ToString('o')
                    StateKeys = @($this._state.Keys)
                    FastIndexKeys = @($this._fastIndex.Keys) 
                    Stats = @{
                        GetOperations = $this._getOperations
                        SetOperations = $this._setOperations
                    }
                }
            }
            
            # Convert to JSON with compression option
            $jsonParams = @{
                Depth = 10
                Compress = $this.EnableCompression
            }
            $json = $data | ConvertTo-Json @jsonParams
            
            # Atomic write (write to temp file, then replace)
            $tempPath = "$($this.StatePath).tmp"
            [System.IO.File]::WriteAllText($tempPath, $json, [System.Text.Encoding]::UTF8)
            Move-Item $tempPath $this.StatePath -Force
            
            # Update tracking
            $this._isDirty = $false
            $this._lastSave = [datetime]::Now
            
            # Publish save event
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Saved", @{
                    Path = $this.StatePath
                    StateKeyCount = $data.Metadata.StateKeys.Count
                    SaveTime = $this._lastSave
                })
            }
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: State saved to $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to save state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== PERFORMANCE OPTIMIZATIONS ====================
    
    [void] RebuildFastIndex() {
        try {
            $this._fastIndex.Clear()
            $this.BuildFastIndexRecursive("", $this._state)
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Fast index rebuilt with $($this._fastIndex.Count) entries")
            }
            
        } catch {
            $this.LogError("Fast index rebuild failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] BuildFastIndexRecursive([string]$prefix, [hashtable]$data) {
        foreach ($key in $data.Keys) {
            $fullKey = if ($prefix) { "$prefix.$key" } else { $key }
            $value = $data[$key]
            
            # Add to fast index
            $this._fastIndex[$fullKey] = $value
            
            # Recurse into nested hashtables
            if ($value -is [hashtable]) {
                $this.BuildFastIndexRecursive($fullKey, $value)
            }
        }
    }
    
    [bool] AreEqual([object]$a, [object]$b) {
        # Fast reference equality check first
        if ([object]::ReferenceEquals($a, $b)) {
            return $true
        }
        
        # Null checks
        if ($a -eq $null -or $b -eq $null) {
            return ($a -eq $null -and $b -eq $null)
        }
        
        # Use PowerShell's efficient comparison
        try {
            # For complex objects, try Equals method first
            if ($a.GetType().GetMethod("Equals", @([object]))) {
                return $a.Equals($b)
            }
            
            # Fall back to PowerShell comparison
            return $a -eq $b
            
        } catch {
            # If comparison fails, assume not equal
            return $false
        }
    }
    
    # ==================== EVENT SYSTEM ====================
    
    [void] OnStateChanged([string]$pattern, [scriptblock]$handler) {
        if ([string]::IsNullOrEmpty($pattern) -or $handler -eq $null) {
            return
        }
        
        try {
            if (-not $this._subscribers.ContainsKey($pattern)) {
                $this._subscribers[$pattern] = @()
            }
            
            $this._subscribers[$pattern] += $handler
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Subscriber added for pattern '$pattern'")
            }
            
        } catch {
            $this.LogError("Failed to add state subscriber", @{ Pattern = $pattern; Error = $_.Exception.Message })
        }
    }
    
    hidden [void] PublishStateChange([string]$key, [object]$newValue, [object]$oldValue) {
        if ($this._transactionDepth -gt 0) {
            return  # Don't publish during transactions
        }
        
        try {
            # Publish to EventBus
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Changed", @{
                    Key = $key
                    NewValue = $newValue
                    OldValue = $oldValue
                    Timestamp = [datetime]::Now
                })
            }
            
            # Publish to pattern subscribers
            foreach ($pattern in $this._subscribers.Keys) {
                if ($this.MatchesPattern($key, $pattern)) {
                    foreach ($handler in $this._subscribers[$pattern]) {
                        try {
                            & $handler @{
                                Key = $key
                                NewValue = $newValue
                                OldValue = $oldValue
                            }
                        } catch {
                            $this.LogError("State subscriber handler failed", @{ 
                                Pattern = $pattern
                                Key = $key
                                Error = $_.Exception.Message 
                            })
                        }
                    }
                }
            }
            
        } catch {
            $this.LogError("Failed to publish state change", @{ Key = $key; Error = $_.Exception.Message })
        }
    }
    
    [bool] MatchesPattern([string]$key, [string]$pattern) {
        # Simple wildcard pattern matching
        if ($pattern -eq "*") {
            return $true
        }
        
        if ($pattern.EndsWith("*")) {
            $prefix = $pattern.Substring(0, $pattern.Length - 1)
            return $key.StartsWith($prefix)
        }
        
        return $key -eq $pattern
    }
    
    # ==================== INTERNAL HELPERS ====================
    
    [void] InitializeDefaultState() {
        $this._state = @{
            app = @{
                version = "1.0.0"
                startTime = [datetime]::Now
                sessionId = [System.Guid]::NewGuid().ToString()
            }
            ui = @{
                currentScreen = ""
                selectedItems = @{}
                viewStates = @{}
            }
            data = @{
                projects = @{}
                tasks = @{}
                config = @{}
            }
        }
        
        $this.RebuildFastIndex()
    }
    
    hidden [void] SetStateInternal([string]$key, [object]$value) {
        $keys = $key -split '\.'
        $current = $this._state
        
        # Navigate to parent container
        for ($i = 0; $i -lt $keys.Count - 1; $i++) {
            $k = $keys[$i]
            if (-not $current.ContainsKey($k)) {
                $current[$k] = @{}
            }
            $current = $current[$k]
        }
        
        # Set the final value
        $finalKey = $keys[-1]
        $current[$finalKey] = $value
    }
    
    [void] MarkDirty() {
        $this._isDirty = $true
        
        if ($this._transactionDepth -gt 0) {
            $this._pendingSave = $true
        } elseif ($this.AutoSave) {
            # Immediate save for non-transaction updates
            $this.SaveState()
        }
    }
    
    hidden [void] CreateBackup() {
        if (-not (Test-Path $this.StatePath)) {
            return
        }
        
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
            }
            
            $timestamp = [datetime]::Now.ToString("yyyyMMdd_HHmmss")
            $backupPath = Join-Path $backupDir "application_$timestamp.json"
            
            Copy-Item $this.StatePath $backupPath
            
            # Clean old backups
            $this.CleanOldBackups($backupDir)
            
        } catch {
            $this.LogError("Backup creation failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] CleanOldBackups([string]$backupDir) {
        try {
            $backups = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending
            
            if ($backups.Count -gt $this.MaxBackups) {
                $toDelete = $backups | Select-Object -Skip $this.MaxBackups
                foreach ($file in $toDelete) {
                    Remove-Item $file.FullName -Force
                }
            }
            
        } catch {
            $this.LogError("Backup cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] LoadFromBackup() {
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                return
            }
            
            $latestBackup = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending | Select-Object -First 1
            
            if ($latestBackup) {
                $json = Get-Content $latestBackup.FullName -Raw
                $data = $json | ConvertFrom-Json -AsHashtable
                
                if ($data -and $data.ContainsKey("State")) {
                    $this._state = $data.State
                    $this.RebuildFastIndex()
                    
                    if ($this.Logger) {
                        $this.Logger.Info("StateManager: Recovered from backup: $($latestBackup.Name)")
                    }
                }
            }
            
        } catch {
            $this.LogError("Backup recovery failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] StartAutoSave() {
        # Note: PowerShell doesn't have great built-in timer support
        # This could be enhanced with System.Timers.Timer if needed
        # For now, auto-save happens on each SetState call
    }
    
    hidden [void] LogError([string]$message, [hashtable]$context = @{}) {
        if ($this.Logger) {
            $this.Logger.Error("$message - Context: $($context | ConvertTo-Json -Compress)")
        }
    }
    
    # ==================== PUBLIC API METHODS ====================
    
    [hashtable] GetPerformanceStats() {
        $uptime = [datetime]::Now - $this._lastStatsReset
        
        return @{
            GetOperations = $this._getOperations
            SetOperations = $this._setOperations
            FastIndexSize = $this._fastIndex.Count
            StateKeyCount = $this._state.Keys.Count
            TransactionDepth = $this._transactionDepth
            IsDirty = $this._isDirty
            LastSave = $this._lastSave
            Uptime = $uptime.ToString()
            OperationsPerSecond = if ($uptime.TotalSeconds -gt 0) { ($this._getOperations + $this._setOperations) / $uptime.TotalSeconds } else { 0 }
        }
    }
    
    [void] ResetPerformanceStats() {
        $this._getOperations = 0
        $this._setOperations = 0
        $this._lastStatsReset = [datetime]::Now
    }
    
    [void] ClearState() {
        $this.BeginTransaction()
        try {
            $this._state.Clear()
            $this._fastIndex.Clear()
            $this.InitializeDefaultState()
            
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Cleared", @{ Timestamp = [datetime]::Now })
            }
            
        } finally {
            $this.EndTransaction()
        }
    }
    
    [void] Cleanup() {
        try {
            if ($this._isDirty) {
                $this.SaveState()
            }
            
            $this._subscribers.Clear()
            $this._fastIndex.Clear()
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager cleanup completed")
            }
            
        } catch {
            $this.LogError("Cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
}


####\_Backup/20250726_003635/Services/SubtaskService.ps1
# SubtaskService.ps1 - Service for managing subtasks

class SubtaskService {
    [System.Collections.Generic.List[Subtask]]$Subtasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    SubtaskService() {
        $this.Subtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "subtasks.json"
        
        # Load existing subtasks
        $this.Load()
    }
    
    # CRUD Operations
    [Subtask] AddSubtask([string]$parentTaskId, [string]$title) {
        $subtask = [Subtask]::new($parentTaskId)
        $subtask.Title = $title
        
        # Set sort order to be last among siblings
        $siblings = $this.GetSubtasksForTask($parentTaskId)
        if ($siblings.Count -gt 0) {
            $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
            $subtask.SortOrder = $maxOrder + 1
        } else {
            $subtask.SortOrder = 0
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] CreateSubtask([hashtable]$properties) {
        $subtask = [Subtask]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($key -eq 'Progress') {
                # Use UpdateProgress to auto-handle status changes
                $subtask.UpdateProgress($properties[$key])
            } elseif ($subtask.PSObject.Properties.Name -contains $key) {
                $subtask.$key = $properties[$key]
            }
        }
        
        # Ensure sort order is set
        if (-not $properties.ContainsKey('SortOrder')) {
            $siblings = $this.GetSubtasksForTask($subtask.ParentTaskId)
            if ($siblings.Count -gt 0) {
                $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
                $subtask.SortOrder = $maxOrder + 1
            } else {
                $subtask.SortOrder = 0
            }
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] GetSubtask([string]$id) {
        return $this.Subtasks | Where-Object { $_.Id -eq $id -and -not $_.Deleted } | Select-Object -First 1
    }
    
    [System.Collections.Generic.List[Subtask]] GetSubtasksForTask([string]$parentTaskId) {
        $taskSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if ($subtask.ParentTaskId -eq $parentTaskId -and -not $subtask.Deleted) {
                $taskSubtasks.Add($subtask)
            }
        }
        
        # Sort by SortOrder
        return $taskSubtasks | Sort-Object SortOrder
    }
    
    [System.Collections.Generic.List[Subtask]] GetAllSubtasks() {
        $activeSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if (-not $subtask.Deleted) {
                $activeSubtasks.Add($subtask)
            }
        }
        
        return $activeSubtasks
    }
    
    [void] UpdateSubtask([Subtask]$subtask) {
        $existingSubtask = $this.GetSubtask($subtask.Id)
        if ($existingSubtask) {
            $existingSubtask.Title = $subtask.Title
            $existingSubtask.Description = $subtask.Description
            $existingSubtask.Status = $subtask.Status
            $existingSubtask.Priority = $subtask.Priority
            $existingSubtask.UpdateProgress($subtask.Progress)  # Use UpdateProgress to auto-handle status
            $existingSubtask.DueDate = $subtask.DueDate
            $existingSubtask.Tags = $subtask.Tags
            $existingSubtask.EstimatedMinutes = $subtask.EstimatedMinutes
            $existingSubtask.ActualMinutes = $subtask.ActualMinutes
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] DeleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Deleted = $true
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] CompleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Status = [TaskStatus]::Completed
            $subtask.Progress = 100
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] ReorderSubtasks([string]$parentTaskId, [string[]]$subtaskIds) {
        $sortOrder = 0
        foreach ($subtaskId in $subtaskIds) {
            $subtask = $this.GetSubtask($subtaskId)
            if ($subtask -and $subtask.ParentTaskId -eq $parentTaskId) {
                $subtask.SortOrder = $sortOrder
                $subtask.UpdatedAt = Get-Date
                $sortOrder++
            }
        }
        $this._isDirty = $true
        $this.Save()
    }
    
    # Calculate parent task progress based on subtask completion
    [int] CalculateTaskProgress([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        if ($taskSubtasks.Count -eq 0) {
            return 0
        }
        
        $totalProgress = 0
        foreach ($subtask in $taskSubtasks) {
            $totalProgress += $subtask.Progress
        }
        
        return [Math]::Floor($totalProgress / $taskSubtasks.Count)
    }
    
    [hashtable] GetTaskStatistics([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        $stats = @{
            Total = $taskSubtasks.Count
            Completed = 0
            InProgress = 0
            Pending = 0
            Overdue = 0
            EstimatedMinutes = 0
            ActualMinutes = 0
        }
        
        foreach ($subtask in $taskSubtasks) {
            switch ($subtask.Status) {
                ([TaskStatus]::Completed) { $stats.Completed++ }
                ([TaskStatus]::InProgress) { $stats.InProgress++ }
                ([TaskStatus]::Pending) { $stats.Pending++ }
            }
            
            if ($subtask.IsOverdue()) {
                $stats.Overdue++
            }
            
            $stats.EstimatedMinutes += $subtask.EstimatedMinutes
            $stats.ActualMinutes += $subtask.ActualMinutes
        }
        
        return $stats
    }
    
    # Data persistence
    [void] Save() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Convert to serializable format
            $data = @()
            foreach ($subtask in $this.Subtasks) {
                $data += @{
                    Id = $subtask.Id
                    ParentTaskId = $subtask.ParentTaskId
                    Title = $subtask.Title
                    Description = $subtask.Description
                    Status = [int]$subtask.Status
                    Priority = [int]$subtask.Priority
                    Progress = $subtask.Progress
                    SortOrder = $subtask.SortOrder
                    Tags = $subtask.Tags
                    DueDate = if ($subtask.DueDate -eq [DateTime]::MinValue) { "" } else { $subtask.DueDate.ToString("yyyy-MM-ddTHH:mm:ss") }
                    CreatedAt = $subtask.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    UpdatedAt = $subtask.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    EstimatedMinutes = $subtask.EstimatedMinutes
                    ActualMinutes = $subtask.ActualMinutes
                    Deleted = $subtask.Deleted
                }
            }
            
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to save subtasks: $($_.Exception.Message)"
        }
    }
    
    [void] Load() {
        if (-not (Test-Path $this.DataPath)) {
            return
        }
        
        try {
            $json = Get-Content -Path $this.DataPath -Raw -Encoding UTF8
            $data = $json | ConvertFrom-Json
            
            $this.Subtasks.Clear()
            
            foreach ($item in $data) {
                $subtask = [Subtask]::new()
                $subtask.Id = $item.Id
                $subtask.ParentTaskId = $item.ParentTaskId
                $subtask.Title = $item.Title
                $subtask.Description = $item.Description
                $subtask.Status = [TaskStatus]$item.Status
                $subtask.Priority = [TaskPriority]$item.Priority
                $subtask.Progress = $item.Progress
                $subtask.SortOrder = $item.SortOrder
                $subtask.Tags = $item.Tags
                $subtask.DueDate = if ([string]::IsNullOrEmpty($item.DueDate)) { [DateTime]::MinValue } else { [DateTime]::Parse($item.DueDate) }
                $subtask.CreatedAt = [DateTime]::Parse($item.CreatedAt)
                $subtask.UpdatedAt = [DateTime]::Parse($item.UpdatedAt)
                $subtask.EstimatedMinutes = if ($item.PSObject.Properties.Name -contains 'EstimatedMinutes') { $item.EstimatedMinutes } else { 0 }
                $subtask.ActualMinutes = if ($item.PSObject.Properties.Name -contains 'ActualMinutes') { $item.ActualMinutes } else { 0 }
                $subtask.Deleted = if ($item.PSObject.Properties.Name -contains 'Deleted') { $item.Deleted } else { $false }
                
                $this.Subtasks.Add($subtask)
            }
            
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to load subtasks: $($_.Exception.Message)"
        }
    }
}


####\_Backup/20250726_003635/Services/TaskService.ps1
# TaskService.ps1 - Service for managing tasks

class TaskService {
    [System.Collections.Generic.List[Task]]$Tasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    TaskService() {
        $this.Tasks = [System.Collections.Generic.List[Task]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "tasks.json"
        
        # Load existing tasks
        $this.Load()
    }
    
    # CRUD Operations
    [Task] AddTask([string]$title, [string]$projectId) {
        $task = [Task]::new()
        $task.Title = $title
        $task.ProjectId = $projectId
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] CreateTask([hashtable]$properties) {
        $task = [Task]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($task.PSObject.Properties.Name -contains $key) {
                $task.$key = $properties[$key]
            }
        }
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] GetTask([string]$id) {
        return $this.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Task[]] GetAllTasks() {
        return $this.Tasks.ToArray()
    }
    
    [Task[]] GetTasksByProject([string]$projectId) {
        return $this.Tasks | Where-Object { $_.ProjectId -eq $projectId -and -not $_.Deleted }
    }
    
    [Task[]] GetActiveTasks() {
        return $this.Tasks | Where-Object { 
            -not $_.Deleted -and 
            $_.Status -ne [TaskStatus]::Completed -and 
            $_.Status -ne [TaskStatus]::Cancelled 
        }
    }
    
    [void] UpdateTask([Task]$task) {
        $task.MarkAsUpdated()  # Use BaseModel method
        $this._isDirty = $true
        $this.Save()
    }
    
    [void] DeleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.SoftDelete()  # Use BaseModel method
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Status management
    [void] UpdateTaskStatus([string]$id, [TaskStatus]$status) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.Status = $status
            $task.MarkAsUpdated()  # Use BaseModel method
            
            # Auto-update progress
            if ($status -eq [TaskStatus]::Completed) {
                $task.Progress = 100
            } elseif ($status -eq [TaskStatus]::Pending) {
                $task.Progress = 0
            }
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Priority management
    [void] CyclePriority([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            switch ($task.Priority) {
                ([TaskPriority]::Low) { $task.Priority = [TaskPriority]::Medium }
                ([TaskPriority]::Medium) { $task.Priority = [TaskPriority]::High }
                ([TaskPriority]::High) { $task.Priority = [TaskPriority]::Low }
            }
            $task.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Persistence
    [void] Save() {
        if (-not $this._isDirty) { return }
        
        try {
            $json = $this.Tasks | ConvertTo-Json -Depth 10
            $json | Set-Content -Path $this.DataPath -Encoding UTF8
            $this._isDirty = $false
            
            if ($global:Logger) {
                $global:Logger.Debug("TaskService: Saved $($this.Tasks.Count) tasks")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TaskService: Failed to save tasks: $_")
            }
        }
    }
    
    [void] Load() {
        if (Test-Path $this.DataPath) {
            try {
                $json = Get-Content -Path $this.DataPath -Raw
                $data = $json | ConvertFrom-Json
                
                $this.Tasks.Clear()
                foreach ($item in $data) {
                    $task = [Task]::new()
                    
                    # Map properties
                    $task.Id = $item.Id
                    $task.Title = $item.Title
                    $task.Description = $item.Description
                    $task.Status = [TaskStatus]$item.Status
                    $task.Priority = [TaskPriority]$item.Priority
                    $task.Progress = $item.Progress
                    $task.ProjectId = $item.ProjectId
                    $task.Tags = $item.Tags
                    $task.DueDate = if ($item.DueDate) { [DateTime]$item.DueDate } else { [DateTime]::MinValue }
                    $task.CreatedAt = [DateTime]$item.CreatedAt
                    $task.UpdatedAt = [DateTime]$item.UpdatedAt
                    $task.Deleted = $item.Deleted
                    
                    $this.Tasks.Add($task)
                }
                
                if ($global:Logger) {
                    $global:Logger.Debug("TaskService: Loaded $($this.Tasks.Count) tasks")
                }
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("TaskService: Failed to load tasks: $_")
                }
                # Start with empty list on error
                $this.Tasks.Clear()
            }
        } else {
            # Create sample tasks for testing
            $this.CreateSampleTasks()
        }
    }
    
    hidden [void] CreateSampleTasks() {
        # Create a few sample tasks
        $task1 = $this.AddTask("Implement user authentication", "")
        $task1.Description = "Add login/logout functionality with session management"
        $task1.Priority = [TaskPriority]::High
        $task1.Status = [TaskStatus]::InProgress
        $task1.Progress = 45
        
        $task2 = $this.AddTask("Write API documentation", "")
        $task2.Description = "Document all REST endpoints with examples"
        $task2.Priority = [TaskPriority]::Medium
        $task2.DueDate = (Get-Date).AddDays(7)
        
        $task3 = $this.AddTask("Fix navigation bug", "")
        $task3.Description = "Users report navigation not working after login"
        $task3.Priority = [TaskPriority]::High
        $task3.Status = [TaskStatus]::Completed
        $task3.Progress = 100
        
        $this.Save()
    }
}


####\_Backup/20250726_003635/Services/ThemeManager.ps1
# ThemeManager.ps1 - Fast theme management with pre-cached ANSI sequences
# All colors are pre-computed to avoid runtime lookups

class ThemeManager {
    hidden [hashtable]$_themes = @{}
    hidden [string]$_currentTheme = "default"
    hidden [hashtable]$_cache = @{}
    hidden [System.Collections.Generic.List[scriptblock]]$_listeners
    hidden [EventBus]$EventBus
    
    ThemeManager() {
        $this._listeners = [System.Collections.Generic.List[scriptblock]]::new()
        $this.InitializeDefaultTheme()
        
        # EventBus will be set later via SetEventBus
    }
    
    [void] InitializeDefaultTheme() {
        # Define default theme with RGB values
        $defaultTheme = @{
            # Base colors
            "background" = @(24, 24, 24)        # Dark background
            "foreground" = @(204, 204, 204)     # Light gray text
            "accent" = @(0, 150, 255)           # Blue accent
            "success" = @(0, 200, 83)           # Green
            "warning" = @(255, 195, 0)          # Yellow
            "error" = @(255, 85, 85)            # Red
            
            # UI elements
            "border" = @(68, 68, 68)           # Dark gray
            "border.focused" = @(0, 150, 255)   # Blue
            "selection" = @(60, 60, 60)         # Selection background
            "disabled" = @(128, 128, 128)       # Gray
            
            # Generic component colors (for backward compatibility)
            "title" = @(0, 150, 255)              # Blue titles
            "normal" = @(204, 204, 204)           # Normal text
            "selected" = @(60, 60, 60)            # Alias for selection
            
            # Component specific
            "button.background" = @(48, 48, 48)
            "button.foreground" = @(204, 204, 204)
            "button.focused.background" = @(0, 150, 255)
            "button.focused.foreground" = @(255, 255, 255)
            
            "input.background" = @(32, 32, 32)
            "input.foreground" = @(204, 204, 204)
            "input.focused.border" = @(0, 150, 255)
            
            "menu.background" = @(32, 32, 32)
            "menu.foreground" = @(204, 204, 204)
            "menu.selected.background" = @(0, 150, 255)
            "menu.selected.foreground" = @(255, 255, 255)
            
            "tab.background" = @(48, 48, 48)
            "tab.foreground" = @(170, 170, 170)
            "tab.active.background" = @(24, 24, 24)
            "tab.active.foreground" = @(255, 255, 255)
            "tab.active.accent" = @(0, 150, 255)
            
            # DataGrid specific colors
            "header.background" = @(48, 48, 48)
            "header.foreground" = @(0, 150, 255)
            "scrollbar" = @(68, 68, 68)
            "scrollbar.thumb" = @(128, 128, 128)
            
            # Additional component colors
            "checkbox" = @(0, 150, 255)
            "checkbox.selected" = @(0, 200, 255)
            "search" = @(255, 195, 0)
            "highlight" = @(255, 255, 0)
            "directory" = @(0, 150, 255)
            "file" = @(204, 204, 204)
            "input.border" = @(68, 68, 68)
            "input.placeholder" = @(128, 128, 128)
            "progress.active" = @(0, 150, 255)
            "progress.complete" = @(0, 200, 83)
            "progress.text" = @(204, 204, 204)
        }
        
        $this.RegisterTheme("default", $defaultTheme)
        
        # Define matrix theme - black background with green text
        $matrixTheme = @{
            # Base colors
            "background" = @(0, 0, 0)             # Pure black background
            "foreground" = @(0, 255, 0)           # Bright green text
            "accent" = @(0, 200, 0)               # Darker green accent
            "success" = @(0, 255, 0)              # Bright green
            "warning" = @(255, 255, 0)            # Yellow
            "error" = @(255, 0, 0)                # Red
            
            # UI elements
            "border" = @(0, 100, 0)               # Dark green borders
            "border.focused" = @(0, 255, 0)       # Bright green when focused
            "selection" = @(0, 100, 0)            # Dark green selection - more visible
            "disabled" = @(0, 128, 0)             # Medium green for disabled
            
            # Generic component colors (for backward compatibility)
            "title" = @(0, 255, 0)                # Bright green for titles
            "normal" = @(0, 200, 0)               # Normal text (slightly dimmer green)
            "selected" = @(0, 100, 0)             # Alias for selection
            
            # Component specific
            "button.background" = @(0, 20, 0)
            "button.foreground" = @(0, 255, 0)
            "button.focused.background" = @(0, 100, 0)
            "button.focused.foreground" = @(0, 255, 0)
            
            "input.background" = @(0, 10, 0)
            "input.foreground" = @(0, 255, 0)
            "input.focused.border" = @(0, 255, 0)
            
            "menu.background" = @(0, 0, 0)
            "menu.foreground" = @(0, 200, 0)
            "menu.selected.background" = @(0, 80, 0)
            "menu.selected.foreground" = @(0, 255, 0)
            
            "tab.background" = @(0, 30, 0)
            "tab.foreground" = @(0, 150, 0)
            "tab.active.background" = @(0, 0, 0)
            "tab.active.foreground" = @(0, 255, 0)
            "tab.active.accent" = @(0, 255, 0)
            
            # DataGrid specific colors
            "header.background" = @(0, 30, 0)
            "header.foreground" = @(0, 255, 0)
            "scrollbar" = @(0, 100, 0)
            "scrollbar.thumb" = @(0, 150, 0)
            
            # Additional component colors
            "checkbox" = @(0, 255, 0)
            "checkbox.selected" = @(0, 255, 100)
            "search" = @(255, 255, 0)
            "highlight" = @(255, 255, 0)
            "directory" = @(0, 255, 0)
            "file" = @(0, 200, 0)
            "input.border" = @(0, 100, 0)
            "input.placeholder" = @(0, 128, 0)
            "progress.active" = @(0, 255, 0)
            "progress.complete" = @(0, 255, 0)
            "progress.text" = @(0, 200, 0)
            
            # Dialog colors
            "dialog.background" = @(0, 0, 0)
            "dialog.border" = @(0, 150, 0)
            "dialog.title" = @(0, 255, 0)
        }
        
        $this.RegisterTheme("matrix", $matrixTheme)
        $this.SetTheme("matrix")
    }
    
    # Register a new theme
    [void] RegisterTheme([string]$name, [hashtable]$colors) {
        $this._themes[$name] = $colors
        
        # If this is the current theme, rebuild cache
        if ($name -eq $this._currentTheme) {
            $this.RebuildCache()
        }
    }
    
    # Switch to a different theme
    [void] SetTheme([string]$name) {
        if (-not $this._themes.ContainsKey($name)) {
            throw "Theme '$name' not found"
        }
        
        $oldTheme = $this._currentTheme
        $this._currentTheme = $name
        $this.RebuildCache()
        
        # Notify via EventBus if available
        if ($this.EventBus) {
            $this.EventBus.Publish('app.themeChanged', @{
                OldTheme = $oldTheme
                NewTheme = $name
                ThemeManager = $this
            })
        }
        
        # Also notify legacy listeners for backward compatibility
        $this.NotifyListeners()
    }
    
    # Get pre-computed ANSI color sequence
    [string] GetColor([string]$key) {
        if ($this._cache.ContainsKey($key)) {
            return $this._cache[$key]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$key] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get background color sequence
    [string] GetBgColor([string]$key) {
        $bgKey = "$key.bg"
        if ($this._cache.ContainsKey($bgKey)) {
            return $this._cache[$bgKey]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$bgKey] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get raw RGB values
    [int[]] GetRGB([string]$key) {
        $theme = $this._themes[$this._currentTheme]
        
        if ($theme.ContainsKey($key)) {
            return $theme[$key]
        }
        
        # Try parent keys (e.g., "button" for "button.focused.background")
        $parts = $key -split '\.'
        for ($i = $parts.Count - 1; $i -gt 0; $i--) {
            $parentKey = $parts[0..($i-1)] -join '.'
            if ($theme.ContainsKey($parentKey)) {
                return $theme[$parentKey]
            }
        }
        
        return $null
    }
    
    # Rebuild the entire cache
    hidden [void] RebuildCache() {
        $this._cache.Clear()
        $theme = $this._themes[$this._currentTheme]
        
        # Pre-compute all theme colors
        foreach ($key in $theme.Keys) {
            $rgb = $theme[$key]
            if ($rgb -is [array] -and $rgb.Count -eq 3) {
                # Foreground
                $this._cache[$key] = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
                # Background
                $this._cache["$key.bg"] = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            }
        }
        
        # Add common combinations
        $this._cache["reset"] = [VT]::Reset()
        $this._cache["clear"] = [VT]::Clear()
        $this._cache["clearline"] = [VT]::ClearLine()
    }
    
    # Subscribe to theme changes (legacy method - use EventBus instead)
    [void] Subscribe([scriptblock]$callback) {
        # Always use legacy listeners for now to avoid initialization order issues
        # EventBus subscription happens too early
        $this._listeners.Add($callback)
    }
    
    # Notify all listeners of theme change (legacy method)
    hidden [void] NotifyListeners() {
        # Only notify legacy listeners if EventBus is not available
        if (-not $this.EventBus) {
            foreach ($listener in $this._listeners) {
                try {
                    & $listener
                } catch {
                    # Ignore listener errors
                }
            }
        }
    }
    
    # Set EventBus after initialization (called by ServiceContainer)
    [void] SetEventBus([EventBus]$eventBus) {
        $this.EventBus = $eventBus
    }
    
    # Get list of available themes
    [string[]] GetThemeNames() {
        return $this._themes.Keys | Sort-Object
    }
    
    # Get current theme name
    [string] GetCurrentTheme() {
        return $this._currentTheme
    }
}


####\_Backup/20250726_003635/Services/TimeTrackingService.ps1
# TimeTrackingService - Manages all time entries and calculations

class TimeTrackingService {
    [string]$DataPath
    [System.Collections.ArrayList]$TimeEntries
    [System.Collections.ArrayList]$TimeCodes
    [Logger]$Logger
    [EventBus]$EventBus
    [ProjectService]$ProjectService
    
    TimeTrackingService() {
        $this.TimeEntries = [System.Collections.ArrayList]::new()
        $this.TimeCodes = [System.Collections.ArrayList]::new()
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/timeentries.json"
        $this.LoadData()
        $this.InitializeCommonTimeCodes()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService("Logger")
        $this.EventBus = $container.GetService("EventBus")
        $this.ProjectService = $container.GetService("ProjectService")
    }
    
    [void] InitializeCommonTimeCodes() {
        # Add common codes if not already present
        $commonCodes = [TimeCode]::GetCommonCodes()
        foreach ($code in $commonCodes) {
            if (-not ($this.TimeCodes | Where-Object { $_.ID2 -eq $code.ID2 })) {
                $this.TimeCodes.Add($code) | Out-Null
            }
        }
    }
    
    [void] LoadData() {
        if (Test-Path $this.DataPath) {
            try {
                $data = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                
                # Load time entries
                if ($data.TimeEntries) {
                    foreach ($entry in $data.TimeEntries) {
                        $timeEntry = [TimeEntry]::new()
                        foreach ($prop in $entry.PSObject.Properties) {
                            if ($timeEntry.PSObject.Properties[$prop.Name]) {
                                $timeEntry.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeEntries.Add($timeEntry) | Out-Null
                    }
                }
                
                # Load time codes
                if ($data.TimeCodes) {
                    foreach ($code in $data.TimeCodes) {
                        $timeCode = [TimeCode]::new()
                        foreach ($prop in $code.PSObject.Properties) {
                            if ($timeCode.PSObject.Properties[$prop.Name]) {
                                $timeCode.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeCodes.Add($timeCode) | Out-Null
                    }
                }
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to load time tracking data: $_")
                }
            }
        }
    }
    
    [void] SaveData() {
        $data = @{
            TimeEntries = $this.TimeEntries
            TimeCodes = $this.TimeCodes
            LastUpdated = [DateTime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        }
        
        try {
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Time tracking data saved")
            }
        }
        catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save time tracking data: $_")
            }
        }
    }
    
    # Get or create time entry for a specific week and ID2
    [TimeEntry] GetOrCreateTimeEntry([string]$weekEndingFriday, [string]$id2) {
        $existing = $this.TimeEntries | Where-Object { 
            $_.WeekEndingFriday -eq $weekEndingFriday -and $_.ID2 -eq $id2 
        } | Select-Object -First 1
        
        if ($existing) {
            return $existing
        }
        
        # Create new entry
        $entry = [TimeEntry]::new($weekEndingFriday, $id2)
        
        # If it's a project ID2, populate project info
        if ($id2.Length -gt 5) {
            $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
            if ($project) {
                $entry.Name = $project.Nickname
                $entry.ID1 = $project.ID1
            }
        }
        
        $this.TimeEntries.Add($entry) | Out-Null
        return $entry
    }
    
    # Get entries for a specific week
    [TimeEntry[]] GetWeekEntries([string]$weekEndingFriday) {
        return $this.TimeEntries | Where-Object { $_.WeekEndingFriday -eq $weekEndingFriday }
    }
    
    # Get entries for current week
    [TimeEntry[]] GetCurrentWeekEntries() {
        $friday = $this.GetCurrentWeekFriday()
        return $this.GetWeekEntries($friday.ToString("yyyyMMdd"))
    }
    
    # Update time entry
    [void] UpdateTimeEntry([TimeEntry]$entry) {
        $entry.CalculateTotal()
        $entry.CalculateFiscalYear()
        $entry.UpdatedAt = [DateTime]::Now
        
        $this.SaveData()
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TimeEntryUpdated, $this, @{ TimeEntry = $entry })
        }
    }
    
    # Add hours for today
    [void] AddHoursForToday([string]$id2, [decimal]$hours, [string]$description = "") {
        $today = [DateTime]::Now
        $friday = $this.GetWeekFridayForDate($today)
        
        $entry = $this.GetOrCreateTimeEntry($friday.ToString("yyyyMMdd"), $id2)
        
        # Add hours to appropriate day
        switch ($today.DayOfWeek) {
            Monday { $entry.Monday += $hours }
            Tuesday { $entry.Tuesday += $hours }
            Wednesday { $entry.Wednesday += $hours }
            Thursday { $entry.Thursday += $hours }
            Friday { $entry.Friday += $hours }
            default {
                if ($this.Logger) {
                    $this.Logger.Warning("Cannot add time for weekend day")
                }
                return
            }
        }
        
        $this.UpdateTimeEntry($entry)
    }
    
    # Get Friday date for current week
    [DateTime] GetCurrentWeekFriday() {
        $today = [DateTime]::Now
        return $this.GetWeekFridayForDate($today)
    }
    
    # Get Friday date for any date's week
    [DateTime] GetWeekFridayForDate([DateTime]$date) {
        $friday = $date
        while ($friday.DayOfWeek -ne [DayOfWeek]::Friday) {
            if ($friday.DayOfWeek -eq [DayOfWeek]::Saturday) {
                $friday = $friday.AddDays(-1)
            } else {
                $friday = $friday.AddDays(1)
            }
        }
        return $friday
    }
    
    # Calculate total hours for a project
    [decimal] GetProjectTotalHours([string]$id2) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { $_.ID2 -eq $id2 }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Calculate fiscal year total for non-project code
    [decimal] GetFiscalYearTotal([string]$id2, [string]$fiscalYear) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { 
            $_.ID2 -eq $id2 -and $_.FiscalYear -eq $fiscalYear 
        }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Get current fiscal year string
    [string] GetCurrentFiscalYear() {
        $today = [DateTime]::Now
        if ($today.Month -ge 4) {
            return "$($today.Year)-$($today.Year + 1)"
        } else {
            return "$($today.Year - 1)-$($today.Year)"
        }
    }
    
    # Get all unique ID2s (both project and non-project)
    [string[]] GetAllID2s() {
        $id2s = @()
        
        # Add project ID2s
        $projects = $this.ProjectService.GetAllProjects() | Where-Object { -not $_.Deleted -and $_.ID2 }
        foreach ($project in $projects) {
            $id2s += $project.ID2
        }
        
        # Add time code ID2s
        foreach ($code in $this.TimeCodes) {
            if ($code.IsActive) {
                $id2s += $code.ID2
            }
        }
        
        return $id2s | Select-Object -Unique | Sort-Object
    }
    
    # Get display info for an ID2
    [hashtable] GetID2DisplayInfo([string]$id2) {
        # Check if it's a project
        $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($project) {
            return @{
                Name = $project.Nickname
                ID1 = $project.ID1
                ID2 = $id2
                IsProject = $true
            }
        }
        
        # It's a non-project code
        $timeCode = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        return @{
            Name = ""
            ID1 = ""
            ID2 = $id2
            IsProject = $false
            Description = if ($timeCode) { $timeCode.Description } else { "" }
        }
    }
    
    # Add or update time code
    [void] AddTimeCode([string]$id2, [string]$description = "") {
        $existing = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($existing) {
            $existing.Description = $description
            $existing.UpdatedAt = [DateTime]::Now
        } else {
            $code = [TimeCode]::new($id2, $description)
            $this.TimeCodes.Add($code) | Out-Null
        }
        $this.SaveData()
    }
}


####\Actions/AppendFieldAction.ps1
# AppendFieldAction.ps1 - Adds a calculated field to the database
# Core data cleaning action for Phase 0

class AppendFieldAction : BaseAction {
    AppendFieldAction() : base() {
        $this.Name = "Append Calculated Field"
        $this.Description = "Adds a new field based on a calculation or equation"
        $this.Category = "Data Cleaning"
        $this.Icon = ""
        
        $this.Consumes = @(
            @{
                Name = "fieldName"
                Type = "String"
                Description = "Name for the new field"
            },
            @{
                Name = "fieldEquation"
                Type = "String"
                Description = "IDEA equation for the field calculation"
            },
            @{
                Name = "fieldType"
                Type = "String"
                Description = "Data type: Character, Numeric, Date, Logical"
            },
            @{
                Name = "fieldLength"
                Type = "String"
                Description = "Field length (optional, for Character fields)"
            }
        )
        
        $this.Produces = @(
            @{
                Name = "newField"
                Type = "Field"
                Description = "The newly created field"
            }
        )
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        $fieldName = $macroContext["fieldName"]
        $equation = $macroContext["fieldEquation"]
        $fieldType = $macroContext["fieldType"]
        $fieldLength = $macroContext["fieldLength"]
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Build the append field script
        $sb.AppendLine("Set db = Client.OpenDatabase(""$($macroContext['ActiveDatabase'])"")")
        $sb.AppendLine("Set task = db.TableManagement.AppendDatabase")
        
        # Set field properties
        $sb.AppendLine("task.AddFieldToAppend ""$fieldName"", ""$equation""")
        
        # Set field type
        switch ($fieldType.ToUpper()) {
            "CHARACTER" { 
                $length = if ($fieldLength) { $fieldLength } else { "50" }
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_CHAR_FIELD, $length")
            }
            "NUMERIC" { 
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_VIRT_NUM_FIELD")
            }
            "DATE" { 
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_VIRT_DATE_FIELD")
            }
            "LOGICAL" { 
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_VIRT_BOOL_FIELD")
            }
        }
        
        # Execute the task
        $sb.AppendLine("task.PerformTask")
        $sb.AppendLine("Set db = Nothing")
        $sb.AppendLine("Set task = Nothing")
        
        return $sb.ToString()
    }
}


####\Actions/CustomIdeaCommandAction.ps1
# CustomIdeaCommandAction.ps1 - Allows insertion of custom IDEA@ commands from CommandLibrary
# Integrates with existing CommandService to pull available commands

class CustomIdeaCommandAction : BaseAction {
    [string]$SelectedCommand = ""
    [hashtable]$CommandParameters = @{}
    
    CustomIdeaCommandAction() : base() {
        $this.Name = "Custom IDEA@ Command"
        $this.Description = "Execute a custom IDEA@ command from your command library or type in manually"
        $this.Category = "Custom"
        $this.Icon = ""
        $this.AllowsCustomCommands = $true
        
        # This action is flexible - consumes/produces depend on the selected command
        $this.Consumes = @()
        $this.Produces = @()
    }
    
    # Set the command to execute
    [void] SetCommand([string]$commandText) {
        $this.SelectedCommand = $commandText
        $this.UpdateDataContract()
    }
    
    # Update Consumes/Produces based on selected command
    [void] UpdateDataContract() {
        # Clear existing contracts
        $this.Consumes = @()
        $this.Produces = @()
        
        if ([string]::IsNullOrWhiteSpace($this.SelectedCommand)) {
            return
        }
        
        # Parse command for @function references and add as requirements
        $functions = $this.ExtractFunctions($this.SelectedCommand)
        foreach ($func in $functions) {
            $this.Consumes += @{
                Name = $func
                Type = "Variable"
                Description = "Value for $func"
            }
        }
        
        # Most IDEA@ commands produce some kind of output
        # This is generic since we don't know the specific command's output
        $this.Produces += @{
            Name = "commandResult"
            Type = "Unknown"
            Description = "Result of custom IDEA@ command"
        }
    }
    
    # Extract @function references from command text
    [string[]] ExtractFunctions([string]$commandText) {
        $functions = @()
        $pattern = '@(\w+(?:\([^)]*\))?)'
        $matches = [regex]::Matches($commandText, $pattern)
        
        foreach ($match in $matches) {
            $functions += $match.Groups[1].Value
        }
        
        return $functions
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        if ([string]::IsNullOrWhiteSpace($this.SelectedCommand)) {
            return "' No command specified"
        }
        
        $scriptText = $this.SelectedCommand
        
        # Replace @function references with values from macro context
        $functions = $this.ExtractFunctions($scriptText)
        foreach ($func in $functions) {
            if ($macroContext.ContainsKey($func)) {
                $value = $macroContext[$func]
                $scriptText = $scriptText.Replace("@$func", $value)
            }
        }
        
        # Add comment with original command for reference
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine("' Custom IDEA@ Command: $($this.SelectedCommand)")
        $sb.AppendLine($scriptText)
        
        return $sb.ToString()
    }
    
    # Get available commands from CommandService
    [System.Collections.ArrayList] GetAvailableCommands([object]$commandService) {
        if (-not $commandService) {
            return [System.Collections.ArrayList]::new()
        }
        
        # Filter commands that are IDEA@ related
        $ideaCommands = [System.Collections.ArrayList]::new()
        foreach ($command in $commandService.Commands) {
            # Look for commands that contain IDEA@ syntax or are tagged as IDEA commands
            if ($command.Command -match '@\w+' -or 
                $command.Tags -contains "idea" -or 
                $command.Tags -contains "ideascript" -or
                $command.Group -eq "IDEA") {
                $ideaCommands.Add($command) | Out-Null
            }
        }
        
        return $ideaCommands
    }
}


####\Actions/ExportToExcelAction.ps1
# ExportToExcelAction.ps1 - Exports current database to Excel
# Data I/O action for Phase 0

class ExportToExcelAction : BaseAction {
    ExportToExcelAction() : base() {
        $this.Name = "Export to Excel"
        $this.Description = "Exports the current database to an Excel file"
        $this.Category = "Data I/O"
        $this.Icon = ""
        
        $this.Consumes = @(
            @{
                Name = "outputPath"
                Type = "String"
                Description = "Full path for the output Excel file"
            },
            @{
                Name = "includeAllRecords"
                Type = "Boolean"
                Description = "Include all records or only extracted ones"
            }
        )
        
        $this.Produces = @(
            @{
                Name = "excelFile"
                Type = "File"
                Description = "The created Excel file"
            }
        )
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        $outputPath = $macroContext["outputPath"]
        $includeAll = $macroContext["includeAllRecords"]
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Build the export script
        $sb.AppendLine("Set db = Client.OpenDatabase(""$($macroContext['ActiveDatabase'])"")")
        $sb.AppendLine("Set task = db.ExternalFiles.ExcelFiles.NewExport")
        
        # Set output file
        $sb.AppendLine("task.OutputFileName = ""$outputPath""")
        
        # Set record selection
        if ($includeAll -eq "True" -or $includeAll -eq $true) {
            $sb.AppendLine("task.UseAllRecords")
        } else {
            $sb.AppendLine("task.UseExtractedRecords")
        }
        
        # Export all fields
        $sb.AppendLine("task.UseAllFields")
        
        # Execute the export
        $sb.AppendLine("task.PerformTask")
        $sb.AppendLine("Set db = Nothing")
        $sb.AppendLine("Set task = Nothing")
        
        return $sb.ToString()
    }
}


####\Actions/SummarizationAction.ps1
# SummarizationAction.ps1 - Performs IDEA summarization operation
# One of the core Phase 0 actions for data analysis

class SummarizationAction : BaseAction {
    SummarizationAction() : base() {
        $this.Name = "Summarization"
        $this.Description = "Summarizes data by grouping fields and calculating totals"
        $this.Category = "Core Analysis"
        $this.Icon = ""
        
        $this.Consumes = @(
            @{
                Name = "summaryFields"
                Type = "FieldList"
                Description = "Fields to group by in the summarization"
            },
            @{
                Name = "totalFields"
                Type = "FieldList"
                Description = "Numeric fields to total (optional)"
            },
            @{
                Name = "outputDatabase"
                Type = "String"
                Description = "Name for the output database"
            }
        )
        
        $this.Produces = @(
            @{
                Name = "summaryResult"
                Type = "Database"
                Description = "Database containing summarized results"
            }
        )
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        $summaryFields = $macroContext["summaryFields"]
        $totalFields = $macroContext["totalFields"]
        $outputDb = $macroContext["outputDatabase"]
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Build the summarization script
        $sb.AppendLine("Set db = Client.OpenDatabase(""$($macroContext['ActiveDatabase'])"")")
        $sb.AppendLine("Set task = db.Summarization")
        
        # Add grouping fields
        if ($summaryFields) {
            $sb.AppendLine("task.AddFieldToSummarize ""$summaryFields""")
        }
        
        # Add total fields if specified
        if ($totalFields -and $totalFields -ne "") {
            $sb.AppendLine("task.AddFieldToTotal ""$totalFields""")
        }
        
        # Set output database
        $sb.AppendLine("task.OutputDBName = ""$outputDb""")
        
        # Execute the task
        $sb.AppendLine("task.CreatePercentage = False")
        $sb.AppendLine("task.AppendDB = True")
        $sb.AppendLine("dbName = task.Run()")
        $sb.AppendLine("Set db = Nothing")
        $sb.AppendLine("Set task = Nothing")
        
        return $sb.ToString()
    }
}


####\Base/BaseDialog.ps1
# BaseDialog.ps1 - Base class for modal dialogs to eliminate code duplication

class BaseDialog : Screen {
    # Dialog properties
    [int]$DialogWidth = 50
    [int]$DialogHeight = 14
    [int]$DialogPadding = 2
    [int]$ButtonHeight = 3
    [int]$ButtonSpacing = 2
    [int]$MaxButtonWidth = 12
    [BorderType]$BorderType = [BorderType]::Rounded
    
    # Common buttons
    [MinimalButton]$PrimaryButton
    [MinimalButton]$SecondaryButton
    [string]$PrimaryButtonText = "OK"
    [string]$SecondaryButtonText = "Cancel"
    
    # Event handlers
    [scriptblock]$OnPrimary = {}
    [scriptblock]$OnSecondary = {}
    [scriptblock]$OnCreate = {}  # Legacy support
    [scriptblock]$OnCancel = {}  # Legacy support
    
    # Internal state
    hidden [hashtable]$_dialogBounds = @{}
    hidden [System.Collections.ArrayList]$_contentControls
    hidden [bool]$_initialized = $false
    [EventBus]$EventBus
    
    BaseDialog([string]$title) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    BaseDialog([string]$title, [int]$width, [int]$height) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this.DialogWidth = $width
        $this.DialogHeight = $height
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Prevent double initialization
        if ($this._initialized) {
            return
        }
        $this._initialized = $true
        
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create default buttons
        $this.CreateDefaultButtons()
        
        # Call derived class initialization
        $this.InitializeContent()
    }
    
    # Virtual method for derived classes to override
    [void] InitializeContent() {
        # Override in derived classes
    }
    
    [void] CreateDefaultButtons() {
        # Create primary button
        $this.PrimaryButton = [MinimalButton]::new($this.PrimaryButtonText)
        $this.PrimaryButton.IsDefault = $true
        $dialog = $this  # Capture reference
        $this.PrimaryButton.OnClick = {
            $dialog.HandlePrimaryAction()
        }.GetNewClosure()
        $this.PrimaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.PrimaryButton)
        
        # Create secondary button
        $this.SecondaryButton = [MinimalButton]::new($this.SecondaryButtonText)
        $this.SecondaryButton.OnClick = {
            $dialog.HandleSecondaryAction()
        }.GetNewClosure()
        $this.SecondaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SecondaryButton)
    }
    
    [void] AddContentControl([UIElement]$control, [int]$tabIndex = -1) {
        if ($tabIndex -gt 0) {
            $control.TabIndex = $tabIndex
        }
        $control.Initialize($global:ServiceContainer)
        $this.AddChild($control)
        $this._contentControls.Add($control) | Out-Null
    }
    
    [void] HandlePrimaryAction() {
        # Call custom handler first
        if ($this.OnPrimary -and $this.OnPrimary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnPrimary
        }
        
        # Legacy support
        if ($this.OnCreate -and $this.OnCreate.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCreate
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] HandleSecondaryAction() {
        # Call custom handler first
        if ($this.OnSecondary -and $this.OnSecondary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnSecondary
        }
        
        # Legacy support  
        if ($this.OnCancel -and $this.OnCancel.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCancel
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] CloseDialog() {
        if ($global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    # PARENT-DELEGATED INPUT MODEL (inherits from Screen)
    # Dialog shortcuts are handled via HandleScreenInput
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Dialog-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                if (-not $key.Modifiers) {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleSecondaryAction()
                return $true
            }
        }
        return $false
    }
    
    [void] OnActivated() {
        # Publish dialog opened event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::DialogOpened, @{ 
                Dialog = $this.GetType().Name
            })
        }
        
        # Focus first content control
        if ($this._contentControls.Count -gt 0) {
            $this._contentControls[0].Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog position (centered)
        $centerX = [int](($this.Width - $this.DialogWidth) / 2)
        $centerY = [int](($this.Height - $this.DialogHeight) / 2)
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $this.DialogWidth
            Height = $this.DialogHeight
        }
        
        # Position content controls
        $this.PositionContentControls($centerX, $centerY)
        
        # Position buttons
        $this.PositionButtons($centerX, $centerY)
    }
    
    # Virtual method for derived classes to override content positioning
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Default implementation - stack controls vertically
        $currentY = $dialogY + $this.DialogPadding
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $controlHeight = 3
        
        foreach ($control in $this._contentControls) {
            $control.SetBounds(
                $dialogX + $this.DialogPadding,
                $currentY,
                $controlWidth,
                $controlHeight
            )
            $currentY += $controlHeight + 1
        }
    }
    
    [void] PositionButtons([int]$dialogX, [int]$dialogY) {
        # Calculate button positioning
        $buttonY = $dialogY + $this.DialogHeight - $this.ButtonHeight - 1
        $totalButtonWidth = ($this.MaxButtonWidth * 2) + $this.ButtonSpacing
        
        # Center buttons if dialog is wide enough
        if ($this.DialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $dialogX + [int](($this.DialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $this.MaxButtonWidth
        } else {
            $buttonStartX = $dialogX + $this.DialogPadding
            $buttonWidth = [int](($this.DialogWidth - ($this.DialogPadding * 2) - $this.ButtonSpacing) / 2)
        }
        
        # Position primary button
        $this.PrimaryButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        # Position secondary button
        $this.SecondaryButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024  # Dialogs need moderate capacity
        
        # Render overlay background
        $this.RenderOverlay($sb)
        
        # Render dialog box
        if ($this._dialogBounds.Count -gt 0) {
            $this.RenderDialogBox($sb)
            $this.RenderTitle($sb)
        }
        
        # Render children (content controls and buttons) only within dialog bounds
        $this.RenderDialogChildren($sb)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [void] RenderOverlay([System.Text.StringBuilder]$sb) {
        # Dark overlay background
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
    }
    
    [void] RenderDialogBox([System.Text.StringBuilder]$sb) {
        $borderColor = $this.Theme.GetColor("dialog.border")
        $bgColor = $this.Theme.GetBgColor("dialog.background")
        
        $x = $this._dialogBounds.X
        $y = $this._dialogBounds.Y
        $w = $this._dialogBounds.Width
        $h = $this._dialogBounds.Height
        
        # Fill background
        for ($i = 0; $i -lt $h; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($w))
        }
        
        # Draw border using BorderStyle system
        $sb.Append([BorderStyle]::RenderBorder($x, $y, $w, $h, $this.BorderType, $borderColor))
    }
    
    [void] RenderTitle([System.Text.StringBuilder]$sb) {
        if (-not [string]::IsNullOrEmpty($this.Title)) {
            $titleColor = $this.Theme.GetColor("dialog.title")
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            
            # Calculate title position (centered)
            $titleText = " $($this.Title) "
            $titleX = $x + [int](($w - $titleText.Length) / 2)
            
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($titleText)
        }
    }
    
    [void] RenderDialogChildren([System.Text.StringBuilder]$sb) {
        # Render all visible children - they should be positioned correctly by OnBoundsChanged
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Handle Tab navigation
        if ($key.Key -eq [System.ConsoleKey]::Tab) {
            $reverse = ($key.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
            
            # Get all focusable controls (content + buttons)
            $focusableControls = @()
            foreach ($control in $this._contentControls) {
                if ($control.IsFocusable) {
                    $focusableControls += $control
                }
            }
            if ($this.PrimaryButton -and $this.PrimaryButton.IsFocusable) {
                $focusableControls += $this.PrimaryButton
            }
            if ($this.SecondaryButton -and $this.SecondaryButton.IsFocusable) {
                $focusableControls += $this.SecondaryButton
            }
            
            if ($focusableControls.Count -gt 0) {
                # Find currently focused control
                $currentIndex = -1
                for ($i = 0; $i -lt $focusableControls.Count; $i++) {
                    if ($focusableControls[$i].IsFocused) {
                        $currentIndex = $i
                        break
                    }
                }
                
                # Move focus
                if ($reverse) {
                    $currentIndex--
                    if ($currentIndex -lt 0) {
                        $currentIndex = $focusableControls.Count - 1
                    }
                } else {
                    $currentIndex++
                    if ($currentIndex -ge $focusableControls.Count) {
                        $currentIndex = 0
                    }
                }
                
                # Set focus to new control
                foreach ($control in $focusableControls) {
                    $control.IsFocused = $false
                }
                $focusableControls[$currentIndex].IsFocused = $true
                $focusableControls[$currentIndex].Focus()
                
                $this.Invalidate()
                return $true
            }
        }
        
        # Let base class handle other input
        return ([Screen]$this).HandleInput($key)
    }
}


####\Base/BaseModel.ps1
# BaseModel.ps1 - Base class for all data models to standardize common properties

class BaseModel {
    [string]$Id
    [DateTime]$CreatedAt
    [DateTime]$UpdatedAt
    [bool]$Deleted = $false
    
    BaseModel() {
        $this.Id = [guid]::NewGuid().ToString()
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    BaseModel([string]$id) {
        $this.Id = $id
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    # Method to update the UpdatedAt timestamp when model is modified
    [void] MarkAsUpdated() {
        $this.UpdatedAt = Get-Date
    }
    
    # Method to soft delete the model
    [void] SoftDelete() {
        $this.Deleted = $true
        $this.MarkAsUpdated()
    }
    
    # Method to restore a soft deleted model
    [void] Restore() {
        $this.Deleted = $false
        $this.MarkAsUpdated()
    }
    
    # Helper method to check if model is active (not deleted)
    [bool] IsActive() {
        return -not $this.Deleted
    }
    
    # Helper method to get age of the model
    [TimeSpan] GetAge() {
        return (Get-Date) - $this.CreatedAt
    }
    
    # Helper method to get time since last update
    [TimeSpan] GetTimeSinceUpdate() {
        return (Get-Date) - $this.UpdatedAt
    }
}


####\Base/Container.ps1
# Container.ps1 - Base class for components that contain other components
# Optimized for fast string aggregation

class Container : UIElement {
    # Optional background
    [bool]$DrawBackground = $false
    hidden [string]$_cachedBackground = ""
    hidden [string]$_cachedBgColor = ""
    hidden [ThemeManager]$Theme
    
    Container() : base() {
    }
    
    # Efficient child rendering with string builder
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Draw background if enabled
        if ($this.DrawBackground -and $this._cachedBackground) {
            $sb.Append($this._cachedBackground)
        }
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Pre-compute background
    [void] SetBackgroundColor([string]$ansiColor) {
        $this._cachedBgColor = $ansiColor
        $this.InvalidateBackground()
    }
    
    [void] InvalidateBackground() {
        if (-not $this.DrawBackground -or $this.Width -le 0 -or $this.Height -le 0) { 
            $this._cachedBackground = ""
            return 
        }
        
        $sb = Get-PooledStringBuilder ($this.Width * $this.Height * 2)
        $line = [StringCache]::GetSpaces($this.Width)
        
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            if ($this._cachedBgColor) {
                $sb.Append($this._cachedBgColor)
            }
            $sb.Append($line)
        }
        
        if ($this._cachedBgColor) {
            $sb.Append([VT]::Reset())
        }
        
        $this._cachedBackground = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    [void] OnBoundsChanged() {
        # Recalculate background when size changes
        if ($this.DrawBackground) {
            $this.InvalidateBackground()
        }
        
        # Let derived classes handle child layout
        $this.LayoutChildren()
    }
    
    # Override in derived classes for custom layouts
    [void] LayoutChildren() {
        # Base implementation does nothing
        # Derived classes like HorizontalSplit, VerticalSplit, etc. will implement
    }
    
    # Find child at specific coordinates
    [UIElement] HitTest([int]$x, [int]$y) {
        # Check if point is within our bounds
        if ($x -lt $this.X -or $x -ge ($this.X + $this.Width) -or
            $y -lt $this.Y -or $y -ge ($this.Y + $this.Height)) {
            return $null
        }
        
        # Check children in reverse order (top to bottom)
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                $hit = if ($child -is [Container]) {
                    $child.HitTest($x, $y)
                } else {
                    # Non-containers do simple bounds check
                    if ($x -ge $child.X -and $x -lt ($child.X + $child.Width) -and
                        $y -ge $child.Y -and $y -lt ($child.Y + $child.Height)) {
                        $child
                    } else {
                        $null
                    }
                }
                
                if ($hit) { return $hit }
            }
        }
        
        # No child hit, return self
        return $this
    }
    
    # Route input to focused child
    # PARENT-DELEGATED INPUT MODEL with FocusManager optimization
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Fast path: Use FocusManager to get current focus
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager) {
            $focused = $focusManager.GetFocused()
            if ($focused -and $this.ContainsElement($focused)) {
                return $focused.HandleInput($key)
            }
        }
        
        # Fallback to traditional search
        $focused = $this.FindFocusedChild()
        if ($focused) {
            return $focused.HandleInput($key)
        }
        
        return $false
    }
    
    # Check if this container contains the given element
    [bool] ContainsElement([UIElement]$element) {
        $current = $element
        while ($current) {
            if ($current.Parent -eq $this) { return $true }
            $current = $current.Parent
        }
        return $false
    }
    
    # Find direct focused child (not deep search)
    [UIElement] FindFocusedChild() {
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.IsFocused) {
                if ($global:Logger) {
                    $global:Logger.Debug("Container.FindFocusedChild: Found focused child $($child.GetType().Name)")
                }
                return $child
            }
        }
        if ($global:Logger) {
            $global:Logger.Debug("Container.FindFocusedChild: No focused child found among $($this.Children.Count) children")
        }
        return $null
    }
    
    # Fast focus navigation using FocusManager
    [void] FocusNextChild([UIElement]$currentChild) {
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager) {
            [void]$focusManager.FocusNext($this)
        } else {
            # Fallback for initialization
            $this.FocusFirstInTree()
        }
    }
    
    [void] FocusPreviousChild([UIElement]$currentChild) {
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager) {
            [void]$focusManager.FocusPrevious($this)
        } else {
            # Fallback for initialization
            $this.FocusLastInTree()
        }
    }
    
    # Focus first focusable child
    [void] FocusFirst() {
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
        }
    }
    
    # Focus first focusable element in the entire tree
    [void] FocusFirstInTree() {
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager) {
            $focusables = $focusManager.GetFocusableChildren($this)
            if ($focusables.Count -gt 0) {
                [void]$focusManager.SetFocus($focusables[0])
            }
        } else {
            # Fallback
            $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
            if ($focusable) {
                $focusable.Focus()
            }
        }
    }
    
    # Focus last focusable element in the entire tree
    [void] FocusLastInTree() {
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager) {
            $focusables = $focusManager.GetFocusableChildren($this)
            if ($focusables.Count -gt 0) {
                [void]$focusManager.SetFocus($focusables[$focusables.Count - 1])
            }
        } else {
            # Fallback - check children in reverse
            for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
                $child = $this.Children[$i]
                if ($child.Visible -and $child.IsFocusable) {
                    $child.Focus()
                    return
                }
            }
        }
    }
}


####\Base/FocusableComponent.ps1
# FocusableComponent.ps1 - Base class for focusable UI components with minimalist styling
# Provides standardized focus handling and visual feedback

class FocusableComponent : Container {
    # Focus visual style
    [string]$FocusStyle = 'minimal'  # minimal, border, highlight
    [bool]$ShowFocusIndicator = $true
    
    # Pre-cached focus strings
    hidden [string]$_focusPrefix = ""
    hidden [string]$_focusSuffix = ""
    hidden [string]$_focusBorder = ""
    
    FocusableComponent() : base() {
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        # Get theme manager for colors
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.UpdateFocusStyle()
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateFocusStyle()
                }.GetNewClosure())
            }
        }
    }
    
    [void] UpdateFocusStyle() {
        if (-not $this.Theme -or -not $this.ShowFocusIndicator) { return }
        
        $focusColor = $this.Theme.GetColor('focus')
        $focusBg = $this.Theme.GetColor('focus.background')
        
        switch ($this.FocusStyle) {
            'minimal' {
                # Subtle underline effect
                $this._focusPrefix = [VT]::Underline() + $focusColor
                $this._focusSuffix = [VT]::NoUnderline() + [VT]::Reset()
            }
            'border' {
                # Clean border (handled in render)
                $this._focusPrefix = $focusColor
                $this._focusSuffix = [VT]::Reset()
            }
            'highlight' {
                # Background highlight
                $this._focusPrefix = $focusBg + $focusColor
                $this._focusSuffix = [VT]::Reset()
            }
        }
    }
    
    # Render with focus indication
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render content first
        $content = $this.RenderContent()
        
        if ($this.IsFocused -and $this.ShowFocusIndicator) {
            if ($this.FocusStyle -eq 'border') {
                # Draw clean focus border
                $this.RenderFocusBorder($sb)
            } else {
                # Apply focus style to content
                $sb.Append($this._focusPrefix)
                $sb.Append($content)
                $sb.Append($this._focusSuffix)
            }
        } else {
            $sb.Append($content)
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Override in derived classes to provide content
    [string] RenderContent() {
        return ""
    }
    
    # Render minimal focus border
    [void] RenderFocusBorder([System.Text.StringBuilder]$sb) {
        if ($this.Width -lt 2 -or $this.Height -lt 2) { return }
        
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this._focusPrefix)
        $sb.Append('' * $this.Width)
        
        # Side borders (minimal - just corners)
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append('')
        $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y))
        $sb.Append('')
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append('')
        $sb.Append('' * ($this.Width - 2))
        $sb.Append('')
        $sb.Append($this._focusSuffix)
        
        # Render content inside border
        $sb.Append($this.RenderContent())
    }
    
    # Focus state changes
    [void] OnGotFocus() {
        $this.InvalidateFocusOnly()
    }
    
    [void] OnLostFocus() {
        $this.InvalidateFocusOnly()
    }
    
    # Handle common navigation keys
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Let derived classes handle first
        if ($this.OnHandleInput($key)) { return $true }
        
        # Default navigation
        switch ($key.Key) {
            ([System.ConsoleKey]::Tab) {
                if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                    if ($this.Parent) { $this.Parent.FocusPreviousChild($this) }
                } else {
                    if ($this.Parent) { $this.Parent.FocusNextChild($this) }
                }
                return $true
            }
        }
        
        return $false
    }
    
    # Override in derived classes for custom input
    [bool] OnHandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}


####\Base/Screen.ps1
# Screen.ps1 - Base class for all screens
# Simplified from ALCAR with focus on speed

class Screen : Container {
    [string]$Title = "Screen"
    [bool]$Active = $true
    hidden [hashtable]$_keyBindings = @{}
    hidden [ThemeManager]$Theme
    
    # Protected service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    Screen() : base() {
        $this.IsFocusable = $false  # Screens are containers, not focusable elements
        $this.DrawBackground = $true
    }
    
    # Initialize with services
    [void] Initialize([ServiceContainer]$services) {
        # Call base initialization
        ([UIElement]$this).Initialize($services)
        
        # Screen-specific initialization
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    # Helper method for service access with error handling
    [object] GetService([string]$serviceName) {
        if (-not $this.ServiceContainer) {
            if ($global:Logger) {
                $global:Logger.Warning("Screen.GetService: ServiceContainer not available, falling back to global access for $serviceName")
            }
            return $global:ServiceContainer.GetService($serviceName)
        }
        return $this.ServiceContainer.GetService($serviceName)
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Theme change handler
    [void] OnThemeChanged() {
        # Use background color for screen background
        $bgColor = $this.Theme.GetBgColor("background")
        $this.SetBackgroundColor($bgColor)
        $this.InvalidateBackground()
        $this.Invalidate()
    }
    
    # Override this method in derived screens to handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        return $false  # Base implementation - no screen-specific handling
    }
    
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Debug logging removed for performance
        
        # 1. Let focused child handle first (components get priority)
        $handled = ([Container]$this).HandleInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen base handled: $handled")
        }
        if ($handled) {
            return $true
        }
        
        # 2. Screen shortcuts as fallback only
        $screenHandled = $this.HandleScreenInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen shortcuts handled: $screenHandled")
        }
        return $screenHandled
    }
    
    # Lifecycle methods - simple and fast
    [void] OnActivated() {
        # Force a render when screen is activated
        $this.Invalidate()
    }
    
    [void] OnDeactivated() {
        # Override in derived classes if needed
    }
    
    # Removed old FocusNext/FocusPrevious - now handled by parent delegation
    
    # Delegate to Container's FocusFirst
    [void] FocusFirst() {
        ([Container]$this).FocusFirst()
    }

    # Request a re-render
    [void] RequestRender() {
        $this.Invalidate()
        # The ScreenManager will handle the actual rendering
    }
}


####\Base/UIElement.ps1
# UIElement.ps1 - Fast base class for all UI components
# Inspired by AxiomPhoenix architecture but optimized for string-based rendering

class UIElement {
    # Position and dimensions
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 0
    [int]$Height = 0
    
    # Visibility and focus
    [bool]$Visible = $true
    [bool]$IsFocusable = $false
    [bool]$IsFocused = $false
    [int]$TabIndex = 0
    
    # Hierarchy
    [UIElement]$Parent = $null
    [System.Collections.Generic.List[UIElement]]$Children
    
    # Service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    # Caching for maximum speed
    hidden [string]$_renderCache = ""
    hidden [bool]$_cacheInvalid = $true
    hidden [bool]$_focusOnly = $false  # Lightweight focus-only update
    
    # Pre-computed values
    hidden [string]$_cachedPosition = ""
    hidden [string]$_cachedClear = ""
    
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Fast render - returns cached string if valid
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        if ($this._cacheInvalid) {
            # Rebuild cache only when needed
            $this._renderCache = $this.OnRender()
            $this._cacheInvalid = $false
        }
        
        return $this._renderCache
    }
    
    # Override in derived classes
    [string] OnRender() {
        return ""
    }
    
    # Mark this element (and parents) as needing re-render
    [void] Invalidate() {
        if ($this._cacheInvalid -and -not $this._focusOnly) { return }  # Already invalid
        
        $this._cacheInvalid = $true
        $this._focusOnly = $false
        $this.InvalidatePosition()  # Position might have changed too
        
        # Propagate up the tree
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
        
        # Render request is handled by propagation to root
    }
    
    # Lightweight invalidation for focus changes only
    [void] InvalidateFocusOnly() {
        if ($this._cacheInvalid -and -not $this._focusOnly) { return }
        
        $this._cacheInvalid = $true
        $this._focusOnly = $true
        
        # Propagate with focus-only flag
        if ($this.Parent -and $this.Parent._focusOnly) {
            $this.Parent.InvalidateFocusOnly()
        } elseif ($this.Parent) {
            $this.Parent.Invalidate()
        }
    }
    
    # Pre-compute position strings
    [void] InvalidatePosition() {
        # Pre-compute ANSI sequences for this element's position
        $this._cachedPosition = [VT]::MoveTo($this.X, $this.Y)
        
        # Pre-compute clear sequence for this element's area
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $clearLine = [StringCache]::GetSpaces($this.Width)
            $clearSeq = Get-PooledStringBuilder ($this.Height * ($this.Width + 10))
            for ($i = 0; $i -lt $this.Height; $i++) {
                $clearSeq.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $clearSeq.Append($clearLine)
            }
            $this._cachedClear = $clearSeq.ToString()
            Return-PooledStringBuilder $clearSeq
        } else {
            $this._cachedClear = ""
        }
    }
    
    # Layout management
    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($this.X -eq $x -and $this.Y -eq $y -and 
            $this.Width -eq $width -and $this.Height -eq $height) {
            return  # No change
        }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        
        $this.InvalidatePosition()
        $this.Invalidate()
        $this.OnBoundsChanged()
    }
    
    # Override for custom layout logic
    [void] OnBoundsChanged() {
        # Base implementation does nothing
    }
    
    # Child management
    [void] AddChild([UIElement]$child) {
        $child.Parent = $this
        $this.Children.Add($child)
        $this.Invalidate()
    }
    
    [void] RemoveChild([UIElement]$child) {
        if ($child.IsFocusable -and $this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
            if ($focusManager) {
                $focusManager.UnregisterFocusable($child)
            }
        }
        $child.Parent = $null
        $this.Children.Remove($child)
        $this.Invalidate()
    }
    
    # Fast focus management using FocusManager
    [void] Focus() {
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager) {
            [void]$focusManager.SetFocus($this)
        } else {
            # Fallback for initialization phase
            $this.IsFocused = $true
            $this.OnGotFocus()
            $this.InvalidateFocusOnly()
        }
    }
    
    # Find focused element in tree
    [UIElement] FindFocusedElement([UIElement]$element) {
        if ($element.IsFocused) { return $element }
        foreach ($child in $element.Children) {
            $found = $this.FindFocusedElement($child)
            if ($found) { return $found }
        }
        return $null
    }
    
    [UIElement] GetRoot() {
        $current = $this
        while ($current.Parent) {
            $current = $current.Parent
        }
        return $current
    }
    
    [UIElement] FindFocused() {
        if ($this.IsFocused) { return $this }
        
        foreach ($child in $this.Children) {
            $focused = $child.FindFocused()
            if ($focused) { return $focused }
        }
        
        return $null
    }
    
    # Override for focus behavior
    [void] OnGotFocus() {}
    [void] OnLostFocus() {}
    
    # Initialize with service container
    [void] Initialize([ServiceContainer]$services) {
        $this.ServiceContainer = $services
        
        # Register with focus manager if focusable
        $focusManager = $services.GetService('FocusManager')
        if ($this.IsFocusable -and $focusManager) {
            $focusManager.RegisterFocusable($this)
        }
        
        $this.OnInitialize()
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Base implementation does nothing
        return $false
    }
}


####\Components/Button.ps1
# Button.ps1 - Fast button component with theming

class Button : UIElement {
    [string]$Text = "Button"
    [scriptblock]$OnClick = {}
    [bool]$IsDefault = $false
    
    # Cached rendering
    hidden [string]$_cachedRender = ""
    hidden [ThemeManager]$Theme
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    # Cached theme colors
    hidden [hashtable]$_colors = @{}
    
    Button() : base() {
        $this.IsFocusable = $true
        $this.Height = 3  # Default button height
    }
    
    Button([string]$text) : base() {
        $this.Text = $text
        $this.IsFocusable = $true
        $this.Height = 3
        if ($global:Logger) {
            $global:Logger.Debug("Button created with text: '$text'")
        }
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.Invalidate()  # Force initial render
    }
    
    [void] OnThemeChanged() {
        # Cache colors on theme change
        if ($this.Theme) {
            $this._colors = @{
                "button.background" = $this.Theme.GetBgColor("button.background")
                "button.foreground" = $this.Theme.GetColor("button.foreground")
                "button.focused.background" = $this.Theme.GetBgColor("button.focused.background")
                "button.focused.foreground" = $this.Theme.GetColor("button.focused.foreground")
                "border" = $this.Theme.GetColor("border")
                "border.focused" = $this.Theme.GetColor("border.focused")
                "accent" = $this.Theme.GetColor("accent")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Method to properly track text changes
    [void] SetText([string]$text) {
        if ($this.Text -ne $text) {
            $this.Text = $text
            $this._dataVersion++  # Increment on text change
            $this.Invalidate()
        }
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        # Debug logging removed for performance
        
        # Return early if Theme is not initialized
        if (-not $this.Theme) {
            $this._cachedRender = ""
            return
        }
        
        $sb = Get-PooledStringBuilder 512  # Button rendering typically needs small capacity
        
        # Determine colors based on state
        $bgColor = ""
        $fgColor = ""
        $borderColor = ""
        
        if ($this.IsFocused) {
            $bgColor = $this._colors["button.focused.background"]
            $fgColor = $this._colors["button.focused.foreground"]
            $borderColor = $this._colors["border.focused"]
        } else {
            $bgColor = $this._colors["button.background"]
            $fgColor = $this._colors["button.foreground"]
            $borderColor = $this._colors["border"]
        }
        
        # Calculate text position (centered)
        $textX = $this.X + [Math]::Max(1, [int](($this.Width - $this.Text.Length) / 2))
        $textY = $this.Y + 1  # For height=3, text should be on the middle line
        
        # Debug logging removed for performance
        
        # Draw button box
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $borderWidth = [Math]::Max(0, $this.Width - 2)
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($borderWidth) + [VT]::TR())
        } else {
            $sb.Append([VT]::TL() + [VT]::TR())
        }
        
        # Middle lines
        for ($y = $this.Y + 1; $y -lt $this.Y + $this.Height - 1; $y++) {
            # Debug logging removed for performance
            
            $sb.Append([VT]::MoveTo($this.X, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Fill line with background, but handle text line specially
            if ($y -eq $textY -and $this.Text) {
                # Draw background up to text
                $sb.Append($bgColor)
                $textStartOffset = [Math]::Max(0, ($this.Width - $this.Text.Length) / 2) - 1
                if ($textStartOffset -gt 0) {
                    $sb.Append([StringCache]::GetSpaces([int]$textStartOffset))
                }
                
                # Draw text
                $sb.Append($fgColor)
                $sb.Append($this.Text)
                
                # Fill rest of line
                $sb.Append($bgColor)
                $remainingSpace = $this.Width - 2 - [int]$textStartOffset - $this.Text.Length
                if ($remainingSpace -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($remainingSpace))
                }
            } else {
                # Non-text lines - just fill with background
                $sb.Append($bgColor)
                $paddingWidth = [Math]::Max(0, $this.Width - 2)
                if ($paddingWidth -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($paddingWidth))
                }
            }
            
            # Draw right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            $sb.Append([VT]::Reset())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($borderWidth) + [VT]::BR())
        } else {
            $sb.Append([VT]::BL() + [VT]::BR())
        }
        
        # Add default indicator if needed
        if ($this.IsDefault) {
            $sb.Append([VT]::MoveTo($this.X + 1, $this.Y))
            $sb.Append($this._colors["accent"])
            $sb.Append("*")
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -eq [System.ConsoleKey]::Enter -or 
                $key.Key -eq [System.ConsoleKey]::Spacebar) {
                $this.Click()
                return $true
            }
            return $false
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    [void] Click() {
        try {
            if ($this.OnClick) {
                & $this.OnClick
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.Click: Error executing OnClick handler - $($_.Exception.Message)")
            }
        }
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/CommandPalette.ps1
# CommandPalette.ps1 - Fast command palette overlay

class CommandPalette : Container {
    [string]$SearchText = ""
    [ListBox]$ResultsList
    [System.Collections.ArrayList]$AllCommands
    [System.Collections.ArrayList]$FilteredCommands
    [scriptblock]$OnCommandSelected = {}
    [bool]$IsVisible = $false
    [EventBus]$EventBus
    [ThemeManager]$Theme
    
    # Layout
    hidden [int]$PaletteWidth = 60
    hidden [int]$PaletteHeight = 20
    hidden [int]$MaxResults = 15
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    CommandPalette() : base() {
        $this.AllCommands = [System.Collections.ArrayList]::new()
        $this.FilteredCommands = [System.Collections.ArrayList]::new()
        $this.DrawBackground = $true
        
        # Create results list
        $this.ResultsList = [ListBox]::new()
        $this.ResultsList.ShowBorder = $false
        $this.ResultsList.ShowScrollbar = $true
        $this.ResultsList.ItemRenderer = {
            param($cmd)
            $name = $cmd.Name.PadRight(20)
            $desc = if ($cmd.Description.Length -gt 35) {
                $cmd.Description.Substring(0, 32) + "..."
            } else {
                $cmd.Description
            }
            return "$name $desc"
        }
        $this.AddChild($this.ResultsList)
    }
    
    [void] OnInitialize() {
        # Get services
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Subscribe to command registration events
        if ($this.EventBus) {
            $this.EventBus.Subscribe('command.registered', {
                param($sender, $eventData)
                if ($eventData.Name -and $eventData.Description -and $eventData.Action) {
                    $this.AddCommand($eventData.Name, $eventData.Description, $eventData.Action)
                }
            }.GetNewClosure())
        }
        
        # Initialize child components
        if ($this.ResultsList) {
            $this.ResultsList.Initialize($this.ServiceContainer)
        }
        
        # Set palette background if theme is available
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        # Load default commands
        $this.LoadDefaultCommands()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'menu.background' = $this.Theme.GetBgColor("menu.background")
                'border.focused' = $this.Theme.GetColor("border.focused")
                'accent' = $this.Theme.GetColor("accent")
                'foreground' = $this.Theme.GetColor("foreground")
                'disabled' = $this.Theme.GetColor("disabled")
            }
            $this.SetBackgroundColor($this._colors['menu.background'])
        }
        $this.Invalidate()
    }
    
    [void] LoadDefaultCommands() {
        # Store reference to this palette for use in scriptblocks
        $palette = $this
        
        # Add some default commands
        $this.AddCommand("new project", "Create a new project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new project command")
            }
            
            # Publish event to switch to projects tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
            }
            
            # Create and show the dialog
            $dialog = [NewProjectDialog]::new()
            $dialog.OnCreate = {
                param($project)
                if ($global:Logger) {
                    $global:Logger.Info("Creating project: $($project.Name)")
                }
                # Add project via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    # Create proper Project object using single-parameter constructor
                    $newProject = $projectService.AddProject($project.Name)
                    
                    # Publish project created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::ProjectCreated, @{ Project = $newProject })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        $this.AddCommand("new task", "Create a new task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new task command")
            }
            
            # Publish event to switch to tasks tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
            }
            
            # Create and show the dialog directly (same pattern as new project)
            $dialog = [NewTaskDialog]::new()
            $dialog.OnCreate = {
                param($task)
                if ($global:Logger) {
                    $global:Logger.Info("Creating task: $($task.Title)")
                }
                # Create task via service
                $taskService = $global:ServiceContainer.GetService("TaskService")
                if ($taskService) {
                    $newTask = $taskService.CreateTask($task)
                    
                    # Publish task created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TaskCreated, @{ Task = $newTask })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit project", "Edit selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit task", "Edit selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete project", "Delete selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete task", "Delete selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("time entry", "Go to time entry screen", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Time entry command executed")
            }
            # Switch to time tab (tab index 2)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 2 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("quick time entry", "Quick time entry for today", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quick time entry command executed")
            }
            
            # Switch to time tab first
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 2 })
            }
            
            # Get current week Friday for time entry
            $timeService = $global:ServiceContainer.GetService("TimeTrackingService")
            $currentWeekFriday = if ($timeService) { 
                $timeService.GetCurrentWeekFriday() 
            } else { 
                # Fallback to current week's Friday
                $today = [DateTime]::Today
                $daysUntilFriday = ([int][DayOfWeek]::Friday - [int]$today.DayOfWeek + 7) % 7
                if ($daysUntilFriday -eq 0 -and $today.DayOfWeek -ne [DayOfWeek]::Friday) {
                    $daysUntilFriday = 7
                }
                $today.AddDays($daysUntilFriday)
            }
            
            # Create and show quick time entry dialog
            $dialog = [QuickTimeEntryDialog]::new($currentWeekFriday)
            $dialog.OnSave = {
                param($timeEntry)
                if ($global:Logger) {
                    $global:Logger.Info("Creating time entry: $($timeEntry.Hours) hours for project $($timeEntry.ProjectId)")
                }
                # Create time entry via service
                $timeService = $global:ServiceContainer.GetService("TimeTrackingService")
                if ($timeService) {
                    $timeService.AddTimeEntry($timeEntry)
                    
                    # Publish time entry created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TimeEntryUpdated, @{ TimeEntry = $timeEntry })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("search", "Search in files", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Search command executed")
            }
            # Publish search event for current screen to handle
            if ($palette.EventBus) {
                $palette.EventBus.Publish('command.search', $palette, @{})
            }
            $palette.Hide()
        }.GetNewClosure())
        
        $this.AddCommand("files", "Open file browser", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Files command executed")
            }
            # Switch to files tab (tab index 3 - Projects, Tasks, Time, Files)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 3 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("text editor", "Open text editor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Text editor command executed")
            }
            # Switch to editor tab (tab index 4 - Projects, Tasks, Time, Files, Editor)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("editor", "Open text editor tab", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Editor tab command executed")
            }
            # Switch to editor tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("settings", "Open settings", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Settings command executed")
            }
            # Switch to settings tab (tab index 5 - Projects, Tasks, Time, Files, Editor, Settings)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 5 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("eventbus monitor", "Open EventBus monitor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: EventBus monitor command executed")
            }
            # Open EventBus monitor dialog
            $monitor = [EventBusMonitor]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($monitor)
            }
        }.GetNewClosure())
        
        $this.AddCommand("reload", "Reload configuration", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Reload command executed")
            }
            # Publish reload event for services to handle
            if ($palette.EventBus) {
                $palette.EventBus.Publish('command.reload', $palette, @{})
            }
            # Reload configuration service
            $configService = $global:ServiceContainer.GetService('ConfigurationService')
            if ($configService) {
                $configService.LoadConfiguration()
            }
            $palette.Hide()
        }.GetNewClosure())
        
        $this.AddCommand("theme dark", "Switch to dark theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Dark theme command executed")
            }
            if ($palette.Theme) {
                $palette.Theme.SetTheme('default')
            }
            $palette.Hide()
        }.GetNewClosure())
        
        $this.AddCommand("theme matrix", "Switch to matrix theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Matrix theme command executed")
            }
            if ($palette.Theme) {
                $palette.Theme.SetTheme('matrix')
            }
            $palette.Hide()
        }.GetNewClosure())
        $this.AddCommand("quit", "Exit application (Ctrl+Q)", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quit command executed")
            }
            if ($global:ScreenManager) {
                $screen = $global:ScreenManager.GetActiveScreen()
                if ($screen) { 
                    $screen.Active = $false 
                }
            }
        }.GetNewClosure())
    }
    
    [void] AddCommand([string]$name, [string]$description, [scriptblock]$action) {
        $this.AllCommands.Add(@{
            Name = $name
            Description = $description
            Action = $action
        })
    }
    
    [void] Show() {
        $this.IsVisible = $true
        $this.SearchText = ""
        $this.UpdateFilter()
        $this.Invalidate()
        
        # Focus on results
        $this.ResultsList.Focus()
    }
    
    [void] Hide() {
        $this.IsVisible = $false
        $this.Invalidate()
        
        # Return focus to parent's active tab
        if ($this.Parent -and $this.Parent.GetType().Name -eq "MainScreen") {
            $activeTab = $this.Parent.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                $activeTab.Content.Focus()
            }
        }
    }
    
    [void] UpdateFilter() {
        $this.FilteredCommands.Clear()
        
        if ([string]::IsNullOrEmpty($this.SearchText)) {
            $this.FilteredCommands.AddRange($this.AllCommands)
        } else {
            # Simple fuzzy search
            $searchLower = $this.SearchText.ToLower()
            foreach ($cmd in $this.AllCommands) {
                if ($cmd.Name.ToLower().Contains($searchLower) -or 
                    $cmd.Description.ToLower().Contains($searchLower)) {
                    $this.FilteredCommands.Add($cmd)
                }
            }
        }
        
        # Update list
        $this.ResultsList.SetItems($this.FilteredCommands.ToArray())
    }
    
    [void] OnBoundsChanged() {
        # Center the palette
        $centerX = [int](($this.Width - $this.PaletteWidth) / 2)
        $centerY = [int](($this.Height - $this.PaletteHeight) / 2)
        
        # Update own bounds to be centered
        $this.X = $centerX
        $this.Y = $centerY
        $this.Width = $this.PaletteWidth
        $this.Height = $this.PaletteHeight
        
        # Layout results list (leave room for search box and border)
        $this.ResultsList.SetBounds(
            $this.X + 2,
            $this.Y + 4,
            $this.Width - 4,
            $this.Height - 6
        )
        
        # Recalculate visible items
        $this.ResultsList.VisibleItems = [Math]::Min($this.MaxResults, $this.Height - 6)
        
        ([Container]$this).OnBoundsChanged()
    }
    
    [string] OnRender() {
        if (-not $this.IsVisible) { return "" }
        
        $sb = Get-PooledStringBuilder 1024
        
        # Draw background first
        $sb.Append(([Container]$this).OnRender())
        
        # Draw border
        $borderColor = $this._colors['border.focused']
        
        # Top border with title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal(2))
        $accentColor = $this._colors['accent']
        $sb.Append($accentColor)
        $sb.Append(" Command Palette ")
        $sb.Append($borderColor)
        $sb.Append([StringCache]::GetVTHorizontal($this.Width - 19) + [VT]::TR())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        
        # Search box
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 2))
        $foregroundColor = $this._colors['foreground']
        $sb.Append($foregroundColor)
        $sb.Append("Search: ")
        $sb.Append($accentColor)
        $sb.Append($this.SearchText)
        $sb.Append("_")
        
        # Separator
        $sb.Append([VT]::MoveTo($this.X + 1, $this.Y + 3))
        $sb.Append($borderColor)
        $sb.Append([StringCache]::GetVTHorizontal($this.Width - 2))
        
        # Help text
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + $this.Height - 2))
        $disabledColor = $this._colors['disabled']
        $sb.Append($disabledColor)
        $sb.Append("[Enter] Select  [Esc] Cancel")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsVisible) { return $false }
        
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($global:Logger) {
                    $global:Logger.Debug("CommandPalette: Escape pressed, hiding palette")
                }
                try {
                    $this.Hide()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("CommandPalette: Error hiding palette: $_")
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.ResultsList.GetSelectedItem()
                if ($selected) {
                    if ($global:Logger) {
                        $global:Logger.Debug("CommandPalette: Executing command '$($selected.Name)'")
                    }
                    $this.Hide()
                    if ($selected.Action) {
                        try {
                            # Execute in the context of the CommandPalette
                            $selected.Action.Invoke()
                        } catch {
                            if ($global:Logger) {
                                $global:Logger.Error("CommandPalette: Error executing command '$($selected.Name)': $_")
                            }
                        }
                    }
                    if ($this.OnCommandSelected) {
                        & $this.OnCommandSelected $selected
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.SearchText.Length -gt 0) {
                    $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                    $this.UpdateFilter()
                    $this.Invalidate()
                }
                return $true
            }
            default {
                # Let list handle navigation
                if ($this.ResultsList.HandleInput($key)) {
                    return $true
                }
                
                # Add character to search
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or $key.KeyChar -eq ' ') {
                    $this.SearchText += $key.KeyChar
                    $this.UpdateFilter()
                    $this.Invalidate()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Components/DataGrid.ps1
# DataGrid.ps1 - Fast data grid component for tabular display with full grid lines
# Optimized for performance with caching and pooled string builders

class DataGrid : UIElement {
    [System.Collections.ArrayList]$Items
    [hashtable[]]$Columns = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$ShowGridLines = $true  # New property for grid lines
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_colors = @{}
    hidden [hashtable]$_columnWidths = @{}
    hidden [string]$_cachedHeader = ""
    hidden [string]$_cachedSeparator = ""
    hidden [string[]]$_cachedHeaders = @()        # Pre-built header strings
    hidden [int[]]$_cachedColumnWidths = @()      # Pre-calculated widths
    hidden [string]$_cachedBorders = ""           # Pre-built border strings
    hidden [bool]$_layoutCacheValid = $false
    hidden [int]$_lastWidth = 0
    hidden [int]$_dataVersion = 0                 # Version-based change detection
    hidden [int]$_lastRenderedVersion = -1
    
    DataGrid() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Cache all colors used by DataGrid
        $this._colors['border'] = $this.Theme.GetColor('border')
        $this._colors['border.focused'] = $this.Theme.GetColor('border.focused')
        $this._colors['accent'] = $this.Theme.GetColor('accent')
        $this._colors['header.foreground'] = $this.Theme.GetColor('header.foreground')
        $this._colors['header.background'] = $this.Theme.GetBgColor('header.background')
        $this._colors['background'] = $this.Theme.GetBgColor('background')
        $this._colors['foreground'] = $this.Theme.GetColor('foreground')
        $this._colors['selection'] = $this.Theme.GetBgColor('selection')
        $this._colors['scrollbar'] = $this.Theme.GetColor('scrollbar')
        
        $this._dataVersion++  # Increment for theme change
        $this._layoutCacheValid = $false
        $this.Invalidate()
    }
    
    # Set the columns for the grid
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this._layoutCacheValid = $false
        $this._dataVersion++  # Increment on any data change
        $this.Invalidate()
    }
    
    # Set data items
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = if ($this.Items.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on any data change
        $this.Invalidate()
    }
    
    # Get selected item
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    # Select specific index
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    # Calculate column widths with auto-sizing
    hidden [void] CalculateColumnWidths([int]$availableWidth) {
        if ($this._layoutCacheValid -and $this._lastWidth -eq $availableWidth) {
            return
        }
        
        $this._columnWidths.Clear()
        $totalFixed = 0
        $flexCount = 0
        
        # First pass: calculate fixed widths and count flex columns
        foreach ($col in $this.Columns) {
            if ($col.Width -and $col.Width -gt 0) {
                $this._columnWidths[$col.Name] = $col.Width
                $totalFixed += $col.Width
            } else {
                $flexCount++
            }
        }
        
        # Add space for separators if grid lines are shown
        if ($this.ShowGridLines -and $this.Columns.Count -gt 1) {
            $totalFixed += ($this.Columns.Count - 1)  # Vertical separators
        }
        
        # Second pass: distribute remaining width to flex columns
        if ($flexCount -gt 0 -and $availableWidth -gt $totalFixed) {
            $flexWidth = [Math]::Floor(($availableWidth - $totalFixed) / $flexCount)
            foreach ($col in $this.Columns) {
                if (-not $col.Width -or $col.Width -eq 0) {
                    $this._columnWidths[$col.Name] = [Math]::Max(5, $flexWidth)  # Min width of 5
                }
            }
        }
        
        $this._lastWidth = $availableWidth
        $this._layoutCacheValid = $true
    }
    
    # Build cached header string
    hidden [void] BuildCachedHeader([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedHeader) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $header = if ($col.Header) { $col.Header } else { $col.Name }
                $text = if ($header.Length -gt $width) {
                    $header.Substring(0, $width - 1) + ""
                } else {
                    $header.PadRight($width)
                }
                $sb.Append($text)
                $x += $width
                
                # Add separator after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append([StringCache]::GetSpaces($contentWidth - $x))
        }
        
        $this._cachedHeader = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Build cached separator line
    hidden [void] BuildCachedSeparator([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedSeparator) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $sb.Append([StringCache]::GetHorizontalLine($width))
                $x += $width
                
                # Add intersection after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append([StringCache]::GetHorizontalLine($contentWidth - $x))
        }
        
        $this._cachedSeparator = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Ensure selected item is visible
    hidden [void] EnsureVisible() {
        if ($this.Items.Count -eq 0) { return }
        
        $contentHeight = $this.Height - 2  # Account for borders
        if ($this.ShowHeader) { 
            $contentHeight -= 2  # Header + separator line
        }
        
        # Account for row separators
        if ($this.ShowGridLines) {
            $contentHeight = [Math]::Floor($contentHeight / 2)  # Each row takes 2 lines with separator
        }
        
        # Scroll up if selected is above visible area
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        # Scroll down if selected is below visible area
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $contentHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Ensure scroll offset is valid
        $maxScroll = [Math]::Max(0, $this.Items.Count - $contentHeight)
        $this.ScrollOffset = [Math]::Max(0, [Math]::Min($this.ScrollOffset, $maxScroll))
    }
    
    [string] OnRender() {
        # Return empty if Theme is not initialized
        if (-not $this.Theme) {
            return ""
        }
        
        $sb = Get-PooledStringBuilder 4096  # Larger size for grid with separators
        
        # Calculate content area
        $contentX = $this.X + 1
        $contentY = $this.Y + 1
        $contentWidth = $this.Width - 2
        $contentHeight = $this.Height - 2
        
        # Draw border if enabled
        if ($this.ShowBorder -and $this.Theme) {
            $borderColor = if ($this.IsFocused) { 
                $this._colors['border.focused'] 
            } else { 
                $this._colors['border'] 
            }
            
            # Top border with title
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL())
            
            if ($this.Title) {
                $titleText = " " + $this.Title + " "  # Avoid string interpolation overhead
                $titleLen = $titleText.Length
                $borderLen = $this.Width - 2
                $leftPad = [int](($borderLen - $titleLen) / 2)
                
                if ($leftPad -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($leftPad))
                }
                $sb.Append($this._colors['accent'])
                $sb.Append($titleText)
                $sb.Append($borderColor)
                $remainingBorder = [Math]::Max(0, $borderLen - $leftPad - $titleLen)
                if ($remainingBorder -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($remainingBorder))
                }
            } else {
                $topBorderWidth = [Math]::Max(0, $this.Width - 2)
                if ($topBorderWidth -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($topBorderWidth))
                }
            }
            
            $sb.Append([VT]::TR())
            
            # Side borders
            for ($i = 1; $i -lt $this.Height - 1; $i++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i))
                $sb.Append([VT]::V())
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
            $sb.Append([VT]::BL())
            $bottomBorderWidth = [Math]::Max(0, $this.Width - 2)
            if ($bottomBorderWidth -gt 0) {
                $sb.Append([StringCache]::GetVTHorizontal($bottomBorderWidth))
            }
            $sb.Append([VT]::BR())
            $sb.Append([VT]::Reset())
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
            $contentHeight = $this.Height
        }
        
        # Calculate column widths
        $this.CalculateColumnWidths($contentWidth)
        
        # Clear content area
        $bgColor = $this._colors['background']
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $sb.Append([VT]::MoveTo($contentX, $contentY + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
        }
        
        $currentY = $contentY
        $dataStartY = $currentY
        
        # Render header if enabled
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            # Build cached header
            $this.BuildCachedHeader($contentWidth)
            
            # Render header
            $sb.Append([VT]::MoveTo($contentX, $currentY))
            $sb.Append($this._colors['header.background'])
            $sb.Append($this._colors['header.foreground'])
            $sb.Append($this._cachedHeader)
            $sb.Append([VT]::Reset())
            $currentY++
            
            # Render header separator line
            if ($this.ShowGridLines) {
                $this.BuildCachedSeparator($contentWidth)
                $sb.Append([VT]::MoveTo($contentX, $currentY))
                $sb.Append($this._colors['border'])
                $sb.Append($this._cachedSeparator)
                $sb.Append([VT]::Reset())
                $currentY++
            }
            
            $dataStartY = $currentY
            $contentHeight = $this.Height - 2 - ($currentY - $contentY)
        }
        
        # Calculate visible rows (accounting for separators) - optimization: only render visible rows
        $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
        $maxVisibleRows = [Math]::Floor($contentHeight / $rowHeight)
        
        # Optimization: Skip off-screen rows entirely - zero overhead bounds checking
        $startRow = $this.ScrollOffset
        $endRow = [Math]::Min($startRow + $maxVisibleRows, $this.Items.Count)
        $visibleRows = $endRow - $startRow
        
        # Render data rows (only visible ones)
        for ($i = 0; $i -lt $visibleRows; $i++) {
            $itemIndex = $startRow + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isSelected = ($itemIndex -eq $this.SelectedIndex)
            $rowY = $currentY + ($i * $rowHeight)
            
            # Render data row
            $sb.Append([VT]::MoveTo($contentX, $rowY))
            
            if ($isSelected) {
                $sb.Append($this._colors['selection'])
                $sb.Append($this._colors['foreground'])
            } else {
                $sb.Append($this._colors['background'])
                $sb.Append($this._colors['foreground'])
            }
            
            # Render columns
            $x = 0
            for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                $col = $this.Columns[$j]
                $width = $this._columnWidths[$col.Name]
                
                if ($x + $width -gt $contentWidth) {
                    $width = $contentWidth - $x
                }
                
                if ($width -gt 0) {
                    # Get value using property name or custom getter
                    $value = ""
                    if ($col.Getter) {
                        $value = & $col.Getter $item
                    } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                        $value = $item.($col.Name)
                    }
                    
                    # Apply formatter if provided
                    if ($col.Formatter) {
                        $value = & $col.Formatter $value
                    }
                    
                    # Convert to string and truncate if needed
                    $text = $value.ToString()
                    if ($text.Length -gt $width) {
                        $text = $text.Substring(0, $width - 1) + ""
                    } else {
                        $text = $text.PadRight($width)
                    }
                    
                    $sb.Append($text)
                    $x += $width
                    
                    # Add vertical separator after column (except last)
                    if ($this.ShowGridLines -and $j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                        if ($isSelected) {
                            # Keep selection colors for separator
                            $sb.Append("")
                        } else {
                            $sb.Append($this._colors['border'])
                            $sb.Append("")
                            $sb.Append($this._colors['foreground'])
                        }
                        $x++
                    }
                }
                
                if ($x -ge $contentWidth) { break }
            }
            
            # Fill remaining row space
            if ($x -lt $contentWidth) {
                $sb.Append([StringCache]::GetSpaces($contentWidth - $x))
            }
            
            # Render row separator (except after last visible row)
            if ($this.ShowGridLines -and $i -lt $visibleRows - 1) {
                $sb.Append([VT]::MoveTo($contentX, $rowY + 1))
                $sb.Append($this._colors['border'])
                
                $x = 0
                for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                    $col = $this.Columns[$j]
                    $width = $this._columnWidths[$col.Name]
                    
                    if ($x + $width -gt $contentWidth) {
                        $width = $contentWidth - $x
                    }
                    
                    if ($width -gt 0) {
                        $sb.Append([StringCache]::GetHorizontalLine($width))
                        $x += $width
                        
                        # Add intersection
                        if ($j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                            $sb.Append("")
                            $x++
                        }
                    }
                    
                    if ($x -ge $contentWidth) { break }
                }
                
                # Fill remaining separator
                if ($x -lt $contentWidth) {
                    $sb.Append([StringCache]::GetHorizontalLine($contentWidth - $x))
                }
                $sb.Append([VT]::Reset())
            }
        }
        
        # Show scroll indicator
        if ($this.Items.Count -gt $maxVisibleRows) {
            $scrollBarX = $this.X + $this.Width - 1
            $scrollBarHeight = $contentHeight
            $scrollThumbSize = [Math]::Max(1, [int]($scrollBarHeight * $maxVisibleRows / $this.Items.Count))
            $scrollThumbPos = [int]($this.ScrollOffset * ($scrollBarHeight - $scrollThumbSize) / ($this.Items.Count - $maxVisibleRows))
            
            $sb.Append($this._colors['scrollbar'])
            for ($i = 0; $i -lt $scrollBarHeight; $i++) {
                $sb.Append([VT]::MoveTo($scrollBarX, $dataStartY + $i))
                if ($i -ge $scrollThumbPos -and $i -lt ($scrollThumbPos + $scrollThumbSize)) {
                    $sb.Append("")
                } else {
                    $sb.Append("")
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsFocused -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.EnsureVisible()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._dataVersion++  # Increment for focus change
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._dataVersion++  # Increment for focus change
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        # Invalidate layout cache when bounds change
        if ($this.Width -ne $this._lastWidth) {
            $this._layoutCacheValid = $false
        }
        ([UIElement]$this).OnBoundsChanged()
    }
}


####\Components/DockPanel.ps1
# DockPanel.ps1 - Dock-based layout container
# Allows children to be docked to Top, Bottom, Left, Right, or Fill remaining space

enum DockPosition {
    Top
    Bottom
    Left
    Right
    Fill
}

class DockPanel : Container {
    [bool]$LastChildFill = $true
    [int]$DockSpacing = 0
    
    # Layout caching for performance
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastChildCount = 0
    
    # Available content area after docking
    hidden [int]$_contentX = 0
    hidden [int]$_contentY = 0  
    hidden [int]$_contentWidth = 0
    hidden [int]$_contentHeight = 0
    
    DockPanel() : base() {
        # DockPanel manages its own layout
    }
    
    [void] SetChildDock([UIElement]$child, [DockPosition]$position) {
        # Add custom property to track dock position
        $child | Add-Member -MemberType NoteProperty -Name "DockPosition" -Value $position -Force
        $this.InvalidateLayout()
    }
    
    [void] SetChildHeight([UIElement]$child, [int]$height) {
        # Add custom property to track fixed height
        $child | Add-Member -MemberType NoteProperty -Name "FixedHeight" -Value $height -Force
        $child.Height = $height
        $this.InvalidateLayout()
    }
    
    [void] SetChildWidth([UIElement]$child, [int]$width) {
        # Add custom property to track fixed width
        $child | Add-Member -MemberType NoteProperty -Name "FixedWidth" -Value $width -Force
        $child.Width = $width
        $this.InvalidateLayout()
    }
    
    [DockPosition] GetChildDock([UIElement]$child) {
        if ($child.PSObject.Properties["DockPosition"]) {
            return $child.DockPosition
        }
        return [DockPosition]::Fill
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        ([Container]$this).OnBoundsChanged()
    }
    
    [void] AddChild([UIElement]$child) {
        ([Container]$this).AddChild($child)
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        ([Container]$this).RemoveChild($child)
        $this.InvalidateLayout()
    }
    
    [void] UpdateLayout() {
        # Check if layout needs updating
        if (-not $this._layoutInvalid -and 
            $this.Width -eq $this._lastWidth -and 
            $this.Height -eq $this._lastHeight -and 
            $this.Children.Count -eq $this._lastChildCount) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Recalculating layout for $($this.Children.Count) children")
        }
        
        # Initialize available area (full container minus any padding)
        $availableX = $this.X
        $availableY = $this.Y
        $availableWidth = $this.Width
        $availableHeight = $this.Height
        
        # Group children by dock position
        $topChildren = @()
        $bottomChildren = @()
        $leftChildren = @()
        $rightChildren = @()
        $fillChild = $null
        
        foreach ($child in $this.Children) {
            if (-not $child.Visible) { continue }
            
            $dock = $this.GetChildDock($child)
            switch ($dock) {
                ([DockPosition]::Top) { $topChildren += $child }
                ([DockPosition]::Bottom) { $bottomChildren += $child }
                ([DockPosition]::Left) { $leftChildren += $child }
                ([DockPosition]::Right) { $rightChildren += $child }
                ([DockPosition]::Fill) { $fillChild = $child }
            }
        }
        
        # Process docked children in order: Top, Bottom, Left, Right
        
        # Top docked children
        foreach ($child in $topChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $child.SetBounds($availableX, $availableY, $availableWidth, $childHeight)
            $availableY += $childHeight + $this.DockSpacing
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Bottom docked children
        foreach ($child in $bottomChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $childY = $availableY + $availableHeight - $childHeight
            $child.SetBounds($availableX, $childY, $availableWidth, $childHeight)
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Left docked children  
        foreach ($child in $leftChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $child.SetBounds($availableX, $availableY, $childWidth, $availableHeight)
            $availableX += $childWidth + $this.DockSpacing
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Right docked children
        foreach ($child in $rightChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $childX = $availableX + $availableWidth - $childWidth
            $child.SetBounds($childX, $availableY, $childWidth, $availableHeight)
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Fill remaining space with fill child (if LastChildFill is enabled and we have one)
        if ($this.LastChildFill -and $fillChild) {
            # Ensure minimum size
            $fillWidth = [Math]::Max(0, $availableWidth)
            $fillHeight = [Math]::Max(0, $availableHeight)
            $fillChild.SetBounds($availableX, $availableY, $fillWidth, $fillHeight)
        }
        
        # Cache current state
        $this._contentX = $availableX
        $this._contentY = $availableY
        $this._contentWidth = $availableWidth
        $this._contentHeight = $availableHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Layout complete. Content area: ($availableX,$availableY) ${availableWidth}x$availableHeight")
        }
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering - render all visible children
        $sb = Get-PooledStringBuilder 2048
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child first
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [hashtable] GetContentArea() {
        $this.UpdateLayout()
        return @{
            X = $this._contentX
            Y = $this._contentY
            Width = $this._contentWidth
            Height = $this._contentHeight
        }
    }
    
    # Convenience methods for setting dock positions
    [void] DockTop([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Top) }
    [void] DockBottom([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Bottom) }
    [void] DockLeft([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Left) }
    [void] DockRight([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Right) }
    [void] DockFill([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Fill) }
}


####\Components/FastFileTree.ps1
# FastFileTree.ps1 - High-performance file system browser based on ALCAR patterns
# Fast string-based rendering with directory caching and lazy loading

class FileSystemNode {
    [string]$Name
    [string]$FullPath
    [bool]$IsDirectory
    [long]$Size
    [datetime]$LastModified
    [bool]$IsExpanded = $false
    [System.Collections.ArrayList]$Children
    [FileSystemNode]$Parent
    [int]$Level = 0
    [bool]$IsLoaded = $false
    [bool]$HasChildren = $false
    
    FileSystemNode([string]$fullPath) {
        $this.FullPath = $fullPath
        $this.Name = Split-Path $fullPath -Leaf
        $this.Children = [System.Collections.ArrayList]::new()
        
        if (Test-Path $fullPath) {
            $item = Get-Item $fullPath -ErrorAction SilentlyContinue
            if ($item) {
                $this.IsDirectory = $item.PSIsContainer
                $this.Size = if (-not $this.IsDirectory -and $item.Length) { $item.Length } else { 0 }
                $this.LastModified = $item.LastWriteTime
                
                # Check if directory has children without loading them
                if ($this.IsDirectory) {
                    try {
                        $hasItems = Get-ChildItem $fullPath -Force -ErrorAction Stop | Select-Object -First 1
                        $this.HasChildren = $hasItems -ne $null
                    } catch {
                        $this.HasChildren = $false
                    }
                }
            }
        }
    }
    
    [void] LoadChildren() {
        if ($this.IsLoaded -or -not $this.IsDirectory) {
            return
        }
        
        try {
            $items = Get-ChildItem $this.FullPath -Force -ErrorAction Stop | Sort-Object @{Expression={$_.PSIsContainer}; Descending=$true}, Name
            
            $this.Children.Clear()
            foreach ($item in $items) {
                $child = [FileSystemNode]::new($item.FullName)
                $child.Parent = $this
                $child.Level = $this.Level + 1
                $this.Children.Add($child) | Out-Null
            }
            
            $this.IsLoaded = $true
            $this.HasChildren = $this.Children.Count -gt 0
            
        } catch {
            # Access denied or other error - mark as loaded but empty
            $this.IsLoaded = $true
            $this.HasChildren = $false
        }
    }
    
    [string] GetIcon() {
        if ($this.IsDirectory) {
            if ($this.IsExpanded) { 
                return "" 
            } else { 
                return "" 
            }
        }
        
        # File type icons based on extension
        $ext = [System.IO.Path]::GetExtension($this.Name).ToLower()
        switch ($ext) {
            ".ps1" { return "" }
            ".txt" { return "" }
            ".log" { return "" }
            ".json" { return "" }
            ".xml" { return "" }
            ".md" { return "" }
            ".zip" { return "" }
            ".exe" { return "" }
            ".dll" { return "" }
            ".png" { return "" }
            ".jpg" { return "" }
            ".gif" { return "" }
            default { return "" }
        }
        return ""  # Fallback
    }
    
    [string] GetSizeString() {
        if ($this.IsDirectory) {
            return ""
        }
        
        if ($this.Size -lt 1KB) {
            return "$($this.Size) B"
        } elseif ($this.Size -lt 1MB) {
            return "$([math]::Round($this.Size / 1KB, 1)) KB"
        } elseif ($this.Size -lt 1GB) {
            return "$([math]::Round($this.Size / 1MB, 1)) MB"
        } else {
            return "$([math]::Round($this.Size / 1GB, 2)) GB"
        }
    }
}

class FastFileTree : UIElement {
    [string]$RootPath = ""
    [FileSystemNode]$RootNode
    [System.Collections.ArrayList]$_flatView
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = "File Browser"
    [bool]$ShowSize = $true
    [bool]$ShowModified = $false
    [string]$Filter = "*"
    
    # Events
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnFileSelected = {}
    [scriptblock]$OnDirectoryChanged = {}
    
    # Visual settings
    [int]$IndentSize = 2
    [string]$ExpandedIcon = ""
    [string]$CollapsedIcon = ""
    
    hidden [ThemeManager]$Theme
    hidden [int]$_lastSelectedIndex = -1
    hidden [System.Collections.Generic.HashSet[string]]$_expandedPaths
    hidden [hashtable]$_colors = @{}
    
    FastFileTree() : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        
        # Default to current directory
        $this.RootPath = $PWD.Path
    }
    
    FastFileTree([string]$rootPath) : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        $this.RootPath = $rootPath
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        $this.LoadDirectory($this.RootPath)
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selection' = $this.Theme.GetBgColor("selection")
                'normal' = $this.Theme.GetColor("normal")
                'directory' = $this.Theme.GetColor("directory")
                'file' = $this.Theme.GetColor("file")
                'border.focused' = $this.Theme.GetColor("border.focused")
                'foreground' = $this.Theme.GetColor("foreground")
                'background' = $this.Theme.GetBgColor("background")
            }
        }
        $this.Invalidate()
    }
    
    
    # Public API
    [void] LoadDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        try {
            $this.RootPath = Resolve-Path $path
            $this.RootNode = [FileSystemNode]::new($this.RootPath)
            $this.RootNode.IsExpanded = $true
            $this.RootNode.LoadChildren()
            
            # Auto-expand remembered paths
            $this.RestoreExpandedState()
            
            $this.RebuildFlatView()
            $this.SelectedIndex = 0
            $this.ScrollOffset = 0
            $this.Invalidate()
            
            # Fire directory changed event
            if ($this.OnDirectoryChanged) {
                & $this.OnDirectoryChanged $this.RootPath
            }
            
        } catch {
            # Handle errors - could show in status or log
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Error("FastFileTree: Failed to load directory '$path': $($_.Exception.Message)")
            }
        }
    }
    
    [void] NavigateUp() {
        $parentPath = Split-Path $this.RootPath -Parent
        if ($parentPath -and (Test-Path $parentPath)) {
            $this.LoadDirectory($parentPath)
        }
    }
    
    [void] NavigateToSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory) {
            $this.LoadDirectory($selected.FullPath)
        }
    }
    
    [FileSystemNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] ExpandSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and -not $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] CollapseSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] ToggleExpanded([FileSystemNode]$node) {
        if (-not $node.IsDirectory) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        
        if ($node.IsExpanded) {
            $node.LoadChildren()
            $this._expandedPaths.Add($node.FullPath) | Out-Null
        } else {
            $this._expandedPaths.Remove($node.FullPath) | Out-Null
        }
        
        $this.RebuildFlatView()
        
        # Try to keep selection on the same node
        $this.SetSelectedNode($node)
        $this.Invalidate()
    }
    
    [void] SetSelectedNode([FileSystemNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].FullPath -eq $node.FullPath) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex) {
                if ($this.OnSelectionChanged) {
                    & $this.OnSelectionChanged
                }
            }
            
            $this.Invalidate()
        }
    }
    
    [void] RefreshCurrent() {
        # Save current selection
        $selectedPath = $null
        $selected = $this.GetSelectedNode()
        if ($selected) {
            $selectedPath = $selected.FullPath
        }
        
        # Reload directory
        $this.LoadDirectory($this.RootPath)
        
        # Restore selection if possible
        if ($selectedPath) {
            for ($i = 0; $i -lt $this._flatView.Count; $i++) {
                if ($this._flatView[$i].FullPath -eq $selectedPath) {
                    $this.SelectIndex($i)
                    break
                }
            }
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        if ($this.RootNode) {
            $this.AddNodeToFlatView($this.RootNode)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([FileSystemNode]$node) {
        # Apply filter for non-directories
        if (-not $node.IsDirectory -and $this.Filter -ne "*") {
            if (-not ($node.Name -like $this.Filter)) {
                return
            }
        }
        
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] RestoreExpandedState() {
        if ($this.RootNode) {
            $this.RestoreExpandedStateRecursive($this.RootNode)
        }
    }
    
    [void] RestoreExpandedStateRecursive([FileSystemNode]$node) {
        if ($this._expandedPaths.Contains($node.FullPath)) {
            $node.IsExpanded = $true
            $node.LoadChildren()
        }
        
        foreach ($child in $node.Children) {
            $this.RestoreExpandedStateRecursive($child)
        }
    }
    
    [void] EnsureVisible() {
        # Calculate visible lines based on current dimensions
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        $borderReduction = $effectiveShowBorder ? 2 : 0
        $titleReduction = ($this.Title -and $this.Height -gt $borderReduction) ? 1 : 0
        $visibleLines = [Math]::Max(0, $this.Height - $borderReduction - $titleReduction)
        
        if ($visibleLines -gt 0) {
            if ($this.SelectedIndex -lt $this.ScrollOffset) {
                $this.ScrollOffset = $this.SelectedIndex
            } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
                $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
            }
            
            $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
        }
    }
    
    # Rendering
    [string] OnRender() {
        return $this.BuildRenderString()
    }
    
    [string] BuildRenderString() {
        # Validate dimensions before rendering
        if ($this.Width -le 0 -or $this.Height -le 0) {
            return ""
        }
        
        # Disable border if dimensions are too small
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        
        # Use StringBuilder pool if available, otherwise create new
        $sb = $null
        if (Get-Command -Name 'Get-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            $sb = Get-PooledStringBuilder 4096  # File trees can be quite large
        } else {
            $sb = [System.Text.StringBuilder]::new(4096)
        }
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selection']
        $normalColor = $this._colors['normal']
        $directoryColor = if ($this._colors['directory']) { $this._colors['directory'] } else { $normalColor }
        $fileColor = if ($this._colors['file']) { $this._colors['file'] } else { $normalColor }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area with proper bounds checking
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($effectiveShowBorder ? 2 : 0)
        
        # Ensure content width is never negative
        if ($contentWidth -lt 0) {
            $contentWidth = 0
        }
        
        if ($effectiveShowBorder) {
            # Top border - safe to render since we validated Width >= 3
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title -and $contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                if ($titleText.Length -gt $contentWidth) {
                    $titleText = "..." + $titleText.Substring($titleText.Length - $contentWidth + 3)
                }
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title -and $this.Width -gt 0) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render file/directory entries
        $visibleLines = $contentHeight - ($effectiveShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
            
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                }
                
                # Build display line
                $line = ""
                
                # Indentation
                $line += [StringCache]::GetSpaces($node.Level * $this.IndentSize)
                
                # Expand/collapse icon for directories
                if ($node.IsDirectory -and $node.HasChildren) {
                    $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
                } else {
                    $line += "  "  # Space for alignment
                }
                
                # File/directory icon
                $line += $node.GetIcon() + " "
                
                # Name
                $line += $node.Name
                
                # Size (for files, if enabled)
                if ($this.ShowSize -and -not $node.IsDirectory) {
                    $sizeStr = $node.GetSizeString()
                    if ($sizeStr) {
                        $line += " ($sizeStr)"
                    }
                }
                
                # Pad and truncate to fit
                $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
                
                # Apply appropriate color and render line
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                if ($i -eq $this.SelectedIndex) {
                    # Selected item - use selection colors
                    $sb.Append($selectedBg)
                    $foregroundColor = $this._colors['foreground']
                    $sb.Append($foregroundColor)
                } else {
                    # Normal item - directory or file color with normal background
                    $normalBg = $this._colors['background']
                    $sb.Append($normalBg)
                    $color = if ($node.IsDirectory) { $directoryColor } else { $fileColor }
                    $sb.Append($color)
                }
                $sb.Append($line)
            }
            
            # Side borders
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append([StringCache]::GetSpaces($contentWidth))
            }
            
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($effectiveShowBorder) {
            # Bottom border - safe to render since we validated Width >= 3
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        if (Get-Command -Name 'Return-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            Return-PooledStringBuilder $sb  # Return to pool for reuse
        }
        return $result
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.GetSelectedNode()
                if ($selected) {
                    if ($selected.IsDirectory) {
                        if ($selected.HasChildren) {
                            $this.ToggleExpanded($selected)
                        } else {
                            $this.LoadDirectory($selected.FullPath)
                        }
                    } else {
                        # Fire file selected event
                        if ($this.OnFileSelected) {
                            & $this.OnFileSelected $selected
                        }
                    }
                }
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                $selected = $this.GetSelectedNode()
                if ($selected -and $selected.IsDirectory -and $selected.HasChildren) {
                    $this.ToggleExpanded($selected)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Backspace) {
                $this.NavigateUp()
                $handled = $true
            }
            ([System.ConsoleKey]::F5) {
                $this.RefreshCurrent()
                $handled = $true
            }
        }
        
        # Handle character keys for quick navigation
        if (-not $handled -and $key.KeyChar -ge 'A' -and $key.KeyChar -le 'z') {
            $this.QuickNavigate($key.KeyChar)
            $handled = $true
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] QuickNavigate([char]$char) {
        $startIndex = ($this.SelectedIndex + 1) % $this._flatView.Count
        
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            $index = ($startIndex + $i) % $this._flatView.Count
            $node = $this._flatView[$index]
            
            if ($node.Name.Length -gt 0 -and [char]::ToLower($node.Name[0]) -eq [char]::ToLower($char)) {
                $this.SelectIndex($index)
                break
            }
        }
    }
    
    [void] OnGotFocus() {
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this.Invalidate()
    }
}


####\Components/GridPanel.ps1
# GridPanel.ps1 - Fast grid layout component for PRAXIS

class GridPanel : Container {
    [int]$Columns = 2
    [int]$Rows = 0  # Auto-calculated if 0
    [int]$CellSpacing = 1
    [int]$MinCellWidth = 5
    [int]$MinCellHeight = 2
    [bool]$ShowBorder = $false
    [bool]$AutoSize = $true  # Auto-calculate rows based on children
    
    # Cached layout calculations
    hidden [int]$_cachedCellWidth = 0
    hidden [int]$_cachedCellHeight = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastColumns = 0
    hidden [int]$_lastChildCount = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    GridPanel() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    GridPanel([int]$columns) : base() {
        $this.Columns = [Math]::Max(1, $columns)
        $this.DrawBackground = $false
    }
    
    [void] SetGridSize([int]$columns, [int]$rows) {
        $this.Columns = [Math]::Max(1, $columns)
        $this.Rows = [Math]::Max(0, $rows)
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] AddChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).AddChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).RemoveChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastHeight -eq $this.Height -and
            $this._lastColumns -eq $this.Columns -and
            $this._lastChildCount -eq $this.Children.Count) {
            return  # Layout is still valid
        }
        
        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) {
            $this._layoutInvalid = $false
            return
        }
        
        # Calculate grid dimensions
        $cols = $this.Columns
        $actualRows = if ($this.AutoSize) {
            [Math]::Ceiling($visibleChildren.Count / $cols)
        } else {
            [Math]::Max(1, $this.Rows)
        }
        
        # Calculate cell dimensions
        $totalSpacingWidth = ($cols - 1) * $this.CellSpacing
        $totalSpacingHeight = ($actualRows - 1) * $this.CellSpacing
        
        $cellWidth = [Math]::Max($this.MinCellWidth, 
            [int](($this.Width - $totalSpacingWidth) / $cols))
        $cellHeight = [Math]::Max($this.MinCellHeight, 
            [int](($this.Height - $totalSpacingHeight) / $actualRows))
        
        # Position children in grid
        for ($i = 0; $i -lt $visibleChildren.Count; $i++) {
            $child = $visibleChildren[$i]
            $col = $i % $cols
            $row = [int]($i / $cols)
            
            # Calculate position
            $childX = $this.X + ($col * ($cellWidth + $this.CellSpacing))
            $childY = $this.Y + ($row * ($cellHeight + $this.CellSpacing))
            
            # Set child bounds
            $child.SetBounds($childX, $childY, $cellWidth, $cellHeight)
        }
        
        # Cache the layout
        $this._cachedCellWidth = $cellWidth
        $this._cachedCellHeight = $cellHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastColumns = $this.Columns
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 2048
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        # Optional: render grid borders
        if ($this.ShowBorder -and $this._cachedCellWidth -gt 0) {
            $borderColor = $this._colors['border']
            $sb.Append($borderColor)
            
            # Draw grid lines (simplified - just basic grid)
            $cols = $this.Columns
            $actualRows = if ($this.AutoSize) {
                [Math]::Ceiling($this.Children.Count / $cols)
            } else {
                $this.Rows
            }
            
            # Vertical lines
            for ($col = 1; $col -lt $cols; $col++) {
                $lineX = $this.X + ($col * ($this._cachedCellWidth + $this.CellSpacing)) - 1
                for ($y = 0; $y -lt $this.Height; $y++) {
                    $sb.Append([VT]::MoveTo($lineX, $this.Y + $y))
                    $sb.Append("")
                }
            }
            
            # Horizontal lines
            for ($row = 1; $row -lt $actualRows; $row++) {
                $lineY = $this.Y + ($row * ($this._cachedCellHeight + $this.CellSpacing)) - 1
                $sb.Append([VT]::MoveTo($this.X, $lineY))
                $sb.Append([StringCache]::GetHorizontalLine($this.Width))
            }
            
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [int] GetCellWidth() { return $this._cachedCellWidth }
    [int] GetCellHeight() { return $this._cachedCellHeight }
    
    # Get child at grid position
    [UIElement] GetChildAt([int]$col, [int]$row) {
        $index = ($row * $this.Columns) + $col
        if ($index -ge 0 -and $index -lt $this.Children.Count) {
            return $this.Children[$index]
        }
        return $null
    }
    
    # Focus management with grid navigation
    [void] FocusCell([int]$col, [int]$row) {
        $child = $this.GetChildAt($col, $row)
        if ($child -and $child.IsFocusable) {
            $child.Focus()
        }
    }
}


####\Components/HorizontalSplit.ps1
# HorizontalSplit.ps1 - Fast horizontal layout component for PRAXIS

class HorizontalSplit : Container {
    [UIElement]$LeftPane
    [UIElement]$RightPane
    [int]$SplitRatio = 50  # Percentage for left pane (0-100)
    [int]$MinPaneWidth = 5
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedLeftWidth = 0
    hidden [int]$_cachedRightWidth = 0
    hidden [int]$_cachedRightX = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastSplitRatio = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    HorizontalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    [void] SetLeftPane([UIElement]$pane) {
        if ($this.LeftPane) {
            $this.RemoveChild($this.LeftPane)
        }
        $this.LeftPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetRightPane([UIElement]$pane) {
        if ($this.RightPane) {
            $this.RemoveChild($this.RightPane)
        }
        $this.RightPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalWidth = $this.Width
        $leftWidth = [int](($totalWidth * $this.SplitRatio) / 100)
        $leftWidth = [Math]::Max($this.MinPaneWidth, [Math]::Min($leftWidth, $totalWidth - $this.MinPaneWidth))
        $rightWidth = $totalWidth - $leftWidth
        $rightX = $this.X + $leftWidth
        
        # Update left pane
        if ($this.LeftPane) {
            $this.LeftPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        }
        
        # Update right pane
        if ($this.RightPane) {
            $this.RightPane.SetBounds($rightX, $this.Y, $rightWidth, $this.Height)
        }
        
        # Cache the layout
        $this._cachedLeftWidth = $leftWidth
        $this._cachedRightWidth = $rightWidth
        $this._cachedRightX = $rightX
        $this._lastWidth = $this.Width
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 1024
        
        # Render children
        if ($this.LeftPane -and $this.LeftPane.Visible) {
            $sb.Append($this.LeftPane.Render())
        }
        
        if ($this.RightPane -and $this.RightPane.Visible) {
            $sb.Append($this.RightPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedLeftWidth -gt 0) {
            $borderColor = $this._colors['border']
            for ($y = 0; $y -lt $this.Height; $y++) {
                $sb.Append([VT]::MoveTo($this._cachedRightX - 1, $this.Y + $y))
                $sb.Append($borderColor)
                $sb.Append("")
            }
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.LeftPane -and $this.LeftPane.IsFocused) {
            if ($this.LeftPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.RightPane -and $this.RightPane.IsFocused) {
            if ($this.RightPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetLeftFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetRightFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetLeftPane() { return $this.LeftPane }
    [UIElement] GetRightPane() { return $this.RightPane }
    
    # Focus management
    [void] FocusLeftPane() {
        if ($this.LeftPane -and $this.LeftPane.IsFocusable) {
            $this.LeftPane.Focus()
        }
    }
    
    [void] FocusRightPane() {
        if ($this.RightPane -and $this.RightPane.IsFocusable) {
            $this.RightPane.Focus()
        }
    }
}


####\Components/ListBox.ps1
# ListBox.ps1 - Fast list box component with selection and scrolling

class ListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [int]$VisibleItems = 10
    [bool]$ShowBorder = $true
    [bool]$ShowScrollbar = $true
    
    # Display properties
    [scriptblock]$ItemRenderer = { param($item) $item.ToString() }
    [string]$Title = ""
    
    # Callback for selection changes
    [scriptblock]$OnSelectionChanged = {}
    
    # Cached rendering
    hidden [string]$_cachedItems = ""
    hidden [bool]$_itemsCacheInvalid = $true
    hidden [ThemeManager]$Theme
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedRender = ""
    
    # Cached theme colors
    hidden [hashtable]$_colors = @{}
    
    ListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        # Cache colors on theme change
        if ($this.Theme) {
            $this._colors = @{
                "accent" = $this.Theme.GetColor("accent")
                "foreground" = $this.Theme.GetColor("foreground")
                "selection.bg" = $this.Theme.GetBgColor("selection")
                "selection.fg" = $this.Theme.GetColor("menu.selected.foreground")
                "border" = $this.Theme.GetColor("border")
                "border.focused" = $this.Theme.GetColor("border.focused")
                "scrollbar" = $this.Theme.GetColor("scrollbar")
                "scrollbar.thumb" = $this.Theme.GetColor("scrollbar.thumb")
                "disabled" = $this.Theme.GetColor("disabled")
                "background" = $this.Theme.GetBgColor("background")
            }
        }
        $this._dataVersion++  # Increment for theme change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] SetItems([array]$items) {
        $oldIndex = $this.SelectedIndex
        $this.Items.Clear()
        $this.Items.AddRange($items)
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on any data change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
        
        # Trigger callback if we have items and the selection changed
        if ($this.Items.Count -gt 0 -and ($oldIndex -ne 0 -or $this.Items.Count -eq 1) -and $this.OnSelectionChanged) {
            try {
                & $this.OnSelectionChanged
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("ListBox.SetItems: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                }
            }
        }
    }
    
    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible($index)
            $this._dataVersion++  # Increment on selection change
            $this._itemsCacheInvalid = $true
            $this.Invalidate()
            
            # Trigger callback if selection actually changed
            if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
                try {
                    & $this.OnSelectionChanged
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ListBox.SelectIndex: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                    }
                }
            }
        }
    }
    
    [void] EnsureVisible([int]$index) {
        # Adjust scroll to keep selected item visible
        $visibleEnd = $this.ScrollOffset + $this.VisibleItems - 1
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        } elseif ($index -gt $visibleEnd) {
            $this.ScrollOffset = $index - $this.VisibleItems + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # Recalculate visible items based on height
        $contentHeight = $this.Height
        if ($this.ShowBorder) { $contentHeight -= 2 }
        if ($this.Title) { $contentHeight -= 1 }
        
        $this.VisibleItems = [Math]::Max(1, $contentHeight)
        $this._itemsCacheInvalid = $true
    }
    
    [string] OnRender() {
        if ($this._itemsCacheInvalid) {
            $this.RebuildItemsCache()
        }
        return $this._cachedItems
    }
    
    [void] RebuildItemsCache() {
        $sb = Get-PooledStringBuilder 2048  # ListBox can have many items
        
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($sb)
            $contentX++
            $contentY++
            $contentWidth -= 2
        }
        
        # Draw title if present
        if ($this.Title) {
            $sb.Append([VT]::MoveTo($contentX, $contentY))
            $sb.Append($this._colors["accent"])
            $titleText = $this.Title
            if ($titleText.Length -gt $contentWidth) {
                $titleText = $titleText.Substring(0, $contentWidth - 3) + "..."
            }
            $sb.Append($titleText)
            $sb.Append($this._colors["foreground"])
            $contentY++
        }
        
        # Draw items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        $itemY = $contentY
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $text = & $this.ItemRenderer $item
            
            # Truncate if too long
            if ($text.Length -gt $contentWidth - 2) {
                $text = $text.Substring(0, $contentWidth - 5) + "..."
            }
            
            $sb.Append([VT]::MoveTo($contentX, $itemY))
            
            # Selection highlighting
            if ($i -eq $this.SelectedIndex) {
                if ($this.IsFocused) {
                    $sb.Append($this._colors["selection.bg"])
                    $sb.Append($this._colors["selection.fg"])
                } else {
                    $sb.Append($this._colors["disabled"])
                }
                $sb.Append("> ")
            } else {
                $sb.Append("  ")
            }
            
            $sb.Append($text)
            
            # Clear to end of line if selected
            if ($i -eq $this.SelectedIndex) {
                $remainingSpace = $contentWidth - $text.Length - 2
                if ($remainingSpace -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($remainingSpace))
                }
                $sb.Append([VT]::Reset())
            }
            
            $itemY++
        }
        
        # Clear any remaining empty lines in the visible area
        $remainingLines = $this.VisibleItems - ($endIndex - $this.ScrollOffset)
        if ($remainingLines -gt 0) {
            $bgColor = $this._colors["background"]
            $clearLine = [StringCache]::GetSpaces($contentWidth)
            
            for ($i = 0; $i -lt $remainingLines; $i++) {
                $sb.Append([VT]::MoveTo($contentX, $itemY))
                $sb.Append($bgColor)
                $sb.Append($clearLine)
                $sb.Append([VT]::Reset())
                $itemY++
            }
        }
        
        # Draw scrollbar if enabled and needed
        if ($this.ShowScrollbar -and $this.Items.Count -gt $this.VisibleItems) {
            $this.DrawScrollbar($sb)
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedItems = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._itemsCacheInvalid = $false
    }
    
    [void] DrawBorder([System.Text.StringBuilder]$sb) {
        $borderColor = if ($this.IsFocused) { 
            $this._colors["border.focused"] 
        } else { 
            $this._colors["border"] 
        }
        
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
        
        # Side borders
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        $sb.Append([VT]::Reset())
    }
    
    [void] DrawScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        if ($this.ShowBorder) { $scrollbarX-- }
        
        $scrollbarY = $this.Y + 1
        if ($this.ShowBorder) { $scrollbarY++ }
        if ($this.Title) { $scrollbarY++ }
        
        $scrollbarHeight = $this.VisibleItems
        
        # Calculate thumb position and size
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $this.VisibleItems / $this.Items.Count))
        $thumbPos = [int]($scrollbarY + ($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $this.VisibleItems))
        
        # Draw scrollbar track and thumb
        for ($y = $scrollbarY; $y -lt $scrollbarY + $scrollbarHeight; $y++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $y))
            
            if ($y -ge $thumbPos -and $y -lt $thumbPos + $thumbSize) {
                $sb.Append($this._colors["accent"])
                $sb.Append("")
            } else {
                $sb.Append($this._colors["border"])
                $sb.Append("")
            }
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $false
            
            switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectIndex($this.SelectedIndex - 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectIndex($this.SelectedIndex + 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $newIndex = [Math]::Max(0, $this.SelectedIndex - $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $newIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectIndex(0)
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectIndex($this.Items.Count - 1)
                $handled = $true
            }
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ListBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Focus handling
    [void] OnGotFocus() {
        $this._dataVersion++  # Increment for focus change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._dataVersion++  # Increment for focus change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
}


####\Components/LoadingIndicator.ps1
# LoadingIndicator.ps1 - Visual feedback for loading states

enum LoadingStyle {
    Spinner = 0
    Dots = 1
    Bar = 2
    Pulse = 3
    Minimal = 4
}

class LoadingIndicator : UIElement {
    [string]$Message = "Loading..."
    [LoadingStyle]$Style = [LoadingStyle]::Minimal
    [bool]$ShowProgress = $false
    [double]$Progress = 0.0  # 0.0 to 1.0
    
    # Animation state
    hidden [int]$_animationFrame = 0
    hidden [DateTime]$_lastUpdate
    hidden [System.Timers.Timer]$_animationTimer
    
    # Visual elements
    hidden [string[]]$_spinnerFrames = @('', '', '', '', '', '', '', '', '', '')
    hidden [string[]]$_dotsFrames = @('.  ', '.. ', '...', '   ')
    hidden [string[]]$_pulseFrames = @('', '', '', '', '', '', '', '')
    
    # Colors
    hidden [hashtable]$_colors = @{}
    
    LoadingIndicator() : base() {
        $this.Height = 3
        $this._lastUpdate = [DateTime]::Now
        
        # Create animation timer
        $this._animationTimer = [System.Timers.Timer]::new(100)  # 10 FPS
        $this._animationTimer.AutoReset = $true
        
        Register-ObjectEvent -InputObject $this._animationTimer -EventName Elapsed -Action {
            $Event.MessageData.UpdateAnimation()
        } -MessageData $this | Out-Null
    }
    
    [void] OnInitialize() {
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
        
        # Start animation
        $this._animationTimer.Start()
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._colors = @{
                accent = $this.Theme.GetColor('accent')
                normal = $this.Theme.GetColor('normal')
                disabled = $this.Theme.GetColor('disabled')
                background = $this.Theme.GetBgColor('panel.background')
            }
        }
    }
    
    [void] UpdateAnimation() {
        $this._animationFrame++
        $this.Invalidate()
    }
    
    [void] SetProgress([double]$progress) {
        $this.Progress = [Math]::Max(0.0, [Math]::Min(1.0, $progress))
        $this.ShowProgress = $true
        $this.Invalidate()
    }
    
    [void] Show() {
        $this.Visible = $true
        $this._animationTimer.Start()
        $this.Invalidate()
    }
    
    [void] Hide() {
        $this.Visible = $false
        $this._animationTimer.Stop()
        $this.Invalidate()
    }
    
    [string] OnRender() {
        if (-not $this.Visible) { return "" }
        
        $sb = Get-PooledStringBuilder 512
        
        # Clear area with background
        $sb.Append($this._colors.background)
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append(' ' * $this.Width)
        }
        
        # Center content
        $centerY = $this.Y + ($this.Height / 2)
        
        # Render based on style
        switch ($this.Style) {
            ([LoadingStyle]::Spinner) {
                $frame = $this._spinnerFrames[$this._animationFrame % $this._spinnerFrames.Count]
                $text = "$frame $($this.Message)"
                $centerX = $this.X + ($this.Width - $text.Length) / 2
                
                $sb.Append([VT]::MoveTo($centerX, $centerY))
                $sb.Append($this._colors.accent)
                $sb.Append($frame)
                $sb.Append(' ')
                $sb.Append($this._colors.normal)
                $sb.Append($this.Message)
            }
            
            ([LoadingStyle]::Dots) {
                $dots = $this._dotsFrames[$this._animationFrame % $this._dotsFrames.Count]
                $text = "$($this.Message)$dots"
                $centerX = $this.X + ($this.Width - $text.Length) / 2
                
                $sb.Append([VT]::MoveTo($centerX, $centerY))
                $sb.Append($this._colors.normal)
                $sb.Append($this.Message)
                $sb.Append($this._colors.accent)
                $sb.Append($dots)
            }
            
            ([LoadingStyle]::Bar) {
                # Message
                $messageX = $this.X + ($this.Width - $this.Message.Length) / 2
                $sb.Append([VT]::MoveTo($messageX, $centerY - 1))
                $sb.Append($this._colors.normal)
                $sb.Append($this.Message)
                
                # Progress bar
                $barWidth = [Math]::Min(40, $this.Width - 4)
                $barX = $this.X + ($this.Width - $barWidth) / 2
                $barY = $centerY + 1
                
                if ($this.ShowProgress) {
                    # Determinate progress
                    $filledWidth = [int]($barWidth * $this.Progress)
                    
                    $sb.Append([VT]::MoveTo($barX, $barY))
                    $sb.Append($this._colors.disabled)
                    $sb.Append('[')
                    
                    $sb.Append($this._colors.accent)
                    $sb.Append('' * $filledWidth)
                    
                    $sb.Append($this._colors.disabled)
                    $sb.Append('' * ($barWidth - $filledWidth))
                    $sb.Append(']')
                    
                    # Percentage
                    $percentage = [int]($this.Progress * 100)
                    $percentText = " $percentage%"
                    $sb.Append($this._colors.normal)
                    $sb.Append($percentText)
                } else {
                    # Indeterminate progress
                    $position = $this._animationFrame % ($barWidth + 10) - 5
                    
                    $sb.Append([VT]::MoveTo($barX, $barY))
                    $sb.Append($this._colors.disabled)
                    $sb.Append('[')
                    
                    for ($i = 0; $i -lt $barWidth; $i++) {
                        if ($i -ge $position -and $i -lt $position + 5) {
                            $sb.Append($this._colors.accent)
                            $sb.Append('')
                        } else {
                            $sb.Append($this._colors.disabled)
                            $sb.Append('')
                        }
                    }
                    
                    $sb.Append($this._colors.disabled)
                    $sb.Append(']')
                }
            }
            
            ([LoadingStyle]::Pulse) {
                $pulse = $this._pulseFrames[$this._animationFrame % $this._pulseFrames.Count]
                $text = "$pulse $($this.Message) $pulse"
                $centerX = $this.X + ($this.Width - $text.Length) / 2
                
                $sb.Append([VT]::MoveTo($centerX, $centerY))
                $sb.Append($this._colors.accent)
                $sb.Append($pulse)
                $sb.Append(' ')
                $sb.Append($this._colors.normal)
                $sb.Append($this.Message)
                $sb.Append(' ')
                $sb.Append($this._colors.accent)
                $sb.Append($pulse)
            }
            
            ([LoadingStyle]::Minimal) {
                # Simple centered message with subtle animation
                $centerX = $this.X + ($this.Width - $this.Message.Length) / 2
                
                $sb.Append([VT]::MoveTo($centerX, $centerY))
                
                # Fade effect using different colors
                $fadeIndex = $this._animationFrame % 4
                switch ($fadeIndex) {
                    0 { $sb.Append($this._colors.disabled) }
                    1 { $sb.Append($this._colors.normal) }
                    2 { $sb.Append($this._colors.accent) }
                    3 { $sb.Append($this._colors.normal) }
                }
                
                $sb.Append($this.Message)
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] Cleanup() {
        if ($this._animationTimer) {
            $this._animationTimer.Stop()
            $this._animationTimer.Dispose()
        }
    }
}

# Loading overlay for full-screen loading states
class LoadingOverlay : Screen {
    [LoadingIndicator]$Indicator
    [string]$Title = ""
    [bool]$Cancellable = $true
    [scriptblock]$OnCancel = {}
    
    LoadingOverlay([string]$message) : base() {
        $this.DrawBackground = $true
        
        # Create loading indicator
        $this.Indicator = [LoadingIndicator]::new()
        $this.Indicator.Message = $message
        $this.Indicator.Style = [LoadingStyle]::Bar
    }
    
    [void] OnInitialize() {
        ([Screen]$this).OnInitialize()
        
        # Dark overlay
        if ($this.Theme) {
            $overlayColor = [VT]::RGBBG(0, 0, 0)
            $this.SetBackgroundColor($overlayColor)
        }
        
        # Center indicator
        $indicatorWidth = [Math]::Min(60, $this.Width - 10)
        $indicatorHeight = 5
        $indicatorX = ($this.Width - $indicatorWidth) / 2
        $indicatorY = ($this.Height - $indicatorHeight) / 2
        
        $this.Indicator.SetBounds($indicatorX, $indicatorY, $indicatorWidth, $indicatorHeight)
        $this.AddChild($this.Indicator)
        $this.Indicator.Initialize($this.ServiceContainer)
        $this.Indicator.Show()
        
        # Add title if provided
        if ($this.Title) {
            $titleElement = [UIElement]::new()
            $titleElement.OnRender = {
                $sb = Get-PooledStringBuilder 256
                $theme = $this.ServiceContainer.GetService('ThemeManager')
                $titleX = ($this.Parent.Width - $this.Parent.Title.Length) / 2
                $titleY = $this.Y - 2
                
                $sb.Append([VT]::MoveTo($titleX, $titleY))
                $sb.Append($theme.GetColor('accent'))
                $sb.Append($this.Parent.Title)
                $sb.Append([VT]::Reset())
                
                $result = $sb.ToString()
                Return-PooledStringBuilder $sb
                return $result
            }.GetNewClosure()
            
            $titleElement.SetBounds(0, $indicatorY - 2, $this.Width, 1)
            $this.AddChild($titleElement)
        }
        
        # Add cancel hint if cancellable
        if ($this.Cancellable) {
            $hintElement = [UIElement]::new()
            $hintElement.OnRender = {
                $sb = Get-PooledStringBuilder 256
                $theme = $this.ServiceContainer.GetService('ThemeManager')
                $hint = "Press ESC to cancel"
                $hintX = ($this.Parent.Width - $hint.Length) / 2
                $hintY = $this.Y + 3
                
                $sb.Append([VT]::MoveTo($hintX, $hintY))
                $sb.Append($theme.GetColor('disabled'))
                $sb.Append($hint)
                $sb.Append([VT]::Reset())
                
                $result = $sb.ToString()
                Return-PooledStringBuilder $sb
                return $result
            }.GetNewClosure()
            
            $hintElement.SetBounds(0, $indicatorY + $indicatorHeight, $this.Width, 1)
            $this.AddChild($hintElement)
        }
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Render dimmed background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::Dim())
            $sb.Append('' * $this.Width)
        }
        
        # Render children (indicator, title, hint)
        $sb.Append(([Screen]$this).OnRender())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($this.Cancellable -and $key.Key -eq [System.ConsoleKey]::Escape) {
            if ($this.OnCancel) {
                & $this.OnCancel
            }
            
            if ($global:ScreenManager) {
                [void]$global:ScreenManager.Pop()
            }
            return $true
        }
        
        return $false
    }
    
    [void] SetProgress([double]$progress) {
        $this.Indicator.SetProgress($progress)
    }
    
    [void] UpdateMessage([string]$message) {
        $this.Indicator.Message = $message
        $this.Indicator.Invalidate()
    }
}

# Helper class for managing loading states
class LoadingManager {
    hidden [LoadingOverlay]$_currentOverlay
    hidden [ScreenManager]$_screenManager
    
    [void] Initialize([ServiceContainer]$container) {
        $this._screenManager = $container.GetService('ScreenManager')
    }
    
    [LoadingOverlay] ShowLoading([string]$message, [bool]$cancellable = $true) {
        if ($this._currentOverlay) {
            $this.HideLoading()
        }
        
        $this._currentOverlay = [LoadingOverlay]::new($message)
        $this._currentOverlay.Cancellable = $cancellable
        
        if ($this._screenManager) {
            $this._screenManager.Push($this._currentOverlay)
        }
        
        return $this._currentOverlay
    }
    
    [void] HideLoading() {
        if ($this._currentOverlay -and $this._screenManager) {
            $this._screenManager.Pop()
            $this._currentOverlay = $null
        }
    }
    
    [void] UpdateProgress([double]$progress) {
        if ($this._currentOverlay) {
            $this._currentOverlay.SetProgress($progress)
        }
    }
    
    [void] UpdateMessage([string]$message) {
        if ($this._currentOverlay) {
            $this._currentOverlay.UpdateMessage($message)
        }
    }
}


####\Components/MinimalButton.ps1
# MinimalButton.ps1 - Clean, minimalist button component

class MinimalButton : FocusableComponent {
    [string]$Text = "Button"
    [scriptblock]$OnClick = {}
    [bool]$IsDefault = $false
    [int]$Padding = 2  # Horizontal padding
    
    # Cached colors
    hidden [string]$_normalColor = ""
    hidden [string]$_accentColor = ""
    
    MinimalButton() : base() {
        $this.Height = 1  # Single line for minimalism
        $this.FocusStyle = 'minimal'
    }
    
    MinimalButton([string]$text) : base() {
        $this.Text = $text
        $this.Height = 1
        $this.FocusStyle = 'minimal'
    }
    
    [void] OnInitialize() {
        ([FocusableComponent]$this).OnInitialize()
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._normalColor = $this.Theme.GetColor('button.foreground')
            $this._accentColor = $this.Theme.GetColor('accent')
        }
    }
    
    [void] SetText([string]$text) {
        if ($this.Text -ne $text) {
            $this.Text = $text
            $this.Invalidate()
        }
    }
    
    [string] RenderContent() {
        $sb = Get-PooledStringBuilder 256
        
        # Position
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        
        # Clean minimal style
        if ($this.IsFocused) {
            # Focused: accent color with subtle brackets
            $sb.Append($this._accentColor)
            $sb.Append('[ ')
            $sb.Append($this.Text)
            $sb.Append(' ]')
        } else {
            # Normal: just padded text
            $sb.Append($this._normalColor)
            $sb.Append(' ' * $this.Padding)
            $sb.Append($this.Text)
            $sb.Append(' ' * $this.Padding)
        }
        
        # Default indicator
        if ($this.IsDefault) {
            $sb.Append(' ')
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] OnHandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                $this.Click()
                return $true
            }
            ([System.ConsoleKey]::Spacebar) {
                $this.Click()
                return $true
            }
        }
        return $false
    }
    
    [void] Click() {
        if ($this.OnClick) {
            try {
                & $this.OnClick
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("Button click error: $_")
                }
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Auto-size width based on text if not set
        if ($this.Width -eq 0) {
            $this.Width = $this.Text.Length + (2 * $this.Padding) + 2
        }
    }
}


####\Components/MinimalContextMenu.ps1
# MinimalContextMenu.ps1 - Clean, minimal context menu component

class ContextMenuItem {
    [string]$Text
    [string]$Shortcut = ""
    [scriptblock]$Action
    [bool]$IsSeparator = $false
    [bool]$IsEnabled = $true
    [string]$Icon = ""  # Optional icon/emoji
    
    ContextMenuItem() {}
    
    ContextMenuItem([string]$text, [scriptblock]$action) {
        $this.Text = $text
        $this.Action = $action
    }
    
    static [ContextMenuItem] Separator() {
        $item = [ContextMenuItem]::new()
        $item.IsSeparator = $true
        return $item
    }
}

class MinimalContextMenu : UIElement {
    [System.Collections.Generic.List[ContextMenuItem]]$Items
    [int]$SelectedIndex = 0
    [bool]$IsVisible = $false
    [int]$MenuX = 0
    [int]$MenuY = 0
    [int]$MenuWidth = 0
    [int]$MenuHeight = 0
    [scriptblock]$OnClose = {}
    
    # Styling
    [BorderType]$BorderType = [BorderType]::Rounded
    [bool]$ShowShadow = $true
    [int]$MinWidth = 20
    [int]$MaxWidth = 40
    
    # Colors
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    MinimalContextMenu() : base() {
        $this.Items = [System.Collections.Generic.List[ContextMenuItem]]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._colors = @{
                background = $this.Theme.GetBgColor('menu.background')
                text = $this.Theme.GetColor('menu.foreground')
                selected = $this.Theme.GetColor('menu.selected.foreground')
                selectedBg = $this.Theme.GetBgColor('menu.selected.background')
                disabled = $this.Theme.GetColor('disabled')
                border = $this.Theme.GetColor('border')
                shortcut = $this.Theme.GetColor('accent')
                separator = $this.Theme.GetColor('border')
            }
        }
    }
    
    [void] AddItem([string]$text, [scriptblock]$action) {
        $this.Items.Add([ContextMenuItem]::new($text, $action))
    }
    
    [void] AddItem([ContextMenuItem]$item) {
        $this.Items.Add($item)
    }
    
    [void] AddSeparator() {
        $this.Items.Add([ContextMenuItem]::Separator())
    }
    
    [void] Show([int]$x, [int]$y) {
        $this.MenuX = $x
        $this.MenuY = $y
        $this.IsVisible = $true
        
        # Calculate menu dimensions
        $this.CalculateSize()
        
        # Adjust position to stay on screen
        $screenWidth = [Console]::WindowWidth
        $screenHeight = [Console]::WindowHeight
        
        if ($this.MenuX + $this.MenuWidth -gt $screenWidth) {
            $this.MenuX = $screenWidth - $this.MenuWidth - 1
        }
        if ($this.MenuY + $this.MenuHeight -gt $screenHeight) {
            $this.MenuY = $screenHeight - $this.MenuHeight - 1
        }
        
        # Find first selectable item
        $this.SelectedIndex = -1
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if (-not $this.Items[$i].IsSeparator -and $this.Items[$i].IsEnabled) {
                $this.SelectedIndex = $i
                break
            }
        }
        
        $this.Focus()
        $this.Invalidate()
    }
    
    [void] Hide() {
        $this.IsVisible = $false
        if ($this.OnClose) {
            & $this.OnClose
        }
        $this.Invalidate()
    }
    
    [void] CalculateSize() {
        $maxTextLength = 0
        $maxShortcutLength = 0
        
        foreach ($item in $this.Items) {
            if (-not $item.IsSeparator) {
                $textLen = $item.Text.Length
                if ($item.Icon) { $textLen += 3 }  # Icon + space
                $maxTextLength = [Math]::Max($maxTextLength, $textLen)
                $maxShortcutLength = [Math]::Max($maxShortcutLength, $item.Shortcut.Length)
            }
        }
        
        # Width = padding + text + gap + shortcut + padding
        $this.MenuWidth = 2 + $maxTextLength + 2 + $maxShortcutLength + 2
        $this.MenuWidth = [Math]::Max($this.MinWidth, [Math]::Min($this.MaxWidth, $this.MenuWidth))
        
        # Height = border + items + border
        $this.MenuHeight = 2 + $this.Items.Count
    }
    
    [string] OnRender() {
        if (-not $this.IsVisible) { return "" }
        
        $sb = Get-PooledStringBuilder 2048
        
        # Shadow
        if ($this.ShowShadow) {
            $this.RenderShadow($sb)
        }
        
        # Background
        $sb.Append($this._colors.background)
        for ($y = 0; $y -lt $this.MenuHeight; $y++) {
            $sb.Append([VT]::MoveTo($this.MenuX, $this.MenuY + $y))
            $sb.Append(' ' * $this.MenuWidth)
        }
        
        # Border
        $sb.Append([BorderStyle]::RenderBorder(
            $this.MenuX, $this.MenuY, $this.MenuWidth, $this.MenuHeight,
            $this.BorderType, $this._colors.border
        ))
        
        # Items
        $y = $this.MenuY + 1
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $this.RenderItem($sb, $this.Items[$i], $i, $y)
            $y++
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] RenderShadow([System.Text.StringBuilder]$sb) {
        $shadowColor = [VT]::RGBBG(20, 20, 20)
        
        # Right shadow
        for ($y = 1; $y -lt $this.MenuHeight; $y++) {
            $sb.Append([VT]::MoveTo($this.MenuX + $this.MenuWidth, $this.MenuY + $y))
            $sb.Append($shadowColor)
            $sb.Append(' ')
        }
        
        # Bottom shadow
        $sb.Append([VT]::MoveTo($this.MenuX + 1, $this.MenuY + $this.MenuHeight))
        $sb.Append($shadowColor)
        $sb.Append(' ' * $this.MenuWidth)
        
        $sb.Append([VT]::Reset())
    }
    
    [void] RenderItem([System.Text.StringBuilder]$sb, [ContextMenuItem]$item, [int]$index, [int]$y) {
        $sb.Append([VT]::MoveTo($this.MenuX + 1, $y))
        
        if ($item.IsSeparator) {
            # Render separator
            $sb.Append($this._colors.separator)
            $sb.Append('' * ($this.MenuWidth - 2))
        } else {
            # Selection highlight
            if ($index -eq $this.SelectedIndex) {
                $sb.Append($this._colors.selectedBg)
                $sb.Append($this._colors.selected)
            } else {
                $sb.Append($this._colors.background)
                if ($item.IsEnabled) {
                    $sb.Append($this._colors.text)
                } else {
                    $sb.Append($this._colors.disabled)
                }
            }
            
            # Icon
            if ($item.Icon) {
                $sb.Append(" $($item.Icon) ")
            } else {
                $sb.Append("  ")
            }
            
            # Text
            $text = $item.Text
            $availableWidth = $this.MenuWidth - 6  # Borders + padding
            if ($item.Shortcut) {
                $availableWidth -= ($item.Shortcut.Length + 2)
            }
            
            if ($text.Length -gt $availableWidth) {
                $text = $text.Substring(0, $availableWidth - 1) + ""
            }
            $sb.Append($text)
            
            # Padding
            $paddingLength = $availableWidth - $text.Length
            if ($paddingLength -gt 0) {
                $sb.Append(' ' * $paddingLength)
            }
            
            # Shortcut
            if ($item.Shortcut) {
                $sb.Append("  ")
                if ($index -eq $this.SelectedIndex) {
                    $sb.Append($this._colors.selected)
                } else {
                    $sb.Append($this._colors.shortcut)
                }
                $sb.Append($item.Shortcut)
            }
            
            # Clear to end
            $sb.Append("  ")
        }
        
        $sb.Append([VT]::Reset())
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsVisible) { return $false }
        
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                $this.Hide()
                return $true
            }
            ([System.ConsoleKey]::UpArrow) {
                $this.SelectPrevious()
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                $this.SelectNext()
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $this.ExecuteSelected()
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectFirst()
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectLast()
                return $true
            }
        }
        
        # Check for shortcut keys
        foreach ($item in $this.Items) {
            if ($item.Shortcut -and $item.IsEnabled -and -not $item.IsSeparator) {
                # Simple shortcut matching (first character)
                if ($item.Shortcut.Length -gt 0 -and 
                    [char]::ToUpper($key.KeyChar) -eq [char]::ToUpper($item.Shortcut[0])) {
                    if ($item.Action) {
                        & $item.Action
                    }
                    $this.Hide()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [void] SelectNext() {
        if ($this.Items.Count -eq 0) { return }
        
        $start = $this.SelectedIndex
        do {
            $this.SelectedIndex = ($this.SelectedIndex + 1) % $this.Items.Count
            $item = $this.Items[$this.SelectedIndex]
        } while (($item.IsSeparator -or -not $item.IsEnabled) -and $this.SelectedIndex -ne $start)
        
        $this.Invalidate()
    }
    
    [void] SelectPrevious() {
        if ($this.Items.Count -eq 0) { return }
        
        $start = $this.SelectedIndex
        do {
            $this.SelectedIndex--
            if ($this.SelectedIndex -lt 0) {
                $this.SelectedIndex = $this.Items.Count - 1
            }
            $item = $this.Items[$this.SelectedIndex]
        } while (($item.IsSeparator -or -not $item.IsEnabled) -and $this.SelectedIndex -ne $start)
        
        $this.Invalidate()
    }
    
    [void] SelectFirst() {
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $item = $this.Items[$i]
            if (-not $item.IsSeparator -and $item.IsEnabled) {
                $this.SelectedIndex = $i
                $this.Invalidate()
                return
            }
        }
    }
    
    [void] SelectLast() {
        for ($i = $this.Items.Count - 1; $i -ge 0; $i--) {
            $item = $this.Items[$i]
            if (-not $item.IsSeparator -and $item.IsEnabled) {
                $this.SelectedIndex = $i
                $this.Invalidate()
                return
            }
        }
    }
    
    [void] ExecuteSelected() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            $item = $this.Items[$this.SelectedIndex]
            if ($item.IsEnabled -and -not $item.IsSeparator -and $item.Action) {
                & $item.Action
            }
        }
        $this.Hide()
    }
}


####\Components/MinimalDataGrid.ps1
# MinimalDataGrid.ps1 - Clean, minimalist data grid component

class MinimalDataGrid : FocusableComponent {
    [System.Collections.Generic.List[object]]$Items
    [System.Collections.Generic.List[GridColumn]]$Columns
    [int]$SelectedIndex = -1
    [string]$Title = ""
    [bool]$ShowBorder = $true
    [bool]$ShowHeader = $true
    [bool]$ShowGridLines = $false  # Minimal style - no grid lines by default
    [bool]$ShowRowNumbers = $false
    [bool]$AlternateRowColors = $false
    [BorderType]$BorderType = [BorderType]::Rounded
    
    # Scrolling
    hidden [int]$_scrollOffset = 0
    hidden [int]$_viewportHeight = 0
    hidden [int]$_headerHeight = 0
    
    # Cached rendering
    hidden [string]$_cachedHeader = ""
    hidden [bool]$_headerInvalid = $true
    
    # Colors
    hidden [hashtable]$_colors = @{}
    
    MinimalDataGrid() : base() {
        $this.Items = [System.Collections.Generic.List[object]]::new()
        $this.Columns = [System.Collections.Generic.List[GridColumn]]::new()
        $this.FocusStyle = 'minimal'
    }
    
    [void] OnInitialize() {
        ([FocusableComponent]$this).OnInitialize()
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                    $this._headerInvalid = $true
                }.GetNewClosure())
            }
        }
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._colors = @{
                header = $this.Theme.GetColor('header.foreground')
                headerBg = $this.Theme.GetBgColor('header.background')
                normal = $this.Theme.GetColor('normal')
                selected = $this.Theme.GetColor('menu.selected.foreground')
                selectedBg = $this.Theme.GetBgColor('menu.selected.background')
                alternate = $this.Theme.GetColor('disabled')
                border = $this.Theme.GetColor('border')
                accent = $this.Theme.GetColor('accent')
            }
        }
    }
    
    [void] AddColumn([string]$name, [scriptblock]$valueGetter, [int]$width = 0) {
        $col = [GridColumn]::new()
        $col.Name = $name
        $col.ValueGetter = $valueGetter
        $col.Width = $width
        $this.Columns.Add($col)
        $this._headerInvalid = $true
        $this.Invalidate()
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items.Clear()
        $this.Items.AddRange($items)
        
        # Auto-size columns if needed
        $this.AutoSizeColumns()
        
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = $this.Items.Count - 1
        }
        
        $this.Invalidate()
    }
    
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns.Clear()
        foreach ($colDef in $columns) {
            $col = [GridColumn]::new()
            $col.Name = $colDef.Name
            $col.Header = $colDef.Header
            $col.Width = $colDef.Width
            if ($colDef.ContainsKey('Getter')) {
                $col.ValueGetter = $colDef.Getter
            }
            if ($colDef.ContainsKey('Formatter')) {
                $col.Formatter = $colDef.Formatter
            }
            $this.Columns.Add($col)
        }
        $this._headerInvalid = $true
        $this.Invalidate()
    }
    
    [void] AutoSizeColumns() {
        if ($this.Columns.Count -eq 0) { return }
        
        # Calculate max width for each column
        foreach ($col in $this.Columns) {
            if ($col.Width -gt 0) { continue }  # Skip fixed-width columns
            
            $maxWidth = $col.Name.Length
            foreach ($item in $this.Items) {
                $value = ""
                if ($col.ValueGetter) {
                    $value = (& $col.ValueGetter $item).ToString()
                } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                    $value = $item."$($col.Name)".ToString()
                }
                $maxWidth = [Math]::Max($maxWidth, $value.Length)
            }
            
            $col.Width = [Math]::Max(3, [Math]::Min($maxWidth + 2, 30))  # Min 3, max 30 chars
        }
    }
    
    [string] RenderContent() {
        if ($this.Columns.Count -eq 0) { return "" }
        
        $sb = Get-PooledStringBuilder 4096
        
        # Calculate viewport
        $this._headerHeight = if ($this.ShowHeader) { 2 } else { 0 }
        $borderInset = if ($this.BorderType -ne [BorderType]::None) { 2 } else { 0 }
        $this._viewportHeight = $this.Height - $this._headerHeight - $borderInset
        
        # Ensure scroll is valid
        $this.EnsureSelectedVisible()
        
        # Render border if enabled
        if ($this.BorderType -ne [BorderType]::None) {
            $color = if ($this.IsFocused) { $this._colors.accent } else { $this._colors.border }
            $sb.Append([BorderStyle]::RenderBorder(
                $this.X, $this.Y, $this.Width, $this.Height,
                $this.BorderType, $color
            ))
        }
        
        # Render header
        if ($this.ShowHeader) {
            if ($this._headerInvalid) {
                $this.RebuildHeader()
            }
            $sb.Append($this._cachedHeader)
        }
        
        # Render rows
        $startY = $this.Y + $this._headerHeight
        if ($this.BorderType -ne [BorderType]::None) { $startY++ }
        
        $endIndex = [Math]::Min($this._scrollOffset + $this._viewportHeight, $this.Items.Count)
        
        for ($i = $this._scrollOffset; $i -lt $endIndex; $i++) {
            $y = $startY + ($i - $this._scrollOffset)
            $this.RenderRow($sb, $i, $y)
        }
        
        # Minimal scrollbar if needed
        if ($this.Items.Count -gt $this._viewportHeight) {
            $this.RenderScrollbar($sb)
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] RenderRow([System.Text.StringBuilder]$sb, [int]$index, [int]$y) {
        $item = $this.Items[$index]
        $x = $this.X + 1
        if ($this.BorderType -ne [BorderType]::None) { $x++ }
        
        $sb.Append([VT]::MoveTo($x, $y))
        
        # Row selection
        if ($index -eq $this.SelectedIndex) {
            $sb.Append($this._colors.selectedBg)
            $sb.Append($this._colors.selected)
            if ($this.IsFocused) {
                $sb.Append(' ')
            } else {
                $sb.Append('  ')
            }
        } else {
            # Alternate row colors
            if ($this.AlternateRowColors -and ($index % 2 -eq 1)) {
                $sb.Append($this._colors.alternate)
            } else {
                $sb.Append($this._colors.normal)
            }
            $sb.Append('  ')
        }
        
        # Row number if enabled
        if ($this.ShowRowNumbers) {
            $sb.Append(($index + 1).ToString().PadLeft(4))
            $sb.Append('  ')
        }
        
        # Render columns
        foreach ($col in $this.Columns) {
            $value = ""
            if ($col.ValueGetter) {
                $rawValue = & $col.ValueGetter $item
                if ($col.Formatter) {
                    $value = (& $col.Formatter $rawValue).ToString()
                } else {
                    $value = if ($null -ne $rawValue) { $rawValue.ToString() } else { "" }
                }
            } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                $rawValue = $item."$($col.Name)"
                if ($col.Formatter) {
                    $value = (& $col.Formatter $rawValue).ToString()
                } else {
                    $value = if ($null -ne $rawValue) { $rawValue.ToString() } else { "" }
                }
            }
            
            if ($col.Width -gt 1 -and $value.Length -gt $col.Width - 1) {
                $maxLength = [Math]::Max(1, $col.Width - 2)
                if ($value.Length -gt $maxLength) {
                    $value = $value.Substring(0, $maxLength) + ''
                }
            }
            $sb.Append($value.PadRight($col.Width))
        }
        
        # Clear to end of row
        $remainingWidth = $this.Width - ($x - $this.X) - 2
        if ($this.ShowRowNumbers) { $remainingWidth -= 7 }
        foreach ($col in $this.Columns) { $remainingWidth -= $col.Width }
        if ($remainingWidth -gt 0) {
            $sb.Append(' ' * $remainingWidth)
        }
        
        $sb.Append([VT]::Reset())
    }
    
    [void] RebuildHeader() {
        $sb = Get-PooledStringBuilder 512
        
        $x = $this.X + 1
        $y = $this.Y
        if ($this.BorderType -ne [BorderType]::None) { 
            $x++
            $y++
        }
        
        # Header row
        $sb.Append([VT]::MoveTo($x, $y))
        $sb.Append($this._colors.headerBg)
        $sb.Append($this._colors.header)
        $sb.Append('  ')  # Selection column
        
        if ($this.ShowRowNumbers) {
            $sb.Append(' No.  ')
        }
        
        foreach ($col in $this.Columns) {
            $header = if ($col.Header) { $col.Header } else { $col.Name }
            if ($header.Length -gt $col.Width) {
                $header = $header.Substring(0, [Math]::Max(1, $col.Width - 1)) + ''
            }
            $sb.Append($header.PadRight($col.Width))
        }
        
        # Clear to end
        $totalWidth = 2
        if ($this.ShowRowNumbers) { $totalWidth += 7 }
        foreach ($col in $this.Columns) { $totalWidth += $col.Width }
        $remainingWidth = $this.Width - $totalWidth - 2
        if ($this.BorderType -ne [BorderType]::None) { $remainingWidth -= 2 }
        if ($remainingWidth -gt 0) {
            $sb.Append(' ' * $remainingWidth)
        }
        
        $sb.Append([VT]::Reset())
        
        # Separator line
        $sb.Append([VT]::MoveTo($x, $y + 1))
        $sb.Append($this._colors.border)
        $sb.Append('' * ($this.Width - 2))
        if ($this.BorderType -ne [BorderType]::None) {
            $sb.Length -= 2
        }
        $sb.Append([VT]::Reset())
        
        $this._cachedHeader = $sb.ToString()
        Return-PooledStringBuilder $sb
        $this._headerInvalid = $false
    }
    
    [void] RenderScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        if ($this.BorderType -ne [BorderType]::None) { $scrollbarX-- }
        
        $scrollbarY = $this.Y + $this._headerHeight
        if ($this.BorderType -ne [BorderType]::None) { $scrollbarY++ }
        
        $scrollbarHeight = $this._viewportHeight
        
        # Calculate thumb
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
        $thumbPos = [int]($this._scrollOffset * ($scrollbarHeight - $thumbSize) / ($this.Items.Count - $this._viewportHeight))
        
        $sb.Append($this._colors.border)
        
        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $scrollbarY + $i))
            if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) {
                $sb.Append('')
            } else {
                $sb.Append('')
            }
        }
        
        $sb.Append([VT]::Reset())
    }
    
    [void] EnsureSelectedVisible() {
        if ($this.SelectedIndex -lt 0 -or $this.Items.Count -eq 0) { return }
        
        if ($this.SelectedIndex -lt $this._scrollOffset) {
            $this._scrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this._scrollOffset + $this._viewportHeight)) {
            $this._scrollOffset = $this.SelectedIndex - $this._viewportHeight + 1
        }
        
        $maxScroll = [Math]::Max(0, $this.Items.Count - $this._viewportHeight)
        $this._scrollOffset = [Math]::Max(0, [Math]::Min($this._scrollOffset, $maxScroll))
    }
    
    [bool] OnHandleInput([System.ConsoleKeyInfo]$key) {
        if ($this.Items.Count -eq 0) { return $false }
        
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.Invalidate()
                }
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                    $this.SelectedIndex++
                    $this.Invalidate()
                }
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this._scrollOffset = 0
                $this.Invalidate()
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.Invalidate()
                return $true
            }
            ([System.ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this._viewportHeight)
                $this.Invalidate()
                return $true
            }
            ([System.ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this._viewportHeight)
                $this.Invalidate()
                return $true
            }
        }
        
        return $false
    }
    
    [void] OnBoundsChanged() {
        $this._headerInvalid = $true
        $this.AutoSizeColumns()
    }
    
    [void] OnGotFocus() {
        if ($this.SelectedIndex -lt 0 -and $this.Items.Count -gt 0) {
            $this.SelectedIndex = 0
        }
        ([FocusableComponent]$this).OnGotFocus()
    }
    
    # Get selected item
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    # Select specific index
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.SelectedIndex = $index
            $this.EnsureSelectedVisible()
            $this.Invalidate()
        }
    }
}

class GridColumn {
    [string]$Name
    [string]$Header
    [scriptblock]$ValueGetter
    [scriptblock]$Formatter
    [int]$Width
}


####\Components/MinimalListBox.ps1
# MinimalListBox.ps1 - Clean, minimalist list box component

class MinimalListBox : FocusableComponent {
    [System.Collections.Generic.List[object]]$Items
    [int]$SelectedIndex = -1
    [scriptblock]$OnSelectionChanged = {}
    [bool]$ShowBorder = $false
    [BorderType]$BorderType = [BorderType]::Rounded
    [bool]$ShowScrollbar = $true
    
    # Display options
    [scriptblock]$ItemFormatter = { param($item) $item.ToString() }
    [int]$MaxDisplayLength = 0  # 0 = no limit
    
    # Scrolling
    hidden [int]$_scrollOffset = 0
    hidden [int]$_viewportHeight = 0
    
    # Cached colors
    hidden [string]$_normalColor = ""
    hidden [string]$_selectedColor = ""
    hidden [string]$_selectedBgColor = ""
    hidden [string]$_scrollbarColor = ""
    
    MinimalListBox() : base() {
        $this.Items = [System.Collections.Generic.List[object]]::new()
        $this.FocusStyle = 'minimal'
    }
    
    [void] OnInitialize() {
        ([FocusableComponent]$this).OnInitialize()
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._normalColor = $this.Theme.GetColor('normal')
            $this._selectedColor = $this.Theme.GetColor('menu.selected.foreground')
            $this._selectedBgColor = $this.Theme.GetBgColor('menu.selected.background')
            $this._scrollbarColor = $this.Theme.GetColor('scrollbar')
        }
    }
    
    [void] SetItems([object[]]$items) {
        $this.Items.Clear()
        $this.Items.AddRange($items)
        
        # Reset selection if out of bounds
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = $this.Items.Count - 1
        }
        
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [string] RenderContent() {
        $sb = Get-PooledStringBuilder 2048
        
        # Calculate viewport
        $this._viewportHeight = $this.Height
        if ($this.ShowBorder) { $this._viewportHeight -= 2 }
        
        # Ensure scroll offset is valid
        $this.EnsureSelectedVisible()
        
        # Draw items
        $startY = $this.Y
        if ($this.ShowBorder) { $startY++ }
        
        $endIndex = [Math]::Min($this._scrollOffset + $this._viewportHeight, $this.Items.Count)
        
        for ($i = $this._scrollOffset; $i -lt $endIndex; $i++) {
            $y = $startY + ($i - $this._scrollOffset)
            $sb.Append([VT]::MoveTo($this.X + 1, $y))
            
            # Format item
            $text = & $this.ItemFormatter $this.Items[$i]
            if ($this.MaxDisplayLength -gt 0 -and $text.Length -gt $this.MaxDisplayLength) {
                $text = $text.Substring(0, $this.MaxDisplayLength - 1) + ""
            }
            
            # Pad to width
            $availableWidth = $this.Width - 2
            if ($this.ShowScrollbar -and $this.Items.Count -gt $this._viewportHeight) {
                $availableWidth--
            }
            
            if ($text.Length -lt $availableWidth) {
                $text = $text.PadRight($availableWidth)
            } elseif ($text.Length -gt $availableWidth) {
                $text = $text.Substring(0, $availableWidth - 1) + ""
            }
            
            # Render with selection highlight
            if ($i -eq $this.SelectedIndex) {
                $sb.Append($this._selectedBgColor)
                $sb.Append($this._selectedColor)
                if ($this.IsFocused) {
                    $sb.Append(" ")  # Minimal focus indicator
                    $text = $text.Substring(2)
                }
            } else {
                $sb.Append($this._normalColor)
                $sb.Append("  ")
                $text = $text.Substring(2)
            }
            
            $sb.Append($text)
            $sb.Append([VT]::Reset())
        }
        
        # Minimal scrollbar
        if ($this.ShowScrollbar -and $this.Items.Count -gt $this._viewportHeight) {
            $this.RenderMinimalScrollbar($sb)
        }
        
        # Border if enabled
        if ($this.ShowBorder) {
            $this.RenderMinimalBorder($sb)
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] RenderMinimalScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        $scrollbarHeight = $this._viewportHeight
        $scrollbarY = $this.Y
        if ($this.ShowBorder) { 
            $scrollbarY++
            $scrollbarHeight = [Math]::Max(1, $scrollbarHeight - 2)
        }
        
        # Calculate thumb position
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $scrollbarHeight / $this.Items.Count))
        $thumbPos = [int]($this._scrollOffset * ($scrollbarHeight - $thumbSize) / ($this.Items.Count - $this._viewportHeight))
        
        $sb.Append($this._scrollbarColor)
        
        for ($i = 0; $i -lt $scrollbarHeight; $i++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $scrollbarY + $i))
            if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) {
                $sb.Append('')  # Minimal scrollbar thumb
            } else {
                $sb.Append('')  # Minimal scrollbar track
            }
        }
        
        $sb.Append([VT]::Reset())
    }
    
    [void] RenderMinimalBorder([System.Text.StringBuilder]$sb) {
        # Use BorderStyle for consistent rendering
        $borderColor = if ($this.IsFocused) { 
            $this.Theme.GetColor('border.focused') 
        } else { 
            $this.Theme.GetColor('border.normal') 
        }
        $sb.Append([BorderStyle]::RenderBorder($this.X, $this.Y, $this.Width, $this.Height, $this.BorderType, $borderColor))
    }
    
    [void] EnsureSelectedVisible() {
        if ($this.SelectedIndex -lt 0 -or $this.Items.Count -eq 0) { return }
        
        if ($this.SelectedIndex -lt $this._scrollOffset) {
            $this._scrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge ($this._scrollOffset + $this._viewportHeight)) {
            $this._scrollOffset = $this.SelectedIndex - $this._viewportHeight + 1
        }
        
        # Clamp scroll offset
        $maxScroll = [Math]::Max(0, $this.Items.Count - $this._viewportHeight)
        $this._scrollOffset = [Math]::Max(0, [Math]::Min($this._scrollOffset, $maxScroll))
    }
    
    [bool] OnHandleInput([System.ConsoleKeyInfo]$key) {
        if ($this.Items.Count -eq 0) { return $false }
        
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.OnSelectionChangedInternal($oldIndex)
                }
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt ($this.Items.Count - 1)) {
                    $this.SelectedIndex++
                    $this.OnSelectionChangedInternal($oldIndex)
                }
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this._scrollOffset = 0
                $this.OnSelectionChangedInternal($oldIndex)
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.OnSelectionChangedInternal($oldIndex)
                return $true
            }
            ([System.ConsoleKey]::PageUp) {
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $this._viewportHeight)
                $this.OnSelectionChangedInternal($oldIndex)
                return $true
            }
            ([System.ConsoleKey]::PageDown) {
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this._viewportHeight)
                $this.OnSelectionChangedInternal($oldIndex)
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.OnSelectionChanged) {
                    & $this.OnSelectionChanged
                }
                return $true
            }
        }
        
        return $false
    }
    
    [void] OnSelectionChangedInternal([int]$oldIndex) {
        if ($oldIndex -ne $this.SelectedIndex) {
            $this.Invalidate()
            if ($this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
    }
    
    [void] OnGotFocus() {
        if ($this.SelectedIndex -lt 0 -and $this.Items.Count -gt 0) {
            $this.SelectedIndex = 0
        }
        ([FocusableComponent]$this).OnGotFocus()
    }
}


####\Components/MinimalModal.ps1
# MinimalModal.ps1 - Clean, minimal modal dialog system

class MinimalModal : Screen {
    [string]$Title = ""
    [UIElement]$Content
    [int]$ModalWidth = 60
    [int]$ModalHeight = 20
    [BorderType]$BorderType = [BorderType]::Rounded
    [bool]$ShowOverlay = $true
    [bool]$CenterContent = $true
    
    # Buttons
    [System.Collections.Generic.List[ModalButton]]$Buttons
    [int]$SelectedButtonIndex = 0
    
    # Actions
    [scriptblock]$OnClose = {}
    
    # Internal
    hidden [Container]$ModalContainer
    hidden [Container]$ButtonContainer
    hidden [hashtable]$_colors = @{}
    hidden [int]$_modalX
    hidden [int]$_modalY
    
    MinimalModal() : base() {
        $this.Buttons = [System.Collections.Generic.List[ModalButton]]::new()
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        ([Screen]$this).OnInitialize()
        
        # Set dark overlay background
        if ($this.ShowOverlay -and $this.Theme) {
            $overlayColor = [VT]::RGBBG(0, 0, 0)  # Black overlay
            $this.SetBackgroundColor($overlayColor)
        }
        
        # Update colors
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
        
        # Create modal container
        $this.ModalContainer = [Container]::new()
        $this.ModalContainer.DrawBackground = $true
        
        # Calculate centered position
        $this._modalX = [Math]::Max(1, ($this.Width - $this.ModalWidth) / 2)
        $this._modalY = [Math]::Max(1, ($this.Height - $this.ModalHeight) / 2)
        
        $this.ModalContainer.SetBounds(
            $this.X + $this._modalX,
            $this.Y + $this._modalY,
            $this.ModalWidth,
            $this.ModalHeight
        )
        
        # Add content if provided
        if ($this.Content) {
            $this.ModalContainer.AddChild($this.Content)
            $this.Content.Initialize($this.ServiceContainer)
        }
        
        # Create button container
        if ($this.Buttons.Count -gt 0) {
            $this.CreateButtonContainer()
        }
        
        $this.AddChild($this.ModalContainer)
        
        # Focus first button or content
        $this.FocusFirst()
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._colors = @{
                modalBg = $this.Theme.GetBgColor('menu.background')
                border = $this.Theme.GetColor('border.focused')
                title = $this.Theme.GetColor('accent')
                text = $this.Theme.GetColor('normal')
            }
            
            if ($this.ModalContainer) {
                $this.ModalContainer.SetBackgroundColor($this._colors.modalBg)
            }
        }
    }
    
    [void] CreateButtonContainer() {
        $this.ButtonContainer = [Container]::new()
        $buttonY = $this.ModalHeight - 4
        $this.ButtonContainer.SetBounds(0, $buttonY, $this.ModalWidth, 3)
        
        # Create button instances
        $totalWidth = 0
        $buttonInstances = @()
        
        foreach ($btn in $this.Buttons) {
            $minBtn = [MinimalButton]::new($btn.Text)
            $minBtn.OnClick = $btn.OnClick
            $minBtn.IsDefault = $btn.IsDefault
            $buttonInstances += $minBtn
            $totalWidth += $btn.Text.Length + 6  # Padding
        }
        
        # Layout buttons
        $spacing = 2
        $startX = ($this.ModalWidth - $totalWidth - ($spacing * ($this.Buttons.Count - 1))) / 2
        $x = [Math]::Max(2, $startX)
        
        for ($i = 0; $i -lt $buttonInstances.Count; $i++) {
            $btn = $buttonInstances[$i]
            $this.ButtonContainer.AddChild($btn)
            $btn.Initialize($this.ServiceContainer)
            $width = $this.Buttons[$i].Text.Length + 6
            $btn.SetBounds($x, 0, $width, 1)
            $x += $width + $spacing
        }
        
        $this.ModalContainer.AddChild($this.ButtonContainer)
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Render overlay
        if ($this.ShowOverlay) {
            # Dim the background
            for ($y = 0; $y -lt $this.Height; $y++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
                $sb.Append([VT]::Dim())
                $sb.Append('' * $this.Width)
            }
        }
        
        # Render modal shadow (subtle)
        if ($this.BorderType -ne [BorderType]::None) {
            $shadowX = $this.X + $this._modalX + 2
            $shadowY = $this.Y + $this._modalY + 1
            $sb.Append([VT]::RGBBG(20, 20, 20))  # Very dark shadow
            
            for ($y = 0; $y -lt $this.ModalHeight - 1; $y++) {
                $sb.Append([VT]::MoveTo($shadowX, $shadowY + $y))
                $sb.Append(' ' * ($this.ModalWidth - 2))
            }
        }
        
        # Base render (includes modal container)
        $sb.Append(([Screen]$this).OnRender())
        
        # Render border
        if ($this.BorderType -ne [BorderType]::None) {
            $sb.Append([BorderStyle]::RenderBorderWithTitle(
                $this.X + $this._modalX,
                $this.Y + $this._modalY,
                $this.ModalWidth,
                $this.ModalHeight,
                $this.BorderType,
                $this._colors.border,
                $this.Title,
                $this._colors.title
            ))
        }
        
        # Render content area
        if ($this.Content -and $this.CenterContent) {
            # Position content with padding
            $contentX = $this.X + $this._modalX + 2
            $contentY = $this.Y + $this._modalY + 2
            $contentWidth = $this.ModalWidth - 4
            $contentHeight = $this.ModalHeight - 6  # Leave room for buttons
            
            if ($this.Buttons.Count -eq 0) {
                $contentHeight = $this.ModalHeight - 4
            }
            
            $this.Content.SetBounds($contentX, $contentY, $contentWidth, $contentHeight)
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] AddButton([string]$text, [scriptblock]$onClick, [bool]$isDefault = $false) {
        $btn = [ModalButton]::new()
        $btn.Text = $text
        $btn.OnClick = $onClick
        $btn.IsDefault = $isDefault
        $this.Buttons.Add($btn)
    }
    
    [void] Close() {
        if ($this.OnClose) {
            & $this.OnClose
        }
        
        if ($global:ScreenManager) {
            [void]$global:ScreenManager.Pop()
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Escape closes modal
        if ($key.Key -eq [System.ConsoleKey]::Escape) {
            $this.Close()
            return $true
        }
        
        # Enter activates default button
        if ($key.Key -eq [System.ConsoleKey]::Enter -and $this.Buttons.Count -gt 0) {
            $defaultBtn = $this.Buttons | Where-Object { $_.IsDefault } | Select-Object -First 1
            if ($defaultBtn -and $defaultBtn.OnClick) {
                & $defaultBtn.OnClick
                return $true
            }
        }
        
        return ([Screen]$this).HandleInput($key)
    }
    
    [void] OnBoundsChanged() {
        # Recenter modal
        $this._modalX = [Math]::Max(1, ($this.Width - $this.ModalWidth) / 2)
        $this._modalY = [Math]::Max(1, ($this.Height - $this.ModalHeight) / 2)
        
        if ($this.ModalContainer) {
            $this.ModalContainer.SetBounds(
                $this.X + $this._modalX,
                $this.Y + $this._modalY,
                $this.ModalWidth,
                $this.ModalHeight
            )
        }
    }
}

class ModalButton {
    [string]$Text
    [scriptblock]$OnClick
    [bool]$IsDefault
}

# Common modal types
class MessageModal : MinimalModal {
    [string]$Message = ""
    
    MessageModal([string]$title, [string]$message) : base() {
        $this.Title = $title
        $this.Message = $message
        $this.ModalWidth = [Math]::Max(40, $message.Length + 10)
        $this.ModalHeight = 10
        
        # Add OK button
        $this.AddButton("OK", { $this.Close() }, $true)
    }
    
    [void] OnInitialize() {
        # Create message content
        $this.Content = [UIElement]::new()
        $this.Content.OnRender = {
            $sb = Get-PooledStringBuilder 512
            $lines = $this.Parent.Parent.Message -split "`n"
            $y = $this.Y
            
            foreach ($line in $lines) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($line)
                $y++
            }
            
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        
        ([MinimalModal]$this).OnInitialize()
    }
}

class ConfirmModal : MinimalModal {
    [string]$Message = ""
    [scriptblock]$OnConfirm = {}
    [scriptblock]$OnCancel = {}
    
    ConfirmModal([string]$title, [string]$message) : base() {
        $this.Title = $title
        $this.Message = $message
        $this.ModalWidth = [Math]::Max(50, $message.Length + 10)
        $this.ModalHeight = 10
        
        # Add buttons
        $this.AddButton("Yes", {
            if ($this.OnConfirm) { & $this.OnConfirm }
            $this.Close()
        }, $true)
        
        $this.AddButton("No", {
            if ($this.OnCancel) { & $this.OnCancel }
            $this.Close()
        }, $false)
    }
    
    [void] OnInitialize() {
        # Create message content
        $this.Content = [UIElement]::new()
        $this.Content.OnRender = {
            $sb = Get-PooledStringBuilder 512
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            $lines = $this.Parent.Parent.Message -split "`n"
            $y = $this.Y
            
            $sb.Append($theme.GetColor('warning'))
            foreach ($line in $lines) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($line)
                $y++
            }
            $sb.Append([VT]::Reset())
            
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        
        ([MinimalModal]$this).OnInitialize()
    }
}


####\Components/MinimalStatusBar.ps1
# MinimalStatusBar.ps1 - Clean, minimal status bar component

class MinimalStatusBar : UIElement {
    # Status bar sections
    [string]$LeftText = ""
    [string]$CenterText = ""
    [string]$RightText = ""
    
    # Styling
    [bool]$ShowSeparator = $true
    [string]$SeparatorChar = ""
    [bool]$UseMinimalStyle = $true
    
    # Dynamic content providers
    [scriptblock]$LeftProvider = $null
    [scriptblock]$CenterProvider = $null
    [scriptblock]$RightProvider = $null
    
    # Shortcut hints
    [string[]]$ShortcutHints = @()
    
    # Colors
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    hidden [KeyboardShortcutManager]$ShortcutManager
    
    MinimalStatusBar() : base() {
        $this.Height = 1  # Single line for minimalism
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        $this.ShortcutManager = $this.ServiceContainer.GetService('KeyboardShortcutManager')
        
        if ($this.Theme) {
            $this.UpdateColors()
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
        
        # Update dynamic content periodically
        if ($this.LeftProvider -or $this.CenterProvider -or $this.RightProvider) {
            $timer = [System.Timers.Timer]::new(1000)  # Update every second
            $timer.Elapsed.Add({
                $this.UpdateDynamicContent()
                $this.Invalidate()
            }.GetNewClosure())
            $timer.Start()
        }
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._colors = @{
                background = $this.Theme.GetBgColor('header.background')
                text = $this.Theme.GetColor('normal')
                separator = $this.Theme.GetColor('border')
                accent = $this.Theme.GetColor('accent')
                dim = $this.Theme.GetColor('disabled')
            }
        }
    }
    
    [void] UpdateDynamicContent() {
        if ($this.LeftProvider) {
            $this.LeftText = & $this.LeftProvider
        }
        if ($this.CenterProvider) {
            $this.CenterText = & $this.CenterProvider
        }
        if ($this.RightProvider) {
            $this.RightText = & $this.RightProvider
        }
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 512
        
        # Move to position
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        
        # Background
        if ($this._colors.background -and -not $this.UseMinimalStyle) {
            $sb.Append($this._colors.background)
        }
        
        # Calculate sections
        $availableWidth = $this.Width
        $leftWidth = [Math]::Min($this.LeftText.Length, [int]($availableWidth * 0.3))
        $rightWidth = [Math]::Min($this.RightText.Length, [int]($availableWidth * 0.3))
        $centerWidth = $availableWidth - $leftWidth - $rightWidth - 4  # Space for separators
        
        # Left section
        if ($this.LeftText) {
            $sb.Append($this._colors.text)
            $text = $this.TruncateText($this.LeftText, $leftWidth)
            $sb.Append($text.PadRight($leftWidth))
        } else {
            $sb.Append(' ' * $leftWidth)
        }
        
        # Left separator
        if ($this.ShowSeparator -and $this.CenterText) {
            $sb.Append(' ')
            $sb.Append($this._colors.separator)
            $sb.Append($this.SeparatorChar)
            $sb.Append(' ')
        } else {
            $sb.Append('   ')
        }
        
        # Center section or shortcuts
        if ($this.ShortcutHints.Count -gt 0 -and $this.ShortcutManager) {
            # Render shortcuts instead of center text
            $hints = $this.ShortcutManager.RenderShortcutHints($this.ShortcutHints, $centerWidth)
            $sb.Append($hints)
            $sb.Append(' ' * [Math]::Max(0, $centerWidth - $hints.Length))
        } elseif ($this.CenterText) {
            $sb.Append($this._colors.accent)
            $text = $this.TruncateText($this.CenterText, $centerWidth)
            $padding = [Math]::Max(0, ($centerWidth - $text.Length) / 2)
            $sb.Append(' ' * [int]$padding)
            $sb.Append($text)
            $sb.Append(' ' * [int]($centerWidth - $text.Length - $padding))
        } else {
            $sb.Append(' ' * $centerWidth)
        }
        
        # Right separator
        if ($this.ShowSeparator -and $this.RightText) {
            $sb.Append(' ')
            $sb.Append($this._colors.separator)
            $sb.Append($this.SeparatorChar)
            $sb.Append(' ')
        } else {
            $sb.Append('   ')
        }
        
        # Right section
        if ($this.RightText) {
            $sb.Append($this._colors.dim)
            $text = $this.TruncateText($this.RightText, $rightWidth)
            $sb.Append($text.PadLeft($rightWidth))
        } else {
            $sb.Append(' ' * $rightWidth)
        }
        
        # Fill remaining space
        $totalLength = $leftWidth + $rightWidth + $centerWidth + 6
        if ($totalLength -lt $this.Width) {
            $sb.Append(' ' * ($this.Width - $totalLength))
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [string] TruncateText([string]$text, [int]$maxLength) {
        if ($text.Length -le $maxLength) {
            return $text
        }
        if ($maxLength -le 3) {
            return $text.Substring(0, $maxLength)
        }
        return $text.Substring(0, $maxLength - 1) + ""
    }
    
    # Helper methods for common status items
    static [string] FormatTime() {
        return [DateTime]::Now.ToString("HH:mm")
    }
    
    static [string] FormatMemory() {
        $process = [System.Diagnostics.Process]::GetCurrentProcess()
        $mb = [Math]::Round($process.WorkingSet64 / 1MB, 1)
        return "Mem: ${mb}MB"
    }
    
    static [string] FormatFPS([double]$fps) {
        return "FPS: $([Math]::Round($fps, 1))"
    }
}

# Specialized status bars
class ScreenStatusBar : MinimalStatusBar {
    [Screen]$ParentScreen
    
    [void] Initialize([Screen]$screen) {
        $this.ParentScreen = $screen
        
        # Default providers
        $this.LeftProvider = {
            if ($this.ParentScreen) {
                return $this.ParentScreen.Name
            }
            return ""
        }.GetNewClosure()
        
        $this.RightProvider = {
            return [MinimalStatusBar]::FormatTime()
        }
        
        # Set common shortcuts
        $this.ShortcutHints = @(
            "F1:Help",
            "Tab:Navigate", 
            "Ctrl+P:Command",
            "Esc:Back"
        )
    }
}

class FileStatusBar : MinimalStatusBar {
    [string]$FilePath = ""
    [int]$Line = 1
    [int]$Column = 1
    [bool]$Modified = $false
    
    [void] OnInitialize() {
        ([MinimalStatusBar]$this).OnInitialize()
        
        $this.LeftProvider = {
            $name = if ($this.FilePath) {
                [System.IO.Path]::GetFileName($this.FilePath)
            } else { "untitled" }
            
            if ($this.Modified) { $name = "*$name" }
            return $name
        }.GetNewClosure()
        
        $this.CenterProvider = {
            return "Ln $($this.Line), Col $($this.Column)"
        }.GetNewClosure()
        
        $this.RightProvider = {
            $items = @()
            if ($this.FilePath) {
                $ext = [System.IO.Path]::GetExtension($this.FilePath)
                if ($ext) { $items += $ext.TrimStart('.').ToUpper() }
            }
            $items += [MinimalStatusBar]::FormatTime()
            return $items -join "  "
        }.GetNewClosure()
    }
}


####\Components/MinimalTabContainer.ps1
# MinimalTabContainer.ps1 - Clean tab container without rendering artifacts

class MinimalTabContainer : Container {
    [System.Collections.Generic.List[TabItem]]$Tabs
    [int]$ActiveTabIndex = -1
    [int]$TabBarHeight = 1  # Minimal single-line tabs
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedTabBar = ""
    hidden [bool]$_tabBarInvalid = $true
    hidden [hashtable]$_colors = @{}
    
    # Double-buffering for artifact-free rendering
    hidden [UIElement]$_activeContent = $null
    hidden [bool]$_contentSwitching = $false
    
    MinimalTabContainer() : base() {
        $this.Tabs = [System.Collections.Generic.List[TabItem]]::new()
        $this.DrawBackground = $true  # Always clear background
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'normal' = $this.Theme.GetColor("tab.foreground")
                'active' = $this.Theme.GetColor("tab.active.foreground")
                'accent' = $this.Theme.GetColor("accent")
                'background' = $this.Theme.GetBgColor("background")
            }
        }
        $this._tabBarInvalid = $true
        $this.Invalidate()
    }
    
    [void] AddTab([string]$title, [UIElement]$content) {
        $tab = [TabItem]::new()
        $tab.Title = $title
        $tab.Content = $content
        $tab.ShortcutKey = [Math]::Min($this.Tabs.Count + 1, 9)
        
        # Initialize content
        if ($content -and $global:ServiceContainer) {
            $content.Initialize($global:ServiceContainer)
        }
        
        $this.Tabs.Add($tab)
        $this._tabBarInvalid = $true
        
        # Activate first tab
        if ($this.Tabs.Count -eq 1) {
            $this.ActivateTab(0)
        }
        
        $this.Invalidate()
    }
    
    [void] ActivateTab([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Tabs.Count -or $index -eq $this.ActiveTabIndex) {
            return
        }
        
        # Begin content switch
        $this._contentSwitching = $true
        
        # Clear focus from old content
        $focusManager = $null
        if ($this.ServiceContainer) {
            $focusManager = $this.ServiceContainer.GetService('FocusManager')
        }
        
        if ($focusManager -and $this._activeContent) {
            $focused = $focusManager.GetFocused()
            if ($focused -and $this.ContainsElement($focused)) {
                $focusManager.ClearFocus()
            }
        }
        
        # Remove old content
        if ($this._activeContent) {
            $this.Children.Remove($this._activeContent)
            if ($this._activeContent -is [Screen]) {
                $this._activeContent.OnDeactivated()
            }
        }
        
        # Update index
        $this.ActiveTabIndex = $index
        $newTab = $this.Tabs[$index]
        
        # Set new content
        $this._activeContent = $newTab.Content
        if ($this._activeContent) {
            # Position content
            $contentY = $this.Y + $this.TabBarHeight
            $contentHeight = $this.Height - $this.TabBarHeight
            $this._activeContent.SetBounds($this.X, $contentY, $this.Width, $contentHeight)
            
            # Add to children
            $this.Children.Add($this._activeContent)
            
            # Activate if screen
            if ($this._activeContent -is [Screen]) {
                $this._activeContent.OnActivated()
            }
            
            # Focus first focusable element
            if ($focusManager) {
                $focusables = $focusManager.GetFocusableChildren($this._activeContent)
                if ($focusables.Count -gt 0) {
                    [void]$focusManager.SetFocus($focusables[0])
                }
            }
        }
        
        # End content switch
        $this._contentSwitching = $false
        $this._tabBarInvalid = $true
        $this.Invalidate()
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Clear entire area first to prevent artifacts
        if ($this.DrawBackground -and $this._colors.ContainsKey('background')) {
            $sb.Append($this._colors['background'])
            for ($y = 0; $y -lt $this.Height; $y++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
                $sb.Append([StringCache]::GetSpaces($this.Width))
            }
        }
        
        # Render tab bar
        if ($this._tabBarInvalid) {
            $this.RebuildTabBar()
        }
        $sb.Append($this._cachedTabBar)
        
        # Render active content
        if ($this._activeContent -and -not $this._contentSwitching) {
            $sb.Append($this._activeContent.Render())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] RebuildTabBar() {
        $sb = Get-PooledStringBuilder 512
        
        # Move to tab bar position
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        
        # Clear tab bar line
        $sb.Append([StringCache]::GetSpaces($this.Width))
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        
        # Minimal tab style
        $x = $this.X + 1
        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {
            $tab = $this.Tabs[$i]
            $title = $tab.Title
            
            # Add shortcut number if applicable
            if ($tab.ShortcutKey -le 9) {
                $title = "$($tab.ShortcutKey):$title"
            }
            
            # Active tab styling
            if ($i -eq $this.ActiveTabIndex) {
                $sb.Append($this._colors['accent'])
                $sb.Append(" [$title] ")
                $sb.Append([VT]::Reset())
            } else {
                $sb.Append($this._colors['normal'])
                $sb.Append("  $title  ")
            }
            
            $x += $title.Length + 4
            
            # Add separator
            if ($i -lt $this.Tabs.Count - 1 -and $x -lt ($this.X + $this.Width - 10)) {
                $sb.Append($this._colors['normal'])
                $sb.Append("")
                $x += 1
            }
            
            # Stop if we run out of space
            if ($x -gt ($this.X + $this.Width - 5)) {
                break
            }
        }
        
        $sb.Append([VT]::Reset())
        
        # Subtle separator line
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.TabBarHeight - 1))
        $sb.Append($this._colors['normal'])
        $sb.Append('' * $this.Width)
        $sb.Append([VT]::Reset())
        
        $this._cachedTabBar = $sb.ToString()
        Return-PooledStringBuilder $sb
        $this._tabBarInvalid = $false
    }
    
    [void] OnBoundsChanged() {
        $this._tabBarInvalid = $true
        
        # Update active content bounds
        if ($this._activeContent) {
            $contentY = $this.Y + $this.TabBarHeight
            $contentHeight = $this.Height - $this.TabBarHeight
            $this._activeContent.SetBounds($this.X, $contentY, $this.Width, $contentHeight)
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Number shortcuts for tabs
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            $tabIndex = [int]($key.KeyChar - '1')
            if ($tabIndex -lt $this.Tabs.Count) {
                $this.ActivateTab($tabIndex)
                return $true
            }
        }
        
        # Tab navigation
        if ($key.Key -eq [System.ConsoleKey]::Tab -and 
            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                # Ctrl+Shift+Tab - previous tab
                $newIndex = if ($this.ActiveTabIndex -gt 0) { $this.ActiveTabIndex - 1 } else { $this.Tabs.Count - 1 }
            } else {
                # Ctrl+Tab - next tab
                $newIndex = if ($this.ActiveTabIndex -lt $this.Tabs.Count - 1) { $this.ActiveTabIndex + 1 } else { 0 }
            }
            $this.ActivateTab($newIndex)
            return $true
        }
        
        # Delegate to active content
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper class
    [bool] ContainsElement([UIElement]$element) {
        $current = $element
        while ($current) {
            if ($current -eq $this._activeContent) { return $true }
            $current = $current.Parent
        }
        return $false
    }
}

# TabItem class remains the same
class TabItem {
    [string]$Title
    [UIElement]$Content
    [int]$ShortcutKey = 0
}


####\Components/MinimalTextBox.ps1
# MinimalTextBox.ps1 - Clean, minimalist text input component

class MinimalTextBox : FocusableComponent {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 0  # 0 = no limit
    [bool]$IsPassword = $false
    [bool]$ShowBorder = $true
    [BorderType]$BorderType = [BorderType]::Rounded
    [scriptblock]$OnTextChanged = {}
    [scriptblock]$OnEnter = {}
    
    # Cursor and viewport
    hidden [int]$_cursorPosition = 0
    hidden [int]$_viewportStart = 0
    hidden [bool]$_showCursor = $true
    
    # Cached colors
    hidden [string]$_normalColor = ""
    hidden [string]$_placeholderColor = ""
    hidden [string]$_cursorColor = ""
    
    MinimalTextBox() : base() {
        $this.Height = 3  # 1 line + 2 for borders
        $this.FocusStyle = 'minimal'
    }
    
    [void] OnInitialize() {
        ([FocusableComponent]$this).OnInitialize()
        $this.UpdateColors()
        if ($this.Theme) {
            # Subscribe to theme changes via EventBus
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Subscribe('theme.changed', {
                    param($sender, $eventData)
                    $this.UpdateColors()
                }.GetNewClosure())
            }
        }
    }
    
    [void] UpdateColors() {
        if ($this.Theme) {
            $this._normalColor = $this.Theme.GetColor('input.foreground')
            $this._placeholderColor = $this.Theme.GetColor('input.placeholder')
            $this._cursorColor = $this.Theme.GetColor('accent')
        }
    }
    
    [void] SetText([string]$newText) {
        if ($this.MaxLength -gt 0 -and $newText.Length -gt $this.MaxLength) {
            $newText = $newText.Substring(0, $this.MaxLength)
        }
        
        if ($this.Text -ne $newText) {
            $this.Text = $newText
            $this._cursorPosition = $newText.Length
            $this.UpdateViewport()
            $this.Invalidate()
            
            if ($this.OnTextChanged) {
                & $this.OnTextChanged
            }
        }
    }
    
    [string] RenderContent() {
        $sb = Get-PooledStringBuilder 512
        
        # Render border if enabled
        if ($this.ShowBorder) {
            $borderColor = if ($this.IsFocused) { 
                $this.Theme.GetColor('border.focused') 
            } else { 
                $this.Theme.GetColor('border.normal') 
            }
            $sb.Append([BorderStyle]::RenderBorder($this.X, $this.Y, $this.Width, $this.Height, $this.BorderType, $borderColor))
        }
        
        # Calculate text position and available width
        $textX = $this.X
        $textY = $this.Y
        $availableWidth = $this.Width
        
        if ($this.ShowBorder) {
            $textX += 1
            $textY += 1
            $availableWidth -= 2
        }
        
        if ($availableWidth -le 0) { $availableWidth = 28 }  # Default width
        
        # Position cursor for text
        $sb.Append([VT]::MoveTo($textX, $textY))
        
        # Determine what to display
        $displayText = ""
        if ($this.Text.Length -gt 0) {
            if ($this.IsPassword) {
                $displayText = '' * $this.Text.Length
            } else {
                $displayText = $this.Text
            }
        } elseif (-not $this.IsFocused -and $this.Placeholder) {
            # Show placeholder when not focused and empty
            $sb.Append($this._placeholderColor)
            $displayText = $this.Placeholder
        }
        
        # Handle viewport for long text
        if ($displayText.Length -gt $availableWidth) {
            $displayText = $displayText.Substring($this._viewportStart, [Math]::Min($availableWidth, $displayText.Length - $this._viewportStart))
        }
        
        # Pad to width
        if ($displayText.Length -lt $availableWidth) {
            $displayText = $displayText.PadRight($availableWidth)
        }
        
        # Render text
        if ($this.Text.Length -eq 0 -and -not $this.IsFocused) {
            # Placeholder is already colored
        } else {
            $sb.Append($this._normalColor)
        }
        
        if ($this.IsFocused) {
            # Show text with cursor
            $cursorPos = $this._cursorPosition - $this._viewportStart
            if ($cursorPos -ge 0 -and $cursorPos -le $displayText.Length) {
                # Text before cursor
                if ($cursorPos -gt 0) {
                    $sb.Append($displayText.Substring(0, $cursorPos))
                }
                
                # Cursor
                if ($this._showCursor) {
                    $sb.Append($this._cursorColor)
                    if ($cursorPos -lt $displayText.Length) {
                        $sb.Append('')  # Minimal cursor on character
                    } else {
                        $sb.Append('')  # Cursor at end
                    }
                    $sb.Append($this._normalColor)
                    
                    # Text after cursor (skip the character under cursor)
                    if ($cursorPos -lt $displayText.Length - 1) {
                        $sb.Append($displayText.Substring($cursorPos + 1))
                    }
                } else {
                    # Text after cursor when not showing cursor
                    if ($cursorPos -lt $displayText.Length) {
                        $sb.Append($displayText.Substring($cursorPos))
                    }
                }
            } else {
                $sb.Append($displayText)
            }
        } else {
            $sb.Append($displayText)
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] UpdateViewport() {
        # Ensure cursor is visible
        if ($this._cursorPosition -lt $this._viewportStart) {
            $this._viewportStart = $this._cursorPosition
        } elseif ($this._cursorPosition -ge ($this._viewportStart + $this.Width)) {
            $this._viewportStart = $this._cursorPosition - $this.Width + 1
        }
        
        # Clamp viewport
        $this._viewportStart = [Math]::Max(0, $this._viewportStart)
    }
    
    [bool] OnHandleInput([System.ConsoleKeyInfo]$key) {
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                if ($this._cursorPosition -gt 0) {
                    $this._cursorPosition--
                    $this.UpdateViewport()
                    $this.Invalidate()
                }
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                if ($this._cursorPosition -lt $this.Text.Length) {
                    $this._cursorPosition++
                    $this.UpdateViewport()
                    $this.Invalidate()
                }
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this._cursorPosition = 0
                $this._viewportStart = 0
                $this.Invalidate()
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this._cursorPosition = $this.Text.Length
                $this.UpdateViewport()
                $this.Invalidate()
                return $true
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this._cursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this._cursorPosition - 1, 1)
                    $this._cursorPosition--
                    $this.UpdateViewport()
                    $this.Invalidate()
                    if ($this.OnTextChanged) { & $this.OnTextChanged }
                }
                return $true
            }
            ([System.ConsoleKey]::Delete) {
                if ($this._cursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this._cursorPosition, 1)
                    $this.Invalidate()
                    if ($this.OnTextChanged) { & $this.OnTextChanged }
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.OnEnter) {
                    & $this.OnEnter
                }
                return $true
            }
            default {
                # Handle character input
                if ($key.KeyChar -and $key.KeyChar -ge ' ') {
                    if ($this.MaxLength -eq 0 -or $this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this._cursorPosition, $key.KeyChar)
                        $this._cursorPosition++
                        $this.UpdateViewport()
                        $this.Invalidate()
                        if ($this.OnTextChanged) { & $this.OnTextChanged }
                    }
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [void] OnGotFocus() {
        $this._showCursor = $true
        ([FocusableComponent]$this).OnGotFocus()
    }
    
    [void] OnLostFocus() {
        $this._showCursor = $false
        ([FocusableComponent]$this).OnLostFocus()
    }
}


####\Components/MultiSelectListBox.ps1
# MultiSelectListBox.ps1 - ListBox with multiple selection support
# Supports checkboxes, range selection, and bulk operations

class MultiSelectListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    
    # Multi-selection settings
    [System.Collections.Generic.HashSet[int]]$SelectedIndices
    [bool]$ShowCheckboxes = $true
    [bool]$AllowRangeSelection = $true
    [bool]$AllowToggleAll = $true
    
    # Visual indicators
    [char]$CheckedIcon = [char]0x2611    # 
    [char]$UncheckedIcon = [char]0x2610  # 
    [char]$PartialIcon = [char]0x2612    # 
    
    # Selection state tracking
    hidden [int]$_lastSelectedIndex = -1  # For range selection
    hidden [bool]$_allSelected = $false
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [hashtable]$_colors = @{}
    
    MultiSelectListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'checkbox' = $this.Theme.GetColor("checkbox")
                'checkbox.selected' = $this.Theme.GetColor("checkbox.selected")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        $this.SelectedIndices.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._lastSelectedIndex = -1
        $this._allSelected = $false
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $indexToRemove = -1
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if ($this.Items[$i] -eq $item) {
                $indexToRemove = $i
                break
            }
        }
        
        if ($indexToRemove -ge 0) {
            $this.RemoveItemAt($indexToRemove)
        }
    }
    
    [void] RemoveItemAt([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.Items.RemoveAt($index)
            
            # Update selected indices
            $newSelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
            foreach ($selectedIndex in $this.SelectedIndices) {
                if ($selectedIndex -lt $index) {
                    $newSelectedIndices.Add($selectedIndex) | Out-Null
                } elseif ($selectedIndex -gt $index) {
                    $newSelectedIndices.Add($selectedIndex - 1) | Out-Null
                }
                # Skip the removed index
            }
            $this.SelectedIndices = $newSelectedIndices
            
            # Update current selection
            if ($this.SelectedIndex -eq $index) {
                $this.SelectedIndex = [Math]::Min($index, $this.Items.Count - 1)
            } elseif ($this.SelectedIndex -gt $index) {
                $this.SelectedIndex--
            }
            
            $this.EnsureSelectionValid()
            $this.UpdateAllSelectedState()
            $this.Invalidate()
        }
    }
    
    # Selection management
    [bool] IsSelected([int]$index) {
        return $this.SelectedIndices.Contains($index)
    }
    
    [void] SetSelected([int]$index, [bool]$selected) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($selected) {
                $this.SelectedIndices.Add($index) | Out-Null
            } else {
                $this.SelectedIndices.Remove($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] ToggleSelected([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($this.IsSelected($index)) {
                $this.SelectedIndices.Remove($index) | Out-Null
            } else {
                $this.SelectedIndices.Add($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] SelectRange([int]$startIndex, [int]$endIndex) {
        if (-not $this.AllowRangeSelection) {
            return
        }
        
        $start = [Math]::Min($startIndex, $endIndex)
        $end = [Math]::Max($startIndex, $endIndex)
        
        for ($i = $start; $i -le $end -and $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [void] SelectAll() {
        $this.SelectedIndices.Clear()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        $this._allSelected = $true
        $this.FireSelectionChanged()
    }
    
    [void] SelectNone() {
        $this.SelectedIndices.Clear()
        $this._allSelected = $false
        $this.FireSelectionChanged()
    }
    
    [void] InvertSelection() {
        $newSelected = [System.Collections.Generic.HashSet[int]]::new()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if (-not $this.IsSelected($i)) {
                $newSelected.Add($i) | Out-Null
            }
        }
        $this.SelectedIndices = $newSelected
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [System.Collections.ArrayList] GetSelectedItems() {
        $selectedItems = [System.Collections.ArrayList]::new()
        foreach ($index in $this.SelectedIndices) {
            if ($index -ge 0 -and $index -lt $this.Items.Count) {
                $selectedItems.Add($this.Items[$index]) | Out-Null
            }
        }
        return $selectedItems
    }
    
    [System.Collections.Generic.List[int]] GetSelectedIndicesList() {
        $result = [System.Collections.Generic.List[int]]::new()
        $sortedIndices = $this.SelectedIndices | Sort-Object
        foreach ($index in $sortedIndices) {
            $result.Add($index)
        }
        return $result
    }
    
    [int] GetSelectedCount() {
        return $this.SelectedIndices.Count
    }
    
    # Navigation
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            $this.Invalidate()
        }
    }
    
    # Internal methods
    [void] UpdateAllSelectedState() {
        $this._allSelected = ($this.SelectedIndices.Count -eq $this.Items.Count -and $this.Items.Count -gt 0)
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this.Items.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [void] FireSelectionChanged() {
        if ($this.OnSelectionChanged) {
            & $this.OnSelectionChanged
        }
        $this.Invalidate()
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 2048  # MultiSelectListBox with items and checkboxes
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $checkboxColor = if ($this._colors['checkbox']) { $this._colors['checkbox'] } else { $normalColor }
        $selectedCheckboxColor = if ($this._colors['checkbox.selected']) { $this._colors['checkbox.selected'] } else { "`e[38;2;0;255;0m" }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title with selection info
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this.Items.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $y = $contentY + ($i - $startIndex)
            $isCurrentSelection = ($i -eq $this.SelectedIndex)
            $isSelected = $this.IsSelected($i)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for current item
            if ($isCurrentSelection) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Checkbox
            if ($this.ShowCheckboxes) {
                $checkboxIcon = if ($isSelected) { $this.CheckedIcon } else { $this.UncheckedIcon }
                $checkboxColorToUse = if ($isSelected) { $selectedCheckboxColor } else { $checkboxColor }
                
                $line += "$checkboxIcon "
            }
            
            # Item content
            $itemText = if ($this.ItemRenderer) {
                & $this.ItemRenderer $item
            } else {
                if ($item -eq $null) {
                    "<null>"
                } else {
                    $item.ToString()
                }
            }
            
            $line += $itemText
            
            # Adjust content width for checkbox
            $availableWidth = if ($this.ShowCheckboxes) { $contentWidth - 2 } else { $contentWidth }
            
            # Truncate if too long
            if ($line.Length -gt $availableWidth) {
                $line = $line.Substring(0, $availableWidth - 3) + "..."
            }
            
            # Pad to full width
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            # Side borders
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldSelectedIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    
                    # Shift+Up for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    
                    # Shift+Down for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                # Toggle selection of current item
                $this.ToggleSelected($this.SelectedIndex)
                $this._lastSelectedIndex = $this.SelectedIndex
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                # Toggle selection and move down
                $this.ToggleSelected($this.SelectedIndex)
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
                $this._lastSelectedIndex = $this.SelectedIndex - 1
                $handled = $true
            }
        }
        
        # Keyboard shortcuts
        if (($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            switch ($key.Key) {
                ([System.ConsoleKey]::A) {
                    if ($this.AllowToggleAll) {
                        if ($this._allSelected) {
                            $this.SelectNone()
                        } else {
                            $this.SelectAll()
                        }
                    }
                    $handled = $true
                }
                ([System.ConsoleKey]::I) {
                    $this.InvertSelection()
                    $handled = $true
                }
                ([System.ConsoleKey]::D) {
                    $this.SelectNone()
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Update last selected index for range operations
            if (-not ($key.Modifiers -band [System.ConsoleModifiers]::Shift)) {
                $this._lastSelectedIndex = $this.SelectedIndex
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/ProgressBar.ps1
# ProgressBar.ps1 - Progress visualization component based on AxiomPhoenix patterns
# Fast string-based rendering with percentage and status text display

class ProgressBar : UIElement {
    [int]$Value = 0                    # Current progress (0-100)
    [int]$Maximum = 100               # Maximum value (default 100 for percentages)
    [string]$StatusText = ""          # Optional status text
    [bool]$ShowPercentage = $true     # Show percentage text
    [bool]$ShowBorder = $true         # Show border around progress bar
    [string]$Title = ""               # Optional title
    
    # Visual customization
    [char]$FilledChar = [char]0x2588  #  (full block)
    [char]$EmptyChar = [char]0x2591   #  (light shade)
    [string]$ProgressColor = ""       # Color for filled portion
    [string]$CompleteColor = ""       # Color when 100% complete
    [string]$TextColor = ""           # Color for percentage text
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_lastValue = -1      # For change detection
    hidden [string]$_lastStatusText = ""
    hidden [hashtable]$_colors = @{}  # Cached color ANSI sequences
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    ProgressBar() : base() {
        $this.Height = 5  # Default height (border + bar + percentage + status + border)
        $this.Width = 40  # Default width
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Cache theme colors
        if ($this.Theme) {
            # Cache all color ANSI sequences
            $this._colors["progress.active"] = $this.Theme.GetColor("progress.active")
            $this._colors["progress.complete"] = $this.Theme.GetColor("progress.complete")
            $this._colors["progress.text"] = $this.Theme.GetColor("progress.text")
            $this._colors["border"] = $this.Theme.GetColor("border")
            $this._colors["title"] = $this.Theme.GetColor("title")
            $this._colors["normal"] = $this.Theme.GetColor("normal")
            
            # Set default colors if not already set
            if ([string]::IsNullOrEmpty($this.ProgressColor)) {
                $this.ProgressColor = $this._colors["progress.active"]
            }
            if ([string]::IsNullOrEmpty($this.CompleteColor)) {
                $this.CompleteColor = $this._colors["progress.complete"]
            }
            if ([string]::IsNullOrEmpty($this.TextColor)) {
                $this.TextColor = $this._colors["progress.text"]
            }
        }
        
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [void] SetProgress([int]$value) {
        $this.SetProgress($value, $this.StatusText)
    }
    
    [void] SetProgress([int]$value, [string]$statusText) {
        # Clamp value to valid range
        $this.Value = [Math]::Max(0, [Math]::Min($this.Maximum, $value))
        $this.StatusText = $statusText
        
        # Only invalidate if something actually changed
        if ($this.Value -ne $this._lastValue -or $this.StatusText -ne $this._lastStatusText) {
            $this._lastValue = $this.Value
            $this._lastStatusText = $this.StatusText
            $this._dataVersion++  # Increment on progress change
            $this.Invalidate()
        }
    }
    
    [int] GetPercentage() {
        if ($this.Maximum -eq 0) {
            return 0
        }
        return [int](($this.Value * 100) / $this.Maximum)
    }
    
    [bool] IsComplete() {
        return $this.Value -ge $this.Maximum
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 512  # ProgressBar is relatively simple
        
        # Colors from cache
        $borderColor = if ($this._colors.ContainsKey("border")) { $this._colors["border"] } else { "" }
        $titleColor = if ($this._colors.ContainsKey("title")) { $this._colors["title"] } else { "" }
        $normalColor = if ($this._colors.ContainsKey("normal")) { $this._colors["normal"] } else { "" }
        
        # Determine progress color based on completion
        $currentProgressColor = if ($this.IsComplete()) { 
            if ([string]::IsNullOrEmpty($this.CompleteColor)) { $this.ProgressColor } else { $this.CompleteColor }
        } else { 
            $this.ProgressColor 
        }
        
        # Calculate dimensions
        $contentY = $this.Y
        $contentHeight = $this.Height
        $barWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($barWidth).Substring(0, $barWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Calculate bar dimensions
        $percentage = $this.GetPercentage()
        $filledWidth = if ($barWidth -gt 0) { [Math]::Floor($barWidth * $percentage / 100) } else { 0 }
        $emptyWidth = $barWidth - $filledWidth
        
        # Render progress bar
        $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
        
        # Filled portion
        if ($filledWidth -gt 0) {
            $sb.Append($currentProgressColor)
            $sb.Append([StringCache]::GetRepeatedChar($this.FilledChar, $filledWidth))
        }
        
        # Empty portion  
        if ($emptyWidth -gt 0) {
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetRepeatedChar($this.EmptyChar, $emptyWidth))
        }
        
        $contentY++
        $contentHeight--
        
        # Percentage text (centered)
        if ($this.ShowPercentage) {
            $percentText = "$percentage%"
            $textX = $this.X + ($this.Width - $percentText.Length) / 2
            $sb.Append([VT]::MoveTo([int]$textX, $contentY))
            $sb.Append($this.TextColor)
            $sb.Append($percentText)
            $contentY++
            $contentHeight--
        }
        
        # Status text (left-aligned, truncated if needed)
        if ($this.StatusText -and $contentHeight -gt ($this.ShowBorder ? 1 : 0)) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($normalColor)
            
            $statusWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
            if ($this.StatusText.Length -gt $statusWidth) {
                $truncated = $this.StatusText.Substring(0, $statusWidth - 3) + "..."
                $sb.Append($truncated)
            } else {
                $paddedStatus = $this.StatusText.PadRight($statusWidth).Substring(0, $statusWidth)
                $sb.Append($paddedStatus)
            }
            $contentY++
            $contentHeight--
        }
        
        # Side borders for remaining height
        if ($this.ShowBorder) {
            while ($contentHeight -gt 1) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $contentY++
                $contentHeight--
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    # Animation helper method (for future use)
    [void] AnimateTo([int]$targetValue, [int]$durationMs = 1000) {
        # Basic animation - could be enhanced with timer/events
        $startValue = $this.Value
        $steps = [Math]::Max(1, $durationMs / 50)  # 50ms per step
        $increment = ($targetValue - $startValue) / $steps
        
        for ($i = 0; $i -lt $steps; $i++) {
            $currentValue = $startValue + ($increment * ($i + 1))
            $this.SetProgress([int]$currentValue)
            Start-Sleep -Milliseconds 50
        }
        
        # Ensure we reach the exact target
        $this.SetProgress($targetValue)
    }
    
    # No input handling needed for progress bar
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}


####\Components/RangerFileTree.ps1
# RangerFileTree.ps1 - Ranger-style 3-pane file browser
# Left: Parent directory, Center: Current directory, Right: Preview/child

class RangerFileTree : Container {
    [string]$CurrentPath
    [FileSystemNode]$ParentNode
    [FileSystemNode]$CurrentNode
    [FileSystemNode]$PreviewNode
    
    # Three panes
    [FastFileTree]$ParentPane
    [FastFileTree]$CurrentPane
    [FastFileTree]$PreviewPane
    
    # Layout
    [double]$LeftPaneWidth = 0.25
    [double]$CenterPaneWidth = 0.35
    [double]$RightPaneWidth = 0.40
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    hidden [ThemeManager]$Theme
    
    RangerFileTree() : base() {
        $this.CurrentPath = (Get-Location).Path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    RangerFileTree([string]$path) : base() {
        $this.CurrentPath = $path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    [void] CreatePanes() {
        # Create parent pane
        $this.ParentPane = [FastFileTree]::new()
        $this.ParentPane.ShowBorder = $true
        $this.ParentPane.Title = "Parent"
        $this.ParentPane.ShowSize = $false
        $this.AddChild($this.ParentPane)
        
        # Create current pane
        $this.CurrentPane = [FastFileTree]::new()
        $this.CurrentPane.ShowBorder = $true
        $this.CurrentPane.Title = "Current"
        $this.CurrentPane.ShowSize = $true
        $this.AddChild($this.CurrentPane)
        
        # Create preview pane
        $this.PreviewPane = [FastFileTree]::new()
        $this.PreviewPane.ShowBorder = $true
        $this.PreviewPane.Title = "Preview"
        $this.PreviewPane.ShowSize = $true
        $this.AddChild($this.PreviewPane)
        
        # Set up event handlers
        $ranger = $this
        $this.CurrentPane.OnSelectionChanged = {
            $ranger.UpdatePreviewPane()
        }.GetNewClosure()
        
        $this.CurrentPane.OnFileSelected = {
            param($node)
            if ($node.IsDirectory) {
                $ranger.NavigateToDirectory($node.FullPath)
            } else {
                if ($ranger.OnFileSelected) {
                    & $ranger.OnFileSelected $node
                }
            }
        }.GetNewClosure()
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnInitialize: Starting initialization")
            $global:Logger.Debug("  IsFocusable: $($this.IsFocusable)")
            $global:Logger.Debug("  CurrentPath: $($this.CurrentPath)")
        }
        
        # Initialize theme
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Initialize child panes
        $this.ParentPane.ServiceContainer = $this.ServiceContainer
        $this.ParentPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  ParentPane initialized, IsFocusable=$($this.ParentPane.IsFocusable)")
        }
        
        $this.CurrentPane.ServiceContainer = $this.ServiceContainer
        $this.CurrentPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  CurrentPane initialized, IsFocusable=$($this.CurrentPane.IsFocusable)")
        }
        
        $this.PreviewPane.ServiceContainer = $this.ServiceContainer
        $this.PreviewPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  PreviewPane initialized, IsFocusable=$($this.PreviewPane.IsFocusable)")
        }
        
        # Load initial directory
        $this.NavigateToDirectory($this.CurrentPath)
        
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnInitialize: Completed")
        }
    }
    
    [void] NavigateToDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        $this.CurrentPath = Resolve-Path $path
        
        # Update parent pane
        $parentPath = Split-Path $this.CurrentPath -Parent
        if ($parentPath) {
            $this.ParentPane.LoadDirectory($parentPath)
            # Select current directory in parent
            $currentName = Split-Path $this.CurrentPath -Leaf
            for ($i = 0; $i -lt $this.ParentPane._flatView.Count; $i++) {
                if ($this.ParentPane._flatView[$i].Name -eq $currentName) {
                    $this.ParentPane.SelectIndex($i)
                    break
                }
            }
        } else {
            # At root, show drives or root
            $this.ParentPane.Title = "Drives"
            $this.ParentPane._flatView.Clear()
            $this.ParentPane.Invalidate()
        }
        
        # Update current pane
        $this.CurrentPane.LoadDirectory($this.CurrentPath)
        $this.CurrentPane.Title = Split-Path $this.CurrentPath -Leaf
        if ($this.CurrentPane._flatView.Count -gt 0) {
            $this.CurrentPane.SelectIndex(0)
            if ($global:Logger) {
                $global:Logger.Debug("RangerFileTree: Selected first item in current pane")
            }
        } else {
            if ($global:Logger) {
                $global:Logger.Warning("RangerFileTree: No items in current directory")
            }
        }
        
        # Update preview pane
        $this.UpdatePreviewPane()
    }
    
    [void] UpdatePreviewPane() {
        $selected = $this.CurrentPane.GetSelectedNode()
        if (-not $selected) {
            $this.PreviewPane.Title = "Preview"
            $this.PreviewPane._flatView.Clear()
            $this.PreviewPane.Invalidate()
            return
        }
        
        if ($selected.IsDirectory) {
            # Show directory contents
            $this.PreviewPane.LoadDirectory($selected.FullPath)
            $this.PreviewPane.Title = $selected.Name
        } else {
            # Show file preview
            $this.PreviewPane.Title = "File: $($selected.Name)"
            $this.PreviewPane._flatView.Clear()
            
            # Could add file preview logic here (first N lines, file info, etc.)
            # For now, just show file info
            $info = [FileSystemNode]::new($selected.FullPath)
            $info.Name = "Size: $($selected.GetSizeString())"
            $this.PreviewPane._flatView.Add($info) | Out-Null
            
            $info2 = [FileSystemNode]::new($selected.FullPath)
            $info2.Name = "Modified: $($selected.LastModified.ToString('yyyy-MM-dd HH:mm'))"
            $this.PreviewPane._flatView.Add($info2) | Out-Null
            
            $this.PreviewPane.Invalidate()
        }
    }
    
    [void] OnBoundsChanged() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Calculate pane widths
        $totalWidth = $this.Width
        if ($totalWidth -le 0) {
            if ($global:Logger) {
                $global:Logger.Warning("RangerFileTree: Invalid width $totalWidth")
            }
            return
        }
        
        $leftWidth = [int]($totalWidth * $this.LeftPaneWidth)
        $centerWidth = [int]($totalWidth * $this.CenterPaneWidth)
        $rightWidth = $totalWidth - $leftWidth - $centerWidth
        
        if ($global:Logger) {
            $global:Logger.Debug("  Pane widths: left=$leftWidth, center=$centerWidth, right=$rightWidth")
        }
        
        # Position panes
        $this.ParentPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        $this.CurrentPane.SetBounds($this.X + $leftWidth, $this.Y, $centerWidth, $this.Height)
        $this.PreviewPane.SetBounds($this.X + $leftWidth + $centerWidth, $this.Y, $rightWidth, $this.Height)
    }
    
    [string] OnRender() {
        # Debug rendering to ensure we're actually drawing
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnRender: Rendering with IsFocused=$($this.IsFocused)")
        }
        
        # Let base Container render children
        return ([Container]$this).OnRender()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Modifiers=$($key.Modifiers)")
            $global:Logger.Debug("  IsFocused: $($this.IsFocused)")
            $global:Logger.Debug("  CurrentPane IsFocused: $($this.CurrentPane.IsFocused)")
        }
        
        # Handle vim-style navigation keys
        if (-not $key.Modifiers) {
            switch ($key.KeyChar) {
                'h' {
                    # Navigate to parent directory (left)
                    $parentPath = Split-Path $this.CurrentPath -Parent
                    if ($parentPath) {
                        $this.NavigateToDirectory($parentPath)
                    }
                    return $true
                }
                'l' {
                    # Navigate into selected directory or open file (right)
                    $selected = $this.CurrentPane.GetSelectedNode()
                    if ($selected) {
                        if ($selected.IsDirectory) {
                            $this.NavigateToDirectory($selected.FullPath)
                        } else {
                            # Open file
                            if ($this.OnFileSelected) {
                                & $this.OnFileSelected $selected
                            }
                        }
                    }
                    return $true
                }
                'j' {
                    # Move down - create a synthetic down arrow key
                    $downKey = New-Object System.ConsoleKeyInfo -ArgumentList ([char]0, [System.ConsoleKey]::DownArrow, $false, $false, $false)
                    return $this.CurrentPane.HandleInput($downKey)
                }
                'k' {
                    # Move up - create a synthetic up arrow key
                    $upKey = New-Object System.ConsoleKeyInfo -ArgumentList ([char]0, [System.ConsoleKey]::UpArrow, $false, $false, $false)
                    return $this.CurrentPane.HandleInput($upKey)
                }
                '.' {
                    # Toggle hidden files
                    # TODO: Implement hidden file toggle
                    return $true
                }
            }
        }
        
        # Also handle arrow keys for compatibility
        switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                # Navigate to parent directory
                $parentPath = Split-Path $this.CurrentPath -Parent
                if ($parentPath) {
                    $this.NavigateToDirectory($parentPath)
                }
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                # Navigate into selected directory
                $selected = $this.CurrentPane.GetSelectedNode()
                if ($selected -and $selected.IsDirectory) {
                    $this.NavigateToDirectory($selected.FullPath)
                }
                return $true
            }
        }
        
        # Let current pane handle other input
        return $this.CurrentPane.HandleInput($key)
    }
    
    [void] OnGotFocus() {
        ([UIElement]$this).OnGotFocus()
        # Don't automatically focus child pane - we'll handle input and delegate as needed
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnGotFocus: Got focus")
        }
    }
    
    [void] Focus() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.Focus: Setting focus")
        }
        
        # Call base Focus to set IsFocused = true
        ([UIElement]$this).Focus()
        
        # Don't focus child panes - we'll handle the input routing ourselves
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.Focus: IsFocused = $($this.IsFocused)")
        }
    }
}


####\Components/SearchableListBox.ps1
# SearchableListBox.ps1 - ListBox with built-in search/filter functionality
# High-performance search with real-time filtering

class SearchableListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [System.Collections.ArrayList]$_filteredItems
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [string]$SearchQuery = ""
    [bool]$ShowSearchBox = $true
    [bool]$CaseSensitive = $false
    [bool]$UseRegex = $false
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnItemActivated = {}
    
    # Search configuration
    [int]$MinSearchLength = 0  # Start filtering immediately
    [bool]$SearchInDescription = $false
    [scriptblock]$SearchFilter = $null  # Custom filter function
    
    # Visual settings
    [string]$SearchPrompt = "Search: "
    [string]$NoResultsText = "No items found"
    [string]$SearchIcon = ""  # Search icon
    [char[]]$ExcludedSearchKeys = @('n', 'e', 'd')  # Keys that should not trigger search mode
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_searchBoxHeight = 3
    hidden [bool]$_searchMode = $false
    hidden [int]$_lastFilteredCount = -1
    hidden [System.Collections.Generic.HashSet[string]]$_highlightCache
    hidden [hashtable]$_colors = @{}
    
    SearchableListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this._filteredItems = [System.Collections.ArrayList]::new()
        $this._highlightCache = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.ApplyFilter()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'background' = $this.Theme.GetBgColor("background")
                'search' = $this.Theme.GetColor("search")
                'highlight' = $this.Theme.GetColor("highlight")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.ApplyFilter()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.ApplyFilter()
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $this.Items.Remove($item) | Out-Null
        $this.ApplyFilter()
        $this.EnsureSelectionValid()
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._filteredItems.Count) {
            return $this._filteredItems[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._filteredItems.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] SetSearchQuery([string]$query) {
        if ($this.SearchQuery -ne $query) {
            $this.SearchQuery = $query
            $this.ApplyFilter()
            $this.SelectedIndex = 0  # Reset to top when search changes
            $this.ScrollOffset = 0
            $this.Invalidate()
        }
    }
    
    [void] ClearSearch() {
        $this.SetSearchQuery("")
    }
    
    [void] EnterSearchMode() {
        $this._searchMode = $true
        $this.Invalidate()
    }
    
    [void] ExitSearchMode() {
        $this._searchMode = $false
        $this.Invalidate()
    }
    
    [void] ToggleSearchMode() {
        $this._searchMode = -not $this._searchMode
        $this.Invalidate()
    }
    
    # Internal methods
    [void] ApplyFilter() {
        $this._filteredItems.Clear()
        $this._highlightCache.Clear()
        
        # If no search query, show all items
        if ([string]::IsNullOrEmpty($this.SearchQuery) -or $this.SearchQuery.Length -lt $this.MinSearchLength) {
            foreach ($item in $this.Items) {
                $this._filteredItems.Add($item) | Out-Null
            }
        } else {
            # Apply filtering - optimize by pre-calculating normalized query
            $normalizedQuery = if ($this.CaseSensitive) { $this.SearchQuery } else { $this.SearchQuery.ToLower() }
            foreach ($item in $this.Items) {
                if ($this.MatchesSearchOptimized($item, $this.SearchQuery, $normalizedQuery)) {
                    $this._filteredItems.Add($item) | Out-Null
                }
            }
        }
        
        $this._lastFilteredCount = $this._filteredItems.Count
        $this.EnsureSelectionValid()
    }
    
    # Optimized version that avoids repeated ToLower() calls
    [bool] MatchesSearchOptimized($item, [string]$query, [string]$normalizedQuery) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity using pre-normalized query
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $normalizedQuery  # Use pre-normalized query
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                return $false
            }
        } else {
            return $searchText.Contains($query)
        }
    }

    [bool] MatchesSearch($item, [string]$query) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $query.ToLower()
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                # Invalid regex, fall back to simple contains
                return $searchText -like "*$query*"
            }
        } else {
            # Simple contains search
            return $searchText -like "*$query*"
        }
    }
    
    [string] GetSearchableText($item) {
        if ($item -eq $null) {
            return ""
        }
        
        # If item has a specific string representation method
        if ($item.PSObject.Methods['ToString'] -and $item.ToString() -ne $item.GetType().FullName) {
            return $item.ToString()
        }
        
        # If it's a hashtable or PSObject, try common text properties
        if ($item -is [hashtable]) {
            $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
            foreach ($prop in $textProps) {
                if ($item.ContainsKey($prop) -and $item[$prop]) {
                    return $item[$prop].ToString()
                }
            }
            # Fall back to all values if SearchInDescription is enabled
            if ($this.SearchInDescription) {
                return ($item.Values -join ' ')
            }
        }
        
        # Try common properties for objects
        $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
        foreach ($prop in $textProps) {
            $value = $item.PSObject.Properties[$prop]
            if ($value -and $value.Value) {
                return $value.Value.ToString()
            }
        }
        
        # Fall back to string conversion
        return $item.ToString()
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this._filteredItems.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this._filteredItems.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $contentHeight = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        if ($this.ShowSearchBox) {
            $contentHeight -= $this._searchBoxHeight
        }
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $contentHeight) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 2048  # SearchableListBox with search box and items
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $bgColor = $this._colors['background']
        $searchColor = if ($this._colors['search']) { $this._colors['search'] } else { $normalColor }
        $highlightColor = if ($this._colors['highlight']) { $this._colors['highlight'] } else { "`e[38;2;255;255;0m" }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = [Math]::Max(1, $this.Width - ($this.ShowBorder ? 2 : 0))
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = if ($contentWidth -le 0) { "" } else { $titleText.PadRight($contentWidth).Substring(0, $contentWidth) }
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = if ($this.Width -le 0) { "" } else { $titleText.PadRight($this.Width).Substring(0, $this.Width) }
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Search box
        if ($this.ShowSearchBox) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($searchColor)
            
            $searchText = "$($this.SearchIcon) $($this.SearchPrompt)$($this.SearchQuery)"
            if ($this._searchMode) {
                $searchText += "|"  # Cursor indicator
            }
            
            $searchLine = if ($contentWidth -le 0) { "" } else { $searchText.PadRight($contentWidth).Substring(0, $contentWidth) }
            $sb.Append($searchLine)
            $contentY++
            $contentHeight--
            
            # Search box separator
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($borderColor)
            $sb.Append([StringCache]::GetVTHorizontal($contentWidth))
            $contentY++
            $contentHeight--
            
            # Side borders for search area
            if ($this.ShowBorder) {
                for ($y = $contentY - 2; $y -lt $contentY; $y++) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._filteredItems.Count)
        
        if ($this._filteredItems.Count -eq 0) {
            # Fill all empty lines first
            for ($i = 0; $i -lt $visibleLines; $i++) {
                $y = $contentY + $i
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($contentWidth))
                
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
            
            # No results message centered in the content area
            if ($visibleLines -gt 0) {
                $noResultsY = $contentY + [int]($visibleLines / 2)
                $messageX = $this.X + ($this.ShowBorder ? 1 : 0) + [Math]::Max(0, [int](($contentWidth - $this.NoResultsText.Length) / 2))
                $sb.Append([VT]::MoveTo($messageX, $noResultsY))
                $sb.Append($normalColor)
                $sb.Append($bgColor)
                $sb.Append($this.NoResultsText)
            }
        } else {
            # Render items
            for ($i = $startIndex; $i -lt $endIndex; $i++) {
                $item = $this._filteredItems[$i]
                $y = $contentY + ($i - $startIndex)
                
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                    $sb.Append($bgColor)
                }
                
                # Get display text
                $displayText = if ($this.ItemRenderer) {
                    & $this.ItemRenderer $item
                } else {
                    $this.GetSearchableText($item)
                }
                
                # Highlight search terms
                if (-not [string]::IsNullOrEmpty($this.SearchQuery) -and $displayText) {
                    $displayText = $this.HighlightSearchTerms($displayText, $highlightColor, $normalColor)
                }
                
                # Pad and truncate to fit
                if ($displayText.Length -gt $contentWidth) {
                    $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
                }
                $displayLine = if ($contentWidth -le 0) { "" } else { $displayText.PadRight($contentWidth).Substring(0, $contentWidth) }
                $sb.Append($displayLine)
                
                # Side borders
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [string] HighlightSearchTerms([string]$text, [string]$highlightColor, [string]$normalColor) {
        if ([string]::IsNullOrEmpty($this.SearchQuery)) {
            return $text
        }
        
        # Simple highlighting - replace matches with colored versions
        try {
            $query = $this.SearchQuery
            if (-not $this.CaseSensitive) {
                # Case-insensitive replacement
                return [regex]::Replace($text, [regex]::Escape($query), "$highlightColor`$0$normalColor", [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
            } else {
                return $text.Replace($query, "$highlightColor$query$normalColor")
            }
        } catch {
            # If highlighting fails, return original text
            return $text
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        # Search mode input
        if ($this._searchMode) {
            switch ($key.Key) {
                ([System.ConsoleKey]::Escape) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Backspace) {
                    if ($this.SearchQuery.Length -gt 0) {
                        $this.SetSearchQuery($this.SearchQuery.Substring(0, $this.SearchQuery.Length - 1))
                    }
                    $handled = $true
                }
                default {
                    if ($key.KeyChar -ge 32 -and $key.KeyChar -lt 127) {  # Printable characters
                        $this.SetSearchQuery($this.SearchQuery + $key.KeyChar)
                        $handled = $true
                    }
                }
            }
        } else {
            # Normal navigation mode
            switch ($key.Key) {
                ([System.ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this._filteredItems.Count - 1) {
                        $this.SelectedIndex++
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::PageUp) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::PageDown) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Min($this._filteredItems.Count - 1, $this.SelectedIndex + $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::Home) {
                    $this.SelectedIndex = 0
                    $handled = $true
                }
                ([System.ConsoleKey]::End) {
                    $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
                    $handled = $true
                }
                ([System.ConsoleKey]::F3) {
                    $this.ToggleSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    if ($this.OnItemActivated -and $this._filteredItems.Count -gt 0 -and $this.SelectedIndex -ge 0) {
                        & $this.OnItemActivated $this.GetSelectedItem()
                    }
                    $handled = $true
                }
            }
            
            # Character-based search activation (exclude shortcut keys)
            if (-not $handled -and $key.KeyChar -ge 32 -and $key.KeyChar -lt 127 -and $key.KeyChar -notin $this.ExcludedSearchKeys) {
                $this.SetSearchQuery([string]$key.KeyChar)
                $this.EnterSearchMode()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._searchMode = $false  # Exit search mode when losing focus
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/TabContainer.ps1
# TabContainer.ps1 - Fast tab-based screen switching
# Core component for PRAXIS multi-screen management

class TabContainer : Container {
    [System.Collections.Generic.List[TabItem]]$Tabs
    [int]$ActiveTabIndex = 0
    [int]$TabBarHeight = 2
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_tabCache = @{}
    hidden [string]$_cachedTabBar = ""
    hidden [bool]$_tabBarInvalid = $true
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TabContainer() : base() {
        $this.Tabs = [System.Collections.Generic.List[TabItem]]::new()
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'tab.background' = $this.Theme.GetBgColor("tab.background")
                'tab.active.background' = $this.Theme.GetBgColor("tab.active.background")
                'tab.active.foreground' = $this.Theme.GetColor("tab.active.foreground")
                'tab.active.accent' = $this.Theme.GetColor("tab.active.accent")
                'tab.foreground' = $this.Theme.GetColor("tab.foreground")
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Propagate to all tabs
        foreach ($tab in $this.Tabs) {
            if ($tab.Content -and $tab.Content -is [Screen]) {
                $tab.Content.OnThemeChanged()
            }
        }
    }
    
    # Add a new tab
    [void] AddTab([string]$title, [UIElement]$content) {
        $tab = [TabItem]::new()
        $tab.Title = $title
        $tab.Content = $content
        $tab.ShortcutKey = $this.Tabs.Count + 1  # 1-9 shortcuts
        
        # Initialize the content if it's a Screen
        if ($content -is [Screen] -and $global:ServiceContainer) {
            $content.Initialize($global:ServiceContainer)
            # Tab content should draw their own background
            $content.DrawBackground = $true
        }
        
        $this.Tabs.Add($tab)
        $this._dataVersion++  # Increment on tab change
        $this._tabBarInvalid = $true
        
        # Set as active if first tab
        if ($this.Tabs.Count -eq 1) {
            # Force activation of first tab by temporarily setting ActiveTabIndex to -1
            $oldIndex = $this.ActiveTabIndex
            $this.ActiveTabIndex = -1
            $this.ActivateTab(0)
            # If ActivateTab failed, restore the index
            if ($this.ActiveTabIndex -eq -1) {
                $this.ActiveTabIndex = $oldIndex
            }
        } else {
            # Position but don't add to children yet
            $this.PositionContent($content, $false)
        }
        
        $this.Invalidate()
    }
    
    # Switch to a specific tab
    [void] ActivateTab([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Tabs.Count) { return }
        
        # Don't switch if already on this tab
        if ($index -eq $this.ActiveTabIndex) { return }
        
        $this._dataVersion++  # Increment on tab activation change
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.ActivateTab: Switching from tab $($this.ActiveTabIndex) to tab $index")
        }
        
        # Store old content reference
        $oldContent = $null
        
        # Deactivate current
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $oldTab = $this.Tabs[$this.ActiveTabIndex]
            if ($oldTab.Content) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Removing old tab content: $($oldTab.Title)")
                }
                $oldContent = $oldTab.Content
                $this.RemoveChild($oldTab.Content)
            }
        }
        
        # Activate new
        $this.ActiveTabIndex = $index
        $newTab = $this.Tabs[$index]
        if ($newTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Adding new tab content: $($newTab.Title)")
                $global:Logger.Debug("TabContainer: Content type: $($newTab.Content.GetType().Name)")
                $global:Logger.Debug("TabContainer: Container bounds: X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
            }
            $this.PositionContent($newTab.Content, $true)
            $this.AddChild($newTab.Content)
            if ($newTab.Content -is [Screen]) {
                # Tab content should draw its own background to clear old content
                $newTab.Content.DrawBackground = $true
                $newTab.Content.SetBackgroundColor([VT]::Reset())
                $newTab.Content.OnActivated()
            }
            # Force the new content to invalidate
            $newTab.Content.Invalidate()
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: New content bounds: X=$($newTab.Content.X) Y=$($newTab.Content.Y) W=$($newTab.Content.Width) H=$($newTab.Content.Height)")
            }
        }
        
        # Now safely deactivate old content after UI tree is updated
        if ($oldContent -and $oldContent -is [Screen]) {
            $oldContent.OnDeactivated()
        }
        
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Force parent to redraw completely to clear any artifacts
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
    }
    
    # Position content below tab bar
    hidden [void] PositionContent([UIElement]$content, [bool]$isActive) {
        # Only set bounds if we have valid dimensions
        if ($this.Width -gt 0 -and $this.Height -gt $this.TabBarHeight) {
            $content.SetBounds(
                $this.X,
                $this.Y + $this.TabBarHeight,
                $this.Width,
                $this.Height - $this.TabBarHeight
            )
        }
    }
    
    # Layout management
    [void] OnBoundsChanged() {
        # Update tab bar cache
        $this._tabBarInvalid = $true
        
        # Update active content bounds
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $activeTab = $this.Tabs[$this.ActiveTabIndex]
            if ($activeTab.Content) {
                $this.PositionContent($activeTab.Content, $true)
            }
        }
    }
    
    # Render the tab container
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: tabBarInvalid=$($this._tabBarInvalid), Children.Count=$($this.Children.Count)")
        }
        
        $sb = Get-PooledStringBuilder 2048
        
        # Render tab bar
        if ($this._tabBarInvalid) {
            $this.RebuildTabBar()
        }
        $sb.Append($this._cachedTabBar)
        
        # Render active content (base class handles children)
        $baseRender = ([Container]$this).OnRender()
        $sb.Append($baseRender)
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: Children.Count = $($this.Children.Count), baseRender.Length = $($baseRender.Length)")
            if ($this.Children.Count -gt 0) {
                $global:Logger.Debug("TabContainer.OnRender: First child type = $($this.Children[0].GetType().Name)")
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Build the tab bar
    hidden [void] RebuildTabBar() {
        $sb = Get-PooledStringBuilder 1024
        
        # Tab bar background
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this._colors['tab.background'])
        $sb.Append([StringCache]::GetSpaces($this.Width))
        
        # Draw tabs
        $x = $this.X + 1
        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {
            $tab = $this.Tabs[$i]
            $title = $tab.Title
            
            # Add shortcut hint if applicable
            if ($tab.ShortcutKey -ge 1 -and $tab.ShortcutKey -le 9) {
                $title = "$($tab.ShortcutKey):$title"
            }
            
            # Calculate tab width
            $tabWidth = $title.Length + 4  # Padding
            
            # Don't draw if it would overflow
            if (($x + $tabWidth) -gt ($this.X + $this.Width - 1)) {
                break
            }
            
            $sb.Append([VT]::MoveTo($x, $this.Y))
            
            # Tab styling
            if ($i -eq $this.ActiveTabIndex) {
                # Active tab
                $sb.Append($this._colors['tab.active.background'])
                $sb.Append($this._colors['tab.active.foreground'])
                $sb.Append(" $title ")
                
                # Bottom accent line
                $sb.Append([VT]::MoveTo($x, $this.Y + 1))
                $sb.Append($this._colors['tab.active.accent'])
                $sb.Append([StringCache]::GetHorizontalLine($tabWidth - 2))
            } else {
                # Inactive tab
                $sb.Append($this._colors['tab.background'])
                $sb.Append($this._colors['tab.foreground'])
                $sb.Append(" $title ")
            }
            
            $x += $tabWidth + 1
        }
        
        # Reset and draw separator line with junction characters
        $sb.Append([VT]::Reset())
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append($this._colors['border'])
        # Draw left junction
        if ($this.X > 0) {
            $sb.Append([VT]::MoveTo($this.X - 1, $this.Y + 1))
            $sb.Append('')
        }
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        # Draw right junction
        if (($this.X + $this.Width) -lt [Console]::WindowWidth) {
            $sb.Append([VT]::MoveTo($this.X + $this.Width, $this.Y + 1))
            $sb.Append('')
        }
        $sb.Append([VT]::Reset())
        
        $this._cachedTabBar = $sb.ToString()
        Return-PooledStringBuilder $sb
        $this._tabBarInvalid = $false
    }
    
    # Handle keyboard input
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Debug logging removed for performance
        
        # Check TabContainer shortcuts FIRST before passing to children
        
        # Number keys for quick tab switching
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            $tabIndex = [int]$key.KeyChar - [int][char]'1'
            if ($tabIndex -lt $this.Tabs.Count) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Switching to tab $($tabIndex + 1)")
                }
                $this.ActivateTab($tabIndex)
                return $true
            }
        }
        
        # Ctrl+Tab / Ctrl+Shift+Tab for cycling
        if ($key.Key -eq [System.ConsoleKey]::Tab -and 
            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.PreviousTab()
            } else {
                $this.NextTab()
            }
            return $true
        }
        
        # Alt+Left/Right for navigation
        if ($key.Modifiers -band [System.ConsoleModifiers]::Alt) {
            if ($key.Key -eq [System.ConsoleKey]::LeftArrow) {
                $this.PreviousTab()
                return $true
            } elseif ($key.Key -eq [System.ConsoleKey]::RightArrow) {
                $this.NextTab()
                return $true
            }
        }
        
        # Route to active tab's content if tab switching didn't handle it
        $activeTab = $this.GetActiveTab()
        if ($activeTab -and $activeTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Routing input to active tab content: $($activeTab.Content.GetType().Name)")
            }
            if ($activeTab.Content.HandleInput($key)) {
                return $true
            }
        }
        
        # No one handled it
        return $false
    }
    
    # Navigation helpers
    [void] NextTab() {
        if ($this.Tabs.Count -gt 0) {
            $next = ($this.ActiveTabIndex + 1) % $this.Tabs.Count
            $this.ActivateTab($next)
        }
    }
    
    [void] PreviousTab() {
        if ($this.Tabs.Count -gt 0) {
            $prev = $this.ActiveTabIndex - 1
            if ($prev -lt 0) { $prev = $this.Tabs.Count - 1 }
            $this.ActivateTab($prev)
        }
    }
    
    # Get active tab
    [TabItem] GetActiveTab() {
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            return $this.Tabs[$this.ActiveTabIndex]
        }
        return $null
    }
}

# Tab item class
class TabItem {
    [string]$Title = "Tab"
    [UIElement]$Content = $null
    [int]$ShortcutKey = 0
}


####\Components/TextBox.ps1
# TextBox.ps1 - Fast text input component
# Adapted from AxiomPhoenix with string-based rendering

class TextBox : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [bool]$ShowBorder = $true
    [bool]$ShowCursor = $true
    [scriptblock]$OnChange = {}
    [scriptblock]$OnSubmit = {}
    
    hidden [int]$_scrollOffset = 0
    hidden [string]$_cachedRender = ""
    hidden [bool]$_needsRender = $true
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TextBox() : base() {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3  # Border + content + border
    }
    
    [void] OnInitialize() {
        if ($this.ServiceContainer) {
            $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
            if ($this.Theme) {
                $this.Theme.Subscribe({ $this.OnThemeChanged() })
                $this.OnThemeChanged()
            }
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'input.focused.border' = $this.Theme.GetColor("input.focused.border")
                'input.border' = $this.Theme.GetColor("input.border")
                'input.background' = $this.Theme.GetBgColor("input.background")
                'input.foreground' = $this.Theme.GetColor("input.foreground")
                'input.placeholder' = $this.Theme.GetColor("input.placeholder")
            }
        }
        $this._dataVersion++  # Increment for theme change
        $this._needsRender = $true
        $this.Invalidate()
    }
    
    [string] OnRender() {
        if (-not $this._needsRender) {
            return $this._cachedRender
        }
        
        $sb = Get-PooledStringBuilder 512  # TextBox typically needs moderate capacity
        
        # Colors based on focus state
        $borderColor = if ($this.IsFocused) {
            $this._colors['input.focused.border']
        } else {
            $this._colors['input.border']
        }
        $bgColor = $this._colors['input.background']
        $fgColor = $this._colors['input.foreground']
        $placeholderColor = $this._colors['input.placeholder']
        
        # Content area
        $contentY = $this.Y + 1
        $contentStartX = $this.X + 1
        $contentWidth = $this.Width - 2
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            
            # Middle line with content
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append([VT]::V())
            
            # Clear content area
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            # Right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + 2))
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        } else {
            # Just clear the content area
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
            $contentY = $this.Y
            $contentStartX = $this.X
            $contentWidth = $this.Width
        }
        
        # Render text or placeholder
        $sb.Append([VT]::MoveTo($contentStartX, $contentY))
        
        if ($this.Text.Length -eq 0 -and -not [string]::IsNullOrEmpty($this.Placeholder)) {
            # Show placeholder
            $sb.Append($placeholderColor)
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth)
            } else {
                $this.Placeholder
            }
            $sb.Append($placeholderText)
        } else {
            # Calculate scroll offset to keep cursor in view
            if ($this.CursorPosition -lt $this._scrollOffset) {
                $this._scrollOffset = $this.CursorPosition
            } elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
            }
            
            # Draw visible portion of text
            $sb.Append($fgColor)
            if ($this.Text.Length -gt $this._scrollOffset) {
                $len = [Math]::Min($contentWidth, $this.Text.Length - $this._scrollOffset)
                $visibleText = $this.Text.Substring($this._scrollOffset, $len)
                $sb.Append($visibleText)
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this.ShowCursor) {
                $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                    $cursorX = $contentStartX + $cursorScreenPos
                    $sb.Append([VT]::MoveTo($cursorX, $contentY))
                    
                    # Reverse video for cursor
                    $charUnderCursor = if ($this.CursorPosition -lt $this.Text.Length) {
                        $this.Text[$this.CursorPosition]
                    } else {
                        ' '
                    }
                    
                    $sb.Append($bgColor)  # Swap colors for cursor
                    if ($this._colors['input.foreground']) {
                        # Create a background color from foreground color
                        $sb.Append("`e[48;2;255;255;255m")  # White background for cursor
                    }
                    $sb.Append($charUnderCursor)
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._needsRender = $false
        return $this._cachedRender
    }
    
    [void] OnGotFocus() {
        $this.ShowCursor = $true
        $this._dataVersion++  # Increment for focus change
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnGotFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [void] OnLostFocus() {
        $this.ShowCursor = $false
        $this._dataVersion++  # Increment for focus change
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnLostFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $oldText = $this.Text
            
            switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                    $this._dataVersion++  # Increment for cursor move
                }
            }
            ([System.ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                    $this._dataVersion++  # Increment for cursor move
                }
            }
            ([System.ConsoleKey]::Home) {
                $this.CursorPosition = 0
                $this._dataVersion++  # Increment for cursor move
            }
            ([System.ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
                $this._dataVersion++  # Increment for cursor move
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            ([System.ConsoleKey]::Enter) {
                try {
                    if ($this.OnSubmit) {
                        & $this.OnSubmit $this.Text
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("TextBox.HandleInput: Error executing OnSubmit handler - $($_.Exception.Message)")
                    }
                }
            }
            ([System.ConsoleKey]::Tab) {
                # Don't handle Tab - let parent handle focus navigation
                $handled = $false
            }
            ([System.ConsoleKey]::Escape) {
                # Don't handle Escape - let parent handle it
                $handled = $false
            }
            default {
                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
            if ($handled) {
                # Increment version if text was modified
                if ($oldText -ne $this.Text) {
                    $this._dataVersion++
                }
                
                # Call OnChange if text was modified
                if ($oldText -ne $this.Text -and $this.OnChange) {
                    try {
                        & $this.OnChange $this.Text
                    } catch {
                        if ($global:Logger) {
                            $global:Logger.Error("TextBox.HandleInput: Error executing OnChange handler - $($_.Exception.Message)")
                        }
                    }
                }
                $this._needsRender = $true
                $this.Invalidate()
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TextBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Helper methods
    [void] SetText([string]$text) {
        if ($text.Length -le $this.MaxLength) {
            $this.Text = $text
            $this.CursorPosition = $text.Length
            $this._dataVersion++  # Increment on text change
            $this._needsRender = $true
            $this.Invalidate()
        }
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this._scrollOffset = 0
        $this._needsRender = $true
        $this.Invalidate()
    }
}


####\Components/VerticalSplit.ps1
# VerticalSplit.ps1 - Fast vertical layout component for PRAXIS

class VerticalSplit : Container {
    [UIElement]$TopPane
    [UIElement]$BottomPane
    [int]$SplitRatio = 50  # Percentage for top pane (0-100)
    [int]$MinPaneHeight = 3
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedTopHeight = 0
    hidden [int]$_cachedBottomHeight = 0
    hidden [int]$_cachedBottomY = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastSplitRatio = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    VerticalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    [void] SetTopPane([UIElement]$pane) {
        if ($this.TopPane) {
            $this.RemoveChild($this.TopPane)
        }
        $this.TopPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetBottomPane([UIElement]$pane) {
        if ($this.BottomPane) {
            $this.RemoveChild($this.BottomPane)
        }
        $this.BottomPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastHeight -eq $this.Height -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalHeight = $this.Height
        $topHeight = [int](($totalHeight * $this.SplitRatio) / 100)
        $topHeight = [Math]::Max($this.MinPaneHeight, [Math]::Min($topHeight, $totalHeight - $this.MinPaneHeight))
        $bottomHeight = $totalHeight - $topHeight
        $bottomY = $this.Y + $topHeight
        
        # Update top pane
        if ($this.TopPane) {
            $this.TopPane.SetBounds($this.X, $this.Y, $this.Width, $topHeight)
        }
        
        # Update bottom pane
        if ($this.BottomPane) {
            $this.BottomPane.SetBounds($this.X, $bottomY, $this.Width, $bottomHeight)
        }
        
        # Cache the layout
        $this._cachedTopHeight = $topHeight
        $this._cachedBottomHeight = $bottomHeight
        $this._cachedBottomY = $bottomY
        $this._lastHeight = $this.Height
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 1024
        
        # Render children
        if ($this.TopPane -and $this.TopPane.Visible) {
            $sb.Append($this.TopPane.Render())
        }
        
        if ($this.BottomPane -and $this.BottomPane.Visible) {
            $sb.Append($this.BottomPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedTopHeight -gt 0) {
            $borderColor = $this._colors['border']
            $sb.Append([VT]::MoveTo($this.X, $this._cachedBottomY - 1))
            $sb.Append($borderColor)
            $sb.Append([StringCache]::GetHorizontalLine($this.Width))
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.TopPane -and $this.TopPane.IsFocused) {
            if ($this.TopPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.BottomPane -and $this.BottomPane.IsFocused) {
            if ($this.BottomPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetTopFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetBottomFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetTopPane() { return $this.TopPane }
    [UIElement] GetBottomPane() { return $this.BottomPane }
    
    # Focus management
    [void] FocusTopPane() {
        if ($this.TopPane -and $this.TopPane.IsFocusable) {
            $this.TopPane.Focus()
        }
    }
    
    [void] FocusBottomPane() {
        if ($this.BottomPane -and $this.BottomPane.IsFocusable) {
            $this.BottomPane.Focus()
        }
    }
}


####\Core/AnimationHelper.ps1
# AnimationHelper.ps1 - Simple animation support for smooth transitions

enum EasingType {
    Linear = 0
    EaseIn = 1
    EaseOut = 2
    EaseInOut = 3
    Bounce = 4
}

class Animation {
    [string]$Name
    [double]$StartValue
    [double]$EndValue
    [double]$Duration  # Milliseconds
    [DateTime]$StartTime
    [EasingType]$Easing
    [scriptblock]$OnUpdate
    [scriptblock]$OnComplete
    [bool]$IsComplete
    [double]$CurrentValue
    
    Animation([string]$name, [double]$start, [double]$end, [double]$duration) {
        $this.Name = $name
        $this.StartValue = $start
        $this.EndValue = $end
        $this.Duration = $duration
        $this.Easing = [EasingType]::EaseInOut
        $this.StartTime = [DateTime]::Now
        $this.IsComplete = $false
        $this.CurrentValue = $start
    }
    
    [void] Update() {
        if ($this.IsComplete) { return }
        
        $elapsed = ([DateTime]::Now - $this.StartTime).TotalMilliseconds
        $progress = [Math]::Min(1.0, $elapsed / $this.Duration)
        
        # Apply easing
        $easedProgress = switch ($this.Easing) {
            ([EasingType]::Linear) { $progress }
            ([EasingType]::EaseIn) { $progress * $progress }
            ([EasingType]::EaseOut) { 1 - (1 - $progress) * (1 - $progress) }
            ([EasingType]::EaseInOut) {
                if ($progress -lt 0.5) {
                    2 * $progress * $progress
                } else {
                    1 - 2 * (1 - $progress) * (1 - $progress)
                }
            }
            ([EasingType]::Bounce) {
                if ($progress -lt 0.5) {
                    8 * $progress * $progress
                } else {
                    1 - 8 * (1 - $progress) * (1 - $progress)
                }
            }
        }
        
        # Calculate current value
        $this.CurrentValue = $this.StartValue + ($this.EndValue - $this.StartValue) * $easedProgress
        
        # Call update callback
        if ($this.OnUpdate) {
            & $this.OnUpdate $this.CurrentValue
        }
        
        # Check if complete
        if ($progress -ge 1.0) {
            $this.IsComplete = $true
            $this.CurrentValue = $this.EndValue
            if ($this.OnComplete) {
                & $this.OnComplete
            }
        }
    }
}

class AnimationManager {
    hidden [System.Collections.Generic.Dictionary[string, Animation]]$_animations
    hidden [System.Timers.Timer]$_updateTimer
    hidden [EventBus]$EventBus
    [int]$FrameRate = 30  # FPS
    
    AnimationManager() {
        $this._animations = [System.Collections.Generic.Dictionary[string, Animation]]::new()
        
        # Create update timer
        $interval = 1000 / $this.FrameRate
        $this._updateTimer = [System.Timers.Timer]::new($interval)
        $this._updateTimer.AutoReset = $true
        
        # Add event handler
        Register-ObjectEvent -InputObject $this._updateTimer -EventName Elapsed -Action {
            $Event.MessageData.UpdateAnimations()
        } -MessageData $this | Out-Null
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.EventBus = $container.GetService('EventBus')
    }
    
    [void] StartAnimation([Animation]$animation) {
        $this._animations[$animation.Name] = $animation
        
        # Start timer if not running
        if (-not $this._updateTimer.Enabled) {
            $this._updateTimer.Start()
        }
    }
    
    [void] StopAnimation([string]$name) {
        if ($this._animations.ContainsKey($name)) {
            $this._animations.Remove($name)
        }
        
        # Stop timer if no animations
        if ($this._animations.Count -eq 0) {
            $this._updateTimer.Stop()
        }
    }
    
    [void] UpdateAnimations() {
        $completed = @()
        
        foreach ($animation in $this._animations.Values) {
            $animation.Update()
            if ($animation.IsComplete) {
                $completed += $animation.Name
            }
        }
        
        # Remove completed animations
        foreach ($name in $completed) {
            $this._animations.Remove($name)
        }
        
        # Stop timer if no animations
        if ($this._animations.Count -eq 0) {
            $this._updateTimer.Stop()
        }
        
        # Notify of animation frame
        if ($this.EventBus -and $this._animations.Count -gt 0) {
            $this.EventBus.Publish('animation.frame', $this, @{})
        }
    }
    
    # Helper methods for common animations
    [Animation] SlideIn([UIElement]$element, [string]$direction, [double]$duration = 300) {
        $startX = $element.X
        $startY = $element.Y
        $endX = $element.X
        $endY = $element.Y
        $anim = $null
        
        switch ($direction) {
            "Left" {
                $startX = -$element.Width
                $anim = [Animation]::new("SlideIn_$($element.GetHashCode())", $startX, $endX, $duration)
                $anim.OnUpdate = {
                    param($value)
                    $element.X = [int]$value
                    $element.Invalidate()
                }.GetNewClosure()
            }
            "Right" {
                $startX = [Console]::WindowWidth
                $anim = [Animation]::new("SlideIn_$($element.GetHashCode())", $startX, $endX, $duration)
                $anim.OnUpdate = {
                    param($value)
                    $element.X = [int]$value
                    $element.Invalidate()
                }.GetNewClosure()
            }
            "Top" {
                $startY = -$element.Height
                $anim = [Animation]::new("SlideIn_$($element.GetHashCode())", $startY, $endY, $duration)
                $anim.OnUpdate = {
                    param($value)
                    $element.Y = [int]$value
                    $element.Invalidate()
                }.GetNewClosure()
            }
            "Bottom" {
                $startY = [Console]::WindowHeight
                $anim = [Animation]::new("SlideIn_$($element.GetHashCode())", $startY, $endY, $duration)
                $anim.OnUpdate = {
                    param($value)
                    $element.Y = [int]$value
                    $element.Invalidate()
                }.GetNewClosure()
            }
        }
        
        if ($anim) {
            $anim.Easing = [EasingType]::EaseOut
        }
        return $anim
    }
    
    [Animation] FadeIn([UIElement]$element, [double]$duration = 200) {
        $anim = [Animation]::new("FadeIn_$($element.GetHashCode())", 0.0, 1.0, $duration)
        $anim.Easing = [EasingType]::EaseIn
        
        # Since we can't do real opacity in terminal, simulate with visibility
        $anim.OnUpdate = {
            param($value)
            # Show element after 10% progress
            if ($value -gt 0.1 -and -not $element.Visible) {
                $element.Visible = $true
                $element.Invalidate()
            }
        }.GetNewClosure()
        
        return $anim
    }
    
    [Animation] Pulse([UIElement]$element, [int]$times = 2, [double]$duration = 500) {
        # Pulse effect using size changes
        $originalWidth = $element.Width
        $originalHeight = $element.Height
        
        $anim = [Animation]::new("Pulse_$($element.GetHashCode())", 0, $times * 2 * [Math]::PI, $duration)
        $anim.Easing = [EasingType]::Linear
        
        $anim.OnUpdate = {
            param($value)
            $scale = 1 + 0.1 * [Math]::Sin($value)  # 10% size variation
            $newWidth = [int]($originalWidth * $scale)
            $newHeight = [int]($originalHeight * $scale)
            
            # Center the scaling
            $element.X -= ($newWidth - $element.Width) / 2
            $element.Y -= ($newHeight - $element.Height) / 2
            
            $element.Width = $newWidth
            $element.Height = $newHeight
            $element.Invalidate()
        }.GetNewClosure()
        
        $anim.OnComplete = {
            # Restore original size
            $element.Width = $originalWidth
            $element.Height = $originalHeight
            $element.Invalidate()
        }.GetNewClosure()
        
        return $anim
    }
}

# Extension methods for UIElement
class AnimatedElement : UIElement {
    hidden [AnimationManager]$AnimationManager
    
    [void] OnInitialize() {
        $this.AnimationManager = $this.ServiceContainer.GetService('AnimationManager')
    }
    
    [void] SlideIn([string]$direction, [double]$duration = 300) {
        if ($this.AnimationManager) {
            $anim = $this.AnimationManager.SlideIn($this, $direction, $duration)
            $this.AnimationManager.StartAnimation($anim)
        }
    }
    
    [void] FadeIn([double]$duration = 200) {
        if ($this.AnimationManager) {
            $anim = $this.AnimationManager.FadeIn($this, $duration)
            $this.AnimationManager.StartAnimation($anim)
        }
    }
    
    [void] Pulse([int]$times = 2) {
        if ($this.AnimationManager) {
            $anim = $this.AnimationManager.Pulse($this, $times)
            $this.AnimationManager.StartAnimation($anim)
        }
    }
}


####\Core/BorderStyle.ps1
# BorderStyle.ps1 - Unified border rendering system for minimal, elegant UI

enum BorderType {
    None = 0
    Single = 1
    Double = 2
    Rounded = 3
    Minimal = 4  # Just corners
    Dotted = 5
}

class BorderStyle {
    # Border characters for different styles
    static [hashtable] $Styles = @{
        Single = @{
            TL = ''; TR = ''; BL = ''; BR = ''
            H = ''; V = ''
            LT = ''; RT = ''; TT = ''; BT = ''
            Cross = ''
        }
        Double = @{
            TL = ''; TR = ''; BL = ''; BR = ''
            H = ''; V = ''
            LT = ''; RT = ''; TT = ''; BT = ''
            Cross = ''
        }
        Rounded = @{
            TL = ''; TR = ''; BL = ''; BR = ''
            H = ''; V = ''
            LT = ''; RT = ''; TT = ''; BT = ''
            Cross = ''
        }
        Minimal = @{
            TL = ''; TR = ''; BL = ''; BR = ''
            H = ' '; V = ' '
            LT = ' '; RT = ' '; TT = ' '; BT = ' '
            Cross = ' '
        }
        Dotted = @{
            TL = ''; TR = ''; BL = ''; BR = ''
            H = ''; V = ''
            LT = ''; RT = ''; TT = ''; BT = ''
            Cross = ''
        }
    }
    
    # Pre-render border for a given size and style
    static [string] RenderBorder(
        [int]$x, [int]$y, [int]$width, [int]$height,
        [BorderType]$type, [string]$color
    ) {
        if ($type -eq [BorderType]::None -or $width -lt 2 -or $height -lt 2) {
            return ""
        }
        
        $style = [BorderStyle]::Styles[$type.ToString()]
        if (-not $style) { return "" }
        
        $sb = Get-PooledStringBuilder (($width + 10) * $height)
        
        # Apply color if specified
        if ($color) { $sb.Append($color) }
        
        # Top border
        $sb.Append([VT]::MoveTo($x, $y))
        $sb.Append($style.TL)
        if ($width -gt 2) {
            $sb.Append($style.H * ($width - 2))
        }
        $sb.Append($style.TR)
        
        # Side borders
        if ($height -gt 2) {
            for ($i = 1; $i -lt ($height - 1); $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($style.V)
                if ($type -eq [BorderType]::Minimal) {
                    # Minimal style - only corners
                } else {
                    $sb.Append([VT]::MoveTo($x + $width - 1, $y + $i))
                    $sb.Append($style.V)
                }
            }
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($x, $y + $height - 1))
        $sb.Append($style.BL)
        if ($width -gt 2) {
            if ($type -eq [BorderType]::Minimal) {
                # Minimal - just corners
                $sb.Append(' ' * ($width - 2))
            } else {
                $sb.Append($style.H * ($width - 2))
            }
        }
        $sb.Append($style.BR)
        
        # Reset color
        if ($color) { $sb.Append([VT]::Reset()) }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Render border with title (elegant placement)
    static [string] RenderBorderWithTitle(
        [int]$x, [int]$y, [int]$width, [int]$height,
        [BorderType]$type, [string]$color,
        [string]$title, [string]$titleColor
    ) {
        if ($type -eq [BorderType]::None) { return "" }
        
        # Start with basic border
        $border = [BorderStyle]::RenderBorder($x, $y, $width, $height, $type, $color)
        
        if (-not $title -or $title.Length -eq 0) { return $border }
        
        # Add title to top border
        $sb = Get-PooledStringBuilder ($border.Length + $title.Length + 20)
        $sb.Append($border)
        
        # Calculate title position (centered with padding)
        $titleWithPadding = " $title "
        $titleStart = $x + [Math]::Max(2, ($width - $titleWithPadding.Length) / 2)
        
        # Overlay title on top border
        $sb.Append([VT]::MoveTo($titleStart, $y))
        if ($titleColor) { $sb.Append($titleColor) }
        $sb.Append($titleWithPadding)
        if ($titleColor) { $sb.Append([VT]::Reset()) }
        if ($color) { $sb.Append($color) }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Get border insets (how much space the border takes)
    static [hashtable] GetInsets([BorderType]$type) {
        if ($type -eq [BorderType]::None) {
            return @{ Top = 0; Left = 0; Right = 0; Bottom = 0 }
        }
        return @{ Top = 1; Left = 1; Right = 1; Bottom = 1 }
    }
}

# Extension method for UIElement
class BorderedElement : UIElement {
    [BorderType]$BorderType = [BorderType]::None
    [string]$BorderTitle = ""
    [bool]$ShowBorder = $false
    
    # Cached border render
    hidden [string]$_cachedBorder = ""
    hidden [string]$_borderColor = ""
    hidden [string]$_borderFocusColor = ""
    
    [void] UpdateBorderColors() {
        if ($this.ServiceContainer) {
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            if ($theme) {
                $this._borderColor = $theme.GetColor('border')
                $this._borderFocusColor = $theme.GetColor('border.focused')
            }
        }
    }
    
    [void] InvalidateBorder() {
        $this._cachedBorder = ""
        $this.Invalidate()
    }
    
    [string] RenderBorder() {
        if (-not $this.ShowBorder -or $this.BorderType -eq [BorderType]::None) {
            return ""
        }
        
        $color = if ($this.IsFocused) { $this._borderFocusColor } else { $this._borderColor }
        
        if ($this.BorderTitle) {
            $titleColor = if ($this.IsFocused -and $this.ServiceContainer) {
                $theme = $this.ServiceContainer.GetService('ThemeManager')
                if ($theme) { $theme.GetColor('accent') } else { "" }
            } else { "" }
            
            return [BorderStyle]::RenderBorderWithTitle(
                $this.X, $this.Y, $this.Width, $this.Height,
                $this.BorderType, $color,
                $this.BorderTitle, $titleColor
            )
        } else {
            return [BorderStyle]::RenderBorder(
                $this.X, $this.Y, $this.Width, $this.Height,
                $this.BorderType, $color
            )
        }
    }
    
    [hashtable] GetContentBounds() {
        $insets = [BorderStyle]::GetInsets($this.BorderType)
        return @{
            X = $this.X + $insets.Left
            Y = $this.Y + $insets.Top
            Width = $this.Width - $insets.Left - $insets.Right
            Height = $this.Height - $insets.Top - $insets.Bottom
        }
    }
}


####\Core/DocumentBuffer.ps1
# DocumentBuffer.ps1 - Model class for text editor content
# Implements Buffer/View separation - this class knows nothing about UI

class DocumentBuffer {
    # Text content storage (Phase 1: ArrayList, Phase 3: Gap Buffer)
    hidden [System.Collections.ArrayList]$Lines
    
    # Command-based undo/redo system
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [int]$_maxUndoHistory = 1000
    
    # File state
    [string]$FilePath = ""
    [bool]$IsModified = $false
    [datetime]$LastModified = [datetime]::MinValue
    
    # Change tracking for render optimization
    hidden [System.Collections.Generic.HashSet[int]]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Events for UI updates
    [scriptblock]$OnContentChanged = {}
    [scriptblock]$OnModifiedStateChanged = {}
    
    DocumentBuffer() {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null  # Always have at least one empty line
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    DocumentBuffer([string]$filePath) {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.FilePath = $filePath
        $this.LoadFromFile($filePath)
    }
    
    # --- Public API for TextEditorScreen ---
    
    [string] GetLine([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Lines.Count) {
            return ""
        }
        return $this.Lines[$index]
    }
    
    [int] GetLineCount() {
        return $this.Lines.Count
    }
    
    [bool] IsLineDirty([int]$line) {
        return $this._allLinesDirty -or $this._dirtyLines.Contains($line)
    }
    
    [void] ClearDirtyLines() {
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
    }
    
    [void] ExecuteCommand([object]$command) {
        $command.Execute($this)
        $this.AddToUndoStack($command)
        $this.SetModified($true)
        $this.NotifyContentChanged()
    }
    
    [bool] CanUndo() {
        return $this._undoStack.Count -gt 0
    }
    
    [bool] CanRedo() {
        return $this._redoStack.Count -gt 0
    }
    
    [void] ClearUndoHistory() {
        $this._undoStack.Clear()
        $this._redoStack.Clear()
    }
    
    [void] Undo() {
        if ($this._undoStack.Count -eq 0) { return }
        
        try {
            $command = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            $command.Undo($this)
            $this._redoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this._allLinesDirty = $true  # Mark all lines dirty after undo
            $this.NotifyContentChanged()
        } catch {
            # If undo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Undo failed: $($_.Exception.Message)")
            }
            # Don't add the failed command to redo stack
        }
    }
    
    [void] Redo() {
        if ($this._redoStack.Count -eq 0) { return }
        
        try {
            $command = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            $command.Execute($this)
            $this._undoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this._allLinesDirty = $true  # Mark all lines dirty after redo
            $this.NotifyContentChanged()
        } catch {
            # If redo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Redo failed: $($_.Exception.Message)")
            }
            # Don't add the failed command to undo stack
        }
    }
    
    [void] LoadFromFile([string]$filePath) {
        if (-not (Test-Path $filePath)) {
            # File doesn't exist, start with empty content
            $this.Lines.Clear()
            $this.Lines.Add("") | Out-Null
            $this.SetModified($false)
            return
        }
        
        try {
            $content = Get-Content $filePath -Raw
            if ($content) {
                $lineArray = $content -split "`r?`n"
                $this.Lines.Clear()
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
                # Ensure we always have at least one line
                if ($this.Lines.Count -eq 0) {
                    $this.Lines.Add("") | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.SetModified($false)
            $this.LastModified = (Get-Item $filePath).LastWriteTime
            $this._allLinesDirty = $true
        } catch {
            throw "Failed to load file '$filePath': $($_.Exception.Message)"
        }
    }
    
    [void] SaveToFile([string]$filePath = "") {
        if ([string]::IsNullOrEmpty($filePath)) {
            $saveFilePath = $this.FilePath
        } else {
            $saveFilePath = $filePath
        }
        if ([string]::IsNullOrEmpty($saveFilePath)) {
            throw "No file path specified for save"
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $saveFilePath -Value $content -NoNewline
            $this.FilePath = $saveFilePath
            $this.SetModified($false)
            $this.LastModified = [datetime]::Now
        } catch {
            throw "Failed to save file '$saveFilePath': $($_.Exception.Message)"
        }
    }
    
    # --- Internal Text Manipulation Methods (Called by Commands) ---
    
    [void] InsertTextAt([int]$line, [int]$col, [string]$text) {
        if ($line -lt 0) { return }
        $this.EnsureLineExists($line)
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $this.Lines[$line] = $currentLine.Insert($col, $text)
        $this._dirtyLines.Add($line) | Out-Null
    }
    
    [void] DeleteTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $line -ge $this.Lines.Count) { return }
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $length = [Math]::Min($length, $currentLine.Length - $col)
        if ($length -gt 0) {
            $this.Lines[$line] = $currentLine.Remove($col, $length)
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] InsertNewlineAt([int]$line, [int]$col) {
        if ($line -lt 0) { return }
        $this.EnsureLineExists($line)
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        
        $leftPart = $currentLine.Substring(0, $col)
        $rightPart = $currentLine.Substring($col)
        
        $this.Lines[$line] = $leftPart
        $this.Lines.Insert($line + 1, $rightPart)
        
        # Mark affected lines as dirty
        $this._dirtyLines.Add($line) | Out-Null
        $this._dirtyLines.Add($line + 1) | Out-Null
        # All lines after the insert point shift, so mark all dirty
        $this._allLinesDirty = $true
    }
    
    [void] JoinLinesAt([int]$line, [string]$separator = "") {
        if ($line -lt 0 -or $line -ge $this.Lines.Count -or $line + 1 -ge $this.Lines.Count) {
            return  # Can't join if invalid line or no next line
        }
        
        $currentLine = $this.Lines[$line]
        $nextLine = $this.Lines[$line + 1]
        $this.Lines[$line] = $currentLine + $separator + $nextLine
        $this.Lines.RemoveAt($line + 1)
        
        # Mark affected line as dirty
        $this._dirtyLines.Add($line) | Out-Null
        # All lines after the removal shift, so mark all dirty
        $this._allLinesDirty = $true
    }
    
    [string] GetTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $line -ge $this.Lines.Count) { return "" }
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $length = [Math]::Min($length, $currentLine.Length - $col)
        if ($length -le 0) {
            return ""
        }
        return $currentLine.Substring($col, $length)
    }
    
    # --- Private Helper Methods ---
    
    hidden [void] EnsureLineExists([int]$line) {
        while ($this.Lines.Count -le $line) {
            $this.Lines.Add("") | Out-Null
        }
    }
    
    hidden [void] AddToUndoStack([object]$command) {
        $this._undoStack.Add($command) | Out-Null
        if ($this._undoStack.Count -gt $this._maxUndoHistory) {
            $this._undoStack.RemoveAt(0)
        }
        # A new action clears the redo stack
        $this._redoStack.Clear()
    }
    
    hidden [void] SetModified([bool]$modified) {
        if ($this.IsModified -ne $modified) {
            $this.IsModified = $modified
            if ($this.OnModifiedStateChanged) {
                & $this.OnModifiedStateChanged $modified
            }
        }
    }
    
    hidden [void] NotifyContentChanged() {
        if ($this.OnContentChanged) {
            & $this.OnContentChanged
        }
    }
}


####\Core/EditorCommands.ps1
# EditorCommands.ps1 - Command Pattern implementation for text editor
# Provides robust undo/redo system using Command Pattern design

# Base interface for all editor commands
class IEditorCommand {
    [void] Execute([object]$buffer) { 
        throw "Execute method must be implemented by derived classes"
    }
    [void] Undo([object]$buffer) { 
        throw "Undo method must be implemented by derived classes"
    }
    [string] GetDescription() {
        return $this.GetType().Name
    }
}

# Command for inserting text at a specific position
class InsertTextCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$Text
    
    InsertTextCommand([int]$line, [int]$col, [string]$text) {
        $this.Line = $line
        $this.Col = $col
        $this.Text = $text
    }
    
    [void] Execute([object]$buffer) {
        $buffer.InsertTextAt($this.Line, $this.Col, $this.Text)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.DeleteTextAt($this.Line, $this.Col, $this.Text.Length)
    }
    
    [string] GetDescription() {
        return "Insert '$($this.Text)' at ($($this.Line),$($this.Col))"
    }
}

# Command for deleting text at a specific position
class DeleteTextCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$DeletedText  # Stores the text that was deleted for undo
    [int]$Length
    
    DeleteTextCommand([int]$line, [int]$col, [string]$deletedText) {
        $this.Line = $line
        $this.Col = $col
        $this.DeletedText = $deletedText
        $this.Length = $deletedText.Length
    }
    
    [void] Execute([object]$buffer) {
        $buffer.DeleteTextAt($this.Line, $this.Col, $this.Length)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.InsertTextAt($this.Line, $this.Col, $this.DeletedText)
    }
    
    [string] GetDescription() {
        return "Delete '$($this.DeletedText)' at ($($this.Line),$($this.Col))"
    }
}

# Command for inserting a new line
class InsertNewlineCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$SplitRightText = ""  # Text moved to new line when splitting
    
    InsertNewlineCommand([int]$line, [int]$col, [string]$splitRightText = "") {
        $this.Line = $line
        $this.Col = $col
        $this.SplitRightText = $splitRightText
    }
    
    [void] Execute([object]$buffer) {
        $buffer.InsertNewlineAt($this.Line, $this.Col)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.JoinLinesAt($this.Line, $this.SplitRightText)
    }
    
    [string] GetDescription() {
        return "Insert newline at ($($this.Line),$($this.Col))"
    }
}

# Command for joining two lines (opposite of newline)
class JoinLinesCommand : IEditorCommand {
    [int]$Line
    [string]$JoinedText  # Text from the next line that was joined
    
    JoinLinesCommand([int]$line, [string]$joinedText) {
        $this.Line = $line
        $this.JoinedText = $joinedText
    }
    
    [void] Execute([object]$buffer) {
        $buffer.JoinLinesAt($this.Line, "")
    }
    
    [void] Undo([object]$buffer) {
        # Find the split position and insert newline
        $currentLine = $buffer.GetLine($this.Line)
        $splitPos = $currentLine.Length - $this.JoinedText.Length
        $buffer.InsertNewlineAt($this.Line, $splitPos)
    }
    
    [string] GetDescription() {
        return "Join lines at $($this.Line)"
    }
}

# Composite command for grouping multiple commands into one undo unit
class CompositeCommand : IEditorCommand {
    [System.Collections.ArrayList]$Commands
    [string]$Description
    
    CompositeCommand([string]$description) {
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.Description = $description
    }
    
    [void] AddCommand([object]$command) {
        $this.Commands.Add($command) | Out-Null
    }
    
    [void] Execute([object]$buffer) {
        foreach ($command in $this.Commands) {
            $command.Execute($buffer)
        }
    }
    
    [void] Undo([object]$buffer) {
        # Undo in reverse order
        for ($i = $this.Commands.Count - 1; $i -ge 0; $i--) {
            $this.Commands[$i].Undo($buffer)
        }
    }
    
    [string] GetDescription() {
        return $this.Description
    }
}


####\Core/GapBuffer.ps1
# GapBuffer.ps1 - High-performance text buffer for editing operations
# Uses a gap buffer data structure for optimal performance on typical editing patterns

class GapBuffer {
    # Internal buffer with gap
    hidden [char[]]$_buffer
    hidden [int]$_gapStart
    hidden [int]$_gapEnd
    hidden [int]$_capacity
    
    # Buffer growth parameters
    hidden [int]$_initialCapacity = 1024
    hidden [double]$_growthFactor = 1.5
    hidden [int]$_minGapSize = 128
    
    # Statistics for debugging/optimization
    [int]$InsertCount = 0
    [int]$DeleteCount = 0
    [int]$MoveCount = 0
    [int]$GrowCount = 0
    
    GapBuffer() {
        $this._capacity = $this._initialCapacity
        $this._buffer = [char[]]::new($this._capacity)
        $this._gapStart = 0
        $this._gapEnd = $this._capacity
    }
    
    GapBuffer([int]$initialCapacity) {
        $this._capacity = [Math]::Max($initialCapacity, $this._minGapSize)
        $this._buffer = [char[]]::new($this._capacity)
        $this._gapStart = 0
        $this._gapEnd = $this._capacity
    }
    
    GapBuffer([string]$text) {
        $textLength = $text.Length
        $this._capacity = [Math]::Max($textLength + $this._minGapSize, $this._initialCapacity)
        $this._buffer = [char[]]::new($this._capacity)
        
        # Copy text to buffer
        if ($textLength -gt 0) {
            [array]::Copy($text.ToCharArray(), 0, $this._buffer, 0, $textLength)
        }
        
        $this._gapStart = $textLength
        $this._gapEnd = $this._capacity
    }
    
    # --- Public Properties ---
    
    [int] GetLength() {
        return $this._capacity - ($this._gapEnd - $this._gapStart)
    }
    
    [int] GetCapacity() {
        return $this._capacity
    }
    
    [int] GetGapSize() {
        return $this._gapEnd - $this._gapStart
    }
    
    # --- Core Operations ---
    
    [void] MoveGapTo([int]$position) {
        if ($position -lt 0 -or $position -gt $this.GetLength()) {
            throw "Position $position is out of range (0-$($this.GetLength()))"
        }
        
        if ($position -eq $this._gapStart) {
            return  # Gap is already at the correct position
        }
        
        $this.MoveCount++
        
        if ($position -lt $this._gapStart) {
            # Move gap left - shift text right
            $moveSize = $this._gapStart - $position
            $sourceStart = $position
            $destStart = $this._gapEnd - $moveSize
            
            [array]::Copy($this._buffer, $sourceStart, $this._buffer, $destStart, $moveSize)
            
            $this._gapStart = $position
            $this._gapEnd -= $moveSize
        } else {
            # Move gap right - shift text left
            $moveSize = $position - $this._gapStart
            $sourceStart = $this._gapEnd
            $destStart = $this._gapStart
            
            [array]::Copy($this._buffer, $sourceStart, $this._buffer, $destStart, $moveSize)
            
            $this._gapStart = $position
            $this._gapEnd += $moveSize
        }
    }
    
    [void] EnsureGapSize([int]$minSize) {
        $currentGapSize = $this._gapEnd - $this._gapStart
        if ($currentGapSize -ge $minSize) {
            return  # Gap is already large enough
        }
        
        # Calculate new capacity
        $currentLength = $this.GetLength()
        $neededCapacity = $currentLength + $minSize
        $newCapacity = [Math]::Max([int]($this._capacity * $this._growthFactor), $neededCapacity)
        
        $this.GrowCount++
        
        # Create new buffer
        $newBuffer = [char[]]::new($newCapacity)
        
        # Copy text before gap
        if ($this._gapStart -gt 0) {
            [array]::Copy($this._buffer, 0, $newBuffer, 0, $this._gapStart)
        }
        
        # Copy text after gap
        $textAfterGap = $this._capacity - $this._gapEnd
        if ($textAfterGap -gt 0) {
            $newGapEnd = $newCapacity - $textAfterGap
            [array]::Copy($this._buffer, $this._gapEnd, $newBuffer, $newGapEnd, $textAfterGap)
            $this._gapEnd = $newGapEnd
        } else {
            $this._gapEnd = $newCapacity
        }
        
        $this._buffer = $newBuffer
        $this._capacity = $newCapacity
    }
    
    # --- Text Operations ---
    
    [void] Insert([int]$position, [char]$char) {
        $this.MoveGapTo($position)
        $this.EnsureGapSize(1)
        
        $this._buffer[$this._gapStart] = $char
        $this._gapStart++
        $this.InsertCount++
    }
    
    [void] Insert([int]$position, [string]$text) {
        if ([string]::IsNullOrEmpty($text)) {
            return
        }
        
        $this.MoveGapTo($position)
        $this.EnsureGapSize($text.Length)
        
        $chars = $text.ToCharArray()
        [array]::Copy($chars, 0, $this._buffer, $this._gapStart, $chars.Length)
        $this._gapStart += $chars.Length
        $this.InsertCount++
    }
    
    [void] Delete([int]$position, [int]$count = 1) {
        if ($count -le 0) {
            return
        }
        
        $length = $this.GetLength()
        if ($position -lt 0 -or $position -ge $length) {
            return  # Position out of bounds
        }
        
        # Clamp count to available characters
        $count = [Math]::Min($count, $length - $position)
        if ($count -le 0) {
            return
        }
        
        $this.MoveGapTo($position)
        
        # Expand gap to include deleted characters
        $this._gapEnd += $count
        $this.DeleteCount++
    }
    
    [char] GetChar([int]$position) {
        $length = $this.GetLength()
        if ($position -lt 0 -or $position -ge $length) {
            return [char]0  # Return null character for out of bounds
        }
        
        if ($position -lt $this._gapStart) {
            return $this._buffer[$position]
        } else {
            return $this._buffer[$position + ($this._gapEnd - $this._gapStart)]
        }
    }
    
    [string] GetText([int]$start, [int]$count) {
        $length = $this.GetLength()
        if ($start -lt 0 -or $start -ge $length -or $count -le 0) {
            return ""
        }
        
        # Clamp count to available characters
        $count = [Math]::Min($count, $length - $start)
        $chars = [char[]]::new($count)
        
        for ($i = 0; $i -lt $count; $i++) {
            $chars[$i] = $this.GetChar($start + $i)
        }
        
        return [string]::new($chars)
    }
    
    [string] GetText() {
        return $this.GetText(0, $this.GetLength())
    }
    
    [string] GetSubstring([int]$start, [int]$length) {
        return $this.GetText($start, $length)
    }
    
    # --- Advanced Operations ---
    
    [void] Clear() {
        $this._gapStart = 0
        $this._gapEnd = $this._capacity
        
        # Optional: Clear the buffer for security
        [array]::Clear($this._buffer, 0, $this._capacity)
    }
    
    [void] SetText([string]$text) {
        $this.Clear()
        if (-not [string]::IsNullOrEmpty($text)) {
            $this.Insert(0, $text)
        }
    }
    
    [int] IndexOf([char]$char, [int]$startIndex = 0) {
        $length = $this.GetLength()
        for ($i = $startIndex; $i -lt $length; $i++) {
            if ($this.GetChar($i) -eq $char) {
                return $i
            }
        }
        return -1
    }
    
    [int] IndexOf([string]$text, [int]$startIndex = 0) {
        if ([string]::IsNullOrEmpty($text)) {
            return -1
        }
        
        $length = $this.GetLength()
        $textLength = $text.Length
        
        for ($i = $startIndex; $i -le $length - $textLength; $i++) {
            $match = $true
            for ($j = 0; $j -lt $textLength; $j++) {
                if ($this.GetChar($i + $j) -ne $text[$j]) {
                    $match = $false
                    break
                }
            }
            if ($match) {
                return $i
            }
        }
        return -1
    }
    
    [int] LastIndexOf([char]$char, [int]$startIndex = -1) {
        $length = $this.GetLength()
        if ($startIndex -eq -1) {
            $startIndex = $length - 1
        }
        
        for ($i = $startIndex; $i -ge 0; $i--) {
            if ($this.GetChar($i) -eq $char) {
                return $i
            }
        }
        return -1
    }
    
    # --- Debugging and Statistics ---
    
    [hashtable] GetStatistics() {
        return @{
            Length = $this.GetLength()
            Capacity = $this._capacity
            GapSize = $this.GetGapSize()
            GapStart = $this._gapStart
            GapEnd = $this._gapEnd
            InsertCount = $this.InsertCount
            DeleteCount = $this.DeleteCount
            MoveCount = $this.MoveCount
            GrowCount = $this.GrowCount
            Efficiency = if ($this.MoveCount -gt 0) { 
                [Math]::Round(($this.InsertCount + $this.DeleteCount) / [double]$this.MoveCount, 2) 
            } else { 
                "N/A" 
            }
        }
    }
    
    [void] ResetStatistics() {
        $this.InsertCount = 0
        $this.DeleteCount = 0
        $this.MoveCount = 0
        $this.GrowCount = 0
    }
    
    [string] ToString() {
        return $this.GetText()
    }
    
    # --- Validation (for debugging) ---
    
    [bool] ValidateStructure() {
        if ($this._gapStart -lt 0 -or $this._gapStart -gt $this._capacity) {
            return $false
        }
        if ($this._gapEnd -lt $this._gapStart -or $this._gapEnd -gt $this._capacity) {
            return $false
        }
        if ($this._capacity -le 0) {
            return $false
        }
        return $true
    }
}


####\Core/GapBufferDocumentBuffer.ps1
# GapBufferDocumentBuffer.ps1 - High-performance document buffer using Gap Buffer
# Drop-in replacement for DocumentBuffer with identical public interface but better performance

class GapBufferDocumentBuffer {
    # Gap buffer for high-performance text storage
    hidden [GapBuffer]$_gapBuffer
    
    # Line index tracking for efficient line operations
    hidden [System.Collections.ArrayList]$_lineStarts
    hidden [bool]$_lineIndexDirty = $true
    
    # Command-based undo/redo system  
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [int]$_maxUndoHistory = 1000
    
    # File state
    [string]$FilePath = ""
    [bool]$IsModified = $false
    [datetime]$LastModified = [datetime]::MinValue
    
    # Change tracking for render optimization
    hidden [System.Collections.Generic.HashSet[int]]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Events for UI updates
    [scriptblock]$OnContentChanged = {}
    [scriptblock]$OnModifiedStateChanged = {}
    
    # Performance tracking
    [int]$LineIndexRebuildCount = 0
    
    GapBufferDocumentBuffer() {
        $this._gapBuffer = [GapBuffer]::new()
        $this._gapBuffer.Insert(0, "`n")  # Start with one empty line
        $this._lineStarts = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.BuildLineIndex()
        $this.UpdateLinesProperty()
    }
    
    GapBufferDocumentBuffer([string]$filePath) {
        $this._gapBuffer = [GapBuffer]::new()
        $this._lineStarts = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.FilePath = $filePath
        $this.LoadFromFile($filePath)
        $this.UpdateLinesProperty()
    }
    
    # --- Line Index Management ---
    
    hidden [void] BuildLineIndex() {
        $this._lineStarts.Clear()
        $this._lineStarts.Add(0) | Out-Null  # First line starts at position 0
        
        $length = $this._gapBuffer.GetLength()
        for ($i = 0; $i -lt $length; $i++) {
            if ($this._gapBuffer.GetChar($i) -eq "`n") {
                $this._lineStarts.Add($i + 1) | Out-Null
            }
        }
        
        $this._lineIndexDirty = $false
        $this.LineIndexRebuildCount++
    }
    
    hidden [void] EnsureLineIndex() {
        if ($this._lineIndexDirty) {
            $this.BuildLineIndex()
        }
    }
    
    hidden [void] InvalidateLineIndex() {
        $this._lineIndexDirty = $true
        $this._allLinesDirty = $true
    }
    
    # --- Public API for TextEditorScreen (Compatible with DocumentBuffer) ---
    
    [string] GetLine([int]$index) {
        $this.EnsureLineIndex()
        
        if ($index -lt 0 -or $index -ge $this._lineStarts.Count) {
            return ""
        }
        
        $lineStart = $this._lineStarts[$index]
        
        # Find line end
        if ($index -eq $this._lineStarts.Count - 1) {
            # Last line - goes to end of buffer
            $lineEnd = $this._gapBuffer.GetLength()
        } else {
            # Line ends at the position before next line start (excluding the newline)
            $lineEnd = $this._lineStarts[$index + 1] - 1
        }
        
        $lineLength = $lineEnd - $lineStart
        if ($lineLength -le 0) {
            return ""
        }
        
        return $this._gapBuffer.GetText($lineStart, $lineLength)
    }
    
    [int] GetLineCount() {
        $this.EnsureLineIndex()
        return $this._lineStarts.Count
    }
    
    [bool] IsLineDirty([int]$line) {
        return $this._allLinesDirty -or $this._dirtyLines.Contains($line)
    }
    
    [void] ClearDirtyLines() {
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
    }
    
    [void] ExecuteCommand([object]$command) {
        $command.Execute($this)
        $this.AddToUndoStack($command)
        $this.SetModified($true)
        $this.NotifyContentChanged()
    }
    
    [bool] CanUndo() {
        return $this._undoStack.Count -gt 0
    }
    
    [bool] CanRedo() {
        return $this._redoStack.Count -gt 0
    }
    
    [void] ClearUndoHistory() {
        $this._undoStack.Clear()
        $this._redoStack.Clear()
    }
    
    [void] Undo() {
        if ($this._undoStack.Count -eq 0) { return }
        
        try {
            $command = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            $command.Undo($this)
            $this._redoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this.InvalidateLineIndex()
            $this.NotifyContentChanged()
        } catch {
            # If undo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Undo failed: $($_.Exception.Message)")
            }
        }
    }
    
    [void] Redo() {
        if ($this._redoStack.Count -eq 0) { return }
        
        try {
            $command = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            $command.Execute($this)
            $this._undoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this.InvalidateLineIndex()
            $this.NotifyContentChanged()
        } catch {
            # If redo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Redo failed: $($_.Exception.Message)")
            }
        }
    }
    
    [void] LoadFromFile([string]$filePath) {
        if (-not (Test-Path $filePath)) {
            # File doesn't exist, start with empty content
            $this._gapBuffer.SetText("`n")
            $this.InvalidateLineIndex()
            $this.SetModified($false)
            return
        }
        
        try {
            $content = Get-Content $filePath -Raw
            if ($content) {
                # Ensure content ends with newline for consistent line handling
                if (-not $content.EndsWith("`n")) {
                    $content += "`n"
                }
                $this._gapBuffer.SetText($content)
            } else {
                $this._gapBuffer.SetText("`n")
            }
            
            $this.InvalidateLineIndex()
            $this.SetModified($false)
            $this.LastModified = (Get-Item $filePath).LastWriteTime
        } catch {
            throw "Failed to load file '$filePath': $($_.Exception.Message)"
        }
    }
    
    [void] SaveToFile([string]$filePath = "") {
        if ([string]::IsNullOrEmpty($filePath)) {
            $saveFilePath = $this.FilePath
        } else {
            $saveFilePath = $filePath
        }
        if ([string]::IsNullOrEmpty($saveFilePath)) {
            throw "No file path specified for save"
        }
        
        try {
            $content = $this._gapBuffer.GetText()
            # Remove trailing newline for cleaner file output
            if ($content.EndsWith("`n")) {
                $content = $content.Substring(0, $content.Length - 1)
            }
            Set-Content -Path $saveFilePath -Value $content -NoNewline
            $this.FilePath = $saveFilePath
            $this.SetModified($false)
            $this.LastModified = [datetime]::Now
        } catch {
            throw "Failed to save file '$saveFilePath': $($_.Exception.Message)"
        }
    }
    
    # --- Internal Text Manipulation Methods (Called by Commands) ---
    
    [void] InsertTextAt([int]$line, [int]$col, [string]$text) {
        if ($line -lt 0) { return }
        if ([string]::IsNullOrEmpty($text)) { return }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            $this._gapBuffer.Insert($position, $text)
            $this.InvalidateLineIndex()
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] DeleteTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $length -le 0) { return }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            $this._gapBuffer.Delete($position, $length)
            $this.InvalidateLineIndex()
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] InsertNewlineAt([int]$line, [int]$col) {
        if ($line -lt 0) { return }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            $this._gapBuffer.Insert($position, "`n")
            $this.InvalidateLineIndex()
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] JoinLinesAt([int]$line, [string]$separator = "") {
        $this.EnsureLineIndex()
        if ($line -lt 0 -or $line -ge $this._lineStarts.Count - 1) {
            return  # Can't join if invalid line or no next line
        }
        
        # Find the newline between the lines and delete it
        $nextLineStart = $this._lineStarts[$line + 1]
        $newlinePos = $nextLineStart - 1
        
        $this._gapBuffer.Delete($newlinePos, 1)
        
        # Insert separator if provided
        if (-not [string]::IsNullOrEmpty($separator)) {
            $this._gapBuffer.Insert($newlinePos, $separator)
        }
        
        $this.InvalidateLineIndex()
        $this._dirtyLines.Add($line) | Out-Null
    }
    
    [string] GetTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $length -le 0) { return "" }
        
        $position = $this.GetBufferPosition($line, $col)
        if ($position -ge 0) {
            return $this._gapBuffer.GetText($position, $length)
        }
        return ""
    }
    
    # --- Helper Methods ---
    
    hidden [int] GetBufferPosition([int]$line, [int]$col) {
        $this.EnsureLineIndex()
        
        if ($line -lt 0 -or $line -ge $this._lineStarts.Count) {
            return -1
        }
        
        $lineStart = $this._lineStarts[$line]
        $position = $lineStart + $col
        
        # Clamp position to line bounds
        if ($line -eq $this._lineStarts.Count - 1) {
            # Last line - clamp to buffer end
            $maxPos = $this._gapBuffer.GetLength()
            $position = [Math]::Min($position, $maxPos)
        } else {
            # Clamp to line end (before newline)
            $lineEnd = $this._lineStarts[$line + 1] - 1
            $position = [Math]::Min($position, $lineEnd)
        }
        
        return $position
    }
    
    hidden [void] AddToUndoStack([object]$command) {
        $this._undoStack.Add($command) | Out-Null
        if ($this._undoStack.Count -gt $this._maxUndoHistory) {
            $this._undoStack.RemoveAt(0)
        }
        # A new action clears the redo stack
        $this._redoStack.Clear()
    }
    
    hidden [void] SetModified([bool]$modified) {
        if ($this.IsModified -ne $modified) {
            $this.IsModified = $modified
            if ($this.OnModifiedStateChanged) {
                & $this.OnModifiedStateChanged $modified
            }
        }
        # Update Lines property for compatibility
        $this.UpdateLinesProperty()
    }
    
    hidden [void] NotifyContentChanged() {
        if ($this.OnContentChanged) {
            & $this.OnContentChanged
        }
    }
    
    # --- Performance and Debugging ---
    
    [hashtable] GetStatistics() {
        $gapStats = $this._gapBuffer.GetStatistics()
        return @{
            GapBuffer = $gapStats
            LineCount = $this.GetLineCount()
            LineIndexRebuildCount = $this.LineIndexRebuildCount
            LineIndexDirty = $this._lineIndexDirty
            UndoStackSize = $this._undoStack.Count
            RedoStackSize = $this._redoStack.Count
            DirtyLinesCount = $this._dirtyLines.Count
            AllLinesDirty = $this._allLinesDirty
        }
    }
    
    [void] ResetStatistics() {
        $this._gapBuffer.ResetStatistics()
        $this.LineIndexRebuildCount = 0
    }
    
    # For compatibility with ArrayList-based DocumentBuffer
    [System.Collections.ArrayList] get_Lines() {
        # Return a virtual ArrayList-like interface
        $linesList = [System.Collections.ArrayList]::new()
        $lineCount = $this.GetLineCount()
        for ($i = 0; $i -lt $lineCount; $i++) {
            $linesList.Add($this.GetLine($i)) | Out-Null
        }
        return $linesList
    }
    
    # PowerShell property syntax for Lines
    [System.Collections.ArrayList]$Lines = $null
    
    hidden [void] UpdateLinesProperty() {
        $this.Lines = $this.get_Lines()
    }
}


####\Core/IEditorCommand.ps1
# IEditorCommand.ps1 - Interface for editor commands
# Separate interface to avoid circular dependencies

# Base interface for all editor commands
class IEditorCommand {
    [void] Execute([DocumentBuffer]$buffer) { 
        throw "Execute method must be implemented by derived classes"
    }
    [void] Undo([DocumentBuffer]$buffer) { 
        throw "Undo method must be implemented by derived classes"
    }
    [string] GetDescription() {
        return $this.GetType().Name
    }
}


####\Core/KeyboardShortcuts.ps1
# KeyboardShortcuts.ps1 - Standardized keyboard shortcut system

class KeyboardShortcut {
    [System.ConsoleKey]$Key
    [System.ConsoleModifiers]$Modifiers
    [string]$Description
    [scriptblock]$Action
    [string]$Category
    [bool]$Global
    
    KeyboardShortcut() {}
    
    KeyboardShortcut([System.ConsoleKey]$key, [string]$description, [scriptblock]$action) {
        $this.Key = $key
        $this.Modifiers = [System.ConsoleModifiers]::None
        $this.Description = $description
        $this.Action = $action
        $this.Category = "General"
        $this.Global = $false
    }
    
    [string] GetDisplayText() {
        $parts = @()
        
        if ($this.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        # Convert key to readable format
        $keyName = switch ($this.Key) {
            ([System.ConsoleKey]::Enter) { "Enter" }
            ([System.ConsoleKey]::Escape) { "Esc" }
            ([System.ConsoleKey]::Spacebar) { "Space" }
            ([System.ConsoleKey]::Tab) { "Tab" }
            ([System.ConsoleKey]::Backspace) { "Backspace" }
            ([System.ConsoleKey]::Delete) { "Delete" }
            ([System.ConsoleKey]::UpArrow) { "" }
            ([System.ConsoleKey]::DownArrow) { "" }
            ([System.ConsoleKey]::LeftArrow) { "" }
            ([System.ConsoleKey]::RightArrow) { "" }
            ([System.ConsoleKey]::PageUp) { "PgUp" }
            ([System.ConsoleKey]::PageDown) { "PgDn" }
            ([System.ConsoleKey]::Home) { "Home" }
            ([System.ConsoleKey]::End) { "End" }
            default { $this.Key.ToString() }
        }
        
        $parts += $keyName
        return $parts -join "+"
    }
    
    [bool] Matches([System.ConsoleKeyInfo]$keyInfo) {
        return $keyInfo.Key -eq $this.Key -and $keyInfo.Modifiers -eq $this.Modifiers
    }
}

class KeyboardShortcutManager {
    hidden [System.Collections.Generic.Dictionary[string, System.Collections.Generic.List[KeyboardShortcut]]]$_shortcuts
    hidden [System.Collections.Generic.List[KeyboardShortcut]]$_globalShortcuts
    hidden [ThemeManager]$Theme
    
    KeyboardShortcutManager() {
        $this._shortcuts = [System.Collections.Generic.Dictionary[string, System.Collections.Generic.List[KeyboardShortcut]]]::new()
        $this._globalShortcuts = [System.Collections.Generic.List[KeyboardShortcut]]::new()
        $this.InitializeStandardShortcuts()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Theme = $container.GetService('ThemeManager')
    }
    
    [void] InitializeStandardShortcuts() {
        # Global navigation shortcuts
        $this.AddGlobalShortcut([System.ConsoleKey]::Tab, [System.ConsoleModifiers]::None, 
            "Next field", {}, "Navigation")
        $this.AddGlobalShortcut([System.ConsoleKey]::Tab, [System.ConsoleModifiers]::Shift, 
            "Previous field", {}, "Navigation")
        $this.AddGlobalShortcut([System.ConsoleKey]::F1, [System.ConsoleModifiers]::None, 
            "Show help", {}, "Help")
        $this.AddGlobalShortcut([System.ConsoleKey]::Escape, [System.ConsoleModifiers]::None, 
            "Cancel/Back", {}, "Navigation")
        
        # Standard component shortcuts
        $this.AddContextShortcut("ListBox", [System.ConsoleKey]::Enter, [System.ConsoleModifiers]::None,
            "Select item", {}, "Selection")
        $this.AddContextShortcut("ListBox", [System.ConsoleKey]::Spacebar, [System.ConsoleModifiers]::None,
            "Toggle item", {}, "Selection")
        
        $this.AddContextShortcut("TextBox", [System.ConsoleKey]::Enter, [System.ConsoleModifiers]::None,
            "Submit", {}, "Input")
        $this.AddContextShortcut("TextBox", [System.ConsoleKey]::A, [System.ConsoleModifiers]::Control,
            "Select all", {}, "Input")
        
        $this.AddContextShortcut("DataGrid", [System.ConsoleKey]::Enter, [System.ConsoleModifiers]::None,
            "Edit cell", {}, "Editing")
        $this.AddContextShortcut("DataGrid", [System.ConsoleKey]::F2, [System.ConsoleModifiers]::None,
            "Edit cell", {}, "Editing")
    }
    
    [void] AddGlobalShortcut([System.ConsoleKey]$key, [System.ConsoleModifiers]$modifiers, 
                             [string]$description, [scriptblock]$action, [string]$category) {
        $shortcut = [KeyboardShortcut]::new()
        $shortcut.Key = $key
        $shortcut.Modifiers = $modifiers
        $shortcut.Description = $description
        $shortcut.Action = $action
        $shortcut.Category = $category
        $shortcut.Global = $true
        
        $this._globalShortcuts.Add($shortcut)
    }
    
    [void] AddContextShortcut([string]$context, [System.ConsoleKey]$key, [System.ConsoleModifiers]$modifiers,
                              [string]$description, [scriptblock]$action, [string]$category) {
        $shortcut = [KeyboardShortcut]::new()
        $shortcut.Key = $key
        $shortcut.Modifiers = $modifiers
        $shortcut.Description = $description
        $shortcut.Action = $action
        $shortcut.Category = $category
        $shortcut.Global = $false
        
        if (-not $this._shortcuts.ContainsKey($context)) {
            $this._shortcuts[$context] = [System.Collections.Generic.List[KeyboardShortcut]]::new()
        }
        
        $this._shortcuts[$context].Add($shortcut)
    }
    
    [System.Collections.Generic.List[KeyboardShortcut]] GetShortcuts([string]$context) {
        $result = [System.Collections.Generic.List[KeyboardShortcut]]::new()
        
        # Add global shortcuts
        $result.AddRange($this._globalShortcuts)
        
        # Add context-specific shortcuts
        if ($context -and $this._shortcuts.ContainsKey($context)) {
            $result.AddRange($this._shortcuts[$context])
        }
        
        return $result
    }
    
    [string] RenderShortcutHelp([string]$context, [int]$maxWidth = 80) {
        $shortcuts = $this.GetShortcuts($context)
        if ($shortcuts.Count -eq 0) { return "" }
        
        # Group by category
        $categories = @{}
        foreach ($shortcut in $shortcuts) {
            if (-not $categories.ContainsKey($shortcut.Category)) {
                $categories[$shortcut.Category] = @()
            }
            $categories[$shortcut.Category] += $shortcut
        }
        
        $sb = Get-PooledStringBuilder 1024
        
        # Render categories
        $first = $true
        foreach ($category in $categories.Keys | Sort-Object) {
            if (-not $first) { $sb.AppendLine() }
            $first = $false
            
            # Category header
            if ($this.Theme) {
                $sb.Append($this.Theme.GetColor('accent'))
            }
            $sb.Append("${category}:")
            if ($this.Theme) {
                $sb.Append([VT]::Reset())
            }
            $sb.AppendLine()
            
            # Shortcuts in category
            foreach ($shortcut in $categories[$category]) {
                $keyText = $shortcut.GetDisplayText()
                $sb.Append("  ")
                
                if ($this.Theme) {
                    $sb.Append($this.Theme.GetColor('normal'))
                }
                $sb.Append($keyText.PadRight(15))
                
                if ($this.Theme) {
                    $sb.Append($this.Theme.GetColor('disabled'))
                }
                $sb.Append($shortcut.Description)
                
                if ($this.Theme) {
                    $sb.Append([VT]::Reset())
                }
                $sb.AppendLine()
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Render minimal shortcut hints (for status bars)
    [string] RenderShortcutHints([string[]]$hints, [int]$maxWidth = 80) {
        if ($hints.Count -eq 0) { return "" }
        
        $sb = Get-PooledStringBuilder 256
        
        $first = $true
        $totalLength = 0
        
        foreach ($hint in $hints) {
            $parts = $hint -split ':'
            if ($parts.Count -ne 2) { continue }
            
            $key = $parts[0].Trim()
            $desc = $parts[1].Trim()
            
            $hintLength = $key.Length + $desc.Length + 5  # Space for formatting
            if ($totalLength + $hintLength -gt $maxWidth -and -not $first) {
                break
            }
            
            if (-not $first) {
                $sb.Append("  ")
                $totalLength += 3
            }
            $first = $false
            
            if ($this.Theme) {
                $sb.Append($this.Theme.GetColor('accent'))
            }
            $sb.Append($key)
            if ($this.Theme) {
                $sb.Append($this.Theme.GetColor('disabled'))
            }
            $sb.Append(":$desc")
            
            $totalLength += $hintLength
        }
        
        if ($this.Theme) {
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}

# Extension for components to display shortcuts
class ShortcutHintBar : UIElement {
    [string[]]$Hints = @()
    hidden [KeyboardShortcutManager]$ShortcutManager
    
    [void] OnInitialize() {
        $this.ShortcutManager = $this.ServiceContainer.GetService('KeyboardShortcutManager')
        $this.Height = 1
    }
    
    [string] OnRender() {
        if (-not $this.ShortcutManager -or $this.Hints.Count -eq 0) {
            return ""
        }
        
        $sb = Get-PooledStringBuilder 256
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this.ShortcutManager.RenderShortcutHints($this.Hints, $this.Width))
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] SetContext([string]$context) {
        # Auto-generate hints from context
        $shortcuts = $this.ShortcutManager.GetShortcuts($context)
        $this.Hints = @()
        
        # Pick most important shortcuts
        $important = @("Enter", "Escape", "F1", "Tab")
        foreach ($imp in $important) {
            $shortcut = $shortcuts | Where-Object { $_.GetDisplayText() -eq $imp } | Select-Object -First 1
            if ($shortcut) {
                $this.Hints += "$($shortcut.GetDisplayText()):$($shortcut.Description)"
            }
        }
        
        $this.Invalidate()
    }
}


####\Core/ScreenManager.ps1
# ScreenManager.ps1 - Manages screen lifecycle and rendering
# Optimized for minimal overhead

class ScreenManager {
    hidden [System.Collections.Generic.Stack[Screen]]$_screenStack
    hidden [Screen]$_activeScreen = $null
    hidden [bool]$_needsRender = $true
    hidden [System.ConsoleKeyInfo]$_lastKey
    hidden [ServiceContainer]$_services
    hidden [ShortcutManager]$_shortcutManager
    hidden [FocusManager]$_focusManager
    hidden [bool]$_exitRequested = $false
    
    # Performance tracking
    hidden [System.Diagnostics.Stopwatch]$_renderTimer
    hidden [int]$_frameCount = 0
    hidden [double]$_lastFPS = 0
    
    # Double buffering
    hidden [string]$_lastContent = ""
    
    ScreenManager([ServiceContainer]$services) {
        $this._screenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this._services = $services
        $this._renderTimer = [System.Diagnostics.Stopwatch]::new()
        
        # Get managers
        $this._shortcutManager = $services.GetService('ShortcutManager')
        $this._focusManager = $services.GetService('FocusManager')
    }
    
    # Push a new screen
    [void] Push([Screen]$screen) {
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Push: Pushing screen $($screen.GetType().Name)")
        }
        
        # Deactivate current
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
            $this._activeScreen.OnDeactivated()
        }
        
        try {
            # Initialize and activate new screen
            $screen.Initialize($this._services)
            
            # Ensure we have valid console dimensions
            $width = [Math]::Max([Console]::WindowWidth, 80)
            $height = [Math]::Max([Console]::WindowHeight, 24)
            $screen.SetBounds(0, 0, $width, $height)
            
            if ($global:Logger) {
                $global:Logger.Debug("ScreenManager.Push: Set screen bounds to (0,0,$width,$height)")
            }
            
            $this._screenStack.Push($screen)
            $this._activeScreen = $screen
            $this._activeScreen.Active = $true
            $this._activeScreen.OnActivated()
            
            # Clear last content to force redraw on screen change
            $this._lastContent = ""
            $this._needsRender = $true
            
            if ($global:Logger) {
                $global:Logger.Info("ScreenManager.Push: Successfully pushed $($screen.GetType().Name), Active=$($this._activeScreen.Active)")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ScreenManager.Push: Error pushing screen - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
            throw
        }
    }
    
    # Pop current screen
    [Screen] Pop() {
        if ($this._screenStack.Count -eq 0) { return $null }
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Pop: Stack count before pop = $($this._screenStack.Count)")
        }
        
        $popped = $this._screenStack.Pop()
        if ($popped) {
            $popped.Active = $false
            $popped.OnDeactivated()
        }
        
        # Activate previous screen if any
        if ($this._screenStack.Count -gt 0) {
            $this._activeScreen = $this._screenStack.Peek()
            if ($this._activeScreen) {
                if ($global:Logger) {
                    $global:Logger.Debug("ScreenManager.Pop: Activating previous screen: $($this._activeScreen.GetType().Name)")
                }
                try {
                    $this._activeScreen.Active = $true
                    $this._activeScreen.OnActivated()
                    $this._activeScreen.Invalidate()  # Force redraw of the screen
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ScreenManager.Pop: Error activating previous screen - $_")
                        $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
                    }
                }
            } else {
                if ($global:Logger) {
                    $global:Logger.Error("ScreenManager.Pop: Previous screen is null!")
                }
            }
        } else {
            $this._activeScreen = $null
        }
        
        # Clear last content to force redraw
        $this._lastContent = ""
        $this._needsRender = $true
        return $popped
    }
    
    # Replace current screen
    [void] Replace([Screen]$screen) {
        if ($this._screenStack.Count -gt 0) {
            $this.Pop() | Out-Null
        }
        $this.Push($screen)
    }
    
    # Get active screen
    [Screen] GetActiveScreen() {
        return $this._activeScreen
    }
    
    # Main run loop
    [void] Run() {
        # Initial setup
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Run: Starting main loop")
            if ($this._activeScreen) {
                $global:Logger.Info("Active screen: $($this._activeScreen.GetType().Name)")
                $global:Logger.Info("Active screen.Active: $($this._activeScreen.Active)")
            } else {
                $global:Logger.Info("Active screen: null")
            }
            $global:Logger.Flush()
        }
        
        # Track window size
        $lastWidth = [Console]::WindowWidth
        $lastHeight = [Console]::WindowHeight
        
        # Set needsRender to true to ensure first frame renders
        $this._needsRender = $true
        
        try {
            while ($this._activeScreen -and $this._activeScreen.Active -and -not $this._exitRequested) {
                if ($global:Logger -and $this._frameCount % 100 -eq 0) {
                    $global:Logger.Debug("ScreenManager: In main loop iteration, activeScreen = " + $(if ($this._activeScreen) { $this._activeScreen.GetType().Name } else { "null" }))
                    $global:Logger.Debug("ScreenManager: needsRender = $($this._needsRender), frameCount = $($this._frameCount)")
                }
                
                # Check for window resize
                $currentWidth = [Console]::WindowWidth
                $currentHeight = [Console]::WindowHeight
                if ($currentWidth -ne $lastWidth -or $currentHeight -ne $lastHeight) {
                    $lastWidth = $currentWidth
                    $lastHeight = $currentHeight
                    
                    # Update screen bounds
                    if ($this._activeScreen) {
                        $this._activeScreen.SetBounds(0, 0, $currentWidth, $currentHeight)
                        $this._needsRender = $true
                        
                        if ($global:Logger) {
                            $global:Logger.Debug("ScreenManager: Window resized to ${currentWidth}x${currentHeight}")
                        }
                    }
                }
                
                # Handle terminal resize
                if ([Console]::WindowWidth -ne $this._activeScreen.Width -or 
                    [Console]::WindowHeight -ne $this._activeScreen.Height) {
                    $this.HandleResize()
                }
                
                # Render if needed
                if ($this._needsRender -or $this._activeScreen._cacheInvalid) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ScreenManager: Rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                    $this.Render()
                } else {
                    # Log occasionally why we're not rendering
                    if ($this._frameCount % 100 -eq 0 -and $global:Logger) {
                        $global:Logger.Debug("ScreenManager: Not rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                }
                
                # Handle input
                try {
                    # Check if running in test mode
                    if ($env:PRAXIS_TEST_MODE) {
                        if ($global:Logger) {
                            $global:Logger.Debug("Running in test mode - skipping input")
                        }
                        Start-Sleep -Milliseconds 100
                        continue
                    }
                    
                    if ([Console]::KeyAvailable) {
                        $key = [Console]::ReadKey($true)
                        $this._lastKey = $key
                        $handled = $false
                        
                        # Log key press for debugging
                        if ($global:Logger) {
                            $global:Logger.Debug("Key pressed: $($key.Key) Char: '$($key.KeyChar)' Modifiers: $($key.Modifiers)")
                        }
                        
                        # PARENT-DELEGATED INPUT MODEL - Simple routing only
                        $handled = $false
                        
                        # 1. Check ShortcutManager for global shortcuts first
                        if ($this._shortcutManager) {
                            # Get the actual active screen (e.g., ProjectsScreen within MainScreen's TabContainer)
                            $currentScreenType = ""
                            if ($this._activeScreen) {
                                if ($this._activeScreen.GetType().Name -eq "MainScreen" -and $this._activeScreen.TabContainer) {
                                    $activeTab = $this._activeScreen.TabContainer.GetActiveTab()
                                    if ($activeTab -and $activeTab.Content) {
                                        $currentScreenType = $activeTab.Content.GetType().Name
                                    }
                                } else {
                                    $currentScreenType = $this._activeScreen.GetType().Name
                                }
                            }
                            
                            $currentContext = if ($this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) { "CommandPalette" } else { "" }
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($key.Key) Char='$($key.KeyChar)' ScreenType=$currentScreenType Context=$currentContext")
                            }
                            
                            $handled = $this._shortcutManager.HandleKeyPress($key, $currentScreenType, $currentContext)
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager handled=$handled")
                            }
                        }
                        
                        # 2. Global F1 for help
                        if (-not $handled -and $key.Key -eq [System.ConsoleKey]::F1) {
                            # Show keyboard help overlay
                            try {
                                # Check if HelpManager is available
                                $helpOverlay = [KeyboardHelpOverlay]::new("")
                                if ($this._activeScreen) {
                                    $helpOverlay = [KeyboardHelpOverlay]::new($this._activeScreen.GetType().Name)
                                }
                                $this.Push($helpOverlay)
                                $handled = $true
                            } catch {
                                # HelpManager not available yet
                                if ($global:Logger) {
                                    $global:Logger.Debug("F1 help not available: $_")
                                }
                            }
                        }
                        
                        # 3. Command Palette override (when visible) - only if not handled by shortcuts
                        if (-not $handled -and $this._activeScreen -and $this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) {
                            $handled = $this._activeScreen.CommandPalette.HandleInput($key)
                            if ($global:Logger) {
                                $global:Logger.Debug("Key routed to CommandPalette")
                            }
                        }
                        # 3. Fallback to hardcoded shortcuts if ShortcutManager not available
                        elseif (-not $this._shortcutManager) {
                            if ($key.KeyChar -eq '/' -or $key.KeyChar -eq ':') {
                                # Show command palette
                                if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
                                    $this._activeScreen.CommandPalette.Show()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Command palette opened")
                                    }
                                }
                            } 
                            elseif ($key.Key -eq [System.ConsoleKey]::Tab) {
                                # Handle Tab navigation via parent delegation
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                            elseif ($key.Modifiers -band [System.ConsoleModifiers]::Control) {
                                # Ctrl+Q for quit
                                if ($key.Key -eq [System.ConsoleKey]::Q) {
                                    $this.RequestExit()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Quit application")
                                    }
                                }
                            }
                            # Ctrl+Arrows for focus navigation
                            elseif ($key.Key -eq [System.ConsoleKey]::RightArrow -or $key.Key -eq [System.ConsoleKey]::LeftArrow) {
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                        }
                        
                        # 4. Tab navigation (if not handled above)
                        if (-not $handled -and $key.Key -eq [System.ConsoleKey]::Tab -and $this._activeScreen) {
                            $handled = $this.HandleTabNavigation($key)
                        }
                        
                        # 5. If not handled by global shortcuts, let screen handle it
                        if (-not $handled -and $this._activeScreen) {
                            try {
                                $handled = $this._activeScreen.HandleInput($key)
                                if ($handled -and $global:Logger) {
                                    $global:Logger.Debug("Key handled by screen: $($this._activeScreen.GetType().Name)")
                                }
                            } catch {
                                if ($global:Logger) {
                                    $global:Logger.LogException($_.Exception, "Error in screen input handling")
                                }
                            }
                        }
                        
                        if ($handled) {
                            $this._needsRender = $true
                        }
                        
                        # Emergency exit (Ctrl+Esc)
                        if ($key.Key -eq [System.ConsoleKey]::Escape -and 
                            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
                            break  # Ctrl+Esc to exit
                        }
                    } else {
                        # Small sleep to prevent CPU spinning
                        Start-Sleep -Milliseconds 10
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.LogException($_.Exception, "Error in input handling")
                    }
                    
                    # In non-interactive mode, just sleep
                    Start-Sleep -Milliseconds 50
                    
                    # Check if we should exit (for testing)
                    if ($env:PRAXIS_TEST_MODE) {
                        break
                    }
                }
            }
        } finally {
            # Cleanup
            [Console]::CursorVisible = $true
            [Console]::Clear()
            [Console]::SetCursorPosition(0, 0)
        }
    }
    
    # Render current screen
    hidden [void] Render() {
        $this._renderTimer.Restart()
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Render: Starting render")
        }
        
        # Get rendered content
        $content = $this._activeScreen.Render()
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Render: Content length = $($content.Length)")
        }
        
        # Clear screen if content changed significantly (like dialog closing)
        if ($this._lastContent -eq "") {
            [Console]::Clear()
        }
        
        # Always write to console
        [Console]::CursorVisible = $false
        [Console]::SetCursorPosition(0, 0)
        [Console]::Write($content)
        
        # Store content for next comparison
        $this._lastContent = $content
        
        $this._renderTimer.Stop()
        $this._frameCount++
        
        # Update FPS every second
        if ($this._frameCount % 60 -eq 0) {
            $this._lastFPS = 1000.0 / $this._renderTimer.ElapsedMilliseconds
        }
        
        $this._needsRender = $false
    }
    
    # Handle terminal resize
    hidden [void] HandleResize() {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        # Update all screens in stack
        foreach ($screen in $this._screenStack) {
            $screen.SetBounds(0, 0, $newWidth, $newHeight)
        }
        
        # Clear and force full redraw
        [Console]::Clear()
        $this._lastContent = ""  # Force full redraw on next render
        $this._needsRender = $true
    }
    
    # Request render on next frame
    [void] RequestRender() {
        $this._needsRender = $true
    }
    
    # Fast Tab navigation using FocusManager
    [bool] HandleTabNavigation([System.ConsoleKeyInfo]$key) {
        if (-not $this._focusManager) { return $false }
        
        $isReverse = ($key.Modifiers -band [System.ConsoleModifiers]::Shift) -ne 0
        
        # Use FocusManager for O(1) navigation
        if ($isReverse) {
            return $this._focusManager.FocusPrevious($this._activeScreen)
        } else {
            return $this._focusManager.FocusNext($this._activeScreen)
        }
    }
    
    # Get focused element using FocusManager (O(1))
    [UIElement] GetFocusedElement() {
        if ($this._focusManager) {
            return $this._focusManager.GetFocused()
        }
        return $null
    }
    
    # Get current FPS
    [double] GetFPS() {
        return $this._lastFPS
    }
    
    # Request application exit
    [void] RequestExit() {
        $this._exitRequested = $true
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
        }
    }
    
    # Show command palette
    [void] ShowCommandPalette() {
        if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
            $this._activeScreen.CommandPalette.Show()
        }
    }
}

# Global screen manager instance
$global:ScreenManager = $null


####\Core/ServiceContainer.ps1
# ServiceContainer.ps1 - Lightweight dependency injection
# Simplified from AxiomPhoenix for PRAXIS

class ServiceContainer {
    hidden [hashtable]$_services = @{}
    hidden [hashtable]$_factories = @{}
    
    # Register a service instance
    [void] Register([string]$name, [object]$instance) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $instance) {
            throw "Service instance cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._services[$name] = $instance
    }
    
    # Register a factory for lazy initialization
    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$singleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $factory) {
            throw "Factory cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._factories[$name] = @{
            Factory = $factory
            Singleton = $singleton
            Instance = $null
        }
    }
    
    # Get a service by name
    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        
        # Check eager instances first
        if ($this._services.ContainsKey($name)) {
            return $this._services[$name]
        }
        
        # Check factories
        if ($this._factories.ContainsKey($name)) {
            $factory = $this._factories[$name]
            
            # Return cached singleton if available
            if ($factory.Singleton -and $null -ne $factory.Instance) {
                return $factory.Instance
            }
            
            # Create new instance
            $instance = & $factory.Factory $this
            
            # Cache if singleton
            if ($factory.Singleton) {
                $factory.Instance = $instance
            }
            
            return $instance
        }
        
        throw "Service '$name' not found. Available: $($this.GetServiceNames() -join ', ')"
    }
    
    # Get all registered service names
    [string[]] GetServiceNames() {
        $names = @()
        $names += $this._services.Keys
        $names += $this._factories.Keys
        return $names | Sort-Object
    }
    
    # Cleanup all services
    [void] Cleanup() {
        # Dispose any IDisposable services
        $allInstances = @()
        $allInstances += $this._services.Values
        $allInstances += $this._factories.Values | Where-Object { $_.Instance } | ForEach-Object { $_.Instance }
        
        foreach ($instance in $allInstances) {
            if ($instance -is [System.IDisposable]) {
                try {
                    $instance.Dispose()
                } catch {
                    # Ignore disposal errors
                }
            }
        }
        
        $this._services.Clear()
        $this._factories.Clear()
    }
}

# Global service container instance
$global:ServiceContainer = [ServiceContainer]::new()


####\Core/SmoothScrolling.ps1
# SmoothScrolling.ps1 - Smooth scrolling support for list components

class ScrollState {
    [double]$Position = 0.0      # Current scroll position (can be fractional during animation)
    [int]$TargetPosition = 0     # Target position to scroll to
    [double]$Velocity = 0.0      # Current scrolling velocity
    [bool]$IsScrolling = $false  # Whether currently animating
    [DateTime]$LastUpdate        # Last update time for delta calculation
    
    # Scrolling physics
    [double]$Acceleration = 3000.0  # Pixels per second squared
    [double]$MaxVelocity = 1000.0   # Max pixels per second
    [double]$Friction = 10.0        # Deceleration factor
    [double]$SnapThreshold = 0.5    # Distance to snap to target
}

class SmoothScroller {
    hidden [ScrollState]$State
    hidden [int]$MinPosition = 0
    hidden [int]$MaxPosition = 0
    hidden [int]$ViewportSize = 0
    hidden [int]$ContentSize = 0
    hidden [System.Timers.Timer]$UpdateTimer
    hidden [UIElement]$Parent
    
    # Scrolling settings
    [double]$ScrollSpeed = 3.0      # Lines per scroll event
    [bool]$EnableSmoothing = $true  # Toggle smooth scrolling
    [bool]$EnableInertia = $true    # Enable inertial scrolling
    
    SmoothScroller([UIElement]$parent) {
        $this.State = [ScrollState]::new()
        $this.State.LastUpdate = [DateTime]::Now
        $this.Parent = $parent
        
        # Create update timer for smooth animation
        $this.UpdateTimer = [System.Timers.Timer]::new(16)  # ~60 FPS
        $this.UpdateTimer.AutoReset = $true
        
        # Register timer event
        Register-ObjectEvent -InputObject $this.UpdateTimer -EventName Elapsed -Action {
            $Event.MessageData.Update()
        } -MessageData $this | Out-Null
    }
    
    [void] SetBounds([int]$viewportSize, [int]$contentSize) {
        $this.ViewportSize = $viewportSize
        $this.ContentSize = $contentSize
        $this.MaxPosition = [Math]::Max(0, $contentSize - $viewportSize)
        
        # Clamp current position
        if ($this.State.Position -gt $this.MaxPosition) {
            $this.State.Position = $this.MaxPosition
            $this.State.TargetPosition = $this.MaxPosition
        }
    }
    
    [void] ScrollTo([int]$position) {
        $this.State.TargetPosition = [Math]::Max($this.MinPosition, [Math]::Min($position, $this.MaxPosition))
        
        if ($this.EnableSmoothing) {
            $this.State.IsScrolling = $true
            if (-not $this.UpdateTimer.Enabled) {
                $this.UpdateTimer.Start()
            }
        } else {
            # Instant scroll
            $this.State.Position = $this.State.TargetPosition
            $this.Parent.Invalidate()
        }
    }
    
    [void] ScrollBy([int]$delta) {
        $newTarget = $this.State.TargetPosition + ($delta * $this.ScrollSpeed)
        $this.ScrollTo([int]$newTarget)
    }
    
    [void] ScrollUp() {
        $this.ScrollBy(-1)
    }
    
    [void] ScrollDown() {
        $this.ScrollBy(1)
    }
    
    [void] PageUp() {
        $this.ScrollBy(-$this.ViewportSize + 1)
    }
    
    [void] PageDown() {
        $this.ScrollBy($this.ViewportSize - 1)
    }
    
    [void] ScrollToTop() {
        $this.ScrollTo($this.MinPosition)
    }
    
    [void] ScrollToBottom() {
        $this.ScrollTo($this.MaxPosition)
    }
    
    [int] GetCurrentPosition() {
        return [int][Math]::Round($this.State.Position)
    }
    
    [bool] CanScrollUp() {
        return $this.GetCurrentPosition() -gt $this.MinPosition
    }
    
    [bool] CanScrollDown() {
        return $this.GetCurrentPosition() -lt $this.MaxPosition
    }
    
    [void] Update() {
        if (-not $this.State.IsScrolling) {
            $this.UpdateTimer.Stop()
            return
        }
        
        $now = [DateTime]::Now
        $deltaTime = ($now - $this.State.LastUpdate).TotalSeconds
        $this.State.LastUpdate = $now
        
        # Calculate distance to target
        $distance = $this.State.TargetPosition - $this.State.Position
        
        if ([Math]::Abs($distance) -lt $this.State.SnapThreshold) {
            # Snap to target
            $this.State.Position = $this.State.TargetPosition
            $this.State.Velocity = 0
            $this.State.IsScrolling = $false
            $this.UpdateTimer.Stop()
        } else {
            # Apply smooth scrolling physics
            if ($this.EnableInertia) {
                # Calculate desired velocity based on distance
                $desiredVelocity = $distance * 10  # Proportional control
                
                # Limit velocity
                $desiredVelocity = [Math]::Max(-$this.State.MaxVelocity, 
                                  [Math]::Min($desiredVelocity, $this.State.MaxVelocity))
                
                # Apply acceleration towards desired velocity
                $velocityDiff = $desiredVelocity - $this.State.Velocity
                $acceleration = $velocityDiff * $this.State.Friction
                
                # Update velocity
                $this.State.Velocity += $acceleration * $deltaTime
                
                # Apply friction
                $this.State.Velocity *= [Math]::Pow(0.95, $deltaTime * 60)  # Frame-rate independent
            } else {
                # Simple easing without inertia
                $this.State.Velocity = $distance * 8  # Direct proportional
            }
            
            # Update position
            $this.State.Position += $this.State.Velocity * $deltaTime
            
            # Clamp position
            $this.State.Position = [Math]::Max($this.MinPosition, 
                                  [Math]::Min($this.State.Position, $this.MaxPosition))
        }
        
        # Notify parent to redraw
        $this.Parent.Invalidate()
    }
    
    [void] StopScrolling() {
        $this.State.IsScrolling = $false
        $this.State.Velocity = 0
        $this.UpdateTimer.Stop()
    }
    
    # Get scroll indicator info
    [hashtable] GetScrollBarInfo([int]$scrollBarHeight) {
        if ($this.ContentSize -le $this.ViewportSize) {
            return @{ Show = $false }
        }
        
        $thumbHeight = [Math]::Max(1, [int]($scrollBarHeight * $this.ViewportSize / $this.ContentSize))
        $scrollRange = $scrollBarHeight - $thumbHeight
        $scrollRatio = $this.GetCurrentPosition() / [double]$this.MaxPosition
        $thumbPosition = [int]($scrollRange * $scrollRatio)
        
        return @{
            Show = $true
            ThumbHeight = $thumbHeight
            ThumbPosition = $thumbPosition
            IsAtTop = $this.GetCurrentPosition() -eq $this.MinPosition
            IsAtBottom = $this.GetCurrentPosition() -eq $this.MaxPosition
        }
    }
}

# Scrollable list box with smooth scrolling
class SmoothScrollListBox : MinimalListBox {
    hidden [SmoothScroller]$Scroller
    [bool]$ShowScrollBar = $true
    
    SmoothScrollListBox() : base() {
        $this.Scroller = [SmoothScroller]::new($this)
    }
    
    [void] OnBoundsChanged() {
        ([MinimalListBox]$this).OnBoundsChanged()
        
        # Update scroller bounds
        $viewportHeight = $this.Height
        if ($this.ShowBorder) { $viewportHeight -= 2 }
        if ($this.Title) { $viewportHeight -= 1 }
        
        $contentHeight = $this.Items.Count
        $this.Scroller.SetBounds($viewportHeight, $contentHeight)
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectIndex($this.SelectedIndex - 1)
                    $this.EnsureVisible($this.SelectedIndex)
                }
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectIndex($this.SelectedIndex + 1)
                    $this.EnsureVisible($this.SelectedIndex)
                }
                return $true
            }
            ([System.ConsoleKey]::PageUp) {
                $this.Scroller.PageUp()
                $newIndex = [Math]::Max(0, $this.Scroller.GetCurrentPosition())
                $this.SelectIndex($newIndex)
                return $true
            }
            ([System.ConsoleKey]::PageDown) {
                $this.Scroller.PageDown()
                $newIndex = [Math]::Min($this.Items.Count - 1, 
                           $this.Scroller.GetCurrentPosition() + $this.Height - 3)
                $this.SelectIndex($newIndex)
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.Scroller.ScrollToTop()
                $this.SelectIndex(0)
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.Scroller.ScrollToBottom()
                $this.SelectIndex($this.Items.Count - 1)
                return $true
            }
        }
        
        return ([MinimalListBox]$this).HandleInput($key)
    }
    
    [void] EnsureVisible([int]$index) {
        $scrollPos = $this.Scroller.GetCurrentPosition()
        $viewportHeight = $this.Height
        if ($this.ShowBorder) { $viewportHeight -= 2 }
        if ($this.Title) { $viewportHeight -= 1 }
        
        if ($index -lt $scrollPos) {
            # Scroll up to show item
            $this.Scroller.ScrollTo($index)
        } elseif ($index -ge $scrollPos + $viewportHeight) {
            # Scroll down to show item
            $this.Scroller.ScrollTo($index - $viewportHeight + 1)
        }
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Render border and title
        if ($this.ShowBorder) {
            $sb.Append([BorderStyle]::RenderBorderWithTitle(
                $this.X, $this.Y, $this.Width, $this.Height,
                $this.BorderType, $this._colors.border,
                $this.Title, $this._colors.title
            ))
        }
        
        # Calculate content area
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        $contentHeight = $this.Height
        
        if ($this.ShowBorder) {
            $contentX++
            $contentY++
            $contentWidth -= 2
            $contentHeight -= 2
        }
        
        if ($this.Title -and $this.ShowBorder) {
            $contentY++
            $contentHeight--
        }
        
        # Render items with smooth scrolling
        $scrollPos = $this.Scroller.GetCurrentPosition()
        $visibleItems = [Math]::Min($contentHeight, $this.Items.Count - $scrollPos)
        
        for ($i = 0; $i -lt $visibleItems; $i++) {
            $itemIndex = $scrollPos + $i
            $item = $this.Items[$itemIndex]
            $y = $contentY + $i
            
            $sb.Append([VT]::MoveTo($contentX, $y))
            
            # Selection highlight
            if ($itemIndex -eq $this.SelectedIndex) {
                if ($this.IsFocused) {
                    $sb.Append($this._colors.selectedBg)
                    $sb.Append($this._colors.selectedFg)
                } else {
                    $sb.Append($this._colors.inactiveSelectedBg)
                    $sb.Append($this._colors.text)
                }
            } else {
                $sb.Append($this._colors.text)
            }
            
            # Render item text
            $displayText = $this.GetDisplayText($item)
            if ($displayText.Length -gt $contentWidth - 1) {
                $displayText = $displayText.Substring(0, $contentWidth - 4) + "..."
            }
            $sb.Append($displayText.PadRight($contentWidth - 1))
        }
        
        # Render scroll bar
        if ($this.ShowScrollBar -and $this.ShowBorder) {
            $scrollInfo = $this.Scroller.GetScrollBarInfo($contentHeight)
            if ($scrollInfo.Show) {
                $scrollX = $this.X + $this.Width - 1
                
                # Render scroll track
                for ($i = 0; $i -lt $contentHeight; $i++) {
                    $sb.Append([VT]::MoveTo($scrollX, $contentY + $i))
                    
                    if ($i -ge $scrollInfo.ThumbPosition -and 
                        $i -lt $scrollInfo.ThumbPosition + $scrollInfo.ThumbHeight) {
                        # Thumb
                        $sb.Append($this._colors.accent)
                        $sb.Append('')
                    } else {
                        # Track
                        $sb.Append($this._colors.disabled)
                        $sb.Append('')
                    }
                }
                
                # Scroll indicators
                if (-not $scrollInfo.IsAtTop) {
                    $sb.Append([VT]::MoveTo($scrollX, $contentY))
                    $sb.Append($this._colors.accent)
                    $sb.Append('')
                }
                
                if (-not $scrollInfo.IsAtBottom) {
                    $sb.Append([VT]::MoveTo($scrollX, $contentY + $contentHeight - 1))
                    $sb.Append($this._colors.accent)
                    $sb.Append('')
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Core/SpacingSystem.ps1
# SpacingSystem.ps1 - Consistent spacing and padding system

class Spacing {
    # Standard spacing units (based on 4px grid)
    static [int]$None = 0
    static [int]$Tiny = 1     # 1 character
    static [int]$Small = 2    # 2 characters
    static [int]$Medium = 4   # 4 characters (default)
    static [int]$Large = 8    # 8 characters
    static [int]$XLarge = 12  # 12 characters
    
    # Component-specific spacing
    static [hashtable]$Component = @{
        # Padding inside components
        ButtonPaddingX = 3
        ButtonPaddingY = 0
        
        TextBoxPaddingX = 1
        TextBoxPaddingY = 0
        
        ListBoxPaddingX = 1
        ListBoxPaddingY = 0
        
        ModalPaddingX = 2
        ModalPaddingY = 2
        
        # Margins between components
        ElementGap = 1
        SectionGap = 2
        ScreenMargin = 1
        
        # Focus indicators
        FocusOffset = 1
        FocusPadding = 1
    }
    
    # Get consistent padding for a component type
    static [hashtable] GetPadding([string]$componentType) {
        switch ($componentType) {
            "Button" {
                return @{
                    Left = [Spacing]::Component.ButtonPaddingX
                    Right = [Spacing]::Component.ButtonPaddingX
                    Top = [Spacing]::Component.ButtonPaddingY
                    Bottom = [Spacing]::Component.ButtonPaddingY
                }
            }
            "TextBox" {
                return @{
                    Left = [Spacing]::Component.TextBoxPaddingX
                    Right = [Spacing]::Component.TextBoxPaddingX
                    Top = [Spacing]::Component.TextBoxPaddingY
                    Bottom = [Spacing]::Component.TextBoxPaddingY
                }
            }
            "ListBox" {
                return @{
                    Left = [Spacing]::Component.ListBoxPaddingX
                    Right = [Spacing]::Component.ListBoxPaddingX
                    Top = [Spacing]::Component.ListBoxPaddingY
                    Bottom = [Spacing]::Component.ListBoxPaddingY
                }
            }
            "Modal" {
                return @{
                    Left = [Spacing]::Component.ModalPaddingX
                    Right = [Spacing]::Component.ModalPaddingX
                    Top = [Spacing]::Component.ModalPaddingY
                    Bottom = [Spacing]::Component.ModalPaddingY
                }
            }
            default {
                return @{
                    Left = [Spacing]::Small
                    Right = [Spacing]::Small
                    Top = [Spacing]::Tiny
                    Bottom = [Spacing]::Tiny
                }
            }
        }
    }
    
    # Calculate content area with padding
    static [hashtable] GetContentArea([int]$x, [int]$y, [int]$width, [int]$height, [hashtable]$padding) {
        return @{
            X = $x + $padding.Left
            Y = $y + $padding.Top
            Width = $width - $padding.Left - $padding.Right
            Height = $height - $padding.Top - $padding.Bottom
        }
    }
    
    # Create padding string
    static [string] Pad([string]$text, [int]$left, [int]$right = 0) {
        $leftPad = ' ' * $left
        $rightPad = ' ' * $right
        return "${leftPad}${text}${rightPad}"
    }
    
    # Create vertical spacing
    static [string] VerticalSpace([int]$lines) {
        return "`n" * $lines
    }
}

# Extension for UIElement to use consistent spacing
class SpacedElement : UIElement {
    [hashtable]$Padding = @{ Left = 0; Right = 0; Top = 0; Bottom = 0 }
    [hashtable]$Margin = @{ Left = 0; Right = 0; Top = 0; Bottom = 0 }
    
    [void] SetPadding([int]$all) {
        $this.Padding = @{
            Left = $all
            Right = $all
            Top = $all
            Bottom = $all
        }
        $this.Invalidate()
    }
    
    [void] SetPadding([int]$horizontal, [int]$vertical) {
        $this.Padding = @{
            Left = $horizontal
            Right = $horizontal
            Top = $vertical
            Bottom = $vertical
        }
        $this.Invalidate()
    }
    
    [void] SetPadding([int]$left, [int]$top, [int]$right, [int]$bottom) {
        $this.Padding = @{
            Left = $left
            Right = $right
            Top = $top
            Bottom = $bottom
        }
        $this.Invalidate()
    }
    
    [void] SetMargin([int]$all) {
        $this.Margin = @{
            Left = $all
            Right = $all
            Top = $all
            Bottom = $all
        }
        $this.Invalidate()
    }
    
    [void] SetMargin([int]$horizontal, [int]$vertical) {
        $this.Margin = @{
            Left = $horizontal
            Right = $horizontal
            Top = $vertical
            Bottom = $vertical
        }
        $this.Invalidate()
    }
    
    [hashtable] GetContentBounds() {
        return [Spacing]::GetContentArea(
            $this.X + $this.Margin.Left,
            $this.Y + $this.Margin.Top,
            $this.Width - $this.Margin.Left - $this.Margin.Right,
            $this.Height - $this.Margin.Top - $this.Margin.Bottom,
            $this.Padding
        )
    }
}

# Layout helpers
class LayoutHelper {
    # Stack elements vertically with consistent spacing
    static [void] StackVertical([UIElement[]]$elements, [int]$startX, [int]$startY, [int]$spacing = 0) {
        if (-not $spacing) {
            $spacing = [Spacing]::Component.ElementGap
        }
        
        $currentY = $startY
        foreach ($element in $elements) {
            $element.X = $startX
            $element.Y = $currentY
            $currentY += $element.Height + $spacing
        }
    }
    
    # Stack elements horizontally with consistent spacing
    static [void] StackHorizontal([UIElement[]]$elements, [int]$startX, [int]$startY, [int]$spacing = 0) {
        if (-not $spacing) {
            $spacing = [Spacing]::Component.ElementGap
        }
        
        $currentX = $startX
        foreach ($element in $elements) {
            $element.X = $currentX
            $element.Y = $startY
            $currentX += $element.Width + $spacing
        }
    }
    
    # Center elements in container
    static [void] CenterInContainer([UIElement]$element, [UIElement]$container) {
        $element.X = $container.X + ($container.Width - $element.Width) / 2
        $element.Y = $container.Y + ($container.Height - $element.Height) / 2
    }
    
    # Align elements
    static [void] AlignLeft([UIElement[]]$elements, [int]$x) {
        foreach ($element in $elements) {
            $element.X = $x
        }
    }
    
    static [void] AlignRight([UIElement[]]$elements, [int]$containerWidth, [int]$rightMargin = 0) {
        foreach ($element in $elements) {
            $element.X = $containerWidth - $element.Width - $rightMargin
        }
    }
    
    static [void] AlignCenter([UIElement[]]$elements, [int]$containerWidth) {
        foreach ($element in $elements) {
            $element.X = ($containerWidth - $element.Width) / 2
        }
    }
}


####\Core/StringBuilderPool.ps1
# StringBuilderPool.ps1 - Pool for reusing StringBuilder instances to reduce memory allocations

class StringBuilderPool {
    static [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]$Pool = [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]::new()
    static [int]$MaxPoolSize = 50
    static [int]$MaxCapacity = 16384  # 16KB max capacity before discarding
    static [int]$CreatedCount = 0
    static [int]$ReusedCount = 0
    
    # Get a StringBuilder from the pool or create new one
    static [System.Text.StringBuilder] Get() {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()  # Clear but keep capacity
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new()
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Get a StringBuilder with initial capacity
    static [System.Text.StringBuilder] Get([int]$initialCapacity) {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()
            if ($sb.Capacity -lt $initialCapacity) {
                $sb.Capacity = $initialCapacity
            }
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new($initialCapacity)
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Return StringBuilder to pool for reuse
    static [void] Return([System.Text.StringBuilder]$sb) {
        if (-not $sb) { return }
        
        # Don't pool if too large (prevents memory bloat)
        if ($sb.Capacity -gt [StringBuilderPool]::MaxCapacity) {
            return
        }
        
        # Don't pool if we're at max capacity
        if ([StringBuilderPool]::Pool.Count -ge [StringBuilderPool]::MaxPoolSize) {
            return
        }
        
        $sb.Clear()
        [StringBuilderPool]::Pool.Enqueue($sb)
    }
    
    # Get pool statistics for debugging
    static [hashtable] GetStats() {
        return @{
            PoolSize = [StringBuilderPool]::Pool.Count
            MaxPoolSize = [StringBuilderPool]::MaxPoolSize
            Created = [StringBuilderPool]::CreatedCount
            Reused = [StringBuilderPool]::ReusedCount
            ReuseRate = if ([StringBuilderPool]::CreatedCount -eq 0) { 0 } else { 
                [Math]::Round(([StringBuilderPool]::ReusedCount / ([StringBuilderPool]::CreatedCount + [StringBuilderPool]::ReusedCount)) * 100, 2)
            }
        }
    }
    
    # Clear the pool (useful for testing or cleanup)
    static [void] Clear() {
        while ([StringBuilderPool]::Pool.TryDequeue([ref]$null)) {
            # Empty the queue
        }
    }
}

# Global helper functions for easier access
function Get-PooledStringBuilder {
    param([int]$initialCapacity = 256)
    
    if ($initialCapacity -gt 0) {
        return [StringBuilderPool]::Get($initialCapacity)
    } else {
        return [StringBuilderPool]::Get()
    }
}

function Return-PooledStringBuilder {
    param([System.Text.StringBuilder]$StringBuilder)
    [StringBuilderPool]::Return($StringBuilder)
}

function Get-StringBuilderPoolStats {
    return [StringBuilderPool]::GetStats()
}


####\Core/StringCache.ps1
# StringCache.ps1 - Pre-cached strings for common rendering patterns
# Optimizes string multiplication operations that allocate frequently

class StringCache {
    # Cache for space strings of various lengths
    static [hashtable]$Spaces = @{}
    
    # Cache for horizontal line strings
    static [hashtable]$HLines = @{}
    
    # Cache for VT100 horizontal sequences (populated later)
    static [hashtable]$VTHorizontal = @{}
    
    # Maximum cached length
    static [int]$MaxCacheLength = 200
    
    # Initialize the cache with common sizes
    static [void] Initialize() {
        # Pre-populate common sizes for spaces
        for ($i = 1; $i -le [StringCache]::MaxCacheLength; $i++) {
            [StringCache]::Spaces[$i] = " " * $i
        }
        
        # Pre-populate common sizes for horizontal lines
        for ($i = 1; $i -le [StringCache]::MaxCacheLength; $i++) {
            [StringCache]::HLines[$i] = "" * $i
        }
        
        # VT100 horizontal sequences will be populated after VT is loaded
    }
    
    # Get spaces of specified width
    static [string] GetSpaces([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength) {
            return [StringCache]::Spaces[$width]
        }
        # For larger widths, build dynamically
        return " " * $width
    }
    
    # Get horizontal lines of specified width
    static [string] GetHorizontalLine([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength) {
            return [StringCache]::HLines[$width]
        }
        # For larger widths, build dynamically
        return "" * $width
    }
    
    # Get VT100 horizontal sequence of specified width
    static [string] GetVTHorizontal([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength -and [StringCache]::VTHorizontal.ContainsKey($width)) {
            return [StringCache]::VTHorizontal[$width]
        }
        # For larger widths, build dynamically using fallback
        return "" * $width
    }
    
    # Get repeated character string
    static [string] GetRepeatedChar([char]$char, [int]$count) {
        if ($count -le 0) { return "" }
        if ($char -eq ' ' -and $count -le [StringCache]::MaxCacheLength) {
            return [StringCache]::Spaces[$count]
        }
        if ($char -eq '' -and $count -le [StringCache]::MaxCacheLength) {
            return [StringCache]::HLines[$count]
        }
        # For other characters or large counts, build dynamically
        return [string]$char * $count
    }
}

# Initialize the cache on module load
[StringCache]::Initialize()


####\Core/VT100.ps1
# VT100/ANSI Core for BOLT-AXIOM with True Color Support

class VT {
    # Cursor movement (ANSI uses 1-based coordinates)
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    
    # Screen control
    static [string] Clear() { return "`e[H`e[2J" }  # Clear screen and home
    static [string] ClearLine() { return "`e[K" }
    static [string] Home() { return "`e[H" }      # Just home position
    static [string] ClearToEnd() { return "`e[J" }  # Clear from cursor to end
    
    # Basic styles
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Dim() { return "`e[2m" }
    static [string] Underline() { return "`e[4m" }
    static [string] NoUnderline() { return "`e[24m" }
    
    # 24-bit True Color
    static [string] RGB([int]$r, [int]$g, [int]$b) { 
        return "`e[38;2;$r;$g;$($b)m" 
    }
    static [string] RGBBG([int]$r, [int]$g, [int]$b) { 
        return "`e[48;2;$r;$g;$($b)m" 
    }
    
    # Wireframe color palette (true color)
    static [string] Border() { return [VT]::RGB(0, 255, 255) }      # Cyan
    static [string] BorderDim() { return [VT]::RGB(0, 128, 128) }   # Dark cyan
    static [string] BorderActive() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Text() { return [VT]::RGB(192, 192, 192) }      # Light gray
    static [string] TextDim() { return [VT]::RGB(128, 128, 128) }   # Gray
    static [string] TextBright() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Accent() { return [VT]::RGB(0, 255, 0) }        # Green
    static [string] Warning() { return [VT]::RGB(255, 255, 0) }     # Yellow
    static [string] Error() { return [VT]::RGB(255, 0, 0) }         # Red
    static [string] Selected() { return [VT]::RGB(255, 255, 255) + [VT]::RGBBG(0, 64, 128) } # White on dark blue
    
    # Box drawing - single lines for speed
    static [string] TL() { return "" }     # Top left
    static [string] TR() { return "" }     # Top right
    static [string] BL() { return "" }     # Bottom left
    static [string] BR() { return "" }     # Bottom right
    static [string] H() { return "" }      # Horizontal
    static [string] V() { return "" }      # Vertical
    static [string] Cross() { return "" }  # Cross
    static [string] T() { return "" }      # T down
    static [string] B() { return "" }      # T up
    static [string] L() { return "" }      # T right
    static [string] R() { return "" }      # T left
    
    # Double lines for emphasis
    static [string] DTL() { return "" }
    static [string] DTR() { return "" }
    static [string] DBL() { return "" }
    static [string] DBR() { return "" }
    static [string] DH() { return "" }
    static [string] DV() { return "" }
}

# Layout measurement helpers
class Measure {
    static [int] TextWidth([string]$text) {
        # Remove ANSI sequences for accurate measurement
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        return $clean.Length
    }
    
    static [string] Truncate([string]$text, [int]$maxWidth) {
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        if ($clean.Length -le $maxWidth) { return $text }
        return $clean.Substring(0, $maxWidth - 3) + "..."
    }
    
    static [string] Pad([string]$text, [int]$width, [string]$align = "Left") {
        $textWidth = [Measure]::TextWidth($text)
        if ($textWidth -ge $width) { return [Measure]::Truncate($text, $width) }
        
        $padding = $width - $textWidth
        switch ($align) {
            "Left" { return $text + [StringCache]::GetSpaces($padding) }
            "Right" { return [StringCache]::GetSpaces($padding) + $text }
            "Center" { 
                $left = [int]($padding / 2)
                $right = $padding - $left
                return [StringCache]::GetSpaces($left) + $text + [StringCache]::GetSpaces($right)
            }
        }
        return $text
    }
}


####\Models/BaseAction.ps1
# BaseAction.ps1 - Base class for Visual Macro Factory actions
# Defines the contract for all macro actions with explicit data dependencies

class BaseAction {
    [string]$Name
    [string]$Description
    [string]$Category
    [string]$Icon = ""
    
    # Declares what variables this action NEEDS from the Macro Context
    # Format: @{ Name="fieldName"; Type="Field"; Description="Field to analyze" }
    [hashtable[]]$Consumes = @()
    
    # Declares what variables this action CREATES  
    # Format: @{ Name="outputDb"; Type="Database"; Description="Result database" }
    [hashtable[]]$Produces = @()
    
    # Whether this action can accept custom IDEA@ commands
    [bool]$AllowsCustomCommands = $false
    
    BaseAction() {
        # Override in derived classes
    }
    
    # Generates the final IDEAScript code using the provided context
    [string] RenderScript([hashtable]$macroContext) {
        throw "RenderScript must be implemented by derived class: $($this.GetType().Name)"
    }
    
    # Get display text for UI lists
    [string] GetDisplayText() {
        return "$($this.Icon) $($this.Name)"
    }
    
    # Get detailed description with requirements
    [string] GetDetailedDescription() {
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine($this.Description)
        
        if ($this.Consumes.Count -gt 0) {
            $sb.AppendLine("`nRequires:")
            foreach ($req in $this.Consumes) {
                $sb.AppendLine("   $($req.Name) ($($req.Type)): $($req.Description)")
            }
        }
        
        if ($this.Produces.Count -gt 0) {
            $sb.AppendLine("`nProduces:")
            foreach ($prod in $this.Produces) {
                $sb.AppendLine("   $($prod.Name) ($($prod.Type)): $($prod.Description)")
            }
        }
        
        return $sb.ToString()
    }
    
    # Validate that required context variables are available
    [bool] ValidateContext([hashtable]$macroContext) {
        foreach ($requirement in $this.Consumes) {
            if (-not $macroContext.ContainsKey($requirement.Name)) {
                return $false
            }
        }
        return $true
    }
    
    # Get list of missing context variables
    [string[]] GetMissingContext([hashtable]$macroContext) {
        $missing = @()
        foreach ($requirement in $this.Consumes) {
            if (-not $macroContext.ContainsKey($requirement.Name)) {
                $missing += $requirement.Name
            }
        }
        return $missing
    }
}


####\Models/Command.ps1
# Command.ps1 - Model for storing reusable command strings
# Used in Command Library for quick access and clipboard copying

class Command : BaseModel {
    [string]$Title = ""
    [string]$Description = ""
    [string[]]$Tags = @()
    [string]$Group = ""
    [string]$CommandText = ""  # REQUIRED - the actual command to copy
    [datetime]$Created = [datetime]::Now
    [datetime]$LastUsed = [datetime]::MinValue
    [int]$UseCount = 0
    
    Command() : base() {
        # Base constructor handles Id generation
    }
    
    Command([string]$commandText) : base() {
        $this.CommandText = $commandText
    }
    
    Command([string]$title, [string]$commandText) : base() {
        $this.Title = $title
        $this.CommandText = $commandText
    }
    
    # Validation - CommandText is required
    [bool] IsValid() {
        return -not [string]::IsNullOrWhiteSpace($this.CommandText)
    }
    
    # Update usage statistics when command is used
    [void] RecordUsage() {
        $this.LastUsed = [datetime]::Now
        $this.UseCount++
    }
    
    # Get display text for lists
    [string] GetDisplayText() {
        $displayText = ""
        
        # Add group prefix if present
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $displayText += "[$($this.Group)] "
        }
        
        # Add title or truncated command text
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $displayText += $this.Title
        } else {
            # Use first 50 chars of command text as fallback
            $commandPreview = $this.CommandText
            if ($commandPreview.Length -gt 50) {
                $commandPreview = $commandPreview.Substring(0, 47) + "..."
            }
            $displayText += $commandPreview
        }
        
        return $displayText
    }
    
    # Get searchable text for filtering
    [string] GetSearchableText() {
        $searchText = @()
        
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $searchText += $this.Title
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Description)) {
            $searchText += $this.Description
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $searchText += $this.Group
        }
        
        if ($this.Tags -and $this.Tags.Count -gt 0) {
            $searchText += ($this.Tags -join " ")
        }
        
        # Always include command text in search
        $searchText += $this.CommandText
        
        return ($searchText -join " ")
    }
    
    # Get detailed text for display in dialogs
    [string] GetDetailText() {
        $details = @()
        
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $details += "Title: $($this.Title)"
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Description)) {
            $details += "Description: $($this.Description)"
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $details += "Group: $($this.Group)"
        }
        
        if ($this.Tags -and $this.Tags.Count -gt 0) {
            $details += "Tags: $($this.Tags -join ', ')"
        }
        
        $details += "Command: $($this.CommandText)"
        
        if ($this.UseCount -gt 0) {
            $details += "Used: $($this.UseCount) times, last: $($this.LastUsed.ToString('yyyy-MM-dd HH:mm'))"
        }
        
        return ($details -join "`n")
    }
    
    # Convert to hashtable for JSON serialization
    [hashtable] ToHashtable() {
        return @{
            Id = $this.Id
            Title = $this.Title
            Description = $this.Description
            Tags = $this.Tags
            Group = $this.Group
            CommandText = $this.CommandText
            Created = $this.Created.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK")
            LastUsed = if ($this.LastUsed -eq [datetime]::MinValue) { $null } else { $this.LastUsed.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK") }
            UseCount = $this.UseCount
        }
    }
    
    # Create from hashtable (for JSON deserialization)
    static [Command] FromHashtable([hashtable]$data) {
        $command = [Command]::new()
        
        $command.Id = $data.Id
        $command.Title = $data.Title ?? ""
        $command.Description = $data.Description ?? ""
        $command.Tags = $data.Tags ?? @()
        $command.Group = $data.Group ?? ""  
        $command.CommandText = $data.CommandText ?? ""
        $command.UseCount = $data.UseCount ?? 0
        
        if ($data.Created) {
            $command.Created = [datetime]::Parse($data.Created)
        }
        
        if ($data.LastUsed) {
            $command.LastUsed = [datetime]::Parse($data.LastUsed)
        } else {
            $command.LastUsed = [datetime]::MinValue
        }
        
        return $command
    }
}


####\Models/Project.ps1
# Project Model - Enhanced project definition based on PMC pattern

class Project : BaseModel {
    [string]$FullProjectName
    [string]$Nickname
    [string]$ID1
    [string]$ID2
    [DateTime]$DateAssigned
    [DateTime]$BFDate
    [DateTime]$DateDue
    [string]$Note
    [string]$CAAPath
    [string]$RequestPath
    [string]$T2020Path
    [decimal]$CumulativeHrs
    [DateTime]$ClosedDate
    
    # Audit Information
    [string]$AuditType
    [string]$AuditProgram
    [string]$AuditCase
    [DateTime]$AuditStartDate
    [DateTime]$AuditPeriodFrom
    [DateTime]$AuditPeriodTo
    
    # Additional Audit Periods
    [DateTime]$AuditPeriod1Start
    [DateTime]$AuditPeriod1End
    [DateTime]$AuditPeriod2Start
    [DateTime]$AuditPeriod2End
    [DateTime]$AuditPeriod3Start
    [DateTime]$AuditPeriod3End
    [DateTime]$AuditPeriod4Start
    [DateTime]$AuditPeriod4End
    [DateTime]$AuditPeriod5Start
    [DateTime]$AuditPeriod5End
    
    # Client Information
    [string]$ClientID  # TPNum
    [string]$Address
    [string]$City
    [string]$Province
    [string]$PostalCode
    [string]$Country
    [string]$ShipToAddress
    
    # Auditor Information
    [string]$AuditorName
    [string]$AuditorPhone
    [string]$AuditorTL
    [string]$AuditorTLPhone
    
    # Contact Information
    [string]$Contact1Name
    [string]$Contact1Phone
    [string]$Contact1Ext
    [string]$Contact1Address
    [string]$Contact1Title
    [string]$Contact2Name
    [string]$Contact2Phone
    [string]$Contact2Ext
    [string]$Contact2Address
    [string]$Contact2Title
    
    # System Information
    [string]$AccountingSoftware1
    [string]$AccountingSoftware1Other
    [string]$AccountingSoftware1Type
    [string]$AccountingSoftware2
    [string]$AccountingSoftware2Other
    [string]$AccountingSoftware2Type
    
    # Other Information
    [DateTime]$RequestDate
    [string]$FXInfo
    [string]$Comments
    
    # Status tracking (not from Excel)
    [string]$Status = "Active"
    
    # Default constructor
    Project() : base() {
        $this.FullProjectName = ""
        $this.Nickname = ""
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Project([string]$fullName, [string]$nickname) : base() {
        $this.FullProjectName = $fullName
        $this.Nickname = $nickname
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Legacy constructor for backward compatibility
    Project([string]$name) : base() {
        $this.FullProjectName = $name
        $this.Nickname = $name
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
}


####\Models/Subtask.ps1
# Subtask.ps1 - Subtask model extending the Task system

class Subtask : BaseModel {
    [string]$ParentTaskId  # Links to parent Task.Id
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [int]$SortOrder = 0  # For ordering subtasks within parent
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    # Estimated and actual time tracking
    [int]$EstimatedMinutes = 0
    [int]$ActualMinutes = 0
    
    Subtask() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Subtask([string]$parentTaskId) : base() {
        $this.ParentTaskId = $parentTaskId
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[]" }
            ([TaskStatus]::Cancelled) { return "[]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "" }
            ([TaskPriority]::Medium) { return "" }
            ([TaskPriority]::High) { return "" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
    
    [string] GetDurationDisplay() {
        if ($this.EstimatedMinutes -eq 0) {
            return ""
        }
        
        $estimated = $this.FormatMinutes($this.EstimatedMinutes)
        if ($this.ActualMinutes -gt 0) {
            $actual = $this.FormatMinutes($this.ActualMinutes)
            return "$actual / $estimated"
        } else {
            return "~$estimated"
        }
    }
    
    [string] FormatMinutes([int]$minutes) {
        if ($minutes -lt 60) {
            return "$($minutes)m"
        } elseif ($minutes -lt 480) {  # Less than 8 hours
            $hours = [Math]::Floor($minutes / 60)
            $mins = $minutes % 60
            if ($mins -eq 0) {
                return "$($hours)h"
            } else {
                return "$($hours)h$($mins)m"
            }
        } else {
            $hours = [Math]::Round($minutes / 60.0, 1)
            return "$($hours)h"
        }
    }
    
    [bool] IsCompleted() {
        return $this.Status -eq [TaskStatus]::Completed
    }
    
    [bool] IsInProgress() {
        return $this.Status -eq [TaskStatus]::InProgress
    }
    
    [bool] IsPending() {
        return $this.Status -eq [TaskStatus]::Pending
    }
}


####\Models/Task.ps1
# Task.ps1 - Task model

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

class Task : BaseModel {
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [string]$ProjectId = ""
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    Task() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[]" }
            ([TaskStatus]::Cancelled) { return "[]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "" }
            ([TaskPriority]::Medium) { return "" }
            ([TaskPriority]::High) { return "" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
}


####\Models/TimeCode.ps1
# TimeCode Model - Non-project time codes (vacation, admin, etc.)

class TimeCode : BaseModel {
    [string]$ID2               # 3-5 character code (e.g., "VAC", "SICK", "ADMIN")
    [string]$Description       # Optional description for display
    [bool]$IsActive           # Whether this code is currently in use
    [int]$DisplayOrder        # For sorting common codes to top
    
    TimeCode() : base() {
        $this.IsActive = $true
        $this.DisplayOrder = 999  # Default to bottom
    }
    
    TimeCode([string]$id2) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = ""
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    TimeCode([string]$id2, [string]$description) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = $description
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    [string] GetDisplayName() {
        if ($this.Description) {
            return "$($this.ID2) - $($this.Description)"
        }
        return $this.ID2
    }
    
    # Static method to get common time codes
    static [TimeCode[]] GetCommonCodes() {
        return @(
            [TimeCode]::new("VAC", "Vacation"),
            [TimeCode]::new("SICK", "Sick Leave"),
            [TimeCode]::new("STAT", "Statutory Holiday"),
            [TimeCode]::new("ADMIN", "Administration"),
            [TimeCode]::new("TRAIN", "Training"),
            [TimeCode]::new("MTG", "Meetings"),
            [TimeCode]::new("PD", "Professional Development")
        )
    }
}


####\Models/TimeEntry.ps1
# TimeEntry Model - Universal time tracking for projects and non-project codes

class TimeEntry : BaseModel {
    [string]$WeekEndingFriday  # Friday date in yyyyMMdd format
    [string]$Name              # Project name or empty for non-project
    [string]$ID1               # Project ID1 or empty for non-project
    [string]$ID2               # Project ID2 or non-project code (3-5 chars)
    [decimal]$Monday
    [decimal]$Tuesday
    [decimal]$Wednesday
    [decimal]$Thursday
    [decimal]$Friday
    [decimal]$Total            # Calculated total for the week
    [string]$FiscalYear       # Format: "2024-2025" (Apr 1 2024 - Mar 31 2025)
    
    TimeEntry() : base() {
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    TimeEntry([string]$weekEndingFriday, [string]$id2) : base() {
        $this.WeekEndingFriday = $weekEndingFriday
        $this.ID2 = $id2
        $this.Name = ""
        $this.ID1 = ""
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    [void] CalculateTotal() {
        $this.Total = $this.Monday + $this.Tuesday + $this.Wednesday + $this.Thursday + $this.Friday
    }
    
    [void] CalculateFiscalYear() {
        if (-not $this.WeekEndingFriday) {
            $fridayDate = [DateTime]::Now
            while ($fridayDate.DayOfWeek -ne [DayOfWeek]::Friday) {
                $fridayDate = $fridayDate.AddDays(1)
            }
            $this.WeekEndingFriday = $fridayDate.ToString("yyyyMMdd")
        }
        
        $date = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        
        # Fiscal year runs April 1 - March 31
        if ($date.Month -ge 4) {
            # April through December - fiscal year starts this calendar year
            $fiscalStart = $date.Year
        } else {
            # January through March - fiscal year started last calendar year
            $fiscalStart = $date.Year - 1
        }
        
        $this.FiscalYear = "$fiscalStart-$($fiscalStart + 1)"
    }
    
    [bool] IsProjectEntry() {
        # Non-project entries have 3-5 character ID2 codes
        return $this.ID2.Length -gt 5
    }
    
    [DateTime] GetWeekStartMonday() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return $fridayDate.AddDays(-4)  # Monday is 4 days before Friday
    }
    
    [string] GetWeekDisplayString() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return "Week ending " + $fridayDate.ToString("MM/dd/yyyy")
    }
}


####\Screens/CommandEditDialog.ps1
# CommandEditDialog.ps1 - Dialog for creating and editing commands
# Handles all CRUD operations for command library entries

class CommandEditDialog : Screen {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [TextBox]$TagsBox
    [TextBox]$GroupBox
    [TextBox]$CommandBox
    [Button]$SaveButton
    [Button]$CancelButton
    [Command]$Command
    [CommandService]$CommandService
    [scriptblock]$OnSave
    
    CommandEditDialog() : base() {
        $this.Title = "Command Editor"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        
        # Create title field
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Placeholder = "Optional: Display name for the command"
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description field
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Optional: What this command does"
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create tags field
        $this.TagsBox = [TextBox]::new()
        $this.TagsBox.Placeholder = "Optional: Comma-separated tags (git, powershell, etc.)"
        $this.TagsBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TagsBox)
        
        # Create group field
        $this.GroupBox = [TextBox]::new()
        $this.GroupBox.Placeholder = "Optional: Category/group name"
        $this.GroupBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.GroupBox)
        
        # Create command field
        $this.CommandBox = [TextBox]::new()
        $this.CommandBox.Placeholder = "REQUIRED: The command text to copy to clipboard"
        $this.CommandBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        $dialog = $this
        $this.SaveButton.OnClick = { $dialog.SaveCommand() }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = { $dialog.Cancel() }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.TitleBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        if ($this.Width -le 0 -or $this.Height -le 0) { return }
        
        # Position components vertically with some spacing
        $margin = 2
        $fieldHeight = 3
        $spacing = 1
        $currentY = $margin
        
        # Title field
        if ($this.TitleBox) {
            $this.TitleBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Description field
        if ($this.DescriptionBox) {
            $this.DescriptionBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Tags field
        if ($this.TagsBox) {
            $this.TagsBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Group field
        if ($this.GroupBox) {
            $this.GroupBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing
        }
        
        # Command field
        if ($this.CommandBox) {
            $this.CommandBox.SetBounds($margin, $currentY, $this.Width - $margin * 2, $fieldHeight)
            $currentY += $fieldHeight + $spacing * 2
        }
        
        # Buttons at bottom
        $buttonWidth = 10
        $buttonHeight = 3
        $buttonY = $this.Height - $buttonHeight - 1
        
        if ($this.SaveButton) {
            $this.SaveButton.SetBounds($this.Width - $buttonWidth * 2 - 3, $buttonY, $buttonWidth, $buttonHeight)
        }
        
        if ($this.CancelButton) {
            $this.CancelButton.SetBounds($this.Width - $buttonWidth - 1, $buttonY, $buttonWidth, $buttonHeight)
        }
    }
    
    [void] SetCommand([Command]$command) {
        $this.Command = $command
        
        if ($command) {
            # Editing existing command
            $this.Title = "Edit Command"
            $this.TitleBox.SetText($command.Title)
            $this.DescriptionBox.SetText($command.Description)
            $this.TagsBox.SetText(($command.Tags -join ", "))
            $this.GroupBox.SetText($command.Group)
            $this.CommandBox.SetText($command.CommandText)
        } else {
            # Creating new command
            $this.Title = "Add Command"
            $this.TitleBox.SetText("")
            $this.DescriptionBox.SetText("")
            $this.TagsBox.SetText("")
            $this.GroupBox.SetText("")
            $this.CommandBox.SetText("")
        }
    }
    
    [void] SaveCommand() {
        try {
            # Check if required components are initialized
            if (-not $this.CommandBox) {
                if ($global:Logger) {
                    $global:Logger.Error("CommandBox is null")
                }
                return
            }
            
            if (-not $this.CommandService) {
                if ($global:Logger) {
                    $global:Logger.Error("CommandService is null")
                }
                return
            }
            
            # Validate required field
            $commandText = $this.CommandBox.Text.Trim()
            if ([string]::IsNullOrWhiteSpace($commandText)) {
                # Show error or just return - command text is required
                if ($global:Logger) {
                    $global:Logger.Warning("Command text is required")
                }
                return
            }
            
            # Parse tags
            $tagsText = $this.TagsBox.Text.Trim()
            $tags = @()
            if (-not [string]::IsNullOrWhiteSpace($tagsText)) {
                $tags = $tagsText -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
            }
            
            if ($this.Command) {
                # Update existing command
                $this.Command.Title = $this.TitleBox.Text.Trim()
                $this.Command.Description = $this.DescriptionBox.Text.Trim()
                $this.Command.Tags = $tags
                $this.Command.Group = $this.GroupBox.Text.Trim()
                $this.Command.CommandText = $commandText
                
                $success = $this.CommandService.UpdateCommand($this.Command)
                if (-not $success) {
                    if ($global:Logger) {
                        $global:Logger.Error("Failed to update command")
                    }
                    return
                }
            } else {
                # Create new command
                $this.Command = $this.CommandService.AddCommand(
                    $this.TitleBox.Text.Trim(),
                    $this.DescriptionBox.Text.Trim(),
                    $tags,
                    $this.GroupBox.Text.Trim(),
                    $commandText
                )
            }
            
            # Call save callback
            if ($this.OnSave) {
                & $this.OnSave $this.Command
            }
            
            # Close dialog
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandEditDialog.SaveCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] Cancel() {
        # Close dialog by popping from screen stack
        if ($global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Handle Ctrl+S to save
        if ($key.Key -eq [System.ConsoleKey]::S -and $key.Modifiers -band [System.ConsoleModifiers]::Control) {
            $this.SaveCommand()
            return $true
        }
        
        # Handle Escape to cancel
        if ($key.Key -eq [System.ConsoleKey]::Escape) {
            $this.Cancel()
            return $true
        }
        
        return $false
    }
    
    # Labels will be shown via placeholder text for now
    
    [string] GetHelpText() {
        return @"
Command Editor Help:

Ctrl+S    - Save command
Escape    - Cancel and close
Tab       - Navigate between fields

Fields:
- Title: Optional display name
- Description: Optional description  
- Tags: Optional comma-separated tags
- Group: Optional category/group
- Command: REQUIRED - text to copy to clipboard

Only the Command field is required. All others are optional.
"@
    }
}


####\Screens/CommandLibraryScreen.ps1
# CommandLibraryScreen.ps1 - Command library management screen
# Browse, search, and manage reusable command strings with clipboard copy

class CommandLibraryScreen : Screen {
    [SearchableListBox]$CommandList
    [CommandService]$CommandService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    CommandLibraryScreen() : base() {
        $this.Title = "Command Library"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Create command list using SearchableListBox
        $this.CommandList = [SearchableListBox]::new()
        $this.CommandList.Title = "Commands"
        $this.CommandList.ShowBorder = $true
        $this.CommandList.SearchPrompt = "Search commands... (t:tag d:desc g:group +and |or)"
        
        # Set custom search filter for advanced syntax
        $this.CommandList.SearchFilter = {
            param($command, $query)
            return $this.CommandService.SearchCommands($query) -contains $command
        }.GetNewClosure()
        
        # Custom renderer for commands
        $this.CommandList.ItemRenderer = {
            param($command)
            if (-not $command) { return "" }
            
            $displayText = $command.GetDisplayText()
            
            # Add usage count if > 0
            if ($command.UseCount -gt 0) {
                $displayText += " $($command.UseCount)"
            }
            
            return $displayText
        }
        
        # Handle selection changes
        $this.CommandList.OnSelectionChanged = {
            # Could update UI state here if needed
        }
        
        $this.CommandList.Initialize($this.ServiceContainer)
        $this.AddChild($this.CommandList)
        
        # Load commands
        $this.LoadCommands()
        
        # Register shortcuts
        $this.RegisterShortcuts()
        
        # Set initial focus to command list
        if ($this.CommandList) {
            $this.CommandList.Focus()
        }
    }
    
    [void] LoadCommands() {
        $commands = $this.CommandService.GetAllCommands()
        $this.CommandList.SetItems($commands)
    }
    
    [void] FilterCommands() {
        # Apply any active search filter
        # SearchableListBox handles its own filtering, so this is just for refresh
        $this.CommandList.Invalidate()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.new"
            Name = "New Command"
            Description = "Create a new command"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.NewCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.edit"
            Name = "Edit Command"
            Description = "Edit the selected command"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.EditCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.delete"
            Name = "Delete Command"
            Description = "Delete the selected command"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.DeleteCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.copy"
            Name = "Copy Command"
            Description = "Copy selected command to clipboard"
            Key = [System.ConsoleKey]::Enter
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.CopySelectedCommand() }.GetNewClosure()
        })
    }
    
    [void] NewCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.NewCommand: Called via shortcut")
        }
        try {
            $screen = [CommandEditDialog]::new()
            $screen.Initialize($this.ServiceContainer)
            
            $screen.SetCommand($null)  # New command
            $screen.OnSave = {
                param($command)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($screen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.NewCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] EditCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.EditCommand: Called via shortcut")
        }
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if (-not $selectedCommand) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen.EditCommand: No command selected")
            }
            return 
        }
        
        try {
            $screen = [CommandEditDialog]::new()
            $screen.Initialize($this.ServiceContainer)
            
            $screen.SetCommand($selectedCommand)
            $screen.OnSave = {
                param($command)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($screen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.EditCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] DeleteCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.DeleteCommand: Called via shortcut")
        }
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if (-not $selectedCommand) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen.DeleteCommand: No command selected")
            }
            return 
        }
        
        try {
            # Show confirmation dialog
            $confirmScreen = [ConfirmationDialog]::new()
            $confirmScreen.Initialize($this.ServiceContainer)
            $confirmScreen.SetTitle("Delete Command")
            $confirmScreen.SetMessage("Are you sure you want to delete this command?`n`n$($selectedCommand.GetDisplayText())")
            $confirmScreen.OnConfirm = {
                $this.CommandService.DeleteCommand($selectedCommand.Id)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($confirmScreen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.DeleteCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] CopySelectedCommand() {
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if ($selectedCommand) {
            try {
                $this.CommandService.CopyToClipboard($selectedCommand.Id)
                
                # Show brief confirmation (could be a toast notification)
                if ($global:Logger) {
                    $global:Logger.Info("Copied to clipboard: $($selectedCommand.GetDisplayText())")
                }
                
                # Refresh the list to show updated usage count
                $this.LoadCommands()
                $this.FilterCommands()
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("Failed to copy command: $($_.Exception.Message)")
                }
            }
        }
    }
    
    # Search help removed - SearchableListBox should handle this
    
    # HandleInput removed - using ShortcutManager instead
    
    [void] OnBoundsChanged() {
        if ($this.Width -le 0 -or $this.Height -le 0) { return }
        
        # CommandLibraryScreen has a single CommandList that takes the full area
        if ($this.CommandList) {
            $this.CommandList.SetBounds(0, 0, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Set focus when screen becomes active
        if ($this.CommandList) {
            $this.CommandList.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Route to ShortcutManager for screen-specific shortcuts
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if ($shortcutManager) {
            return $shortcutManager.HandleKeyPress($keyInfo, $this.GetType().Name, "")
        }
        return $false
    }
    
    [string] GetHelpText() {
        return @"
Command Library Help:

Enter         - Copy selected command to clipboard
n             - Add new command
e             - Edit selected command  
d             - Delete selected command
Escape        - Return to main menu
Tab           - Navigate between elements

Search supports advanced syntax:
  t:tag d:desc g:group +and |or
"@
    }
}


####\Screens/ConfirmationDialog.ps1
# ConfirmationDialog.ps1 - Generic confirmation dialog using BaseDialog

class ConfirmationDialog : BaseDialog {
    [string]$Message
    [string]$ConfirmText = "Yes"
    [string]$CancelText = "No"
    
    ConfirmationDialog() : base("Confirm") {
        $this.Message = "Are you sure?"
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    ConfirmationDialog([string]$message) : base("Confirm") {
        $this.Message = $message
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    [void] InitializeContent() {
        # Base dialog handles button creation, we just need to update button texts if needed
        if ($this.PrimaryButton -and $this.ConfirmText -ne "Yes") {
            $this.PrimaryButton.Text = $this.ConfirmText
        }
        
        if ($this.SecondaryButton -and $this.CancelText -ne "No") {
            $this.SecondaryButton.Text = $this.CancelText
        }
        
        # No additional content controls needed for simple confirmation
        # The message is rendered directly in the dialog
    }
    
    [void] OnActivated() {
        ([BaseDialog]$this).OnActivated()
        # Override to focus on cancel button by default (safer)
        if ($this.SecondaryButton) {
            $this.SecondaryButton.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on message
        $messageLines = $this.Message -split "`n"
        $maxLineLength = ($messageLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $this.DialogWidth = [Math]::Max(40, $maxLineLength + 8)
        $this.DialogHeight = 10 + $messageLines.Count
        
        # Let base class handle the rest
        ([BaseDialog]$this).OnBoundsChanged()
    }
    
    # Override HandleScreenInput to add Y/N shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Y/N shortcuts specific to confirmation dialog
        switch ($key.Key) {
            ([System.ConsoleKey]::Y) {
                if ($key.KeyChar -eq 'Y' -or $key.KeyChar -eq 'y') {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::N) {
                if ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n') {
                    $this.HandleSecondaryAction()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render the base dialog (overlay, box, title, buttons)
        $baseRender = ([BaseDialog]$this).OnRender()
        $sb.Append($baseRender)
        
        # Add our custom content - the message and hint
        if ($this._dialogBounds -and $this._dialogBounds.Count -gt 0) {
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Draw warning icon in title
            $title = "  Confirm "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($this.Theme.GetColor("warning"))
            $sb.Append($title)
            
            # Draw message
            $messageLines = $this.Message -split "`n"
            $messageY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $messageLines) {
                $lineX = $x + [int](($w - $line.Length) / 2)
                $sb.Append([VT]::MoveTo($lineX, $messageY))
                $sb.Append($line)
                $messageY++
            }
            
            # Draw hint
            $hint = "[Y/N] or use Tab to select"
            $hintX = $x + [int](($w - $hint.Length) / 2)
            $sb.Append([VT]::MoveTo($hintX, $y + $h - 2))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append($hint)
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/DashboardScreen.ps1
# DashboardScreen.ps1 - Ultra-complex dashboard to stress-test layout system
# Layout: Main HorizontalSplit -> Left: Project overview, Right: VerticalSplit -> Top: Task metrics, Bottom: GridPanel with action buttons

class DashboardScreen : Screen {
    # Main layout structure
    [HorizontalSplit]$MainLayout
    [VerticalSplit]$RightLayout
    [GridPanel]$ActionGrid
    [HorizontalSplit]$TopRightLayout
    [VerticalSplit]$MetricsLayout
    
    # Left pane components (Project Overview)
    [ListBox]$ProjectList
    [ListBox]$RecentActivity
    [VerticalSplit]$LeftLayout
    
    # Top-right pane components (Task Metrics & Charts)
    [ListBox]$TaskList
    [ListBox]$PriorityBreakdown
    [ListBox]$StatusChart
    [GridPanel]$MetricBoxes
    
    # Bottom-right pane (Action buttons)
    [Button]$NewProjectBtn
    [Button]$NewTaskBtn
    [Button]$ExportBtn
    [Button]$SettingsBtn
    [Button]$RefreshBtn
    [Button]$HelpBtn
    [Button]$ReportsBtn
    [Button]$ArchiveBtn
    
    # Services
    [ProjectService]$ProjectService
    [TaskService]$TaskService
    [EventBus]$EventBus
    
    # Data for complex displays
    hidden [array]$_projectStats
    hidden [array]$_taskMetrics
    hidden [array]$_recentActivities
    hidden [bool]$_isLoading = $false
    hidden [hashtable]$_loadingProgress = @{
        Projects = 0
        Tasks = 0
        Activity = 0
        Metrics = 0
    }
    
    DashboardScreen() : base() {
        $this.Title = "PRAXIS Dashboard"
    }
    
    [void] OnInitialize() {
        Write-Host "Initializing ultra-complex dashboard..."
        
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to data loading events for background updates
        $this.SetupEventHandlers()
        
        # Create the incredibly complex nested layout structure
        $this.BuildMasterLayout()
        $this.BuildLeftPane()
        $this.BuildRightPane()
        
        # Show initial loading state
        $this.ShowLoadingState()
        
        # Start background data loading (non-blocking)
        $this.StartBackgroundDataLoad()
        
        Write-Host "Dashboard initialized with maximum complexity!"
    }
    
    [void] BuildMasterLayout() {
        Write-Host "Building master layout structure..."
        
        # Main horizontal split: 40% left (projects), 60% right (tasks & actions)
        $this.MainLayout = [HorizontalSplit]::new()
        $this.MainLayout.SetSplitRatio(40)
        $this.MainLayout.ShowBorder = $false
        $this.MainLayout.Initialize($global:ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Left side: Vertical split for project list + recent activity
        $this.LeftLayout = [VerticalSplit]::new()
        $this.LeftLayout.SetSplitRatio(65)  # 65% project list, 35% recent activity
        $this.LeftLayout.ShowBorder = $false
        $this.LeftLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetLeftPane($this.LeftLayout)
        
        # Right side: Vertical split for task metrics + action buttons
        $this.RightLayout = [VerticalSplit]::new()
        $this.RightLayout.SetSplitRatio(75)  # 75% metrics, 25% buttons
        $this.RightLayout.ShowBorder = $false
        $this.RightLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetRightPane($this.RightLayout)
    }
    
    [void] BuildLeftPane() {
        Write-Host "Building left pane with project overview..."
        
        # Top-left: Project List with statistics
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = " Project Overview"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { " OVERDUE" } elseif ($daysLeft -lt 7) { "  DUE SOON" } elseif ($daysLeft -lt 30) { " $daysLeft days" } else { " $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        $this.ProjectList.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetTopPane($this.ProjectList)
        
        # Bottom-left: Recent Activity Feed
        $this.RecentActivity = [ListBox]::new()
        $this.RecentActivity.Title = " Recent Activity"
        $this.RecentActivity.ShowBorder = $true
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "" }
                "TaskCompleted" { "" }
                "TaskCreated" { "" }
                "ProjectUpdated" { "" }
                default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
        $this.RecentActivity.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetBottomPane($this.RecentActivity)
    }
    
    [void] BuildRightPane() {
        Write-Host "Building right pane with metrics and controls..."
        
        # Top-right: Another horizontal split for task metrics
        $this.TopRightLayout = [HorizontalSplit]::new()
        $this.TopRightLayout.SetSplitRatio(50)  # Equal split for metrics
        $this.TopRightLayout.ShowBorder = $false
        $this.TopRightLayout.Initialize($global:ServiceContainer)
        
        # Nested vertical split in the left side of top-right
        $this.MetricsLayout = [VerticalSplit]::new()
        $this.MetricsLayout.SetSplitRatio(50)
        $this.MetricsLayout.ShowBorder = $false
        $this.MetricsLayout.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetLeftPane($this.MetricsLayout)
        
        # Task List (top of metrics)
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = " Active Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }
                "Medium" { "" }
                "Low" { "" }
                default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }
                "Done" { "" }
                "Blocked" { "" }
                default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetTopPane($this.TaskList)
        
        # Priority Breakdown (bottom of metrics)
        $this.PriorityBreakdown = [ListBox]::new()
        $this.PriorityBreakdown.Title = " Priority Distribution"
        $this.PriorityBreakdown.ShowBorder = $true
        $this.PriorityBreakdown.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetBottomPane($this.PriorityBreakdown)
        
        # Status Chart (right side of top-right)
        $this.StatusChart = [ListBox]::new()
        $this.StatusChart.Title = " Status Overview"
        $this.StatusChart.ShowBorder = $true
        $this.StatusChart.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetRightPane($this.StatusChart)
        
        # Set the complex top layout
        $this.RightLayout.SetTopPane($this.TopRightLayout)
        
        # Bottom-right: Action button grid (4x2 = 8 buttons)
        $this.ActionGrid = [GridPanel]::new(4)  # 4 columns
        $this.ActionGrid.ShowBorder = $true
        $this.ActionGrid.CellSpacing = 1
        $this.ActionGrid.Initialize($global:ServiceContainer)
        
        # Create all the action buttons with cool icons and actions
        $this.CreateActionButtons()
        
        $this.RightLayout.SetBottomPane($this.ActionGrid)
    }
    
    [void] CreateActionButtons() {
        Write-Host "Creating interactive action buttons..."
        
        # Capture $this reference for use in button handlers
        $dashboardRef = $this
        
        # Button 1: New Project
        $this.NewProjectBtn = [Button]::new(" New Project")
        $this.NewProjectBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Project button clicked")
            }
            # Create new project dialog
            $dialog = [NewProjectDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewProjectBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewProjectBtn)
        
        # Button 2: New Task
        $this.NewTaskBtn = [Button]::new(" New Task")
        $this.NewTaskBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Task button clicked")
            }
            # Create new task dialog
            $dialog = [NewTaskDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewTaskBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewTaskBtn)
        
        # Button 3: Export Data
        $this.ExportBtn = [Button]::new(" Export")
        $this.ExportBtn.OnClick = { 
            Write-Host "Dashboard: Exporting data..."
            # TODO: Implement export functionality
        }.GetNewClosure()
        $this.ExportBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ExportBtn)
        
        # Button 4: Settings
        $this.SettingsBtn = [Button]::new("  Settings")
        $this.SettingsBtn.OnClick = { 
            Write-Host "Dashboard: Opening settings..."
            # TODO: Switch to settings screen
        }.GetNewClosure()
        $this.SettingsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.SettingsBtn)
        
        # Button 5: Refresh Data
        $this.RefreshBtn = [Button]::new(" Refresh")
        $this.RefreshBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Refresh button clicked - reloading all data")
            }
            $dashboardRef.ShowLoadingState()
            $dashboardRef.StartBackgroundDataLoad()
        }.GetNewClosure()
        $this.RefreshBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.RefreshBtn)
        
        # Button 6: Help
        $this.HelpBtn = [Button]::new(" Help")
        $helpBtnRef = $this.HelpBtn
        $this.HelpBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Help button clicked")
            }
            # Change button text to show it was clicked
            $helpBtnRef.Text = " Clicked!"
            $helpBtnRef.Invalidate()
            # TODO: Show help dialog
        }.GetNewClosure()
        $this.HelpBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.HelpBtn)
        
        # Button 7: Reports
        $this.ReportsBtn = [Button]::new(" Reports")
        $this.ReportsBtn.OnClick = { 
            Write-Host "Dashboard: Generating reports..."
            # TODO: Generate analytics reports
        }.GetNewClosure()
        $this.ReportsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ReportsBtn)
        
        # Button 8: Archive
        $this.ArchiveBtn = [Button]::new(" Archive")
        $this.ArchiveBtn.OnClick = { 
            Write-Host "Dashboard: Managing archives..."
            # TODO: Archive management
        }.GetNewClosure()
        $this.ArchiveBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ArchiveBtn)
    }
    
    [void] LoadAllData() {
        Write-Host "Loading complex dashboard data..."
        
        # Load project data with statistics
        $projects = @()
        if ($this.ProjectService) {
            $allProjects = $this.ProjectService.GetAllProjects()
            $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
        }
        
        # Add some demo projects if empty
        if ($projects.Count -eq 0) {
            $projects = @(
                @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
            )
        }
        
        $this.ProjectList.SetItems($projects)
        
        # Load task data with complex metrics
        $tasks = @()
        if ($this.TaskService) {
            $allTasks = $this.TaskService.GetAllTasks()
            $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
        }
        
        # Add demo tasks if empty
        if ($tasks.Count -eq 0) {
            $tasks = @(
                @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
            )
        }
        
        $this.TaskList.SetItems($tasks)
        
        # Generate priority breakdown with visual charts
        $priorityStats = @(
            " High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
            " Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
            " Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
            ""
            "Progress Overview:"
            " 60% Complete"
            "Active: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count) tasks"
            "Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count) tasks"
        )
        $this.PriorityBreakdown.SetItems($priorityStats)
        
        # Create status chart with ASCII visualization
        $completedTasks = if ($this.TaskService) { 
            @($this.TaskService.GetAllTasks() | Where-Object { $_.Status -eq "Done" }).Count
        } else { 8 }
        
        $totalTasks = $completedTasks + $tasks.Count
        $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
        
        $statusData = @(
            " Project Health Dashboard"
            ""
            "Completion Rate: $completionRate%"
            "[$('' * [int]($completionRate/10))$('' * (10 - [int]($completionRate/10)))]"
            ""
            " Completed: $completedTasks"
            " In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
            " Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
            " Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            ""
            " Productivity Score: $(Get-Random -Minimum 75 -Maximum 98)%"
        )
        $this.StatusChart.SetItems($statusData)
        
        # Create realistic recent activity feed
        $this.LoadRecentActivity()
        
        Write-Host "Dashboard data loaded successfully!"
    }
    
    [void] LoadRecentActivity() {
        $activities = @(
            @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
            @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
            @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
            @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
            @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            @{ Type = "TaskCreated"; Message = "Created performance task"; Time = "1 day ago" }
            @{ Type = "ProjectCreated"; Message = "Initialized Testing Framework"; Time = "2 days ago" }
        )
        
        $this.RecentActivity.SetItems($activities)
    }
    
    [void] SetupEventHandlers() {
        # Subscribe to background data loading completion events
        $dashboardRef = $this
        
        $this.EventBus.Subscribe('dashboard.data.projects.loaded', {
            param($sender, $data)
            if ($data.Projects) {
                $dashboardRef.ProjectList.SetItems($data.Projects)
                $dashboardRef._loadingProgress.Projects = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.tasks.loaded', {
            param($sender, $data)
            if ($data.Tasks) {
                $dashboardRef.TaskList.SetItems($data.Tasks)
                $dashboardRef._loadingProgress.Tasks = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.activity.loaded', {
            param($sender, $data)
            if ($data.Activities) {
                $dashboardRef.RecentActivity.SetItems($data.Activities)
                $dashboardRef._loadingProgress.Activity = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.metrics.loaded', {
            param($sender, $data)
            if ($data.PriorityStats) {
                $dashboardRef.PriorityBreakdown.SetItems($data.PriorityStats)
            }
            if ($data.StatusData) {
                $dashboardRef.StatusChart.SetItems($data.StatusData)
            }
            $dashboardRef._loadingProgress.Metrics = 100
            $dashboardRef.UpdateLoadingStatus()
        }.GetNewClosure())
    }
    
    [void] ShowLoadingState() {
        # Display loading indicators in each component
        $loadingProjects = @(
            " Loading project data...",
            "   Please wait..."
        )
        $this.ProjectList.SetItems($loadingProjects)
        
        $loadingTasks = @(
            " Loading task list...",
            "   Fetching from database..."
        )
        $this.TaskList.SetItems($loadingTasks)
        
        $loadingActivity = @(
            " Loading recent activity...",
            "   Analyzing events..."
        )
        $this.RecentActivity.SetItems($loadingActivity)
        
        $loadingMetrics = @(
            " Calculating metrics...",
            "   Processing data..."
        )
        $this.PriorityBreakdown.SetItems($loadingMetrics)
        $this.StatusChart.SetItems($loadingMetrics)
    }
    
    [void] StartBackgroundDataLoad() {
        if ($this._isLoading) {
            Write-Host "Data loading already in progress"
            return
        }
        
        $this._isLoading = $true
        $this._loadingProgress = @{
            Projects = 0
            Tasks = 0
            Activity = 0
            Metrics = 0
        }
        
        # Use PowerShell jobs for true background loading
        $projService = $this.ProjectService
        $taskSvc = $this.TaskService
        $evtBus = $this.EventBus
        
        # Load projects in background
        $projectJob = Start-Job -ScriptBlock {
            param($service, $evtBus)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 800
            
            $projects = @()
            if ($service) {
                $allProjects = $service.GetAllProjects()
                $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
            }
            
            if ($projects.Count -eq 0) {
                $projects = @(
                    @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                    @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                    @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                    @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
                )
            }
            
            # Process projects
            foreach ($project in $projects) {
                $project.ClosedDate = if ($project.ClosedDate) { $project.ClosedDate } else { [DateTime]::MinValue }
                $project.DateDue = if ($project.DateDue) { $project.DateDue } else { [DateTime]::Now.AddDays(30) }
            }
            
            return $projects
        } -ArgumentList $projService, $evtBus
        
        # Load tasks in background
        $taskJob = Start-Job -ScriptBlock {
            param($service)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 1200
            
            $tasks = @()
            if ($service) {
                $allTasks = $service.GetAllTasks()
                $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
            }
            
            if ($tasks.Count -eq 0) {
                $tasks = @(
                    @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                    @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                    @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                    @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
                )
            }
            
            return $tasks
        } -ArgumentList $taskSvc
        
        # Monitor jobs and publish events when complete
        $monitorJob = Start-Job -ScriptBlock {
            param($projectJob, $taskJob, $evtBus)
            
            # Wait for project job
            $projects = Receive-Job -Job $projectJob -Wait
            $evtBus.Publish('dashboard.data.projects.loaded', @{ Projects = $projects })
            
            # Wait for task job
            $tasks = Receive-Job -Job $taskJob -Wait
            $evtBus.Publish('dashboard.data.tasks.loaded', @{ Tasks = $tasks })
            
            # Generate metrics based on loaded data
            Start-Sleep -Milliseconds 500
            
            $priorityStats = @(
                " High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
                " Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
                " Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
                ""
                "Progress Overview:"
                " 60% Complete"
            )
            
            $completedTasks = @($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $totalTasks = $tasks.Count + $completedTasks
            $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
            
            $statusData = @(
                " Project Health Dashboard"
                ""
                "Completion Rate: $completionRate%"
                "[$('' * [int]($completionRate/10))$('' * (10 - [int]($completionRate/10)))]"
                ""
                " Completed: $completedTasks"
                " In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
                " Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
                " Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            )
            
            $evtBus.Publish('dashboard.data.metrics.loaded', @{ 
                PriorityStats = $priorityStats
                StatusData = $statusData 
            })
            
            # Load activity data
            Start-Sleep -Milliseconds 300
            $activities = @(
                @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
                @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
                @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
                @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
                @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            )
            
            $evtBus.Publish('dashboard.data.activity.loaded', @{ Activities = $activities })
            
            # Clean up jobs
            Remove-Job -Job $projectJob -Force
            Remove-Job -Job $taskJob -Force
            
        } -ArgumentList $projectJob, $taskJob, $evtBus
        
        # Set up item renderers that will be used when data loads
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { " OVERDUE" } elseif ($daysLeft -lt 7) { "  DUE SOON" } elseif ($daysLeft -lt 30) { " $daysLeft days" } else { " $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }
                "Medium" { "" }
                "Low" { "" }
                default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }
                "Done" { "" }
                "Blocked" { "" }
                default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "" }
                "TaskCompleted" { "" }
                "TaskCreated" { "" }
                "ProjectUpdated" { "" }
                default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
    }
    
    [void] UpdateLoadingStatus() {
        # Check if all data has loaded
        $totalProgress = ($this._loadingProgress.Projects + $this._loadingProgress.Tasks + 
                         $this._loadingProgress.Activity + $this._loadingProgress.Metrics) / 4
        
        if ($totalProgress -eq 100) {
            $this._isLoading = $false
            Write-Host "Dashboard data fully loaded!"
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Set initial focus to ProjectList
        if ($this.ProjectList) {
            $this.ProjectList.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Update the main layout to fill the entire screen
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Handle dashboard-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::F5) {
                $this.ShowLoadingState()
                $this.StartBackgroundDataLoad()
                Write-Host "Dashboard refresh started!"
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.ShowLoadingState()
                    $this.StartBackgroundDataLoad()
                    Write-Host "Dashboard data reload started!"
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        return $false
    }
    
}


####\Screens/EditProjectDialog.ps1
# EditProjectDialog.ps1 - Dialog for editing existing projects

class EditProjectDialog : BaseDialog {
    [Project]$Project
    [MinimalTextBox]$NameBox
    [MinimalTextBox]$NicknameBox
    [MinimalTextBox]$ID1Box
    [MinimalTextBox]$ID2Box
    [MinimalTextBox]$NoteBox
    [MinimalTextBox]$CAAPathBox
    [MinimalTextBox]$RequestPathBox
    [MinimalTextBox]$T2020PathBox
    [MinimalTextBox]$DueDateBox
    
    EditProjectDialog([Project]$project) : base("Edit Project") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 30
    }
    
    [void] InitializeContent() {
        # Create all project input fields with current values
        $this.NameBox = [MinimalTextBox]::new()
        $this.NameBox.Text = $this.Project.FullProjectName
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [MinimalTextBox]::new()
        $this.NicknameBox.Text = $this.Project.Nickname
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [MinimalTextBox]::new()
        $this.ID1Box.Text = $this.Project.ID1
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [MinimalTextBox]::new()
        $this.ID2Box.Text = $this.Project.ID2
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NoteBox = [MinimalTextBox]::new()
        $this.NoteBox.Text = $this.Project.Note
        $this.NoteBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NoteBox, 5)
        
        $this.CAAPathBox = [MinimalTextBox]::new()
        $this.CAAPathBox.Text = $this.Project.CAAPath
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [MinimalTextBox]::new()
        $this.RequestPathBox.Text = $this.Project.RequestPath
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [MinimalTextBox]::new()
        $this.T2020PathBox.Text = $this.Project.T2020Path
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [MinimalTextBox]::new()
        $this.DueDateBox.Text = $this.Project.DateDue.ToString("MM/dd/yyyy")
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action (Save)
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = $dialog.Project.DateDue
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Keep original date if parsing fails
                    }
                }
                
                # Update project properties
                $dialog.Project.FullProjectName = $dialog.NameBox.Text
                $dialog.Project.Nickname = $dialog.NicknameBox.Text
                $dialog.Project.ID1 = $dialog.ID1Box.Text
                $dialog.Project.ID2 = $dialog.ID2Box.Text
                $dialog.Project.Note = $dialog.NoteBox.Text
                $dialog.Project.CAAPath = $dialog.CAAPathBox.Text
                $dialog.Project.RequestPath = $dialog.RequestPathBox.Text
                $dialog.Project.T2020Path = $dialog.T2020PathBox.Text
                $dialog.Project.DateDue = $dueDate
                $dialog.Project.UpdatedAt = [DateTime]::Now
                
                # Save via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    $projectService.SaveProject($dialog.Project)
                }
                
                # Publish event if EventBus available
                if ($dialog.EventBus) {
                    $dialog.EventBus.Publish([EventNames]::ProjectUpdated, @{ 
                        Project = $dialog.Project 
                    })
                    
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'EditProjectDialog'
                        Action = 'Save'
                        Data = $dialog.Project
                    })
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action (Cancel)
        $this.OnSecondary = {
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'EditProjectDialog'
                    Action = 'Cancel'
                })
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields (same as NewProjectDialog)
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 3)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 3)
        $currentY += 3
        
        $this.NoteBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
    }
}


####\Screens/EditTaskDialog.ps1
# EditTaskDialog.ps1 - Dialog for editing existing tasks

class EditTaskDialog : BaseDialog {
    [Task]$Task
    [MinimalTextBox]$TitleBox
    [MinimalTextBox]$DescriptionBox
    [MinimalListBox]$StatusList
    [MinimalListBox]$PriorityList
    [MinimalTextBox]$ProgressBox
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    EditTaskDialog([Task]$task) : base("Edit Task") {
        $this.Task = $task
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 60
        $this.DialogHeight = 20
    }
    
    [void] InitializeContent() {
        # Create title textbox
        $this.TitleBox = [MinimalTextBox]::new()
        $this.TitleBox.Text = $this.Task.Title
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.TitleBox.ShowBorder = $true
        $this.TitleBox.BorderType = [BorderType]::Rounded
        $this.AddContentControl($this.TitleBox, 1)
        
        # Create description textbox
        $this.DescriptionBox = [MinimalTextBox]::new()
        $this.DescriptionBox.Text = $this.Task.Description
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.DescriptionBox.ShowBorder = $true
        $this.DescriptionBox.BorderType = [BorderType]::Rounded
        $this.AddContentControl($this.DescriptionBox, 2)
        
        # Create status list
        $this.StatusList = [MinimalListBox]::new()
        $this.StatusList.Title = "Status"
        $this.StatusList.ShowBorder = $true
        $this.StatusList.BorderType = [BorderType]::Rounded
        $this.StatusList.SetItems(@(
            @{Name="Pending"; Value=[TaskStatus]::Pending},
            @{Name="In Progress"; Value=[TaskStatus]::InProgress},
            @{Name="Completed"; Value=[TaskStatus]::Completed},
            @{Name="Cancelled"; Value=[TaskStatus]::Cancelled}
        ))
        $this.StatusList.ItemRenderer = { param($item) $item.Name }
        # Select current status
        for ($i = 0; $i -lt $this.StatusList.Items.Count; $i++) {
            if ($this.StatusList.Items[$i].Value -eq $this.Task.Status) {
                $this.StatusList.SelectIndex($i)
                break
            }
        }
        $this.AddContentControl($this.StatusList, 3)
        
        # Create priority list
        $this.PriorityList = [MinimalListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.BorderType = [BorderType]::Rounded
        $this.PriorityList.SetItems(@(
            @{Name="Low"; Value=[TaskPriority]::Low},
            @{Name="Medium"; Value=[TaskPriority]::Medium},
            @{Name="High"; Value=[TaskPriority]::High}
        ))
        $this.PriorityList.ItemRenderer = { param($item) $item.Name }
        # Select current priority
        for ($i = 0; $i -lt $this.PriorityList.Items.Count; $i++) {
            if ($this.PriorityList.Items[$i].Value -eq $this.Task.Priority) {
                $this.PriorityList.SelectIndex($i)
                break
            }
        }
        $this.AddContentControl($this.PriorityList, 4)
        
        # Create progress textbox
        $this.ProgressBox = [MinimalTextBox]::new()
        $this.ProgressBox.Text = $this.Task.Progress.ToString()
        $this.ProgressBox.Placeholder = "0-100"
        $this.ProgressBox.ShowBorder = $true
        $this.ProgressBox.BorderType = [BorderType]::Rounded
        $this.AddContentControl($this.ProgressBox, 5)
        
        # Set up primary action (Save)
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.TitleBox.Text.Trim()) {
                $selectedStatus = $dialog.StatusList.GetSelectedItem()
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $progress = 0
                if ([int]::TryParse($dialog.ProgressBox.Text, [ref]$progress)) {
                    $progress = [Math]::Max(0, [Math]::Min(100, $progress))
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave @{
                        Title = $dialog.TitleBox.Text
                        Description = $dialog.DescriptionBox.Text
                        Status = if ($selectedStatus) { $selectedStatus.Value } else { $dialog.Task.Status }
                        Priority = if ($selectedPriority) { $selectedPriority.Value } else { $dialog.Task.Priority }
                        Progress = $progress
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action (Cancel)
        $this.OnSecondary = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for task dialog
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        # Title
        $this.TitleBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        # Description
        $this.DescriptionBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        # Status and Priority side by side
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.StatusList.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 5)
        $this.PriorityList.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 5)
        $currentY += 6
        
        # Progress
        $this.ProgressBox.SetBounds($dialogX + $this.DialogPadding, $currentY, 20, 3)
    }
}


####\Screens/EventBusMonitor.ps1
# EventBusMonitor.ps1 - Dialog for monitoring EventBus activity

class EventBusMonitor : Screen {
    [TextBox]$InfoDisplay
    [Button]$RefreshButton
    [Button]$ToggleHistoryButton
    [Button]$ToggleDebugButton
    [Button]$ClearHistoryButton
    [Button]$CloseButton
    [EventBus]$EventBus
    hidden [System.Timers.Timer]$RefreshTimer
    
    EventBusMonitor() : base() {
        $this.Title = "EventBus Monitor"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create info display
        $this.InfoDisplay = [TextBox]::new()
        $this.InfoDisplay.ReadOnly = $true
        $this.InfoDisplay.ShowBorder = $true
        $this.InfoDisplay.Text = "Loading EventBus information..."
        $this.InfoDisplay.Initialize($global:ServiceContainer)
        $this.AddChild($this.InfoDisplay)
        
        # Create buttons
        $this.RefreshButton = [Button]::new("Refresh")
        $this.RefreshButton.OnClick = { $this.RefreshInfo() }
        $this.RefreshButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.RefreshButton)
        
        $this.ToggleHistoryButton = [Button]::new("Toggle History")
        $this.ToggleHistoryButton.OnClick = { $this.ToggleHistory() }
        $this.ToggleHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleHistoryButton)
        
        $this.ToggleDebugButton = [Button]::new("Toggle Debug")
        $this.ToggleDebugButton.OnClick = { $this.ToggleDebug() }
        $this.ToggleDebugButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleDebugButton)
        
        $this.ClearHistoryButton = [Button]::new("Clear History")
        $this.ClearHistoryButton.OnClick = { $this.ClearHistory() }
        $this.ClearHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ClearHistoryButton)
        
        $this.CloseButton = [Button]::new("Close")
        $this.CloseButton.IsDefault = $true
        $this.CloseButton.OnClick = { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        $this.CloseButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CloseButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        })
        $this.BindKey('r', { $this.RefreshInfo() })
        $this.BindKey('h', { $this.ToggleHistory() })
        $this.BindKey('d', { $this.ToggleDebug() })
        $this.BindKey('c', { $this.ClearHistory() })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        
        # Initial refresh
        $this.RefreshInfo()
        
        # Focus on close button
        $this.CloseButton.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout components
        $padding = 2
        $buttonHeight = 3
        $buttonWidth = 20
        $buttonSpacing = 2
        
        # Info display takes most of the space
        $this.InfoDisplay.SetBounds(
            $this.X + $padding,
            $this.Y + $padding,
            $this.Width - ($padding * 2),
            $this.Height - $buttonHeight - ($padding * 3)
        )
        
        # Buttons at the bottom
        $totalButtonWidth = ($buttonWidth * 5) + ($buttonSpacing * 4)
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - $padding
        
        $this.RefreshButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleHistoryButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleDebugButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 2, $buttonY, $buttonWidth, $buttonHeight)
        $this.ClearHistoryButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 3, $buttonY, $buttonWidth, $buttonHeight)
        $this.CloseButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 4, $buttonY, $buttonWidth, $buttonHeight)
    }
    
    [void] RefreshInfo() {
        if (-not $this.EventBus) { return }
        
        $report = $this.EventBus.GetDebugReport()
        
        # Add recent history if enabled
        if ($this.EventBus.EnableHistory) {
            $history = $this.EventBus.GetEventHistory()
            if ($history.Count -gt 0) {
                $report += "`n`nRecent Events:`n"
                $recent = $history | Select-Object -Last 10
                foreach ($event in $recent) {
                    $report += "  $($event.Timestamp.ToString('HH:mm:ss')) - $($event.EventName)`n"
                }
            }
        }
        
        # Add keyboard shortcuts
        $report += "`n`nKeyboard Shortcuts:`n"
        $report += "  [R] Refresh  [H] Toggle History  [D] Toggle Debug`n"
        $report += "  [C] Clear History  [Esc] Close"
        
        $this.InfoDisplay.Text = $report
        $this.InfoDisplay.Invalidate()
    }
    
    [void] ToggleHistory() {
        if ($this.EventBus) {
            $this.EventBus.EnableHistory = -not $this.EventBus.EnableHistory
            $this.RefreshInfo()
        }
    }
    
    [void] ToggleDebug() {
        if ($this.EventBus) {
            $this.EventBus.EnableDebugLogging = -not $this.EventBus.EnableDebugLogging
            $this.RefreshInfo()
        }
    }
    
    [void] ClearHistory() {
        if ($this.EventBus) {
            $this.EventBus.ClearHistory()
            $this.RefreshInfo()
        }
    }
    
    [void] FocusNext() {
        $focusableChildren = @($this.RefreshButton, $this.ToggleHistoryButton, 
                              $this.ToggleDebugButton, $this.ClearHistoryButton, 
                              $this.CloseButton)
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        # Move to next
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ExcelImportScreen.ps1
# ExcelImportScreen.ps1 - Excel import screen using PRAXIS patterns

class ExcelImportScreen : Screen {
    [FastFileTree]$FileTree
    [ListBox]$PreviewList
    [Button]$ImportButton
    [Button]$BackButton
    [ProgressBar]$ImportProgress
    [string]$SelectedFile
    [hashtable]$ImportedData
    [string]$StatusMessage = "Select an Excel file to import (SVI-CAS worksheet)"
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$StatusBarHeight = 1
    hidden [int]$ProgressHeight = 3
    
    ExcelImportScreen() : base() {
        $this.Title = "Excel Import"
    }
    
    [void] OnInitialize() {
        # Create file tree for Excel file selection
        $this.FileTree = [FastFileTree]::new()
        $this.FileTree.ShowBorder = $true
        $this.FileTree.Title = "Select Excel File"
        $this.FileTree.FileExtensions = @('.xlsx', '.xlsm', '.xls')
        $this.FileTree.ShowSize = $true
        $this.AddChild($this.FileTree)
        
        # Start with current directory
        $this.FileTree.LoadDirectory((Get-Location).Path)
        
        # Create preview list
        $this.PreviewList = [ListBox]::new()
        $this.PreviewList.Title = "Import Preview"
        $this.PreviewList.ShowBorder = $true
        $this.AddChild($this.PreviewList)
        
        # Create progress bar (initially hidden)
        $this.ImportProgress = [ProgressBar]::new()
        $this.ImportProgress.IsVisible = $false
        $this.AddChild($this.ImportProgress)
        
        # Create buttons
        $screen = $this  # Capture reference for closures
        
        $this.ImportButton = [Button]::new("Import")
        $this.ImportButton.IsEnabled = $false
        $this.ImportButton.OnClick = { $screen.StartImport() }.GetNewClosure()
        $this.AddChild($this.ImportButton)
        
        $this.BackButton = [Button]::new("Back")
        $this.BackButton.OnClick = { 
            $screen.ServiceContainer.GetService('ScreenManager').PopScreen() 
        }.GetNewClosure()
        $this.AddChild($this.BackButton)
        
        # Set up file selection handler
        $this.FileTree.OnFileSelected = {
            param($filePath)
            if ($filePath -match '\.xls[xm]?$') {
                $screen.SelectedFile = $filePath
                $screen.StatusMessage = "Selected: $(Split-Path $filePath -Leaf)"
                $screen.ImportButton.IsEnabled = $true
                $screen.PreviewFile()
                $screen.Invalidate()
            }
        }.GetNewClosure()
        
        # Key bindings
        $this.AddKeyBinding([ConsoleKey]::Escape, { 
            $this.ServiceContainer.GetService('ScreenManager').PopScreen() 
        })
        $this.AddKeyBinding([ConsoleKey]::I, { 
            if ($this.ImportButton.IsEnabled) { $this.StartImport() } 
        })
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.FileTree) { return }
        
        # Calculate layout
        $fileTreeHeight = [Math]::Floor(($this.Height - $this.StatusBarHeight - $this.ButtonHeight - 2) * 0.5)
        $previewHeight = $this.Height - $fileTreeHeight - $this.StatusBarHeight - $this.ButtonHeight - 2
        
        # Position file tree at top
        $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $fileTreeHeight)
        
        # Position preview list below file tree
        $previewY = $this.Y + $fileTreeHeight + 1
        $this.PreviewList.SetBounds($this.X, $previewY, $this.Width, $previewHeight)
        
        # Position progress bar over preview area when visible
        if ($this.ImportProgress.IsVisible) {
            $progressY = $previewY + [Math]::Floor($previewHeight / 2) - 1
            $this.ImportProgress.SetBounds($this.X + 4, $progressY, $this.Width - 8, $this.ProgressHeight)
        }
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - $this.StatusBarHeight
        $buttonWidth = 12
        $this.ImportButton.SetBounds($this.X + $this.Width - ($buttonWidth * 2) - 4, $buttonY, $buttonWidth, 3)
        $this.BackButton.SetBounds($this.X + $this.Width - $buttonWidth - 2, $buttonY, $buttonWidth, 3)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus on file tree
        if ($this.FileTree) {
            $this.FileTree.Focus()
        }
    }
    
    [void] PreviewFile() {
        if (-not $this.SelectedFile) { return }
        
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("File: $(Split-Path $this.SelectedFile -Leaf)")
        $this.PreviewList.AddItem("Path: $($this.SelectedFile)")
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("This will import data from the 'SVI-CAS' worksheet")
        $this.PreviewList.AddItem("Press 'Import' to continue...")
    }
    
    [void] StartImport() {
        if (-not $this.SelectedFile) { return }
        
        $this.ImportButton.IsEnabled = $false
        $this.ImportProgress.IsVisible = $true
        $this.ImportProgress.Value = 0
        $this.StatusMessage = "Importing from Excel..."
        $this.OnBoundsChanged()  # Reposition progress bar
        $this.Invalidate()
        
        try {
            # Get Excel import service
            $excelService = $this.ServiceContainer.GetService('ExcelImportService')
            if (-not $excelService) {
                throw "Excel import service not available"
            }
            
            # Import data
            $this.ImportProgress.Value = 20
            $this.StatusMessage = "Reading Excel file..."
            $this.Invalidate()
            
            $this.ImportedData = $excelService.ImportFromExcel($this.SelectedFile)
            
            $this.ImportProgress.Value = 50
            $this.StatusMessage = "Processing data..."
            $this.Invalidate()
            
            # Display preview
            $this.ShowImportPreview()
            
            $this.ImportProgress.Value = 80
            $this.StatusMessage = "Creating project..."
            $this.Invalidate()
            
            # Create project from imported data
            $project = $excelService.CreateProjectFromImport($this.ImportedData)
            
            # Save project
            $projectService = $this.ServiceContainer.GetService('ProjectService')
            $projectService.CreateProject($project)
            
            $this.ImportProgress.Value = 100
            $this.StatusMessage = "Import completed successfully! Project ID2: $($project.ID2)"
            $this.Invalidate()
            
            # Show success and return to projects screen after delay
            Start-Sleep -Seconds 2
            $screenManager = $this.ServiceContainer.GetService('ScreenManager')
            $screenManager.PopScreen()
            
            # Fire event to refresh projects list
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Publish([EventNames]::ProjectCreated, $this, @{ Project = $project })
            }
        }
        catch {
            $this.StatusMessage = "Import failed: $_"
            $this.ImportProgress.IsVisible = $false
            $this.ImportButton.IsEnabled = $true
            $this.OnBoundsChanged()  # Reset layout
            $this.Invalidate()
        }
    }
    
    [void] ShowImportPreview() {
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("=== IMPORTED DATA PREVIEW ===")
        $this.PreviewList.AddItem("")
        
        # Core project info
        if ($this.ImportedData.CASCase) {
            $this.PreviewList.AddItem("ID2 (CAS Case#): $($this.ImportedData.CASCase)")
        }
        if ($this.ImportedData.TPName) {
            $this.PreviewList.AddItem("TP Name: $($this.ImportedData.TPName)")
        }
        if ($this.ImportedData.TPNum) {
            $this.PreviewList.AddItem("TP Number: $($this.ImportedData.TPNum)")
        }
        if ($this.ImportedData.AuditType) {
            $this.PreviewList.AddItem("Audit Type: $($this.ImportedData.AuditType)")
        }
        
        # Address
        if ($this.ImportedData.Address -or $this.ImportedData.City) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("ADDRESS:")
            if ($this.ImportedData.Address) {
                $this.PreviewList.AddItem("  $($this.ImportedData.Address)")
            }
            if ($this.ImportedData.City -or $this.ImportedData.Province) {
                $this.PreviewList.AddItem("  $($this.ImportedData.City), $($this.ImportedData.Province) $($this.ImportedData.PostalCode)")
            }
        }
        
        # Auditor info
        if ($this.ImportedData.AuditorName) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("AUDITOR:")
            $this.PreviewList.AddItem("  $($this.ImportedData.AuditorName) - $($this.ImportedData.AuditorPhone)")
            if ($this.ImportedData.AuditorTL) {
                $this.PreviewList.AddItem("  Team Lead: $($this.ImportedData.AuditorTL)")
            }
        }
        
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("Press 'Import' to create project...")
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base screen first
        $null = $sb.Append(([Screen]$this).OnRender())
        
        # Render status bar at bottom
        $statusY = $this.Y + $this.Height - 1
        $null = $sb.Append($this.VT.MoveTo($this.X, $statusY))
        $null = $sb.Append($this.ThemeManager.GetCached('StatusBar'))
        $null = $sb.Append(' ' * $this.Width)  # Clear line
        $null = $sb.Append($this.VT.MoveTo($this.X + 2, $statusY))
        $null = $sb.Append($this.StatusMessage)
        $null = $sb.Append($this.VT.Reset)
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/FileBrowserScreen.ps1
# FileBrowserScreen - File browser using FastFileTree component
# Proper PRAXIS architecture implementation

class FileBrowserScreen : Screen {
    [RangerFileTree]$FileTree
    [scriptblock]$FileSelectedCallback = $null  # Callback for file selection
    
    FileBrowserScreen() : base() {
        $this.Title = "File Browser - [h/]Back [j/]Down [k/]Up [l/]Enter [.]Hidden"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnInitialize: Starting initialization")
        }
        
        # Create and configure the ranger-style file tree
        $this.FileTree = [RangerFileTree]::new()
        $this.FileTree.CurrentPath = (Get-Location).Path
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen: Created RangerFileTree with path: $($this.FileTree.CurrentPath)")
            $global:Logger.Debug("FileBrowserScreen: FileTree IsFocusable: $($this.FileTree.IsFocusable)")
        }
        
        # Add the file tree as a child component BEFORE initializing
        # This ensures Parent is set correctly
        $this.AddChild($this.FileTree)
        
        # Initialize the FileTree with the service container
        $this.FileTree.Initialize($this.ServiceContainer)
        
        # Set up event handlers
        $screen = $this  # Capture reference for closures
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($screen.FileSelectedCallback) {
                & $screen.FileSelectedCallback $node.FullPath
            } else {
                # Default behavior: open text editor for files
                $screen.OpenFileInEditor($node.FullPath)
            }
        }.GetNewClosure()
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnInitialize: Completed, Children.Count=$($this.Children.Count)")
        }
    }
    
    [void] OnBoundsChanged() {
        # Call base implementation
        ([Screen]$this).OnBoundsChanged()
        
        # Set the file tree to fill the entire screen
        if ($this.FileTree -and $this.Width -gt 0 -and $this.Height -gt 0) {
            $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
            
            if ($global:Logger) {
                $global:Logger.Debug("FileBrowserScreen.OnBoundsChanged: Set FileTree bounds to ($($this.X),$($this.Y),$($this.Width),$($this.Height))")
            }
        } elseif ($global:Logger) {
            $global:Logger.Warning("FileBrowserScreen.OnBoundsChanged: Invalid bounds - FileTree=$($this.FileTree -ne $null), Width=$($this.Width), Height=$($this.Height)")
        }
    }
    
    [void] OpenFileInEditor([string]$filePath) {
        if (-not $filePath -or -not (Test-Path $filePath)) {
            return
        }
        
        $item = Get-Item $filePath -ErrorAction SilentlyContinue
        if ($item -and -not $item.PSIsContainer) {
            # It's a file, open in text editor
            try {
                $editorType = [type]"TextEditorScreen"
                if ($editorType) {
                    $editor = $editorType::new($filePath)
                    
                    # Get screen manager and push the editor
                    $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Push($editor)
                }
            } catch {
                # TextEditorScreen not available
                if ($global:Logger) {
                    $global:Logger.Info("TextEditor not available for file: $filePath")
                }
            }
        }
    }
    
    # Override OnActivated to ensure FileTree gets focus
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnActivated: Screen activated")
            $global:Logger.Debug("  Children.Count = $($this.Children.Count)")
        }
        
        # Use FocusFirst to focus the first focusable child (should be FileTree)
        $this.FocusFirst()
        
        if ($global:Logger) {
            # Check what got focused
            $focusedChild = $this.FindFocusedChild()
            if ($focusedChild) {
                $global:Logger.Debug("  Focused child: $($focusedChild.GetType().Name)")
                $global:Logger.Debug("  Focused child IsFocused: $($focusedChild.IsFocused)")
            } else {
                $global:Logger.Debug("  No focused child found after FocusFirst()!")
                # Try direct focus as fallback
                if ($this.FileTree) {
                    $global:Logger.Debug("  Attempting direct FileTree.Focus()")
                    $this.FileTree.Focus()
                    # Check again
                    $focusedChild = $this.FindFocusedChild()
                    if ($focusedChild) {
                        $global:Logger.Debug("  After direct focus: Found $($focusedChild.GetType().Name)")
                    } else {
                        $global:Logger.Debug("  Still no focused child!")
                    }
                }
            }
        }
    }
    
    # Override HandleInput to debug input routing
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)'")
            $global:Logger.Debug("  FileTree.IsFocused = $($this.FileTree.IsFocused)")
        }
        
        # Call base implementation
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/FilePickerDialog.ps1
# FilePickerDialog.ps1 - File selection dialog using FastFileTree
# Modal dialog for selecting files or directories

class FilePickerDialog : Screen {
    [FastFileTree]$FileTree
    [MinimalButton]$SelectButton
    [MinimalButton]$CancelButton
    [MinimalTextBox]$PathBox
    
    # Configuration
    [string]$InitialPath = ""
    [string]$Filter = "*"
    [bool]$AllowDirectories = $false
    [bool]$AllowFiles = $true
    [bool]$MustExist = $true
    [string]$DialogTitle = "Select File"
    
    # Results
    [string]$SelectedPath = ""
    [bool]$DialogResult = $false
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    # Layout
    hidden [int]$_treeHeight = 20
    hidden [int]$_dialogWidth = 80
    hidden [int]$_dialogHeight = 25
    
    FilePickerDialog() : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $PWD.Path
    }
    
    FilePickerDialog([string]$initialPath) : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $initialPath
    }
    
    [void] OnInitialize() {
        # Calculate dialog position (centered)
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        # Path input box at top
        $this.PathBox = [MinimalTextBox]::new()
        $this.PathBox.Placeholder = "Enter path or navigate below"
        $this.PathBox.Text = $this.InitialPath
        $this.PathBox.SetBounds([int]$centerX + 2, [int]$centerY + 2, $this._dialogWidth - 4, 3)
        $this.PathBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.PathBox)
        
        # File tree in the middle
        $this.FileTree = [FastFileTree]::new($this.InitialPath)
        $this.FileTree.Title = $this.DialogTitle
        $this.FileTree.Filter = $this.Filter
        $this.FileTree.ShowBorder = $true
        $this.FileTree.SetBounds([int]$centerX + 2, [int]$centerY + 6, $this._dialogWidth - 4, $this._treeHeight)
        $this.FileTree.Initialize($global:ServiceContainer)
        
        # Set up events
        $dialogRef = $this
        $this.FileTree.OnSelectionChanged = {
            $selected = $dialogRef.FileTree.GetSelectedNode()
            if ($selected) {
                $dialogRef.PathBox.Text = $selected.FullPath
                $dialogRef.UpdateButtonStates()
            }
        }.GetNewClosure()
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($dialogRef.IsValidSelection($node)) {
                $dialogRef.SelectedPath = $node.FullPath
                $dialogRef.DialogResult = $true
                $dialogRef.Active = $false
            }
        }.GetNewClosure()
        
        $this.AddChild($this.FileTree)
        
        # Buttons at bottom
        $buttonY = [int]$centerY + 6 + $this._treeHeight + 1
        $buttonWidth = 15
        $buttonSpacing = 2
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = [int]$centerX + (($this._dialogWidth - $totalButtonWidth) / 2)
        
        $this.SelectButton = [MinimalButton]::new("Select")
        $this.SelectButton.IsDefault = $true
        $this.SelectButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, 3)
        $this.SelectButton.OnClick = {
            $dialogRef.SelectFile()
        }.GetNewClosure()
        $this.SelectButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SelectButton)
        
        $this.CancelButton = [MinimalButton]::new("Cancel")
        $this.CancelButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, 3)
        $this.CancelButton.OnClick = {
            $dialogRef.SelectedPath = ""
            $dialogRef.DialogResult = $false
            $dialogRef.Active = $false
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.FileTree.Focus()
        
        # Update button states
        $this.UpdateButtonStates()
    }
    
    [void] UpdateButtonStates() {
        $selected = $this.FileTree.GetSelectedNode()
        $isValid = $this.IsValidSelection($selected)
        
        # Enable/disable select button based on selection
        # Note: Button doesn't have Enabled property in current implementation
        # This is a placeholder for when we add that functionality
        
        # Update button text to reflect what will happen
        if ($selected) {
            if ($selected.IsDirectory) {
                $this.SelectButton.Text = if ($this.AllowDirectories) { "Select Folder" } else { "Enter" }
            } else {
                $this.SelectButton.Text = "Select File"
            }
        } else {
            $this.SelectButton.Text = "Select"
        }
        $this.SelectButton.Invalidate()
    }
    
    [bool] IsValidSelection([FileSystemNode]$node) {
        if ($node -eq $null) {
            return $false
        }
        
        # Check if selection type is allowed
        if ($node.IsDirectory -and -not $this.AllowDirectories) {
            return $false
        }
        
        if (-not $node.IsDirectory -and -not $this.AllowFiles) {
            return $false
        }
        
        # Check if file exists (if required)
        if ($this.MustExist -and -not (Test-Path $node.FullPath)) {
            return $false
        }
        
        return $true
    }
    
    [void] SelectFile() {
        $selected = $this.FileTree.GetSelectedNode()
        
        if ($selected -and $this.IsValidSelection($selected)) {
            $this.SelectedPath = $selected.FullPath
            $this.DialogResult = $true
            
            # Fire event
            if ($this.OnFileSelected) {
                & $this.OnFileSelected $selected.FullPath
            }
            
            $this.Active = $false
        } elseif ($selected -and $selected.IsDirectory -and -not $this.AllowDirectories) {
            # Navigate into directory instead of selecting it
            $this.FileTree.NavigateToSelected()
            $this.PathBox.Text = $this.FileTree.RootPath
        } else {
            # Try to use path from text box
            $pathFromBox = $this.PathBox.Text.Trim()
            if ($pathFromBox -and (Test-Path $pathFromBox)) {
                $this.SelectedPath = $pathFromBox
                $this.DialogResult = $true
                
                if ($this.OnFileSelected) {
                    & $this.OnFileSelected $pathFromBox
                }
                
                $this.Active = $false
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Dialog is positioned manually in OnInitialize
        # This could be enhanced to support resizing
    }
    
    [string] OnRender() {
        # Draw dark overlay background
        $sb = Get-PooledStringBuilder 2048
        
        # Semi-transparent background overlay
        $overlayColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.overlay") } else { "`e[48;2;0;0;0m" }
        
        for ($y = 0; $y -lt [Console]::WindowHeight; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayColor)
            $sb.Append([StringCache]::GetSpaces([Console]::WindowWidth))
        }
        
        # Dialog border
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("dialog.border") } else { "`e[38;2;100;100;100m" }
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.background") } else { "`e[48;2;40;40;40m" }
        
        # Draw dialog background
        for ($y = 0; $y -lt $this._dialogHeight; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this._dialogWidth))
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::TR())
        
        for ($y = 1; $y -lt $this._dialogHeight - 1; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            $sb.Append([VT]::MoveTo([int]$centerX + $this._dialogWidth - 1, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $this._dialogHeight - 1))
        $sb.Append($borderColor)
        $sb.Append([VT]::BL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::BR())
        
        # Title
        if ($this.DialogTitle) {
            $sb.Append([VT]::MoveTo([int]$centerX + 2, [int]$centerY))
            $titleColor = if ($this.Theme) { $this.Theme.GetColor("dialog.title") } else { "`e[38;2;255;255;255m" }
            $sb.Append($titleColor)
            $sb.Append(" $($this.DialogTitle) ")
        }
        
        $sb.Append([VT]::Reset())
        
        # Render children on top
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                $this.SelectedPath = ""
                $this.DialogResult = $false
                $this.Active = $false
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.PathBox.IsFocused) {
                    # Try to navigate to path in text box
                    $path = $this.PathBox.Text.Trim()
                    if ($path -and (Test-Path $path)) {
                        if (Test-Path $path -PathType Container) {
                            $this.FileTree.LoadDirectory($path)
                            $this.FileTree.Focus()
                        } else {
                            # It's a file, select it
                            $this.SelectedPath = $path
                            $this.DialogResult = $true
                            $this.Active = $false
                        }
                    }
                    return $true
                }
                # Let other controls handle Enter
                break
            }
            ([System.ConsoleKey]::Tab) {
                # Cycle focus between controls
                if ($this.PathBox.IsFocused) {
                    $this.FileTree.Focus()
                } elseif ($this.FileTree.IsFocused) {
                    $this.SelectButton.Focus()
                } elseif ($this.SelectButton.IsFocused) {
                    $this.CancelButton.Focus()
                } else {
                    $this.PathBox.Focus()
                }
                return $true
            }
        }
        
        # Let base Screen handle other input
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/FindReplaceDialog.ps1
# FindReplaceDialog.ps1 - Find and replace functionality for text editor
# Provides search and replace capabilities with various options

class FindReplaceDialog : BaseDialog {
    # UI Controls
    [MinimalTextBox]$FindTextBox
    [MinimalTextBox]$ReplaceTextBox
    [MinimalButton]$FindNextButton
    [MinimalButton]$FindPreviousButton
    [MinimalButton]$ReplaceButton
    [MinimalButton]$ReplaceAllButton
    
    # Search options (could be checkboxes in future)
    [bool]$MatchCase = $false
    [bool]$WholeWord = $false
    [bool]$RegexMode = $false
    
    # Search state
    hidden [int]$_lastFoundLine = -1
    hidden [int]$_lastFoundColumn = -1
    hidden [string]$_lastSearchTerm = ""
    
    # Reference to the text editor
    hidden [object]$_textEditor
    hidden [object]$_buffer
    
    # Callback for when dialog closes
    [scriptblock]$OnClose = {}
    
    FindReplaceDialog([object]$textEditor) : base("Find & Replace", 70, 16) {
        $this._textEditor = $textEditor
        $this._buffer = $textEditor._buffer
        
        # Configure dialog buttons
        $this.PrimaryButtonText = "Find Next"
        $this.SecondaryButtonText = "Close"
    }
    
    [void] InitializeContent() {
        # Find text box
        $this.FindTextBox = [MinimalTextBox]::new()
        $this.FindTextBox.Placeholder = "Text to find..."
        $this.FindTextBox.Width = 50
        $this.AddContentControl($this.FindTextBox, 1)
        
        # Replace text box  
        $this.ReplaceTextBox = [MinimalTextBox]::new()
        $this.ReplaceTextBox.Placeholder = "Replace with..."
        $this.ReplaceTextBox.Width = 50
        $this.AddContentControl($this.ReplaceTextBox, 2)
        
        # Find buttons
        $this.FindNextButton = [MinimalButton]::new("Find Next")
        $this.FindNextButton.OnClick = {
            $this.FindNext()
        }.GetNewClosure()
        $this.AddContentControl($this.FindNextButton, 3)
        
        $this.FindPreviousButton = [MinimalButton]::new("Find Previous")
        $this.FindPreviousButton.OnClick = {
            $this.FindPrevious()
        }.GetNewClosure()
        $this.AddContentControl($this.FindPreviousButton, 4)
        
        # Replace buttons
        $this.ReplaceButton = [MinimalButton]::new("Replace")
        $this.ReplaceButton.OnClick = {
            $this.ReplaceNext()
        }.GetNewClosure()
        $this.AddContentControl($this.ReplaceButton, 5)
        
        $this.ReplaceAllButton = [MinimalButton]::new("Replace All")
        $this.ReplaceAllButton.OnClick = {
            $this.ReplaceAll()
        }.GetNewClosure()
        $this.AddContentControl($this.ReplaceAllButton, 6)
        
        # Set initial focus to find text box
        $this.FindTextBox.Focus()
        
        # Pre-populate with selected text if available
        if ($this._textEditor.HasSelection) {
            $selectedText = $this.GetSelectedText()
            if ($selectedText -and $selectedText.Length -lt 100) {
                $this.FindTextBox.SetText($selectedText)
            }
        }
    }
    
    [string] GetSelectedText() {
        if (-not $this._textEditor.HasSelection) {
            return ""
        }
        
        $bounds = $this._textEditor.GetSelectionBounds()
        if ($bounds.StartY -eq $bounds.EndY) {
            # Single line selection
            $line = $this._buffer.GetLine($bounds.StartY)
            return $line.Substring($bounds.StartX, $bounds.EndX - $bounds.StartX)
        } else {
            # Multi-line selection - just return first line for simplicity
            $line = $this._buffer.GetLine($bounds.StartY)
            return $line.Substring($bounds.StartX)
        }
    }
    
    [void] HandlePrimaryAction() {
        # Primary action is Find Next
        $this.FindNext()
    }
    
    [void] HandleSecondaryAction() {
        # Secondary action is Close
        if ($this.OnClose) {
            & $this.OnClose
        }
        $this.CloseDialog()
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Handle F3 for Find Next
        if ($key.Key -eq [System.ConsoleKey]::F3) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.FindPrevious()
            } else {
                $this.FindNext()
            }
            return $true
        }
        
        # Handle Ctrl+H for Replace
        if ($key.Key -eq [System.ConsoleKey]::H -and ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            $this.ReplaceNext()
            return $true
        }
        
        # Let base class handle other keys
        return ([BaseDialog]$this).HandleScreenInput($key)
    }
    
    [void] FindNext() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        # Start search from current cursor position or after last found position
        $startLine = $this._textEditor.CursorY
        $startCol = $this._textEditor.CursorX
        
        # If we're searching for the same term and found it before, start after the last find
        if ($searchTerm -eq $this._lastSearchTerm -and $this._lastFoundLine -ge 0) {
            $startLine = $this._lastFoundLine
            $startCol = $this._lastFoundColumn + $searchTerm.Length
        }
        
        $result = $this.SearchForward($searchTerm, $startLine, $startCol)
        $this.HandleSearchResult($result, $searchTerm)
    }
    
    [void] FindPrevious() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        # Start search from current cursor position or before last found position
        $startLine = $this._textEditor.CursorY
        $startCol = $this._textEditor.CursorX
        
        # If we're searching for the same term and found it before, start before the last find
        if ($searchTerm -eq $this._lastSearchTerm -and $this._lastFoundLine -ge 0) {
            $startLine = $this._lastFoundLine
            $startCol = $this._lastFoundColumn - 1
        }
        
        $result = $this.SearchBackward($searchTerm, $startLine, $startCol)
        $this.HandleSearchResult($result, $searchTerm)
    }
    
    [hashtable] SearchForward([string]$searchTerm, [int]$startLine, [int]$startCol) {
        $lineCount = $this._buffer.GetLineCount()
        
        # Search from starting position to end of document
        for ($line = $startLine; $line -lt $lineCount; $line++) {
            $lineText = $this._buffer.GetLine($line)
            $searchStart = if ($line -eq $startLine) { $startCol } else { 0 }
            
            $index = $this.FindInLine($lineText, $searchTerm, $searchStart)
            if ($index -ge 0) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                }
            }
        }
        
        # Wrap around - search from beginning to start position
        for ($line = 0; $line -lt $startLine; $line++) {
            $lineText = $this._buffer.GetLine($line)
            $searchEnd = if ($line -eq $startLine - 1) { $startCol } else { $lineText.Length }
            
            $index = $this.FindInLine($lineText, $searchTerm, 0)
            if ($index -ge 0 -and $index -lt $searchEnd) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                    Wrapped = $true
                }
            }
        }
        
        return @{ Found = $false }
    }
    
    [hashtable] SearchBackward([string]$searchTerm, [int]$startLine, [int]$startCol) {
        # Search from starting position to beginning of document
        for ($line = $startLine; $line -ge 0; $line--) {
            $lineText = $this._buffer.GetLine($line)
            $searchEnd = if ($line -eq $startLine) { $startCol } else { $lineText.Length }
            
            $index = $this.FindInLineBackward($lineText, $searchTerm, $searchEnd)
            if ($index -ge 0) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                }
            }
        }
        
        # Wrap around - search from end to start position
        $lineCount = $this._buffer.GetLineCount()
        for ($line = $lineCount - 1; $line -gt $startLine; $line--) {
            $lineText = $this._buffer.GetLine($line)
            
            $index = $this.FindInLineBackward($lineText, $searchTerm, $lineText.Length)
            if ($index -ge 0) {
                return @{
                    Found = $true
                    Line = $line
                    Column = $index
                    Wrapped = $true
                }
            }
        }
        
        return @{ Found = $false }
    }
    
    [int] FindInLine([string]$line, [string]$searchTerm, [int]$startIndex) {
        if ($this.MatchCase) {
            return $line.IndexOf($searchTerm, $startIndex)
        } else {
            return $line.ToLower().IndexOf($searchTerm.ToLower(), $startIndex)
        }
    }
    
    [int] FindInLineBackward([string]$line, [string]$searchTerm, [int]$endIndex) {
        if ($endIndex -le 0) { return -1 }
        
        $searchableText = $line.Substring(0, $endIndex)
        if ($this.MatchCase) {
            return $searchableText.LastIndexOf($searchTerm)
        } else {
            return $searchableText.ToLower().LastIndexOf($searchTerm.ToLower())
        }
    }
    
    [void] HandleSearchResult([hashtable]$result, [string]$searchTerm) {
        if ($result.Found) {
            # Move cursor to found position
            $this._textEditor.CursorY = $result.Line
            $this._textEditor.CursorX = $result.Column
            $this._textEditor.EnsureCursorVisible()
            
            # Select the found text
            $this._textEditor.StartSelection()
            $this._textEditor.SelectionStartX = $result.Column
            $this._textEditor.SelectionStartY = $result.Line
            $this._textEditor.SelectionEndX = $result.Column + $searchTerm.Length
            $this._textEditor.SelectionEndY = $result.Line
            $this._textEditor.CursorX = $result.Column + $searchTerm.Length
            
            # Update last found position
            $this._lastFoundLine = $result.Line
            $this._lastFoundColumn = $result.Column
            $this._lastSearchTerm = $searchTerm
            
            # Set status message
            $wrapMsg = if ($result.Wrapped) { " (wrapped)" } else { "" }
            $this._textEditor.StatusMessage = "Found at line $($result.Line + 1), column $($result.Column + 1)$wrapMsg"
        } else {
            $this._textEditor.StatusMessage = "Text not found: '$searchTerm'"
            $this._lastFoundLine = -1
            $this._lastFoundColumn = -1
        }
        
        $this._textEditor.Invalidate()
    }
    
    [void] ReplaceNext() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        $replaceText = $this.ReplaceTextBox.Text
        
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        # If we have a selection that matches the search term, replace it
        if ($this._textEditor.HasSelection) {
            $selectedText = $this.GetSelectedText()
            $matchesSearch = if ($this.MatchCase) { 
                $selectedText -eq $searchTerm 
            } else { 
                $selectedText.ToLower() -eq $searchTerm.ToLower() 
            }
            
            if ($matchesSearch) {
                # Replace the selected text
                $this._textEditor.SaveDocumentState()
                $this._textEditor.DeleteSelection()
                if ($replaceText) {
                    $this._textEditor._buffer.InsertTextAt($this._textEditor.CursorY, $this._textEditor.CursorX, $replaceText)
                    $this._textEditor.CursorX += $replaceText.Length
                }
                $this._textEditor._buffer.IsModified = $true
                $this._textEditor._allLinesDirty = $true
                $this._textEditor.Invalidate()
                $this._textEditor.StatusMessage = "Replaced 1 occurrence"
                
                # Find next occurrence
                $this.FindNext()
                return
            }
        }
        
        # No selection or selection doesn't match - just find next
        $this.FindNext()
    }
    
    [void] ReplaceAll() {
        $searchTerm = $this.FindTextBox.Text.Trim()
        $replaceText = $this.ReplaceTextBox.Text
        
        if ([string]::IsNullOrEmpty($searchTerm)) {
            $this._textEditor.StatusMessage = "Please enter text to find"
            return
        }
        
        $this._textEditor.SaveDocumentState()
        $replacements = 0
        $lineCount = $this._buffer.GetLineCount()
        
        # Search through all lines
        for ($line = 0; $line -lt $lineCount; $line++) {
            $lineText = $this._buffer.GetLine($line)
            $originalText = $lineText
            
            # Keep replacing until no more matches in this line
            $modified = $false
            do {
                $index = $this.FindInLine($lineText, $searchTerm, 0)
                if ($index -ge 0) {
                    # Replace the occurrence
                    $before = $lineText.Substring(0, $index)
                    $after = $lineText.Substring($index + $searchTerm.Length)
                    $lineText = $before + $replaceText + $after
                    $replacements++
                    $modified = $true
                } else {
                    break
                }
            } while ($true)
            
            # Update the line if it was modified
            if ($modified) {
                $this._buffer.Lines[$line] = $lineText
            }
        }
        
        if ($replacements -gt 0) {
            $this._buffer.IsModified = $true
            $this._textEditor._allLinesDirty = $true
            $this._textEditor.Invalidate()
            $this._textEditor.StatusMessage = "Replaced $replacements occurrence(s)"
        } else {
            $this._textEditor.StatusMessage = "No occurrences found to replace"
        }
    }
    
    # Override OnRender to add field labels
    [string] OnRender() {
        # Get base dialog rendering first
        $baseRender = ([BaseDialog]$this).OnRender()
        
        # Add field labels over the dialog content
        $sb = [System.Text.StringBuilder]::new($baseRender)
        
        if ($this._dialogBounds.Count -gt 0) {
            $dialogX = $this._dialogBounds.X
            $dialogY = $this._dialogBounds.Y
            $labelColor = $this.Theme.GetColor("dialog.text")
            
            # Add labels for each field
            $fieldY = $dialogY + $this.DialogPadding
            
            # Find label
            $sb.Append([VT]::MoveTo($dialogX + 2, $fieldY))
            $sb.Append($labelColor)
            $sb.Append("Find:")
            $fieldY += 4
            
            # Replace label  
            $sb.Append([VT]::MoveTo($dialogX + 2, $fieldY))
            $sb.Append("Replace:")
            
            # Add status about search options if any are enabled
            if ($this.MatchCase -or $this.WholeWord -or $this.RegexMode) {
                $options = @()
                if ($this.MatchCase) { $options += "Match Case" }
                if ($this.WholeWord) { $options += "Whole Word" }
                if ($this.RegexMode) { $options += "Regex" }
                
                $sb.Append([VT]::MoveTo($dialogX + 2, $dialogY + $this.DialogHeight - 4))
                $sb.Append("Options: $($options -join ', ')")
            }
        }
        
        return $sb.ToString()
    }
}


####\Screens/KeyboardHelpOverlay.ps1
# KeyboardHelpOverlay.ps1 - Minimal keyboard shortcut help overlay

class KeyboardHelpOverlay : MinimalModal {
    hidden [string]$Context = ""
    hidden [MinimalListBox]$CategoryList
    hidden [UIElement]$ShortcutDisplay
    hidden [KeyboardShortcutManager]$ShortcutManager
    hidden [hashtable]$CategorizedShortcuts = @{}
    
    KeyboardHelpOverlay([string]$context = "") : base() {
        $this.Title = "Keyboard Shortcuts"
        $this.Context = $context
        $this.ModalWidth = 70
        $this.ModalHeight = 24
        $this.BorderType = [BorderType]::Rounded
        
        # Add close hint
        $this.AddButton("Close (ESC/F1)", { $this.Close() }, $true)
    }
    
    [void] OnInitialize() {
        # Get shortcut manager
        $this.ShortcutManager = $this.ServiceContainer.GetService('KeyboardShortcutManager')
        if (-not $this.ShortcutManager) {
            $this.ShortcutManager = [KeyboardShortcutManager]::new()
            $this.ShortcutManager.Initialize($this.ServiceContainer)
        }
        
        # Create main container with horizontal split
        $mainSplit = [HorizontalSplit]::new()
        $mainSplit.SplitPosition = 30  # 30% for categories
        
        # Left: Category list
        $this.CategoryList = [MinimalListBox]::new()
        $this.CategoryList.ShowBorder = $false
        $this.CategoryList.OnSelectionChanged = {
            $this.UpdateShortcutDisplay()
        }.GetNewClosure()
        
        # Right: Shortcut display
        $this.ShortcutDisplay = [UIElement]::new()
        $this.ShortcutDisplay.OnRender = {
            $this.Parent.Parent.RenderShortcuts()
        }.GetNewClosure()
        
        $mainSplit.SetLeftChild($this.CategoryList)
        $mainSplit.SetRightChild($this.ShortcutDisplay)
        
        $this.Content = $mainSplit
        
        # Load shortcuts
        $this.LoadShortcuts()
        
        ([MinimalModal]$this).OnInitialize()
    }
    
    [void] LoadShortcuts() {
        # Get all shortcuts for context
        $allShortcuts = $this.ShortcutManager.GetShortcuts($this.Context)
        
        # Add some additional help shortcuts
        $this.AddHelpShortcuts($allShortcuts)
        
        # Categorize shortcuts
        $this.CategorizedShortcuts.Clear()
        foreach ($shortcut in $allShortcuts) {
            $category = $shortcut.Category
            if (-not $this.CategorizedShortcuts.ContainsKey($category)) {
                $this.CategorizedShortcuts[$category] = @()
            }
            $this.CategorizedShortcuts[$category] += $shortcut
        }
        
        # Populate category list
        $categories = $this.CategorizedShortcuts.Keys | Sort-Object
        $this.CategoryList.SetItems($categories)
        
        if ($categories.Count -gt 0) {
            $this.CategoryList.SelectedIndex = 0
        }
    }
    
    [void] AddHelpShortcuts([System.Collections.Generic.List[KeyboardShortcut]]$shortcuts) {
        # Add context-specific shortcuts based on current screen
        $currentScreen = $null
        if ($global:ScreenManager) {
            $currentScreen = $global:ScreenManager.GetActiveScreen()
        }
        
        if ($currentScreen) {
            # Add screen-specific shortcuts
            switch ($currentScreen.GetType().Name) {
                "ProjectsScreen" {
                    $this.AddShortcut($shortcuts, "N", "New project", "Projects")
                    $this.AddShortcut($shortcuts, "E", "Edit project", "Projects")
                    $this.AddShortcut($shortcuts, "D", "Delete project", "Projects")
                    $this.AddShortcut($shortcuts, "Enter", "View project details", "Projects")
                }
                "TaskScreen" {
                    $this.AddShortcut($shortcuts, "N", "New task", "Tasks")
                    $this.AddShortcut($shortcuts, "E", "Edit task", "Tasks")
                    $this.AddShortcut($shortcuts, "D", "Delete task", "Tasks")
                    $this.AddShortcut($shortcuts, "Space", "Toggle task completion", "Tasks")
                }
                "FileBrowserScreen" {
                    $this.AddShortcut($shortcuts, "H/", "Parent directory", "File Browser")
                    $this.AddShortcut($shortcuts, "L/", "Enter directory", "File Browser")
                    $this.AddShortcut($shortcuts, "J/", "Next file", "File Browser")
                    $this.AddShortcut($shortcuts, "K/", "Previous file", "File Browser")
                }
            }
        }
        
        # Add application-wide shortcuts
        $this.AddShortcut($shortcuts, "Ctrl+P", "Command palette", "Application")
        $this.AddShortcut($shortcuts, "Ctrl+Q", "Quit application", "Application")
        $this.AddShortcut($shortcuts, "1-9", "Switch tabs", "Application")
        $this.AddShortcut($shortcuts, "Ctrl+Tab", "Next tab", "Application")
        $this.AddShortcut($shortcuts, "Ctrl+Shift+Tab", "Previous tab", "Application")
    }
    
    [void] AddShortcut($shortcuts, [string]$keyDisplay, [string]$description, [string]$category) {
        $shortcut = [KeyboardShortcut]::new()
        $shortcut.Key = [System.ConsoleKey]::F1  # Dummy key
        $shortcut.Description = $description
        $shortcut.Category = $category
        
        # Override display text
        $shortcut | Add-Member -MemberType ScriptMethod -Name GetDisplayText -Value {
            return $keyDisplay
        }.GetNewClosure() -Force
        
        $shortcuts.Add($shortcut)
    }
    
    [string] RenderShortcuts() {
        $selectedCategory = $this.CategoryList.GetSelectedItem()
        if (-not $selectedCategory -or -not $this.CategorizedShortcuts.ContainsKey($selectedCategory)) {
            return ""
        }
        
        $sb = Get-PooledStringBuilder 2048
        $shortcuts = $this.CategorizedShortcuts[$selectedCategory]
        
        # Header
        $sb.Append([VT]::MoveTo($this.ShortcutDisplay.X + 2, $this.ShortcutDisplay.Y))
        $sb.Append($this.Theme.GetColor('accent'))
        $sb.Append(" $selectedCategory ")
        $sb.Append([VT]::Reset())
        
        # Shortcuts
        $y = $this.ShortcutDisplay.Y + 2
        $maxY = $this.ShortcutDisplay.Y + $this.ShortcutDisplay.Height - 1
        
        foreach ($shortcut in $shortcuts) {
            if ($y -ge $maxY) { break }
            
            $sb.Append([VT]::MoveTo($this.ShortcutDisplay.X + 2, $y))
            
            # Key combination
            $keyText = $shortcut.GetDisplayText()
            $sb.Append($this.Theme.GetColor('accent'))
            $sb.Append($keyText.PadRight(20))
            
            # Description
            $sb.Append($this.Theme.GetColor('normal'))
            $desc = $shortcut.Description
            if ($desc.Length -gt 40) {
                $desc = $desc.Substring(0, 37) + "..."
            }
            $sb.Append($desc)
            
            $sb.Append([VT]::Reset())
            $y++
        }
        
        # Footer hint
        if ($y -lt $maxY - 2) {
            $sb.Append([VT]::MoveTo($this.ShortcutDisplay.X + 2, $maxY - 2))
            $sb.Append($this.Theme.GetColor('disabled'))
            $sb.Append("Use / to browse categories")
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] UpdateShortcutDisplay() {
        $this.ShortcutDisplay.Invalidate()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # F1 also closes help
        if ($key.Key -eq [System.ConsoleKey]::F1) {
            $this.Close()
            return $true
        }
        
        return ([MinimalModal]$this).HandleInput($key)
    }
}

# Quick help function for screens
class HelpManager {
    static [void] ShowHelp([string]$context = "") {
        $help = [KeyboardHelpOverlay]::new($context)
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($help)
        }
    }
}


####\Screens/LayoutExamplesScreen.ps1
# LayoutExamplesScreen.ps1 - Examples of underutilized layout components

class LayoutExamplesScreen : Screen {
    hidden [MinimalListBox]$ExampleList
    hidden [Container]$ExampleArea
    hidden [VerticalSplit]$MainSplit
    
    LayoutExamplesScreen() : base() {
        $this.Name = "Layout Examples"
    }
    
    [void] OnInitialize() {
        ([Screen]$this).OnInitialize()
        
        # Main vertical split
        $this.MainSplit = [VerticalSplit]::new()
        $this.MainSplit.SplitPosition = 10
        $this.AddChild($this.MainSplit)
        
        # Top: Example selector
        $topContainer = [Container]::new()
        $this.ExampleList = [MinimalListBox]::new()
        $this.ExampleList.ShowBorder = $true
        $this.ExampleList.SetItems(@(
            "GridPanel - Flexible Grid Layout",
            "DockPanel - Docked Layout", 
            "HorizontalSplit - Side by Side",
            "VerticalSplit - Top and Bottom",
            "Nested Splits - Complex Layout",
            "Mixed Layout - All Combined"
        ))
        $this.ExampleList.OnSelectionChanged = {
            $this.ShowExample($this.ExampleList.SelectedIndex)
        }.GetNewClosure()
        $topContainer.AddChild($this.ExampleList)
        $topContainer.LayoutChildren = {
            if ($this.Children.Count -gt 0) {
                $this.Children[0].SetBounds($this.X + 2, $this.Y + 2, $this.Width - 4, $this.Height - 2)
            }
        }
        $this.MainSplit.SetTopChild($topContainer)
        
        # Bottom: Example area
        $this.ExampleArea = [Container]::new()
        $this.ExampleArea.DrawBackground = $true
        $this.MainSplit.SetBottomChild($this.ExampleArea)
        
        # Default to first example
        $this.ExampleList.SelectedIndex = 0
        $this.ShowExample(0)
    }
    
    [void] ShowExample([int]$index) {
        $this.ExampleArea.Children.Clear()
        
        switch ($index) {
            0 { $this.ShowGridPanelExample() }
            1 { $this.ShowDockPanelExample() }
            2 { $this.ShowHorizontalSplitExample() }
            3 { $this.ShowVerticalSplitExample() }
            4 { $this.ShowNestedSplitsExample() }
            5 { $this.ShowMixedLayoutExample() }
        }
        
        $this.ExampleArea.Invalidate()
    }
    
    [void] ShowGridPanelExample() {
        $grid = [GridPanel]::new()
        $grid.Rows = 3
        $grid.Columns = 3
        $grid.RowHeights = @(0.2, 0.6, 0.2)  # 20%, 60%, 20%
        $grid.ColumnWidths = @(0.25, 0.5, 0.25)  # 25%, 50%, 25%
        
        # Add cells with different content
        for ($row = 0; $row -lt 3; $row++) {
            for ($col = 0; $col -lt 3; $col++) {
                $cell = $this.CreateDemoPanel("Cell R$($row+1)C$($col+1)", 
                    "Grid[$row,$col]`nFlexible sizing")
                $grid.SetCell($row, $col, $cell)
            }
        }
        
        # Center cell spans 2 columns
        $centerCell = $this.CreateDemoPanel("Spanning Cell", 
            "This cell spans`n2 columns using`nSetCell with span")
        $grid.SetCell(1, 0, $centerCell, 1, 2)  # row 1, col 0, rowspan 1, colspan 2
        
        $this.ExampleArea.AddChild($grid)
    }
    
    [void] ShowDockPanelExample() {
        $dock = [DockPanel]::new()
        
        # Dock panels to each side
        $topPanel = $this.CreateDemoPanel("Top Dock", "Height: 5 lines")
        $dock.DockTop($topPanel, 5)
        
        $bottomPanel = $this.CreateDemoPanel("Bottom Dock", "Height: 3 lines")
        $dock.DockBottom($bottomPanel, 3)
        
        $leftPanel = $this.CreateDemoPanel("Left Dock", "Width: 20 chars")
        $dock.DockLeft($leftPanel, 20)
        
        $rightPanel = $this.CreateDemoPanel("Right Dock", "Width: 20 chars")
        $dock.DockRight($rightPanel, 20)
        
        # Center fills remaining space
        $centerPanel = $this.CreateDemoPanel("Center Fill", 
            "This panel fills`nall remaining space`nafter docked panels")
        $dock.DockFill($centerPanel)
        
        $this.ExampleArea.AddChild($dock)
    }
    
    [void] ShowHorizontalSplitExample() {
        $split = [HorizontalSplit]::new()
        $split.SplitPosition = 40  # 40% for left panel
        
        $leftPanel = $this.CreateDemoPanel("Left Panel", 
            "40% width`nResizable with`nSplitPosition property")
        $split.SetLeftChild($leftPanel)
        
        $rightPanel = $this.CreateDemoPanel("Right Panel", 
            "60% width`nAutomatically adjusts`nwhen window resizes")
        $split.SetRightChild($rightPanel)
        
        $this.ExampleArea.AddChild($split)
    }
    
    [void] ShowVerticalSplitExample() {
        $split = [VerticalSplit]::new()
        $split.SplitPosition = -8  # Bottom 8 lines
        
        $topPanel = $this.CreateDemoPanel("Top Panel", 
            "Flexible height`nNegative SplitPosition`nmeans lines from bottom")
        $split.SetTopChild($topPanel)
        
        $bottomPanel = $this.CreateDemoPanel("Bottom Panel", 
            "Fixed 8 lines`nUseful for status bars`nor command areas")
        $split.SetBottomChild($bottomPanel)
        
        $this.ExampleArea.AddChild($split)
    }
    
    [void] ShowNestedSplitsExample() {
        # Main horizontal split
        $mainSplitContainer = [HorizontalSplit]::new()
        $mainSplitContainer.SplitPosition = 30
        
        # Left side - vertical split
        $leftSplit = [VerticalSplit]::new()
        $leftSplit.SplitPosition = 50  # 50% split
        
        $leftTop = $this.CreateDemoPanel("Left Top", "Nested splits`nenable complex`nlayouts")
        $leftBottom = $this.CreateDemoPanel("Left Bottom", "Each split can`ncontain more splits")
        
        $leftSplit.SetTopChild($leftTop)
        $leftSplit.SetBottomChild($leftBottom)
        $mainSplitContainer.SetLeftChild($leftSplit)
        
        # Right side - another vertical split
        $rightSplit = [VerticalSplit]::new()
        $rightSplit.SplitPosition = 70  # 70% for top
        
        $rightTop = $this.CreateDemoPanel("Right Top", "70% of right side")
        $rightBottom = $this.CreateDemoPanel("Right Bottom", "30% of right side")
        
        $rightSplit.SetTopChild($rightTop)
        $rightSplit.SetBottomChild($rightBottom)
        $mainSplitContainer.SetRightChild($rightSplit)
        
        $this.ExampleArea.AddChild($mainSplitContainer)
    }
    
    [void] ShowMixedLayoutExample() {
        # DockPanel as main container
        $dock = [DockPanel]::new()
        
        # Top toolbar
        $toolbar = $this.CreateDemoPanel("Toolbar", "Docked to top")
        $dock.DockTop($toolbar, 3)
        
        # Status bar at bottom
        $statusBar = $this.CreateDemoPanel("Status Bar", "Docked to bottom")
        $dock.DockBottom($statusBar, 2)
        
        # Main area is a horizontal split
        $mainSplitContainer = [HorizontalSplit]::new()
        $mainSplitContainer.SplitPosition = 25
        
        # Left sidebar uses GridPanel
        $sidebar = [GridPanel]::new()
        $sidebar.Rows = 3
        $sidebar.Columns = 1
        $sidebar.RowHeights = @(0.3, 0.5, 0.2)
        
        $navPanel = $this.CreateDemoPanel("Navigation", "Grid cell 1")
        $sidebar.SetCell(0, 0, $navPanel)
        
        $toolPanel = $this.CreateDemoPanel("Tools", "Grid cell 2")
        $sidebar.SetCell(1, 0, $toolPanel)
        
        $infoPanel = $this.CreateDemoPanel("Info", "Grid cell 3")
        $sidebar.SetCell(2, 0, $infoPanel)
        
        $mainSplitContainer.SetLeftChild($sidebar)
        
        # Right content area
        $content = $this.CreateDemoPanel("Main Content", 
            "Mixed layout example:`n- DockPanel for frame`n- HorizontalSplit for main`n- GridPanel for sidebar")
        $mainSplitContainer.SetRightChild($content)
        
        # Dock the split panel as center fill
        $dock.DockFill($mainSplitContainer)
        
        $this.ExampleArea.AddChild($dock)
    }
    
    [Container] CreateDemoPanel([string]$title, [string]$content) {
        $panel = [Container]::new()
        $panel.DrawBackground = $true
        
        # Title
        $titleElem = [UIElement]::new()
        $titleElem.OnRender = {
            $sb = Get-PooledStringBuilder 256
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 1))
            $sb.Append($theme.GetColor('accent'))
            $sb.Append(" $title")
            $sb.Append([VT]::Reset())
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        
        # Content
        $contentElem = [UIElement]::new()
        $contentElem.OnRender = {
            $sb = Get-PooledStringBuilder 512
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            $lines = $content -split "`n"
            $y = $this.Y + 3
            foreach ($line in $lines) {
                $sb.Append([VT]::MoveTo($this.X + 4, $y))
                $sb.Append($theme.GetColor('normal'))
                $sb.Append($line)
                $y++
            }
            $sb.Append([VT]::Reset())
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        
        # Border
        $borderElem = [UIElement]::new()
        $borderElem.OnRender = {
            if ($this.Parent.Width -lt 10 -or $this.Parent.Height -lt 5) { return "" }
            
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            return [BorderStyle]::RenderBorder(
                $this.Parent.X, $this.Parent.Y, 
                $this.Parent.Width, $this.Parent.Height,
                [BorderType]::Rounded, 
                $theme.GetColor('border')
            )
        }.GetNewClosure()
        
        $panel.AddChild($borderElem)
        $panel.AddChild($titleElem)
        $panel.AddChild($contentElem)
        
        $panel.LayoutChildren = {
            if ($this.Children.Count -ge 3) {
                $this.Children[0].SetBounds($this.X, $this.Y, $this.Width, $this.Height)
                $this.Children[1].SetBounds($this.X, $this.Y, $this.Width, 3)
                $this.Children[2].SetBounds($this.X, $this.Y, $this.Width, $this.Height)
            }
        }
        
        return $panel
    }
    
    [void] OnBoundsChanged() {
        if ($this.MainSplit) {
            $this.MainSplit.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Number shortcuts
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '6') {
            $index = [int]($key.KeyChar - '1')
            if ($index -lt $this.ExampleList.Items.Count) {
                $this.ExampleList.SelectedIndex = $index
                $this.ShowExample($index)
                return $true
            }
        }
        
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/MainScreen.ps1
# MainScreen.ps1 - Main screen with tab container

class MainScreen : Screen {
    [TabContainer]$TabContainer
    [CommandPalette]$CommandPalette
    [EventBus]$EventBus
    hidden [string]$TabChangedSubscription
    
    MainScreen() : base() {
        $this.Title = "PRAXIS"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to tab change events  
        if ($this.EventBus) {
            # Use string directly to avoid potential class loading issues
            $this.TabChangedSubscription = $this.EventBus.Subscribe('navigation.tabChanged', {
                param($sender, $eventData)
                if ($eventData.TabIndex -ne $null -and $this.TabContainer) {
                    $this.TabContainer.ActivateTab($eventData.TabIndex)
                    $this.RequestRender()
                }
            }.GetNewClosure())
        }
        
        # Create tab container
        $this.TabContainer = [TabContainer]::new()
        $this.TabContainer.Initialize($global:ServiceContainer)
        $this.AddChild($this.TabContainer)
        
        # Add real screens as tabs
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Adding tabs to TabContainer")
        }
        
        $projectsScreen = [ProjectsScreen]::new()
        $this.TabContainer.AddTab("Projects", $projectsScreen)
        
        $taskScreen = [TaskScreen]::new()
        $this.TabContainer.AddTab("Tasks", $taskScreen)
        
        $timeEntryScreen = [TimeEntryScreen]::new()
        $this.TabContainer.AddTab("Time", $timeEntryScreen)
        
        $fileBrowserScreen = [FileBrowserScreen]::new()
        $this.TabContainer.AddTab("Files", $fileBrowserScreen)
        
        $textEditorScreen = [TextEditorScreenNew]::new()
        $this.TabContainer.AddTab("Editor", $textEditorScreen)
        
        $commandLibraryScreen = [CommandLibraryScreen]::new()
        $this.TabContainer.AddTab("Commands", $commandLibraryScreen)
        
        $macroFactoryScreen = [VisualMacroFactoryScreen]::new()
        $this.TabContainer.AddTab("Macro Factory", $macroFactoryScreen)
        
        $settingsScreen = [SettingsScreen]::new()
        $this.TabContainer.AddTab("Settings", $settingsScreen)
        
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Added $($this.TabContainer.Tabs.Count) tabs")
        }
        
        # Create command palette (overlay)
        $this.CommandPalette = [CommandPalette]::new()
        $this.CommandPalette.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandPalette)
        
        # Ensure bounds are set if we already have them
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $this.OnBoundsChanged()
        }
        
        # Key bindings now handled by GetShortcutBindings() method
    }
    
    
    [void] OnBoundsChanged() {
        if ($this.TabContainer) {
            # Leave space for border
            $this.TabContainer.SetBounds($this.X + 1, $this.Y + 1, $this.Width - 2, $this.Height - 2)
        }
        if ($this.CommandPalette) {
            # Command palette uses full screen for centering
            $this.CommandPalette.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure bounds are set
        if ($this.Width -eq 0 -or $this.Height -eq 0) {
            $this.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
        }
        
        # Activate the active tab's content screen
        if ($this.TabContainer) {
            $activeTab = $this.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                # Screens are not focusable - call OnActivated instead
                if ($activeTab.Content -is [Screen]) {
                    $activeTab.Content.OnActivated()
                } else {
                    $activeTab.Content.Focus()
                }
            }
        }
    }
    
    # Override to handle global shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Global shortcuts
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Q) {
                # Only handle Q for quit if Ctrl is pressed
                # This prevents conflict with child screens using 'q'
                if ($keyInfo.Modifiers -eq [System.ConsoleModifiers]::Control) {
                    $this.Active = $false  # Exit the main loop
                    return $true
                }
            }
            # Remove Escape handling - let child screens handle it
        }
        
        # Let TabContainer handle tab switching shortcuts (numbers, Ctrl+Tab, etc)
        # This is safe because TabContainer is not focusable, so it won't be in the normal input chain
        if ($this.TabContainer) {
            return $this.TabContainer.HandleInput($keyInfo)
        }
        
        return $false
    }
    
    # Override render to add border
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Draw main screen border
        $theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($theme) {
            $borderColor = $theme.GetColor('border.normal')
            $sb.Append([BorderStyle]::RenderBorder(
                $this.X, $this.Y, $this.Width, $this.Height,
                [BorderType]::Rounded, $borderColor
            ))
        }
        
        # Render base content (which includes TabContainer)
        $sb.Append(([Screen]$this).OnRender())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/MinimalShowcaseScreen.ps1
# MinimalShowcaseScreen.ps1 - Showcase of minimalist UI components

class MinimalShowcaseScreen : Screen {
    hidden [MinimalListBox]$ComponentList
    hidden [Container]$DemoArea
    hidden [MinimalButton]$TestButton
    hidden [MinimalTextBox]$TestInput
    hidden [MinimalListBox]$TestList
    hidden [HorizontalSplit]$MainSplit
    hidden [VerticalSplit]$RightSplit
    
    MinimalShowcaseScreen() : base() {
        $this.Name = "Minimal UI Showcase"
    }
    
    [void] OnInitialize() {
        ([Screen]$this).OnInitialize()
        
        # Create main horizontal split
        $this.MainSplit = [HorizontalSplit]::new()
        $this.MainSplit.SplitPosition = 30
        $this.AddChild($this.MainSplit)
        
        # Left side - component list
        $this.ComponentList = [MinimalListBox]::new()
        $this.ComponentList.ShowBorder = $true
        $this.ComponentList.SetItems(@(
            "Minimal Button",
            "Minimal TextBox", 
            "Minimal ListBox",
            "Focus Navigation",
            "Theme Colors"
        ))
        $this.ComponentList.OnSelectionChanged = {
            $this.ShowDemo($this.ComponentList.SelectedIndex)
        }.GetNewClosure()
        $this.MainSplit.SetLeftChild($this.ComponentList)
        
        # Right side - vertical split for demo area
        $this.RightSplit = [VerticalSplit]::new()
        $this.RightSplit.SplitPosition = -10  # Bottom 10 lines for info
        $this.MainSplit.SetRightChild($this.RightSplit)
        
        # Demo area container
        $this.DemoArea = [Container]::new()
        $this.DemoArea.DrawBackground = $true
        $this.RightSplit.SetTopChild($this.DemoArea)
        
        # Info panel
        $infoPanel = [Container]::new()
        $infoText = [UIElement]::new()
        $infoText.OnRender = {
            $sb = Get-PooledStringBuilder 512
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 2))
            $sb.Append("Tab/Shift+Tab: Navigate  Enter/Space: Activate  1-5: Quick select")
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 3))
            $sb.Append("Focus style: Minimal underline for clean appearance")
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        $infoPanel.AddChild($infoText)
        $this.RightSplit.SetBottomChild($infoPanel)
        
        # Default to first demo
        $this.ComponentList.SelectedIndex = 0
        $this.ShowDemo(0)
    }
    
    [void] ShowDemo([int]$index) {
        # Clear demo area
        $this.DemoArea.Children.Clear()
        
        switch ($index) {
            0 { $this.ShowButtonDemo() }
            1 { $this.ShowTextBoxDemo() }
            2 { $this.ShowListBoxDemo() }
            3 { $this.ShowFocusDemo() }
            4 { $this.ShowThemeDemo() }
        }
        
        $this.DemoArea.Invalidate()
    }
    
    [void] ShowButtonDemo() {
        $container = [VerticalSplit]::new()
        $container.SplitPosition = 10
        
        # Title
        $title = $this.CreateTitle("Minimal Button Demo")
        $container.SetTopChild($title)
        
        # Buttons
        $buttonPanel = [Container]::new()
        
        $btn1 = [MinimalButton]::new("Primary Action")
        $btn1.IsDefault = $true
        $btn1.OnClick = {
            [System.Console]::Beep(800, 100)
        }
        
        $btn2 = [MinimalButton]::new("Secondary")
        $btn2.OnClick = {
            [System.Console]::Beep(600, 100)
        }
        
        $btn3 = [MinimalButton]::new("Cancel")
        $btn3.OnClick = {
            [System.Console]::Beep(400, 100)
        }
        
        $buttonPanel.AddChild($btn1)
        $buttonPanel.AddChild($btn2)
        $buttonPanel.AddChild($btn3)
        
        # Layout buttons
        $buttonPanel.LayoutChildren = {
            $y = $this.Y + 2
            $x = $this.X + 5
            foreach ($child in $this.Children) {
                $child.SetBounds($x, $y, 20, 1)
                $y += 3
            }
        }.GetNewClosure()
        
        $container.SetBottomChild($buttonPanel)
        $this.DemoArea.AddChild($container)
    }
    
    [void] ShowTextBoxDemo() {
        $container = [VerticalSplit]::new()
        $container.SplitPosition = 10
        
        # Title
        $title = $this.CreateTitle("Minimal TextBox Demo")
        $container.SetTopChild($title)
        
        # Input fields
        $inputPanel = [Container]::new()
        
        $input1 = [MinimalTextBox]::new()
        $input1.Placeholder = "Enter your name..."
        
        $input2 = [MinimalTextBox]::new()
        $input2.Placeholder = "Password"
        $input2.IsPassword = $true
        
        $input3 = [MinimalTextBox]::new()
        $input3.Text = "Pre-filled text"
        $input3.MaxLength = 20
        
        $inputPanel.AddChild($input1)
        $inputPanel.AddChild($input2)
        $inputPanel.AddChild($input3)
        
        # Layout inputs
        $inputPanel.LayoutChildren = {
            $y = $this.Y + 2
            $x = $this.X + 5
            foreach ($child in $this.Children) {
                $child.SetBounds($x, $y, 30, 1)
                $y += 3
            }
        }.GetNewClosure()
        
        $container.SetBottomChild($inputPanel)
        $this.DemoArea.AddChild($container)
    }
    
    [void] ShowListBoxDemo() {
        $container = [VerticalSplit]::new()
        $container.SplitPosition = 10
        
        # Title
        $title = $this.CreateTitle("Minimal ListBox Demo")
        $container.SetTopChild($title)
        
        # List box
        $list = [MinimalListBox]::new()
        $list.ShowBorder = $true
        $list.SetItems(@(
            "First Item",
            "Second Item", 
            "Third Item",
            "Fourth Item",
            "Fifth Item",
            "Sixth Item",
            "Seventh Item",
            "Eighth Item",
            "Ninth Item",
            "Tenth Item"
        ))
        
        $container.SetBottomChild($list)
        $this.DemoArea.AddChild($container)
    }
    
    [void] ShowFocusDemo() {
        $panel = [Container]::new()
        
        # Create mixed focusable elements
        $title = $this.CreateTitle("Focus Navigation Demo")
        $panel.AddChild($title)
        
        $btn1 = [MinimalButton]::new("First")
        $btn1.TabIndex = 1
        
        $input1 = [MinimalTextBox]::new()
        $input1.Placeholder = "Second"
        $input1.TabIndex = 2
        
        $btn2 = [MinimalButton]::new("Third")
        $btn2.TabIndex = 3
        
        $list = [MinimalListBox]::new()
        $list.TabIndex = 4
        $list.SetItems(@("Fourth (List)", "Item 2", "Item 3"))
        $list.ShowBorder = $true
        
        $btn3 = [MinimalButton]::new("Fifth")
        $btn3.TabIndex = 5
        
        $panel.AddChild($btn1)
        $panel.AddChild($input1)
        $panel.AddChild($btn2)
        $panel.AddChild($list)
        $panel.AddChild($btn3)
        
        # Layout
        $panel.LayoutChildren = {
            $y = $this.Y + 5
            $x = $this.X + 5
            
            $this.Children[0].SetBounds($x, $this.Y + 2, 40, 3)  # Title
            $this.Children[1].SetBounds($x, $y, 15, 1)      # btn1
            $this.Children[2].SetBounds($x + 20, $y, 25, 1) # input1
            $this.Children[3].SetBounds($x, $y + 3, 15, 1)  # btn2
            $this.Children[4].SetBounds($x, $y + 6, 30, 8)  # list
            $this.Children[5].SetBounds($x, $y + 15, 15, 1) # btn3
        }.GetNewClosure()
        
        $this.DemoArea.AddChild($panel)
    }
    
    [void] ShowThemeDemo() {
        $panel = [Container]::new()
        
        $title = $this.CreateTitle("Theme Color Showcase")
        $panel.AddChild($title)
        
        # Create color display
        $colorDisplay = [UIElement]::new()
        $colorDisplay.OnRender = {
            $sb = Get-PooledStringBuilder 1024
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            
            $colors = @(
                @{name="Focus"; key="focus"},
                @{name="Accent"; key="accent"},
                @{name="Success"; key="success"},
                @{name="Warning"; key="warning"},
                @{name="Error"; key="error"},
                @{name="Border"; key="border"},
                @{name="Selection"; key="selection"}
            )
            
            $y = $this.Y + 5
            foreach ($color in $colors) {
                $sb.Append([VT]::MoveTo($this.X + 5, $y))
                $sb.Append($color.name.PadRight(12))
                $sb.Append($theme.GetColor($color.key))
                $sb.Append("")
                $sb.Append([VT]::Reset())
                $y += 2
            }
            
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        
        $panel.AddChild($colorDisplay)
        $this.DemoArea.AddChild($panel)
    }
    
    [UIElement] CreateTitle([string]$text) {
        $title = [UIElement]::new()
        $title.OnRender = {
            $sb = Get-PooledStringBuilder 256
            $theme = $this.ServiceContainer.GetService('ThemeManager')
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 1))
            $sb.Append($theme.GetColor('accent'))
            $sb.Append(" ")
            $sb.Append($text)
            $sb.Append(" ")
            $sb.Append([VT]::Reset())
            $result = $sb.ToString()
            Return-PooledStringBuilder $sb
            return $result
        }.GetNewClosure()
        return $title
    }
    
    [void] OnBoundsChanged() {
        if ($this.MainSplit) {
            $this.MainSplit.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Number shortcuts for component list
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '5') {
            $index = [int]($key.KeyChar - '1')
            if ($index -lt $this.ComponentList.Items.Count) {
                $this.ComponentList.SelectedIndex = $index
                $this.ShowDemo($index)
                return $true
            }
        }
        
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/NewProjectDialog.ps1
# NewProjectDialog.ps1 - Dialog for creating new projects (refactored to use BaseDialog)

class NewProjectDialog : BaseDialog {
    [MinimalTextBox]$NameBox
    [MinimalTextBox]$NicknameBox
    [MinimalTextBox]$ID1Box
    [MinimalTextBox]$ID2Box
    [MinimalTextBox]$NotesBox
    [MinimalTextBox]$CAAPathBox
    [MinimalTextBox]$RequestPathBox
    [MinimalTextBox]$T2020PathBox
    [MinimalTextBox]$DueDateBox
    
    NewProjectDialog() : base("New Project") {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 30
    }
    
    [void] InitializeContent() {
        # Create all project input fields
        $this.NameBox = [MinimalTextBox]::new()
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [MinimalTextBox]::new()
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [MinimalTextBox]::new()
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [MinimalTextBox]::new()
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NotesBox = [MinimalTextBox]::new()
        $this.NotesBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NotesBox, 5)
        
        $this.CAAPathBox = [MinimalTextBox]::new()
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [MinimalTextBox]::new()
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [MinimalTextBox]::new()
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [MinimalTextBox]::new()
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.DueDateBox.Text = ([DateTime]::Now.AddDays(42)).ToString("MM/dd/yyyy")
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = [DateTime]::Now.AddDays(42)
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Use default if parsing fails
                        $dueDate = [DateTime]::Now.AddDays(42)
                    }
                }
                
                $projectData = @{
                    FullProjectName = $dialog.NameBox.Text
                    Nickname = if ($dialog.NicknameBox.Text.Trim()) { $dialog.NicknameBox.Text } else { $dialog.NameBox.Text }
                    ID1 = $dialog.ID1Box.Text
                    ID2 = $dialog.ID2Box.Text
                    Note = $dialog.NotesBox.Text
                    CAAPath = $dialog.CAAPathBox.Text
                    RequestPath = $dialog.RequestPathBox.Text
                    T2020Path = $dialog.T2020PathBox.Text
                    DateDue = $dueDate
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create project via service
                    $projectService = $global:ServiceContainer.GetService("ProjectService")
                    if ($projectService) {
                        # Create project with full data
                        $newProject = $projectService.AddProject($projectData.FullProjectName, $projectData.Nickname)
                        
                        # Update additional properties
                        $newProject.ID1 = $projectData.ID1
                        $newProject.ID2 = $projectData.ID2
                        $newProject.Note = $projectData.Note
                        $newProject.CAAPath = $projectData.CAAPath
                        $newProject.RequestPath = $projectData.RequestPath
                        $newProject.T2020Path = $projectData.T2020Path
                        $newProject.DateDue = $projectData.DateDue
                        
                        # Save the updated project
                        $projectService.SaveProject($newProject)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::ProjectCreated, @{ 
                            Project = $newProject 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewProjectDialog'
                        Action = 'Create'
                        Data = $projectData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $projectData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewProjectDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 3)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 3)
        $currentY += 3
        
        $this.NotesBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
        $currentY += 3
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 3)
    }
}


####\Screens/NewTaskDialog.ps1
# NewTaskDialog.ps1 - Dialog for creating new tasks (refactored to use BaseDialog)

class NewTaskDialog : BaseDialog {
    [MinimalTextBox]$TitleBox
    [MinimalTextBox]$DescriptionBox
    [MinimalListBox]$PriorityList
    
    NewTaskDialog() : base("New Task", 50, 18) {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create title textbox
        $this.TitleBox = [MinimalTextBox]::new()
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.AddContentControl($this.TitleBox, 1)
        
        # Create description textbox
        $this.DescriptionBox = [MinimalTextBox]::new()
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.AddContentControl($this.DescriptionBox, 2)
        
        # Create priority list
        $this.PriorityList = [MinimalListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.SetItems(@("Low", "Medium", "High"))
        $this.PriorityList.SelectIndex(1)  # Default to Medium
        $this.AddContentControl($this.PriorityList, 3)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.TitleBox.Text.Trim()) {
                # Get selected priority
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $priority = switch ($selectedPriority) {
                    "Low" { [TaskPriority]::Low }
                    "High" { [TaskPriority]::High }
                    default { [TaskPriority]::Medium }
                }
                
                $taskData = @{
                    Title = $dialog.TitleBox.Text.Trim()
                    Description = $dialog.DescriptionBox.Text.Trim()
                    Priority = $priority
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create task via service
                    $taskService = $global:ServiceContainer.GetService("TaskService")
                    if ($taskService) {
                        $newTask = $taskService.CreateTask($taskData)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::TaskCreated, @{ 
                            Task = $newTask 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewTaskDialog'
                        Action = 'Create'
                        Data = $taskData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $taskData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewTaskDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for task dialog controls
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        
        # Title box
        $this.TitleBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 2, 
            $controlWidth, 
            3
        )
        
        # Description box
        $this.DescriptionBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 6, 
            $controlWidth, 
            3
        )
        
        # Priority list
        $this.PriorityList.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 10, 
            $controlWidth, 
            5
        )
    }
}


####\Screens/NumberInputDialog.ps1
# NumberInputDialog.ps1 - Simple dialog for numeric input

class NumberInputDialog : Screen {
    [string]$Prompt
    [decimal]$DefaultValue
    [decimal]$MinValue
    [decimal]$MaxValue
    [bool]$AllowDecimals
    [MinimalTextBox]$InputBox
    [MinimalButton]$OkButton
    [MinimalButton]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    NumberInputDialog([string]$prompt) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = 0
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    NumberInputDialog([string]$prompt, [decimal]$defaultValue) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [MinimalTextBox]::new()
        $this.InputBox.Text = $this.DefaultValue.ToString()
        $this.InputBox.Placeholder = if ($this.AllowDecimals) { "0.00" } else { "0" }
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [MinimalButton]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            $value = [decimal]0
            if ([decimal]::TryParse($dialog.InputBox.Text, [ref]$value)) {
                # Validate range
                if ($value -lt $dialog.MinValue) {
                    $value = $dialog.MinValue
                } elseif ($value -gt $dialog.MaxValue) {
                    $value = $dialog.MaxValue
                }
                
                # Round if no decimals allowed
                if (-not $dialog.AllowDecimals) {
                    $value = [Math]::Round($value)
                }
                
                if ($dialog.OnSubmit) {
                    & $dialog.OnSubmit $value
                }
            }
            # If parse fails, don't submit
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [MinimalButton]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box
        $this.InputBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 11 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
            
            # Draw constraints if any
            $constraintY = $y + 2 + $promptLines.Count + 4
            $sb.Append([VT]::MoveTo($x + 2, $constraintY))
            $sb.Append($this.Theme.GetColor("disabled"))
            $constraints = @()
            if ($this.MinValue -ne [decimal]::MinValue) {
                $constraints += "Min: $($this.MinValue)"
            }
            if ($this.MaxValue -ne [decimal]::MaxValue) {
                $constraints += "Max: $($this.MaxValue)"
            }
            if (-not $this.AllowDecimals) {
                $constraints += "Integers only"
            }
            if ($constraints.Count -gt 0) {
                $sb.Append($constraints -join " | ")
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ProjectDetailScreen.ps1
# ProjectDetailScreen - Detailed project view with time tracking information
# Redesigned to follow PRAXIS architecture standards using DockPanel and components

class ProjectDetailScreen : Screen {
    [Project]$Project = $null
    [System.Collections.ArrayList]$TimeEntries
    
    # PRAXIS Architecture Components
    [DockPanel]$MainLayout
    [ListBox]$ProjectInfoPanel
    [DataGrid]$WeeklySummaryGrid  
    [DataGrid]$TimeEntriesGrid
    
    # Services
    [ThemeManager]$ThemeManager
    [EventBus]$EventBus
    
    ProjectDetailScreen() : base() {
        $this.Title = "Project Details"
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    ProjectDetailScreen([Project]$project) : base() {
        $this.Title = "Project Details - $($project.Nickname)"
        $this.Project = $project
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services through proper dependency injection
        $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Load time entries if we have a project
        if ($this.Project) {
            $this.LoadTimeEntries()
        }
        
        # Create main DockPanel layout
        $this.MainLayout = [DockPanel]::new()
        $this.MainLayout.Initialize($this.ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Create project info panel (top section)
        $this.CreateProjectInfoPanel()
        
        # Create weekly summary grid (middle section)
        $this.CreateWeeklySummaryGrid()
        
        # Create time entries grid (fill remaining space)
        $this.CreateTimeEntriesGrid()
        
        # Update title
        if ($this.Project) {
            $this.Title = "Project Details - $($this.Project.Nickname)"
        }
        
        # Populate data
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
    }
    
    [void] CreateProjectInfoPanel() {
        $this.ProjectInfoPanel = [ListBox]::new()
        $this.ProjectInfoPanel.Initialize($this.ServiceContainer)
        $this.ProjectInfoPanel.ShowBorder = $true
        $this.ProjectInfoPanel.Title = "Project Information"
        $this.ProjectInfoPanel.IsFocusable = $false  # Read-only display
        
        # Dock to top with a specific height
        $this.MainLayout.SetChildDock($this.ProjectInfoPanel, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.ProjectInfoPanel, 35)  # Allow plenty of space for all fields
        $this.MainLayout.AddChild($this.ProjectInfoPanel)
    }
    
    [void] CreateWeeklySummaryGrid() {
        $this.WeeklySummaryGrid = [DataGrid]::new()
        $this.WeeklySummaryGrid.Initialize($this.ServiceContainer)
        $this.WeeklySummaryGrid.ShowHeader = $true
        $this.WeeklySummaryGrid.ShowBorder = $true
        $this.WeeklySummaryGrid.Title = "Weekly Hours Summary"
        $this.WeeklySummaryGrid.IsFocusable = $false  # Read-only display
        
        # Set up columns for weekly summary
        $columns = @(
            @{ Name = "WeekOf"; Header = "Week of"; Width = 12; Getter = { param($item) $item.WeekOf } }
            @{ Name = "Monday"; Header = "Mon"; Width = 7; Getter = { param($item) $item.Monday.ToString("F1") } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 7; Getter = { param($item) $item.Tuesday.ToString("F1") } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 7; Getter = { param($item) $item.Wednesday.ToString("F1") } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 7; Getter = { param($item) $item.Thursday.ToString("F1") } }
            @{ Name = "Friday"; Header = "Fri"; Width = 7; Getter = { param($item) $item.Friday.ToString("F1") } }
            @{ Name = "Total"; Header = "Total"; Width = 8; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.WeeklySummaryGrid.SetColumns($columns)
        
        # Dock to top (after project info) with a specific height
        $this.MainLayout.SetChildDock($this.WeeklySummaryGrid, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.WeeklySummaryGrid, 8)  # Weekly summary doesn't need much space
        $this.MainLayout.AddChild($this.WeeklySummaryGrid)
    }
    
    [void] CreateTimeEntriesGrid() {
        $this.TimeEntriesGrid = [DataGrid]::new()
        $this.TimeEntriesGrid.Initialize($this.ServiceContainer)
        $this.TimeEntriesGrid.ShowHeader = $true
        $this.TimeEntriesGrid.ShowBorder = $true
        $this.TimeEntriesGrid.Title = "Time Entries - [A]dd [E]dit [D]elete [R]efresh"
        $this.TimeEntriesGrid.IsFocusable = $true  # Interactive
        
        # Set up columns for time entries
        $screen = $this  # Capture reference for closure
        $columns = @(
            @{ Name = "Date"; Header = "Date"; Width = 12; Getter = { param($item) $screen.FormatDate($item.Date) }.GetNewClosure() }
            @{ Name = "Hours"; Header = "Hours"; Width = 8; Getter = { param($item) [double]::Parse($item.Total).ToString("F2") } }
            @{ Name = "Description"; Header = "Description"; Width = 40; Getter = { param($item) if ($item.Description) { $item.Description } else { "No description" } } }
        )
        $this.TimeEntriesGrid.SetColumns($columns)
        
        # Set up selection changed handler
        $screen = $this  # Capture reference for closure
        $this.TimeEntriesGrid.OnSelectionChanged = {
            # Handle selection changes if needed
        }.GetNewClosure()
        
        # Fill remaining space
        $this.MainLayout.SetChildDock($this.TimeEntriesGrid, [DockPosition]::Fill)
        $this.MainLayout.AddChild($this.TimeEntriesGrid)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus the time entries grid which is the main interactive component
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # DockPanel handles layout automatically
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] LoadTimeEntries() {
        # This would load time entries from the tracker system
        # For now, creating sample data based on the tracker.txt structure
        $this.TimeEntries.Clear()
        
        # Sample time entries (in production, this would load from actual data)
        $sampleEntries = @(
            @{
                Date = "20241201"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = "8.00"
                TueHours = ""
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "8.00"
                Description = "Initial project setup and requirements gathering"
            },
            @{
                Date = "20241202"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = "6.50"
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "6.50"
                Description = "Development work on core features"
            },
            @{
                Date = "20241203"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = ""
                WedHours = "7.25"
                ThuHours = ""
                FriHours = ""
                Total = "7.25"
                Description = "Testing and bug fixes"
            }
        )
        
        foreach ($entry in $sampleEntries) {
            $this.TimeEntries.Add([PSCustomObject]$entry) | Out-Null
        }
    }
    
    [void] PopulateProjectInfo() {
        if (-not $this.Project -or -not $this.ProjectInfoPanel) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: Project type = $($this.Project.GetType().Name)")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: AuditType = '$($this.Project.AuditType)'")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: ClientID = '$($this.Project.ClientID)'")
        }
        
        $infoItems = [System.Collections.ArrayList]::new()
        
        # === BASIC PROJECT INFORMATION ===
        $infoItems.Add("=== PROJECT IDENTIFICATION ===") | Out-Null
        $infoItems.Add("Nickname: $($this.Project.Nickname)") | Out-Null
        $infoItems.Add("Full Name: $($this.Project.FullProjectName)") | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen: Showing $($infoItems.Count) items so far")
        }
        
        # IDs
        if ($this.Project.ID1) {
            $infoItems.Add("Client Code (ID1): $($this.Project.ID1)") | Out-Null
        }
        if ($this.Project.ID2) {
            $infoItems.Add("CAS Case# (ID2): $($this.Project.ID2)") | Out-Null
        }
        if ($this.Project.ClientID) {
            $infoItems.Add("Client ID: $($this.Project.ClientID)") | Out-Null
        }
        
        # === AUDIT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDIT INFORMATION ===") | Out-Null
        if ($this.Project.AuditType) {
            $infoItems.Add("Audit Type: $($this.Project.AuditType)") | Out-Null
        }
        if ($this.Project.AuditProgram) {
            $infoItems.Add("Audit Program: $($this.Project.AuditProgram)") | Out-Null
        }
        if ($this.Project.AuditCase) {
            $infoItems.Add("Audit Case: $($this.Project.AuditCase)") | Out-Null
        }
        
        # Audit Dates
        if ($this.Project.AuditStartDate -and $this.Project.AuditStartDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Start Date: $($this.FormatDate($this.Project.AuditStartDate))") | Out-Null
        }
        if ($this.Project.AuditPeriodFrom -and $this.Project.AuditPeriodFrom -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period From: $($this.FormatDate($this.Project.AuditPeriodFrom))") | Out-Null
        }
        if ($this.Project.AuditPeriodTo -and $this.Project.AuditPeriodTo -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period To: $($this.FormatDate($this.Project.AuditPeriodTo))") | Out-Null
        }
        
        # Additional Audit Periods
        $hasAuditPeriods = $false
        for ($i = 1; $i -le 5; $i++) {
            $startProp = "AuditPeriod${i}Start"
            $endProp = "AuditPeriod${i}End"
            if ($this.Project.$startProp -ne [DateTime]::MinValue -or $this.Project.$endProp -ne [DateTime]::MinValue) {
                if (-not $hasAuditPeriods) {
                    $infoItems.Add("Additional Audit Periods:") | Out-Null
                    $hasAuditPeriods = $true
                }
                $start = if ($this.Project.$startProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$startProp) } else { "N/A" }
                $end = if ($this.Project.$endProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$endProp) } else { "N/A" }
                $infoItems.Add("  Period ${i}: $start to $end") | Out-Null
            }
        }
        
        # === PROJECT DATES ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== PROJECT DATES ===") | Out-Null
        if ($this.Project.RequestDate -and $this.Project.RequestDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Data Requested: $($this.FormatDate($this.Project.RequestDate))") | Out-Null
        }
        if ($this.Project.DateAssigned) {
            $infoItems.Add("Date Assigned: $($this.FormatDate($this.Project.DateAssigned))") | Out-Null
        }
        if ($this.Project.BFDate -and $this.Project.BFDate -ne [DateTime]::MinValue) {
            $infoItems.Add("BF Date: $($this.FormatDate($this.Project.BFDate))") | Out-Null
        }
        if ($this.Project.DateDue) {
            $infoItems.Add("Due Date: $($this.FormatDate($this.Project.DateDue))") | Out-Null
        }
        if ($this.Project.ClosedDate -and $this.Project.ClosedDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Completed: $($this.FormatDate($this.Project.ClosedDate))") | Out-Null
        }
        
        # === CLIENT LOCATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CLIENT LOCATION ===") | Out-Null
        if ($this.Project.Address) {
            $infoItems.Add("Address: $($this.Project.Address)") | Out-Null
        }
        if ($this.Project.City -or $this.Project.Province -or $this.Project.PostalCode) {
            $location = @()
            if ($this.Project.City) { $location += $this.Project.City }
            if ($this.Project.Province) { $location += $this.Project.Province }
            if ($this.Project.PostalCode) { $location += $this.Project.PostalCode }
            $infoItems.Add("City/Prov/Postal: $($location -join ', ')") | Out-Null
        }
        if ($this.Project.Country) {
            $infoItems.Add("Country: $($this.Project.Country)") | Out-Null
        }
        if ($this.Project.ShipToAddress) {
            $infoItems.Add("Ship To Address: $($this.Project.ShipToAddress)") | Out-Null
        }
        
        # === AUDITOR INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDITOR INFORMATION ===") | Out-Null
        if ($this.Project.AuditorName) {
            $infoItems.Add("Auditor: $($this.Project.AuditorName)") | Out-Null
        }
        if ($this.Project.AuditorPhone) {
            $infoItems.Add("Auditor Phone: $($this.Project.AuditorPhone)") | Out-Null
        }
        if ($this.Project.AuditorTL) {
            $infoItems.Add("Team Lead: $($this.Project.AuditorTL)") | Out-Null
        }
        if ($this.Project.AuditorTLPhone) {
            $infoItems.Add("Team Lead Phone: $($this.Project.AuditorTLPhone)") | Out-Null
        }
        
        # === CONTACT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CONTACT INFORMATION ===") | Out-Null
        # Contact 1
        if ($this.Project.Contact1Name) {
            $infoItems.Add("Contact 1:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact1Name)") | Out-Null
            if ($this.Project.Contact1Title) { $infoItems.Add("  Title: $($this.Project.Contact1Title)") | Out-Null }
            if ($this.Project.Contact1Phone) { 
                $phone = $this.Project.Contact1Phone
                if ($this.Project.Contact1Ext) { $phone += " x$($this.Project.Contact1Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact1Address) { $infoItems.Add("  Address: $($this.Project.Contact1Address)") | Out-Null }
        }
        # Contact 2
        if ($this.Project.Contact2Name) {
            $infoItems.Add("Contact 2:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact2Name)") | Out-Null
            if ($this.Project.Contact2Title) { $infoItems.Add("  Title: $($this.Project.Contact2Title)") | Out-Null }
            if ($this.Project.Contact2Phone) { 
                $phone = $this.Project.Contact2Phone
                if ($this.Project.Contact2Ext) { $phone += " x$($this.Project.Contact2Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact2Address) { $infoItems.Add("  Address: $($this.Project.Contact2Address)") | Out-Null }
        }
        
        # === SYSTEM INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== SYSTEM INFORMATION ===") | Out-Null
        if ($this.Project.AccountingSoftware1) {
            $sw1 = $this.Project.AccountingSoftware1
            if ($this.Project.AccountingSoftware1Other) { $sw1 += " ($($this.Project.AccountingSoftware1Other))" }
            if ($this.Project.AccountingSoftware1Type) { $sw1 += " - $($this.Project.AccountingSoftware1Type)" }
            $infoItems.Add("Accounting Software 1: $sw1") | Out-Null
        }
        if ($this.Project.AccountingSoftware2) {
            $sw2 = $this.Project.AccountingSoftware2
            if ($this.Project.AccountingSoftware2Other) { $sw2 += " ($($this.Project.AccountingSoftware2Other))" }
            if ($this.Project.AccountingSoftware2Type) { $sw2 += " - $($this.Project.AccountingSoftware2Type)" }
            $infoItems.Add("Accounting Software 2: $sw2") | Out-Null
        }
        
        # === STATUS AND TOTALS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== STATUS AND HOURS ===") | Out-Null
        $status = if ($this.Project.Status) { $this.Project.Status } else { "Active" }
        $infoItems.Add("Status: $status") | Out-Null
        
        # Show cumulative hours from Excel import
        if ($this.Project.CumulativeHrs -gt 0) {
            $infoItems.Add("Cumulative Hours (from import): $($this.Project.CumulativeHrs.ToString('F2'))") | Out-Null
        }
        
        $totalHours = $this.CalculateTotalHours()
        $infoItems.Add("Total Hours (tracked): $($totalHours.ToString('F2'))") | Out-Null
        
        # === FILE PATHS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== FILE PATHS ===") | Out-Null
        if ($this.Project.CAAPath) {
            $infoItems.Add("CAA Path: $($this.Project.CAAPath)") | Out-Null
        }
        if ($this.Project.RequestPath) {
            $infoItems.Add("Request Path: $($this.Project.RequestPath)") | Out-Null
        }
        if ($this.Project.T2020Path) {
            $infoItems.Add("T2020 Path: $($this.Project.T2020Path)") | Out-Null
        }
        
        # === ADDITIONAL INFORMATION ===
        if ($this.Project.FXInfo -or $this.Project.Comments -or $this.Project.Note) {
            $infoItems.Add("") | Out-Null
            $infoItems.Add("=== ADDITIONAL INFORMATION ===") | Out-Null
            
            if ($this.Project.FXInfo) {
                $infoItems.Add("FX Info: $($this.Project.FXInfo)") | Out-Null
            }
            if ($this.Project.Comments) {
                $infoItems.Add("Comments: $($this.Project.Comments)") | Out-Null
            }
            if ($this.Project.Note) {
                $infoItems.Add("Notes: $($this.Project.Note)") | Out-Null
            }
        }
        
        $this.ProjectInfoPanel.SetItems($infoItems)
    }
    
    [void] PopulateWeeklySummary() {
        if (-not $this.WeeklySummaryGrid) {
            return
        }
        
        $weeklyData = $this.CalculateWeeklySummary()
        $this.WeeklySummaryGrid.SetItems($weeklyData)
    }
    
    [void] PopulateTimeEntries() {
        if (-not $this.TimeEntriesGrid) {
            return
        }
        
        # Sort entries by date (most recent first)
        $sortedEntries = $this.TimeEntries | Sort-Object { [DateTime]::ParseExact($_.Date, "yyyyMMdd", $null) } -Descending
        $this.TimeEntriesGrid.SetItems($sortedEntries)
    }
    
    [string] FormatDate([string]$dateStr) {
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Not set"
        }
        
        try {
            if ($dateStr.Length -eq 8) {
                # YYYYMMDD format
                $date = [DateTime]::ParseExact($dateStr, "yyyyMMdd", $null)
                return $date.ToString("MM/dd/yyyy")
            } else {
                # Try parsing as DateTime
                $date = [DateTime]::Parse($dateStr)
                return $date.ToString("MM/dd/yyyy")
            }
        } catch {
            return $dateStr
        }
    }
    
    [string] FormatDate([DateTime]$date) {
        if ($date -eq [DateTime]::MinValue) {
            return "Not set"
        }
        return $date.ToString("MM/dd/yyyy")
    }
    
    [double] CalculateTotalHours() {
        $total = 0.0
        foreach ($entry in $this.TimeEntries) {
            try {
                $hours = [double]::Parse($entry.Total)
                $total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        return $total
    }
    
    [System.Collections.ArrayList] CalculateWeeklySummary() {
        $weeks = @{}
        
        foreach ($entry in $this.TimeEntries) {
            try {
                $entryDate = [DateTime]::ParseExact($entry.Date, "yyyyMMdd", $null)
                $monday = $entryDate.AddDays(-([int]$entryDate.DayOfWeek - 1))
                $weekKey = $monday.ToString("MM/dd/yyyy")
                
                if (-not $weeks.ContainsKey($weekKey)) {
                    $weeks[$weekKey] = @{
                        WeekOf = $weekKey
                        Monday = 0.0
                        Tuesday = 0.0
                        Wednesday = 0.0
                        Thursday = 0.0
                        Friday = 0.0
                        Total = 0.0
                    }
                }
                
                # Add hours to appropriate day
                $dayOfWeek = $entryDate.DayOfWeek.ToString()
                $hours = [double]::Parse($entry.Total)
                
                switch ($dayOfWeek) {
                    "Monday" { $weeks[$weekKey].Monday += $hours }
                    "Tuesday" { $weeks[$weekKey].Tuesday += $hours }
                    "Wednesday" { $weeks[$weekKey].Wednesday += $hours }
                    "Thursday" { $weeks[$weekKey].Thursday += $hours }
                    "Friday" { $weeks[$weekKey].Friday += $hours }
                }
                
                $weeks[$weekKey].Total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        
        $weeklyData = [System.Collections.ArrayList]::new()
        foreach ($week in $weeks.Values) {
            $weeklyData.Add([PSCustomObject]$week) | Out-Null
        }
        
        # Sort by week date (most recent first) and ensure ArrayList type
        $sortedData = $weeklyData | Sort-Object { [DateTime]::Parse($_.WeekOf) } -Descending
        $result = [System.Collections.ArrayList]::new()
        foreach ($item in $sortedData) {
            $result.Add($item) | Out-Null
        }
        return $result
    }
    
    [void] AddTimeEntry() {
        if (-not $this.Project) {
            return
        }
        
        # Create time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project)
        
        # Set up callback for when entry is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Add to local time entries collection
            $screen.TimeEntries.Add($timeEntryData) | Out-Null
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] EditSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.EditTimeEntry($selected)
    }
    
    [void] EditTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $this.Project -or -not $timeEntry) {
            return
        }
        
        # Create edit time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project, $timeEntry)
        
        # Set up callback for when entry is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Find and replace in local collection
            for ($i = 0; $i -lt $screen.TimeEntries.Count; $i++) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries[$i] = $timeEntryData
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] DeleteSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.DeleteTimeEntry($selected)
    }
    
    [void] DeleteTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $timeEntry) {
            return
        }
        
        # Show confirmation dialog
        $message = "Delete time entry for $($this.FormatDate($timeEntry.Date)) ($($timeEntry.Total) hours)?"
        $dialog = [ConfirmationDialog]::new($message)
        
        $screen = $this  # Capture reference for closure
        $dialog.OnConfirm = {
            # Remove from local collection
            for ($i = $screen.TimeEntries.Count - 1; $i -ge 0; $i--) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries.RemoveAt($i)
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] RefreshData() {
        # Reload time entries
        $this.LoadTimeEntries()
        
        # Refresh all displays
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
        
        # Focus the time entries grid
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle character shortcuts
        if ($keyInfo.KeyChar) {
            switch ($keyInfo.KeyChar) {
                'r' {
                    # Refresh/reload data
                    $this.RefreshData()
                    return $true
                }
                'a' {
                    # Add new time entry
                    $this.AddTimeEntry()
                    return $true
                }
                'e' {
                    # Edit selected time entry
                    $this.EditSelectedTimeEntry()
                    return $true
                }
                'd' {
                    # Delete selected time entry
                    $this.DeleteSelectedTimeEntry()
                    return $true
                }
            }
        }
        
        # Handle ESC to go back
        if ($keyInfo.Key -eq [System.ConsoleKey]::Escape) {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
            return $true
        }
        
        # Let base class handle other input (like tab switching and navigation)
        return $false
    }
}


####\Screens/ProjectsScreen.ps1
# ProjectsScreen.ps1 - Project management screen using DataGrid component

class ProjectsScreen : Screen {
    [MinimalDataGrid]$ProjectGrid
    # Buttons removed - using keyboard shortcuts only
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout - buttons removed
    
    ProjectsScreen() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to project created events with explicit closure
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe('project.created', {
                param($sender, $eventData)
                $screen.RefreshProjects()
                # Select the new project if provided
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe('command.executed', {
                param($sender, $eventData)
                if ($eventData.Target -eq 'ProjectsScreen') {
                    switch ($eventData.Command) {
                        'EditProject' { $screen.EditProject() }
                        'DeleteProject' { $screen.DeleteProject() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe('project.updated', {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe('project.deleted', {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create MinimalDataGrid with columns
        $this.ProjectGrid = [MinimalDataGrid]::new()
        $this.ProjectGrid.Title = "Projects"
        $this.ProjectGrid.ShowBorder = $false  # MainScreen draws the border
        $this.ProjectGrid.BorderType = [BorderType]::None
        
        # Define columns with proper formatting
        $columns = @(
            @{
                Name = "Status"
                Header = "Sts"
                Width = 3
                Getter = {
                    param($project)
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[]" } else { "[ ]" }
                }
            },
            @{
                Name = "FullProjectName"
                Header = "Project Name"
                Width = 0  # Flexible width - will auto-size
            },
            @{
                Name = "ID1"
                Header = "ID1"
                Width = 5
            },
            @{
                Name = "ID2"
                Header = "ID2"
                Width = 9
            },
            @{
                Name = "DateAssigned"
                Header = "Assigned"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            },
            @{
                Name = "DateDue"
                Header = "Due"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Buttons removed - use keyboard shortcuts instead
        # n - New Project
        # e - Edit Project
        # d - Delete Project
        # Enter - View Details
        
        # Load projects
        $this.LoadProjects()
        
        # Register screen-specific shortcuts with ShortcutManager
        $this.RegisterShortcuts()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("ProjectsScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.new"
            Name = "New Project"
            Description = "Create a new project"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.NewProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.edit"
            Name = "Edit Project"
            Description = "Edit the selected project"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.EditProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.delete"
            Name = "Delete Project"
            Description = "Delete the selected project"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.DeleteProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.refresh"
            Name = "Refresh"
            Description = "Refresh the project list"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.LoadProjects() }.GetNewClosure()
        })
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.RegisterShortcuts: Registered shortcuts for 'n', 'e', 'd', etc.")
        }
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnActivated: Screen activated with new focus system")
        }
        
        # Add defensive null checks
        try {
            # Focus the grid if it has items, otherwise the New button
            if ($global:Logger) {
                $projectGridNull = ($this.ProjectGrid -eq $null)
                $itemsCount = if ($this.ProjectGrid -and $this.ProjectGrid.Items) { $this.ProjectGrid.Items.Count } else { 0 }
                $global:Logger.Debug("ProjectsScreen focus check: ProjectGrid=$(!$projectGridNull), Items=$itemsCount")
            }
            
            if ($this.ProjectGrid) {
                $this.ProjectGrid.Focus()
            } else {
                if ($global:Logger) {
                    $global:Logger.Debug("ProjectsScreen: No focusable element found!")
                }
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ProjectsScreen.OnActivated: Error during focus - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Debug
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Grid takes full space now that buttons are removed
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $this.Height
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date
        $sorted = $activeProjects | Sort-Object DateDue
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        # Reload projects and update display
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.NewProject() called")
        }
        # Create new project dialog
        $dialog = [NewProjectDialog]::new()
        
        # EventBus will handle project creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                
                # Create nickname from name
                # Create project using single-parameter constructor
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                # Select the new project
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit project dialog
        $dialog = [EditProjectDialog]::new($selected)
        # Capture references
        $screen = $this
        $project = $selected
        $dialog.OnPrimary = {
            # Get the data from the dialog
            $projectData = @{
                FullProjectName = $dialog.NameBox.Text
                Nickname = $dialog.NicknameBox.Text
                Note = $dialog.NoteBox.Text
                DateDue = $dialog.DueDateBox.Text
            }
            
            # Update the project
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            # Save through service
            $screen.ProjectService.UpdateProject($project)
            
            # Publish project updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                # Fallback if EventBus not available
                $screen.LoadProjects()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Show confirmation dialog
            $message = "Are you sure you want to delete project '$($selected.FullProjectName)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            $dialog.OnConfirm = {
                # Delete the project
                $screen.ProjectService.DeleteProject($projectId)
                
                # Publish project deleted event
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    # Fallback if EventBus not available
                    $screen.LoadProjects()
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.ViewProjectDetails() called")
        }
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Create and show project detail screen
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    # Using parent-delegated focus model - Tab handled by ScreenManager/Container
    
    # Override HandleScreenInput instead of HandleInput to work with base Screen class
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Screen-specific shortcuts - only called as fallback by base Screen class
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'N' key pressed, calling NewProject")
                    }
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'E' key pressed, calling EditProject")
                    }
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'V' -or $key.KeyChar -eq 'v')) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadProjects()
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        # If no shortcut matched, return false (let base Screen handle it)
        return $false
    }
}


####\Screens/ProjectsScreenEnhanced.ps1
# ProjectsScreenEnhanced.ps1 - Project management screen with DataGrid

class ProjectsScreenEnhanced : Screen {
    [DataGrid]$ProjectGrid
    [Button]$NewButton
    [Button]$ViewButton
    [Button]$EditButton
    [Button]$DeleteButton
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    ProjectsScreenEnhanced() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to project created events
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe([EventNames]::ProjectCreated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe([EventNames]::ProjectUpdated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe([EventNames]::ProjectDeleted, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create project data grid
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Project List"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowHeader = $true
        $this.ProjectGrid.IsFocusable = $true
        
        # Define columns
        $columns = @(
            @{ 
                Name = "Status"
                Header = "Status"
                Width = 8
                Getter = { 
                    param($project) 
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[Done]" } 
                    else { "[Open]" }
                }
            }
            @{ 
                Name = "Name"
                Header = "Project Name"
                Width = 25
                Getter = { param($project) $project.Nickname }
            }
            @{ 
                Name = "ID1"
                Header = "ID1"
                Width = 10
                Getter = { 
                    param($project) 
                    if ($project.ID1) { $project.ID1 } else { "-" }
                }
            }
            @{ 
                Name = "ID2"
                Header = "ID2"
                Width = 15
                Getter = { 
                    param($project) 
                    if ($project.ID2) { $project.ID2 } else { "-" }
                }
            }
            @{ 
                Name = "Client"
                Header = "Client"
                Width = 20
                Getter = { 
                    param($project) 
                    if ($project.Name) { $project.Name } else { "-" }
                }
            }
            @{ 
                Name = "Assigned"
                Header = "Assigned"
                Width = 10
                Getter = { 
                    param($project) 
                    $project.DateAssigned.ToString("MM/dd/yy")
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Create buttons
        $screen = $this
        
        $this.NewButton = [Button]::new("New Project")
        $this.NewButton.IsDefault = $true
        $this.NewButton.OnClick = { $screen.NewProject() }.GetNewClosure()
        $this.NewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.NewButton)
        
        $this.ViewButton = [Button]::new("View Details")
        $this.ViewButton.OnClick = { $screen.ViewProjectDetails() }.GetNewClosure()
        $this.ViewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ViewButton)
        
        $this.EditButton = [Button]::new("Edit")
        $this.EditButton.OnClick = { $screen.EditProject() }.GetNewClosure()
        $this.EditButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.EditButton)
        
        $this.DeleteButton = [Button]::new("Delete")
        $this.DeleteButton.OnClick = { $screen.DeleteProject() }.GetNewClosure()
        $this.DeleteButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.DeleteButton)
        
        # Load projects
        $this.LoadProjects()
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus the grid if it has items, otherwise the New button
        if ($this.ProjectGrid -and $this.ProjectGrid.Items.Count -gt 0) {
            $this.ProjectGrid.Focus()
        } elseif ($this.NewButton) {
            $this.NewButton.Focus()
        }
    }
    
    [void] OnDeactivated() {
        ([Screen]$this).OnDeactivated()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes most space, buttons at bottom
        $buttonAreaHeight = $this.ButtonHeight + 2
        $gridHeight = $this.Height - $buttonAreaHeight
        
        # Project grid
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $gridHeight
        )
        
        # Buttons (horizontally arranged)
        $maxButtonWidth = 20
        $totalButtonWidth = ($maxButtonWidth * 4) + ($this.ButtonSpacing * 3)
        
        if ($this.Width -gt $totalButtonWidth) {
            $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $this.X
            $buttonWidth = [int](($this.Width - ($this.ButtonSpacing * 3)) / 4)
        }
        
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        
        $this.NewButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.ViewButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.EditButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 2,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.DeleteButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 3,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date (most urgent first), then by assigned date
        $sorted = $activeProjects | Sort-Object -Property @(
            @{Expression = { $_.ClosedDate -eq [DateTime]::MinValue }; Descending = $true}
            @{Expression = { ($_.DateDue - [DateTime]::Now).Days }}
            @{Expression = { $_.DateAssigned }}
        )
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        $dialog = [NewProjectDialog]::new()
        
        if (-not $this.EventBus) {
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $dialog = [EditProjectDialog]::new($selected)
        $screen = $this
        $project = $selected
        
        $dialog.OnSave = {
            param($projectData)
            
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            $screen.ProjectService.UpdateProject($project)
            
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                $screen.LoadProjects()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $message = "Are you sure you want to delete project '$($selected.Nickname)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            
            $dialog.OnConfirm = {
                $screen.ProjectService.DeleteProject($projectId)
                
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    $screen.LoadProjects()
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Screens/QuickTimeEntryDialog.ps1
# QuickTimeEntryDialog - Simple time entry dialog

class QuickTimeEntryDialog : BaseDialog {
    [DateTime]$WeekFriday
    [MinimalTextBox]$ProjectBox
    [MinimalTextBox]$MondayBox
    [MinimalTextBox]$TuesdayBox
    [MinimalTextBox]$WednesdayBox
    [MinimalTextBox]$ThursdayBox
    [MinimalTextBox]$FridayBox
    [TimeTrackingService]$TimeService
    [scriptblock]$OnSave
    
    QuickTimeEntryDialog([DateTime]$weekFriday) : base("Quick Time Entry") {
        $this.WeekFriday = $weekFriday
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 30
    }
    
    [void] InitializeContent() {
        # Create all input fields
        $this.ProjectBox = [MinimalTextBox]::new()
        $this.ProjectBox.Placeholder = "Enter Project ID2 or Non-Project Code..."
        $this.AddContentControl($this.ProjectBox, 1)
        
        $this.MondayBox = [MinimalTextBox]::new()
        $this.MondayBox.Placeholder = "Monday Hours"
        $this.AddContentControl($this.MondayBox, 2)
        
        $this.TuesdayBox = [MinimalTextBox]::new()
        $this.TuesdayBox.Placeholder = "Tuesday Hours"
        $this.AddContentControl($this.TuesdayBox, 3)
        
        $this.WednesdayBox = [MinimalTextBox]::new()
        $this.WednesdayBox.Placeholder = "Wednesday Hours"
        $this.AddContentControl($this.WednesdayBox, 4)
        
        $this.ThursdayBox = [MinimalTextBox]::new()
        $this.ThursdayBox.Placeholder = "Thursday Hours"
        $this.AddContentControl($this.ThursdayBox, 5)
        
        $this.FridayBox = [MinimalTextBox]::new()
        $this.FridayBox.Placeholder = "Friday Hours"
        $this.AddContentControl($this.FridayBox, 6)
        
        # Set up save action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.ProjectBox.Text.Trim()) {
                $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
                
                $data = @{
                    WeekEndingFriday = $dialog.WeekFriday.ToString("yyyyMMdd")
                    ID2 = $dialog.ProjectBox.Text.Trim().ToUpper()
                    Monday = $dialog.ParseHours($dialog.MondayBox.Text)
                    Tuesday = $dialog.ParseHours($dialog.TuesdayBox.Text)
                    Wednesday = $dialog.ParseHours($dialog.WednesdayBox.Text)
                    Thursday = $dialog.ParseHours($dialog.ThursdayBox.Text)
                    Friday = $dialog.ParseHours($dialog.FridayBox.Text)
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave $data
                }
                
                $dialog.CloseDialog()
            }
        }.GetNewClosure()
    }
    
    [decimal] ParseHours([string]$text) {
        if ([string]::IsNullOrWhiteSpace($text)) { return 0 }
        $hours = 0
        if ([decimal]::TryParse($text, [ref]$hours)) {
            return $hours
        }
        return 0
    }
}


####\Screens/SettingsScreen.ps1
# SettingsScreen.ps1 - Settings management screen

class SettingsScreen : Screen {
    [ListBox]$CategoryList
    [DataGrid]$SettingsGrid
    [ConfigurationService]$ConfigService
    [hashtable[]]$CurrentSettings = @()
    [string]$CurrentCategory = ""
    [EventBus]$EventBus
    
    SettingsScreen() : base() {
        $this.Title = "Settings"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ConfigService = $global:ServiceContainer.GetService("ConfigurationService")
        if (-not $this.ConfigService) {
            $this.ConfigService = [ConfigurationService]::new()
            $global:ServiceContainer.Register("ConfigurationService", $this.ConfigService)
        }
        
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create category list
        $this.CategoryList = [ListBox]::new()
        $this.CategoryList.Title = "Categories"
        $this.CategoryList.ShowBorder = $true
        # Capture screen reference for callback
        $screen = $this
        $this.CategoryList.OnSelectionChanged = {
            $screen.LoadCategorySettings()
        }.GetNewClosure()
        $this.CategoryList.Initialize($global:ServiceContainer)
        $this.AddChild($this.CategoryList)
        
        # Create settings grid
        $this.SettingsGrid = [DataGrid]::new()
        $this.SettingsGrid.Title = "Settings"
        $this.SettingsGrid.ShowBorder = $true
        $this.SettingsGrid.Initialize($global:ServiceContainer)
        $this.SettingsGrid.SetColumns(@(
            @{Name="Setting"; Header="Setting"; Width=30},
            @{Name="Value"; Header="Value"; Width=20},
            @{Name="Type"; Header="Type"; Width=10}
        ))
        $this.AddChild($this.SettingsGrid)
        
        # Load categories
        $this.LoadCategories()
        
        # No more BindKey - use HandleScreenInput instead
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) { 
                $this.EditSetting()
                return $true
            }
        }
        
        switch ($key.KeyChar) {
            'e' { $this.EditSetting(); return $true }
            'r' { $this.ResetCategory(); return $true }
            'R' { $this.ResetAll(); return $true }
            's' { $this.SaveSettings(); return $true }
        }
        
        return $false
    }
    
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        $this.CategoryList.Focus()
        # Settings are loaded automatically when selection changes
    }
    
    [void] OnBoundsChanged() {
        # Split the width between category list and settings grid
        $categoryWidth = 25
        $gridWidth = [Math]::Max(10, $this.Width - $categoryWidth)
        
        # Set bounds for category list
        $this.CategoryList.SetBounds(
            $this.X,
            $this.Y,
            $categoryWidth,
            $this.Height
        )
        
        # Set bounds for settings grid
        $this.SettingsGrid.SetBounds(
            $this.X + $categoryWidth,
            $this.Y,
            $gridWidth,
            $this.Height
        )
    }
    
    [void] LoadCategories() {
        $config = $this.ConfigService.GetAll()
        $categories = @()
        
        foreach ($key in $config.Keys | Sort-Object) {
            if ($config[$key] -is [hashtable]) {
                $categories += @{
                    Name = $key
                    DisplayName = $this.FormatCategoryName($key)
                }
            }
        }
        
        $this.CategoryList.SetItems($categories)
        $this.CategoryList.ItemRenderer = { param($cat) $cat.DisplayName }
        
        if ($categories.Count -gt 0) {
            $this.CategoryList.SelectIndex(0)
            # LoadCategorySettings is now called automatically by OnSelectionChanged
        }
    }
    
    [void] LoadCategorySettings() {
        $selected = $this.CategoryList.GetSelectedItem()
        if (-not $selected) { return }
        
        $this.CurrentCategory = $selected.Name
        $categoryConfig = $this.ConfigService.Get($this.CurrentCategory)
        
        if ($categoryConfig -is [hashtable]) {
            $settings = @()
            
            foreach ($key in $categoryConfig.Keys | Sort-Object) {
                $value = $categoryConfig[$key]
                $type = $this.GetValueType($value)
                
                $settings += @{
                    Setting = $this.FormatSettingName($key)
                    Value = $this.FormatValue($value)
                    Type = $type
                    Key = $key
                    RawValue = $value
                }
            }
            
            $this.CurrentSettings = $settings
            $this.SettingsGrid.SetItems($settings)
            $this.SettingsGrid.Title = "Settings - $($selected.DisplayName)"
        }
    }
    
    [void] EditSetting() {
        if (-not $this.SettingsGrid.IsFocused) { return }
        
        $selected = $this.SettingsGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $path = "$($this.CurrentCategory).$($selected.Key)"
        $currentValue = $selected.RawValue
        
        # Create appropriate dialog based on type
        $dialog = $null
        
        # Special handling for theme selection
        if ($path -eq "Theme.CurrentTheme") {
            # Cycle through available themes
            $availableThemes = $this.ConfigService.Get("Theme.AvailableThemes", @("default", "matrix"))
            $currentIndex = $availableThemes.IndexOf($currentValue)
            $nextIndex = ($currentIndex + 1) % $availableThemes.Count
            $newValue = $availableThemes[$nextIndex]
            
            $this.ConfigService.Set($path, $newValue)
            
            # Apply theme immediately
            $themeManager = $global:ServiceContainer.GetService("ThemeManager")
            if ($themeManager) {
                $themeManager.SetTheme($newValue)
            }
            
            # Publish config changed event
            if ($this.EventBus) {
                $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                    Path = $path
                    OldValue = $currentValue
                    NewValue = $newValue
                    Category = $this.CurrentCategory
                })
            }
            
            $this.LoadCategorySettings()
            return
        }
        
        switch ($selected.Type) {
            "Boolean" {
                # Simple toggle
                $newValue = -not $currentValue
                $this.ConfigService.Set($path, $newValue)
                
                # Publish config changed event
                if ($this.EventBus) {
                    $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                        Path = $path
                        OldValue = $currentValue
                        NewValue = $newValue
                        Category = $this.CurrentCategory
                    })
                }
                
                $this.LoadCategorySettings()
                return
            }
            "Number" {
                # TODO: Create NumberInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("Number editing not yet implemented")
                }
            }
            "String" {
                # TODO: Create TextInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("String editing not yet implemented")
                }
            }
        }
    }
    
    [void] ResetCategory() {
        if (-not $this.CurrentCategory) { return }
        
        $message = "Reset all settings in '$($this.CurrentCategory)' to defaults?"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.OnConfirm = {
            $this.ConfigService.ResetSection($this.CurrentCategory)
            $this.LoadCategorySettings()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ResetAll() {
        $message = "Reset ALL settings to defaults?`n`nThis cannot be undone!"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.ConfirmText = "Reset All"
        $dialog.OnConfirm = {
            $this.ConfigService.Reset()
            $this.LoadCategories()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] SaveSettings() {
        $this.ConfigService.Save()
        if ($global:Logger) {
            $global:Logger.Info("Settings saved")
        }
    }
    
    
    hidden [string] FormatCategoryName([string]$name) {
        # Convert PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        return $formatted.Trim()
    }
    
    hidden [string] FormatSettingName([string]$name) {
        # Convert camelCase/PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        $formatted = $formatted.Substring(0,1).ToUpper() + $formatted.Substring(1)
        return $formatted.Trim()
    }
    
    hidden [string] FormatValue($value) {
        if ($value -eq $null) { return "<null>" }
        if ($value -is [bool]) { return $(if ($value) { "Yes" } else { "No" }) }
        if ($value -is [hashtable]) { return "<nested>" }
        if ($value -is [array]) { return "<array[$($value.Count)]>" }
        return $value.ToString()
    }
    
    hidden [string] GetValueType($value) {
        if ($value -eq $null) { return "Null" }
        if ($value -is [bool]) { return "Boolean" }
        if ($value -is [int] -or $value -is [long] -or $value -is [double]) { return "Number" }
        if ($value -is [string]) { return "String" }
        if ($value -is [hashtable]) { return "Object" }
        if ($value -is [array]) { return "Array" }
        return "Unknown"
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append(" [Tab]Navigate [Enter/E]Edit [R]Reset Category [Shift+R]Reset All [S]Save")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/SubtaskDialog.ps1
# SubtaskDialog - Dialog for adding/editing subtasks using BaseDialog

class SubtaskDialog : BaseDialog {
    [Task]$ParentTask = $null
    [Subtask]$Subtask = $null  # For editing existing subtasks
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$TitleTextBox
    [TextBox]$DescriptionTextBox
    [TextBox]$EstimatedTimeTextBox
    [TextBox]$ActualTimeTextBox
    [TextBox]$DueDateTextBox
    
    # Dropdowns (simplified as text for now)
    [TextBox]$PriorityTextBox
    [TextBox]$ProgressTextBox
    
    SubtaskDialog() : base("Add Subtask", 60, 24) {
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask) : base("Add Subtask - $($parentTask.Title)", 60, 24) {
        $this.ParentTask = $parentTask
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask, $subtask) : base("Edit Subtask", 60, 24) {
        $this.ParentTask = $parentTask
        $this.Subtask = $subtask
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Update Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.TitleTextBox = [TextBox]::new()
        $this.TitleTextBox.Title = "Title"
        $this.TitleTextBox.ShowBorder = $true
        $this.TitleTextBox.TabIndex = 1
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Title']) {
            $this.TitleTextBox.Text = $this.Subtask.Title
        }
        $this.AddContentControl($this.TitleTextBox)
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        $this.DescriptionTextBox.TabIndex = 2
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Description']) {
            $this.DescriptionTextBox.Text = $this.Subtask.Description
        }
        $this.AddContentControl($this.DescriptionTextBox)
        
        $this.PriorityTextBox = [TextBox]::new()
        $this.PriorityTextBox.Title = "Priority (Low/Medium/High)"
        $this.PriorityTextBox.ShowBorder = $true
        $this.PriorityTextBox.TabIndex = 3
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.Priority) {
            $this.PriorityTextBox.Text = $this.Subtask.Priority.ToString()
        } else {
            $this.PriorityTextBox.Text = "Medium"
        }
        $this.AddContentControl($this.PriorityTextBox)
        
        $this.ProgressTextBox = [TextBox]::new()
        $this.ProgressTextBox.Title = "Progress (0-100)"
        $this.ProgressTextBox.ShowBorder = $true
        $this.ProgressTextBox.TabIndex = 4
        
        if ($this.IsEditMode -and $this.Subtask) {
            $progress = if ($this.Subtask.PSObject.Properties['Progress']) { $this.Subtask.Progress } else { 0 }
            $this.ProgressTextBox.Text = $progress.ToString()
        } else {
            $this.ProgressTextBox.Text = "0"
        }
        $this.AddContentControl($this.ProgressTextBox)
        
        $this.EstimatedTimeTextBox = [TextBox]::new()
        $this.EstimatedTimeTextBox.Title = "Estimated Time (minutes)"
        $this.EstimatedTimeTextBox.ShowBorder = $true
        $this.EstimatedTimeTextBox.TabIndex = 5
        
        if ($this.IsEditMode -and $this.Subtask) {
            $estimated = if ($this.Subtask.PSObject.Properties['EstimatedMinutes']) { $this.Subtask.EstimatedMinutes } else { 0 }
            if ($estimated -gt 0) {
                $this.EstimatedTimeTextBox.Text = $estimated.ToString()
            }
        }
        $this.AddContentControl($this.EstimatedTimeTextBox)
        
        $this.ActualTimeTextBox = [TextBox]::new()
        $this.ActualTimeTextBox.Title = "Actual Time (minutes)"
        $this.ActualTimeTextBox.ShowBorder = $true
        $this.ActualTimeTextBox.TabIndex = 6
        
        if ($this.IsEditMode -and $this.Subtask) {
            $actual = if ($this.Subtask.PSObject.Properties['ActualMinutes']) { $this.Subtask.ActualMinutes } else { 0 }
            if ($actual -gt 0) {
                $this.ActualTimeTextBox.Text = $actual.ToString()
            }
        }
        $this.AddContentControl($this.ActualTimeTextBox)
        
        $this.DueDateTextBox = [TextBox]::new()
        $this.DueDateTextBox.Title = "Due Date (MM/DD/YYYY, optional)"
        $this.DueDateTextBox.ShowBorder = $true
        $this.DueDateTextBox.TabIndex = 7
        
        if ($this.IsEditMode -and $this.Subtask) {
            $dueDate = if ($this.Subtask.PSObject.Properties['DueDate']) { $this.Subtask.DueDate } else { [DateTime]::MinValue }
            if ($dueDate -ne [DateTime]::MinValue) {
                $this.DueDateTextBox.Text = $dueDate.ToString("MM/dd/yyyy")
            }
        }
        $this.AddContentControl($this.DueDateTextBox)
        
        # Set custom handlers for BaseDialog
        $dialog = $this
        $this.OnPrimary = {
            $dialog.HandleSave()
        }.GetNewClosure()
        
        $this.OnSecondary = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
            $dialog.CloseDialog()
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom layout: Stack inputs vertically
        $padding = $this.DialogPadding
        $shortInputHeight = 3
        $tallInputHeight = 4
        $currentY = $dialogY + $padding
        $inputWidth = $this.DialogWidth - ($padding * 2)
        
        # Title input
        $this.TitleTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $tallInputHeight
        )
        $currentY += $tallInputHeight + 1
        
        # Priority and Progress on same row
        $halfWidth = [int](($inputWidth - 2) / 2)
        $this.PriorityTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ProgressTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Estimated and Actual time on same row
        $this.EstimatedTimeTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ActualTimeTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Due date
        $this.DueDateTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create subtask data
        $subtaskData = $this.CreateSubtaskData()
        
        if ($this.OnSave) {
            & $this.OnSave $subtaskData
        }
        
        # Close dialog after successful save
        $this.CloseDialog()
    }
    
    [string] ValidateInputs() {
        # Validate title
        $title = $this.TitleTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($title)) {
            return "Title is required"
        }
        
        # Validate priority
        $priority = $this.PriorityTextBox.Text.Trim()
        if ($priority -notin @("Low", "Medium", "High")) {
            return "Priority must be Low, Medium, or High"
        }
        
        # Validate progress
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $progress = 0
        if (-not [string]::IsNullOrEmpty($progressStr)) {
            if (-not [int]::TryParse($progressStr, [ref]$progress) -or $progress -lt 0 -or $progress -gt 100) {
                return "Progress must be a number between 0 and 100"
            }
        }
        
        # Validate estimated time
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($estimatedStr)) {
            $estimated = 0
            if (-not [int]::TryParse($estimatedStr, [ref]$estimated) -or $estimated -lt 0) {
                return "Estimated time must be a positive number"
            }
        }
        
        # Validate actual time
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($actualStr)) {
            $actual = 0
            if (-not [int]::TryParse($actualStr, [ref]$actual) -or $actual -lt 0) {
                return "Actual time must be a positive number"
            }
        }
        
        # Validate due date
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($dueDateStr)) {
            try {
                [DateTime]::Parse($dueDateStr) | Out-Null
            } catch {
                return "Invalid due date format. Use MM/DD/YYYY"
            }
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateSubtaskData() {
        # Parse inputs
        $title = $this.TitleTextBox.Text.Trim()
        $description = $this.DescriptionTextBox.Text.Trim()
        $priorityStr = $this.PriorityTextBox.Text.Trim()
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        
        # Convert priority
        $priority = switch ($priorityStr) {
            "Low" { [TaskPriority]::Low }
            "High" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # Parse numbers
        $progress = if ([string]::IsNullOrEmpty($progressStr)) { 0 } else { [int]::Parse($progressStr) }
        $estimated = if ([string]::IsNullOrEmpty($estimatedStr)) { 0 } else { [int]::Parse($estimatedStr) }
        $actual = if ([string]::IsNullOrEmpty($actualStr)) { 0 } else { [int]::Parse($actualStr) }
        
        # Parse due date
        $dueDate = if ([string]::IsNullOrEmpty($dueDateStr)) {
            [DateTime]::MinValue
        } else {
            [DateTime]::Parse($dueDateStr)
        }
        
        # Create subtask data object
        $subtaskData = [PSCustomObject]@{
            Id = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Id']) { $this.Subtask.Id } else { [guid]::NewGuid().ToString() }
            } else { 
                [guid]::NewGuid().ToString() 
            }
            ParentTaskId = $this.ParentTask.Id
            Title = $title
            Description = $description
            Status = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Status']) { $this.Subtask.Status } else { [TaskStatus]::Pending }
            } else { 
                [TaskStatus]::Pending 
            }
            Priority = $priority
            Progress = $progress
            EstimatedMinutes = $estimated
            ActualMinutes = $actual
            DueDate = $dueDate
            IsEditMode = $this.IsEditMode
        }
        
        return $subtaskData
    }
    
    # Override HandleScreenInput to add Ctrl+Enter shortcut
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Ctrl+Enter shortcut for save
        if ($key.Key -eq [System.ConsoleKey]::Enter -and ($key.Modifiers -band [ConsoleModifiers]::Control)) {
            $this.HandleSave()
            return $true
        }
        
        return $false
    }
    
    # Legacy callback support
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
}


####\Screens/TaskScreen.ps1
# TaskScreen.ps1 - Task management screen using DataGrid

class TaskScreen : Screen {
    [MinimalDataGrid]$TaskGrid
    [TaskService]$TaskService
    [SubtaskService]$SubtaskService
    [ProjectService]$ProjectService
    [hashtable]$StatusColors
    [hashtable]$PriorityColors
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    hidden [bool]$ShowSubtasks = $true
    hidden [hashtable]$ProjectCache = @{}
    
    # Layout settings
    hidden [int]$StatusBarHeight = 2
    
    TaskScreen() : base() {
        $this.Title = "Tasks"
    }
    
    [void] OnInitialize() {
        # Get services using proper dependency injection
        $this.TaskService = $this.GetService("TaskService")
        if (-not $this.TaskService) {
            $this.TaskService = [TaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("TaskService", $this.TaskService)
            } else {
                $global:ServiceContainer.Register("TaskService", $this.TaskService)
            }
        }
        
        $this.SubtaskService = $this.GetService("SubtaskService")
        if (-not $this.SubtaskService) {
            $this.SubtaskService = [SubtaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            } else {
                $global:ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            }
        }
        
        $this.ProjectService = $this.GetService("ProjectService")
        $this.EventBus = $this.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to task created events
            $this.EventSubscriptions['TaskCreated'] = $this.EventBus.Subscribe('task.created', {
                param($sender, $eventData)
                $screen.LoadTasks()
                # Select the new task if provided
                if ($eventData.Task) {
                    for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                        if ($screen.TaskGrid.Items[$i].Id -eq $eventData.Task.Id) {
                            $screen.TaskGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe('command.executed', {
                param($sender, $eventData)
                if ($global:Logger) {
                    $global:Logger.Debug("TaskScreen: Received CommandExecuted event - Command: $($eventData.Command), Target: $($eventData.Target)")
                }
                if ($eventData.Target -eq 'TaskScreen') {
                    switch ($eventData.Command) {
                        'NewTask' { 
                            if ($global:Logger) {
                                $global:Logger.Debug("TaskScreen: Executing NewTask command")
                            }
                            $screen.NewTask() 
                        }
                        'EditTask' { $screen.EditTask() }
                        'DeleteTask' { $screen.DeleteTask() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to task updated events
            $this.EventSubscriptions['TaskUpdated'] = $this.EventBus.Subscribe('task.updated', {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
            
            # Subscribe to task deleted events
            $this.EventSubscriptions['TaskDeleted'] = $this.EventBus.Subscribe('task.deleted', {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
        }
        
        # Set up color mappings
        $this.StatusColors = @{
            [TaskStatus]::Pending = "foreground"
            [TaskStatus]::InProgress = "warning"
            [TaskStatus]::Completed = "success"
            [TaskStatus]::Cancelled = "disabled"
        }
        
        $this.PriorityColors = @{
            [TaskPriority]::Low = "success"
            [TaskPriority]::Medium = "warning"
            [TaskPriority]::High = "error"
        }
        
        # Create DataGrid with columns
        $this.TaskGrid = [MinimalDataGrid]::new()
        $this.TaskGrid.Title = "Tasks"
        $this.TaskGrid.ShowBorder = $false  # MainScreen draws the border
        $this.TaskGrid.ShowGridLines = $false
        
        # Define columns
        $screen = $this
        $columns = @(
            @{
                Name = "Status"
                Header = "S"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no status shown in grid (shown in title instead)
                        return " "
                    }
                    switch ($item.Status) {
                        ([TaskStatus]::Pending) { return "P" }
                        ([TaskStatus]::InProgress) { return "W" }
                        ([TaskStatus]::Completed) { return "D" }
                        ([TaskStatus]::Cancelled) { return "X" }
                        default { return "?" }
                    }
                }
            },
            @{
                Name = "Priority"
                Header = "P"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no priority shown in grid
                        return " "
                    }
                    switch ($item.Priority) {
                        ([TaskPriority]::High) { return "H" }
                        ([TaskPriority]::Medium) { return "M" }
                        ([TaskPriority]::Low) { return "L" }
                        default { return " " }
                    }
                }
            },
            @{
                Name = "Title"
                Header = "Task"
                Width = 0  # Flexible width
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - show indented with status
                        $status = switch ($item.Status) {
                            ([TaskStatus]::Pending) { "[ ]" }
                            ([TaskStatus]::InProgress) { "[~]" }
                            ([TaskStatus]::Completed) { "[]" }
                            ([TaskStatus]::Cancelled) { "[]" }
                            default { "[?]" }
                        }
                        return "   $status $($item.Title)"
                    } else {
                        # Main task - include subtask count if any
                        $title = $item.Title
                        if ($screen.SubtaskService) {
                            $stats = $screen.SubtaskService.GetTaskStatistics($item.Id)
                            if ($stats.Total -gt 0) {
                                $title += " [$($stats.Completed)/$($stats.Total)]"
                            }
                        }
                        return $title
                    }
                }
            },
            @{
                Name = "Project"
                Header = "Project"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no project shown
                        return ""
                    }
                    if ($item.ProjectId -and $screen.ProjectService) {
                        # Cache project lookups for performance
                        if (-not $screen.ProjectCache.ContainsKey($item.ProjectId)) {
                            $project = $screen.ProjectService.GetProject($item.ProjectId)
                            if ($project) {
                                $screen.ProjectCache[$item.ProjectId] = $project.FullProjectName
                            } else {
                                $screen.ProjectCache[$item.ProjectId] = ""
                            }
                        }
                        return $screen.ProjectCache[$item.ProjectId]
                    }
                    return ""
                }
            },
            @{
                Name = "DueDate"
                Header = "Due"
                Width = 10
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no due date in grid
                        return ""
                    }
                    if ($item.DueDate -ne [DateTime]::MinValue) {
                        return $item.DueDate.ToString("yyyy-MM-dd")
                    }
                    return ""
                }
            },
            @{
                Name = "Tags"
                Header = "Tags"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no tags shown
                        return ""
                    }
                    if ($item.Tags -and $item.Tags.Count -gt 0) {
                        return ($item.Tags -join ",")
                    }
                    return ""
                }
            }
        )
        
        $this.TaskGrid.SetColumns($columns)
        $this.TaskGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.TaskGrid)
        
        # Load tasks
        $this.LoadTasks()
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        # Focus the grid
        if ($this.TaskGrid -and $this.TaskGrid.Items.Count -gt 0) {
            $this.TaskGrid.Focus()
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.OnActivated: Screen activated and focused grid")
        }
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes all space except status bar
        $gridHeight = $this.Height - $this.StatusBarHeight
        
        # Task grid
        $this.TaskGrid.SetBounds(
            $this.X,
            $this.Y,
            $this.Width,
            $gridHeight
        )
    }
    
    [void] LoadTasks() {
        $tasks = $this.TaskService.GetAllTasks()
        
        # Clear project cache for fresh lookups
        $this.ProjectCache.Clear()
        
        # Filter out deleted tasks
        $activeTasks = $tasks | Where-Object { -not $_.Deleted }
        
        # Sort by priority (high first), then status, then due date
        $sorted = $activeTasks | Sort-Object -Property `
            @{Expression = {$_.Priority}; Descending = $true},
            @{Expression = {$_.Status}; Ascending = $true},
            @{Expression = {if ($_.DueDate -eq [DateTime]::MinValue) { [DateTime]::MaxValue } else { $_.DueDate }}; Ascending = $true}
        
        if ($this.ShowSubtasks -and $this.SubtaskService) {
            # Create combined list with tasks and their subtasks
            $combinedItems = [System.Collections.ArrayList]::new()
            
            foreach ($task in $sorted) {
                $combinedItems.Add($task) | Out-Null
                
                # Add subtasks for this task
                $subtasks = $this.SubtaskService.GetSubtasksForTask($task.Id)
                foreach ($subtask in $subtasks) {
                    $combinedItems.Add($subtask) | Out-Null
                }
            }
            
            $this.TaskGrid.SetItems($combinedItems)
        } else {
            $this.TaskGrid.SetItems($sorted)
        }
    }
    
    [void] NewTask() {
        # Create new task dialog
        $dialog = [NewTaskDialog]::new()
        
        # EventBus will handle task creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($taskData)
                
                $task = $screen.TaskService.CreateTask($taskData)
                $screen.LoadTasks()
                
                # Select the new task
                for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                    if ($screen.TaskGrid.Items[$i].Id -eq $task.Id) {
                        $screen.TaskGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Edit subtask
            $this.EditSubtask($selected)
            return
        }
        
        # Create edit task dialog
        $dialog = [EditTaskDialog]::new($selected)
        # Capture references
        $screen = $this
        $task = $selected
        $dialog.OnSave = {
            param($taskData)
            
            # Update the task
            $task.Title = $taskData.Title
            $task.Description = $taskData.Description
            $task.Status = $taskData.Status
            $task.Priority = $taskData.Priority
            $task.Progress = $taskData.Progress
            $task.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.TaskService.UpdateTask($task)
            
            # Publish task updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskUpdated, @{ Task = $task })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
        $message = if ($isSubtask) {
            "Are you sure you want to delete this subtask?`n`n$($selected.Title)"
        } else {
            "Are you sure you want to delete this task?`n`n$($selected.Title)"
        }
        
        # Show confirmation dialog
        $dialog = [ConfirmationDialog]::new($message)
        # Capture references
        $screen = $this
        $itemId = $selected.Id
        $dialog.OnConfirm = {
            if ($isSubtask) {
                # Delete subtask
                $screen.SubtaskService.DeleteSubtask($itemId)
            } else {
                # Delete task (and all its subtasks)
                $screen.TaskService.DeleteTask($itemId)
            }
            
            # Publish task deleted event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskDeleted, @{ TaskId = $itemId })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CycleStatus() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Cycle through status values
        $newStatus = switch ($selected.Status) {
            ([TaskStatus]::Pending) { [TaskStatus]::InProgress }
            ([TaskStatus]::InProgress) { [TaskStatus]::Completed }
            ([TaskStatus]::Completed) { [TaskStatus]::Cancelled }
            ([TaskStatus]::Cancelled) { [TaskStatus]::Pending }
        }
        
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Update subtask
            $selected.Status = $newStatus
            $selected.UpdatedAt = [DateTime]::Now
            $this.SubtaskService.SaveSubtask($selected)
        } else {
            # Update task
            $this.TaskService.UpdateTaskStatus($selected.Id, $newStatus)
        }
        
        # Publish task status changed event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TaskStatusChanged, @{ 
                TaskId = $selected.Id
                OldStatus = $selected.Status
                NewStatus = $newStatus
            })
        } else {
            # Fallback if EventBus not available
            $this.LoadTasks()
        }
    }
    
    [void] AddSubtask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected -or -not $this.SubtaskService) { return }
        
        # Find the parent task (if selected item is a subtask, get its parent)
        $parentTask = $null
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Selected item is a subtask, find its parent
            $parentTask = $this.TaskService.GetTask($selected.ParentTaskId)
        } else {
            # Selected item is a task
            $parentTask = $selected
        }
        
        if (-not $parentTask) { return }
        
        # Create subtask dialog
        $dialog = [SubtaskDialog]::new($parentTask)
        
        # Set up callback for when subtask is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Create subtask using service
            $properties = @{
                ParentTaskId = $subtaskData.ParentTaskId
                Title = $subtaskData.Title
                Description = $subtaskData.Description
                Priority = $subtaskData.Priority
                Progress = $subtaskData.Progress
                EstimatedMinutes = $subtaskData.EstimatedMinutes
                ActualMinutes = $subtaskData.ActualMinutes
                DueDate = $subtaskData.DueDate
            }
            
            $screen.SubtaskService.CreateSubtask($properties)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ToggleSubtaskView() {
        $this.ShowSubtasks = -not $this.ShowSubtasks
        $this.LoadTasks()
    }
    
    [void] EditSubtask([PSCustomObject]$subtask) {
        if (-not $subtask -or -not $this.SubtaskService) { return }
        
        # Get parent task for context
        $parentTask = $this.TaskService.GetTask($subtask.ParentTaskId)
        if (-not $parentTask) { return }
        
        # Create subtask dialog for editing
        $dialog = [SubtaskDialog]::new($parentTask, $subtask)
        
        # Set up callback for when subtask is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Update the existing subtask
            $subtask.Title = $subtaskData.Title
            $subtask.Description = $subtaskData.Description
            $subtask.Status = $subtaskData.Status
            $subtask.Priority = $subtaskData.Priority
            $subtask.Progress = $subtaskData.Progress
            $subtask.EstimatedMinutes = $subtaskData.EstimatedMinutes
            $subtask.ActualMinutes = $subtaskData.ActualMinutes
            $subtask.DueDate = $subtaskData.DueDate
            $subtask.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.SubtaskService.SaveSubtask($subtask)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CyclePriority() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Don't cycle priority for subtasks in this view
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') { return }
        
        $this.TaskService.CyclePriority($selected.Id)
        $this.LoadTasks()
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Handle screen-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n')) {
                    $this.NewTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'E' -or $key.KeyChar -eq 'e')) {
                    $this.EditTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.EditTask()
                return $true
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Delete) {
                $this.DeleteTask()
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadTasks()
                    return $true
                }
            }
            ([System.ConsoleKey]::F5) {
                $this.LoadTasks()
                return $true
            }
            ([System.ConsoleKey]::S) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'S' -or $key.KeyChar -eq 's')) {
                    $this.CycleStatus()
                    return $true
                }
            }
            ([System.ConsoleKey]::P) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'P' -or $key.KeyChar -eq 'p')) {
                    $this.CyclePriority()
                    return $true
                }
            }
            ([System.ConsoleKey]::A) {
                if ($key.Modifiers -band [ConsoleModifiers]::Shift -and ($key.KeyChar -eq 'A')) {
                    # Shift+A to add subtask
                    $this.AddSubtask()
                    return $true
                }
            }
            ([System.ConsoleKey]::T) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'T' -or $key.KeyChar -eq 't')) {
                    # Toggle subtask view
                    $this.ToggleSubtaskView()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base (background and children)
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - $this.StatusBarHeight
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        
        # Status text
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY + 1))
        $sb.Append($this.Theme.GetColor("disabled"))
        
        $selected = $this.TaskGrid.GetSelectedItem()
        if ($selected) {
            # Show task details in status bar
            $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
            $type = if ($isSubtask) { "Subtask" } else { "Task" }
            $status = $selected.Status.ToString()
            $priority = $selected.Priority.ToString()
            $sb.Append("${type}: $($selected.Title) | Status: $status | Priority: $priority")
        } else {
            # Show help text with letter-based shortcuts
            $sb.Append("[N]ew [E]dit [D]elete [S]tatus [P]riority [A+Shift]Subtask [T]oggle [Tab]Navigate")
        }
        
        # Add legend for status/priority letters
        $sb.Append([VT]::MoveTo($this.X + $this.Width - 35, $statusY + 1))
        $sb.Append("S: P=Pending W=Working D=Done X=Cancel")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/TestScreen.ps1
# TestScreen.ps1 - Simple test screen to verify PRAXIS is working

class TestScreen : Screen {
    [string]$Message = "PRAXIS Test Screen"
    [int]$Counter = 0
    hidden [string]$_cachedContent = ""
    
    TestScreen() : base() {
        $this.Title = "Test"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnInitialize: $($this.Title)")
        }
        
        # No more BindKey - use HandleScreenInput instead
        
        # Don't rebuild content here - wait until we have bounds
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [System.ConsoleKey]::Spacebar) {
            $this.Counter++
            $this._cachedContent = ""  # Force re-render
            $this.RequestRender() 
            return $true
        }
        elseif ($key.KeyChar -eq 'q') {
            $this.Active = $false
            return $true
        }
        
        return $false
    }
    
    [void] OnThemeChanged() {
        ([Screen]$this).OnThemeChanged()
        $this._cachedContent = ""
        $this.RebuildContent()
    }
    
    [void] RebuildContent() {
        $sb = Get-PooledStringBuilder 512
        
        # Calculate absolute positions
        $absoluteCenterY = $this.Y + [int]($this.Height / 2)
        $absoluteCenterX = $this.X + [int](($this.Width - $this.Message.Length) / 2)
        
        # Title
        $sb.Append([VT]::MoveTo($absoluteCenterX, $absoluteCenterY - 2))
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append($this.Message)
        
        # Counter
        $counterText = "Counter: $($this.Counter)"
        $counterX = $this.X + [int](($this.Width - $counterText.Length) / 2)
        $sb.Append([VT]::MoveTo($counterX, $absoluteCenterY))
        $sb.Append($this.Theme.GetColor("foreground"))
        $sb.Append($counterText)
        
        # Instructions
        $instructionText = "Press SPACE to increment, Q to quit"
        $instructionX = $this.X + [int](($this.Width - $instructionText.Length) / 2)
        $sb.Append([VT]::MoveTo($instructionX, $absoluteCenterY + 2))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append($instructionText)
        
        # FPS counter (bottom right)
        if ($global:ScreenManager) {
            $fps = [Math]::Round($global:ScreenManager.GetFPS(), 1)
            $fpsText = "FPS: $fps"
            $sb.Append([VT]::MoveTo($this.X + $this.Width - $fpsText.Length - 2, $this.Y + $this.Height - 2))
            $sb.Append($this.Theme.GetColor("success"))
            $sb.Append($fpsText)
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedContent = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnRender: Bounds X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
        }
        
        # Check if we need to rebuild
        if ([string]::IsNullOrEmpty($this._cachedContent)) {
            $this.RebuildContent()
        }
        
        # Return base background + our content
        return ([Container]$this).OnRender() + $this._cachedContent
    }
}


####\Screens/TextEditorScreen.ps1
# TextEditorScreen - Multi-line text editor screen
# Proper PRAXIS architecture implementation

class TextEditorScreen : Screen {
    # Text content and cursor state
    [System.Collections.ArrayList]$Lines
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$FilePath = ""
    [bool]$Modified = $false
    [string]$StatusMessage = ""
    
    # Undo system - line-based grouping
    hidden [System.Collections.ArrayList]$_undoStates
    hidden [int]$_maxUndoStates = 25
    hidden [int]$_currentUndoIndex = -1
    hidden [int]$_maxFileSizeForUndo = 100KB
    hidden [bool]$_undoEnabled = $true
    
    # Auto-save on focus loss
    [bool]$AutoSaveOnFocusLoss = $true
    hidden [bool]$_lastFocusState = $true
    
    # PRAXIS service integration
    hidden [object]$ThemeManager
    hidden [object]$EventBus
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    # Mode system
    [bool]$InTextMode = $true  # Start in text mode
    
    TextEditorScreen() : base() {
        $this.Title = "Text Editor"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.IsFocusable = $true  # TextEditor itself is focusable
        $this.InitializeUndoSystem()
    }
    
    TextEditorScreen([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this.FilePath = $filePath
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true  # TextEditor itself is focusable
        $this.InitializeUndoSystem()
    }
    
    [void] InitializeUndoSystem() {
        $this._undoStates = [System.Collections.ArrayList]::new()
        # Save initial state
        $this.SaveUndoState()
    }
    
    [void] SaveUndoState() {
        if (-not $this._undoEnabled) { return }
        
        # Check file size limit
        $docSize = ($this.Lines | ForEach-Object { $_.Length } | Measure-Object -Sum).Sum
        if ($docSize -gt $this._maxFileSizeForUndo) {
            $this._undoEnabled = $false
            $this.StatusMessage = "Undo disabled - file too large"
            return
        }
        
        $state = @{
            Lines = $this.Lines.Clone()
            CursorX = $this.CursorX
            CursorY = $this.CursorY
            ScrollOffsetX = $this.ScrollOffsetX
            ScrollOffsetY = $this.ScrollOffsetY
        }
        
        # Remove any redo states if we're not at the end
        if ($this._currentUndoIndex -lt $this._undoStates.Count - 1) {
            $removeCount = $this._undoStates.Count - $this._currentUndoIndex - 1
            for ($i = 0; $i -lt $removeCount; $i++) {
                $this._undoStates.RemoveAt($this._undoStates.Count - 1)
            }
        }
        
        $this._undoStates.Add($state) | Out-Null
        $this._currentUndoIndex = $this._undoStates.Count - 1
        
        # Limit undo history
        if ($this._undoStates.Count -gt $this._maxUndoStates) {
            $this._undoStates.RemoveAt(0)
            $this._currentUndoIndex--
        }
        
        # Publish buffer state change event
        if ($this.EventBus) {
            try {
                $this.EventBus.Publish('editor.buffer.state-saved', @{
                    FilePath = $this.FilePath
                    UndoStates = $this._undoStates.Count
                    CurrentIndex = $this._currentUndoIndex
                })
            }
            catch {
                # Ignore event publishing errors to avoid disrupting editing
            }
        }
    }
    
    [void] PerformUndo() {
        if ($this._currentUndoIndex -le 0) { return }
        
        $this._currentUndoIndex--
        $state = $this._undoStates[$this._currentUndoIndex]
        
        $this.Lines = $state.Lines.Clone()
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] PerformRedo() {
        if ($this._currentUndoIndex -ge $this._undoStates.Count - 1) { return }
        
        $this._currentUndoIndex++
        $state = $this._undoStates[$this._currentUndoIndex]
        
        $this.Lines = $state.Lines.Clone()
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [bool] ShouldSaveUndoForLine() {
        # For line-based undo, save state when cursor moves to a different line
        # or if this is the very first edit
        if ($this._undoStates.Count -eq 0) { return $true }
        
        $lastState = $this._undoStates[$this._currentUndoIndex]
        return ($lastState.CursorY -ne $this.CursorY)
    }
    
    [void] OnApplicationFocusChanged([bool]$hasFocus) {
        # Called by PRAXIS framework when window focus changes
        if ($this._lastFocusState -and -not $hasFocus) {
            # Lost focus - trigger auto-save if enabled and file is modified
            if ($this.AutoSaveOnFocusLoss -and $this.Modified -and $this.FilePath) {
                $this.AutoSave()
            }
        }
        $this._lastFocusState = $hasFocus
    }
    
    [void] AutoSave() {
        try {
            $content = $this.Lines -join "`n"
            $autoSavePath = "$($this.FilePath).autosave"
            Set-Content -Path $autoSavePath -Value $content -NoNewline -ErrorAction Stop
            $this.StatusMessage = "Auto-saved on focus loss"
            if ($global:Logger) {
                $global:Logger.Debug("TextEditor: Auto-saved to $autoSavePath")
            }
        }
        catch {
            $this.StatusMessage = "Auto-save failed: $_"
            if ($global:Logger) {
                $global:Logger.Error("TextEditor: Auto-save failed: $_")
            }
        }
        $this.Invalidate()
    }
    
    [void] OnInitialize() {
        # Get PRAXIS services
        try {
            $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
            $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        }
        catch {
            if ($global:Logger) {
                $global:Logger.Warning("TextEditor: Could not get PRAXIS services: $_")
            }
        }
        
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        } elseif (-not $this.Lines.Count) {
            $this.Lines.Add("") | Out-Null
        }
        
        # Update title
        if ($this.FilePath) {
            $this.Title = "Text Editor - $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        
        # Subscribe to focus change events if EventBus is available
        if ($this.EventBus) {
            try {
                $this.EventBus.Subscribe('application.focus.changed', $this.OnApplicationFocusChanged.GetNewClosure())
            }
            catch {
                if ($global:Logger) {
                    $global:Logger.Warning("TextEditor: Could not subscribe to focus events: $_")
                }
            }
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # TextEditor itself is the focusable element
        $this.Focus()
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw -ErrorAction Stop
            if ($content) {
                $this.Lines.Clear()
                $lineArray = $content -split "`r?`n"
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.Modified = $false
            $this.StatusMessage = "File loaded: $([System.IO.Path]::GetFileName($this.FilePath))"
            
            # Publish file loaded event
            if ($this.EventBus) {
                try {
                    $this.EventBus.Publish('editor.file.loaded', @{
                        FilePath = $this.FilePath
                        LineCount = $this.Lines.Count
                    })
                }
                catch {
                    # Ignore event publishing errors
                }
            }
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
            if (-not $this.Lines.Count) {
                $this.Lines.Add("") | Out-Null
            }
        }
        $this.Invalidate()
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            # Open file browser for save location
            $this.OpenFileBrowser()
            return
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $this.FilePath -Value $content -NoNewline -ErrorAction Stop
            $this.Modified = $false
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($this.FilePath))"
            
            # Publish file saved event
            if ($this.EventBus) {
                try {
                    $this.EventBus.Publish('editor.file.saved', @{
                        FilePath = $this.FilePath
                        LineCount = $this.Lines.Count
                    })
                }
                catch {
                    # Ignore event publishing errors
                }
            }
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
        $this.Invalidate()
    }
    
    [void] OpenFileBrowser() {
        # Open file browser for file selection
        try {
            $fileBrowserType = [type]"FileBrowserScreen"
            if ($fileBrowserType) {
                $fileBrowser = $fileBrowserType::new()
                
                # Set up callback for file selection
                $editor = $this
                $fileBrowser.FileSelectedCallback = {
                    param($filePath)
                    if ($filePath -and (Test-Path $filePath)) {
                        $item = Get-Item $filePath -ErrorAction SilentlyContinue
                        if ($item -and -not $item.PSIsContainer) {
                            # File selected - either save current content or load new file
                            if ($editor.StatusMessage -eq "SELECT_SAVE_LOCATION") {
                                # Save current content to selected file
                                $editor.FilePath = $filePath
                                $editor.SaveFile()
                            } else {
                                # Load selected file
                                $editor.FilePath = $filePath
                                $editor.LoadFile()
                            }
                        }
                    }
                    
                    # Close the file browser
                    $screenManager = $editor.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Pop() | Out-Null
                }.GetNewClosure()
                
                # Push the file browser
                $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                $screenManager.Push($fileBrowser)
            }
        } catch {
            $this.StatusMessage = "FileBrowser not available"
            $this.Invalidate()
        }
    }
    
    # Override HandleScreenInput for text editor controls
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Clear status message on input (except for certain messages)
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Error") -and $this.StatusMessage -ne "SELECT_SAVE_LOCATION") {
            $this.StatusMessage = ""
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TextEditorScreen.HandleScreenInput: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' InTextMode=$($this.InTextMode)")
        }
        
        # ESC toggles between text mode and command mode
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $this.InTextMode = -not $this.InTextMode
            $this.StatusMessage = if ($this.InTextMode) { "TEXT MODE" } else { "COMMAND MODE" }
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: ESC pressed, InTextMode=$($this.InTextMode)")
            }
            $this.Invalidate()
            return $true
        }
        
        # In command mode, let number keys bubble up for tab switching
        if (-not $this.InTextMode -and $keyInfo.KeyChar -ge '1' -and $keyInfo.KeyChar -le '9') {
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: In command mode, not handling number key '$($keyInfo.KeyChar)'")
            }
            return $false  # Let parent handle tab switching
        }
        
        # Handle control key combinations
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::S) { 
                    $this.SaveFile()
                    return $true 
                }
                ([ConsoleKey]::O) { 
                    $this.OpenFileBrowser()
                    return $true 
                }
                ([ConsoleKey]::Z) {
                    if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {
                        $this.PerformRedo()
                    } else {
                        $this.PerformUndo()
                    }
                    return $true
                }
                ([ConsoleKey]::Y) {
                    $this.PerformRedo()
                    return $true
                }
                ([ConsoleKey]::Q) { 
                    if ($this.Modified) {
                        $this.StatusMessage = "Unsaved changes! Press Ctrl+Q again to quit"
                        $this.Invalidate()
                    } else {
                        $this.Active = $false
                    }
                    return $true
                }
            }
        }
        
        # Handle regular keys
        switch ($keyInfo.Key) {
            # Navigation
            ([ConsoleKey]::UpArrow) { $this.MoveCursor(0, -1); return $true }
            ([ConsoleKey]::DownArrow) { $this.MoveCursor(0, 1); return $true }
            ([ConsoleKey]::LeftArrow) { $this.MoveCursor(-1, 0); return $true }
            ([ConsoleKey]::RightArrow) { $this.MoveCursor(1, 0); return $true }
            ([ConsoleKey]::Home) { $this.CursorX = 0; $this.EnsureCursorVisible(); $this.Invalidate(); return $true }
            ([ConsoleKey]::End) { 
                if ($this.CursorY -lt $this.Lines.Count) {
                    $this.CursorX = $this.Lines[$this.CursorY].Length
                }
                $this.EnsureCursorVisible()
                $this.Invalidate()
                return $true
            }
            ([ConsoleKey]::PageUp) { $this.PageUp(); return $true }
            ([ConsoleKey]::PageDown) { $this.PageDown(); return $true }
            
            # Editing
            ([ConsoleKey]::Enter) { $this.InsertNewline(); return $true }
            ([ConsoleKey]::Backspace) { $this.Backspace(); return $true }
            ([ConsoleKey]::Delete) { $this.Delete(); return $true }
            ([ConsoleKey]::Tab) { $this.InsertTab(); return $true }
        }
        
        # Insert printable characters only in text mode
        if ($this.InTextMode -and $keyInfo.KeyChar -and [char]::IsControl($keyInfo.KeyChar) -eq $false) {
            $this.InsertChar($keyInfo.KeyChar)
            return $true
        }
        
        # Let base class handle other input (like tab switching)
        return $false
    }
    
    # Text editor specific methods
    [void] MoveCursor([int]$dx, [int]$dy) {
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.Lines.Count - 1, $this.CursorY + $dy))
        
        if ($dx -ne 0) {
            $this.CursorX = [Math]::Max(0, $this.CursorX + $dx)
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        } else {
            # Vertical movement - try to maintain column
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        }
        
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertChar([char]$char) {
        # Save undo state if this is the first edit on this line
        if ($this.ShouldSaveUndoForLine()) {
            $this.SaveUndoState()
        }
        
        $line = $this.Lines[$this.CursorY]
        $this.Lines[$this.CursorY] = $line.Insert($this.CursorX, $char)
        $this.CursorX++
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertNewline() {
        # Always save undo state before creating a new line
        $this.SaveUndoState()
        
        $line = $this.Lines[$this.CursorY]
        $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
        $after = if ($this.CursorX -lt $line.Length) { $line.Substring($this.CursorX) } else { "" }
        
        $this.Lines[$this.CursorY] = $before
        $this.Lines.Insert($this.CursorY + 1, $after)
        
        $this.CursorY++
        $this.CursorX = 0
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Backspace() {
        if ($this.CursorX -gt 0) {
            # Save undo state if this is first edit on this line
            if ($this.ShouldSaveUndoForLine()) {
                $this.SaveUndoState()
            }
            # Delete character before cursor
            $line = $this.Lines[$this.CursorY]
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Always save undo state before joining lines
            $this.SaveUndoState()
            # Join with previous line
            $prevLine = $this.Lines[$this.CursorY - 1]
            $currentLine = $this.Lines[$this.CursorY]
            $this.CursorX = $prevLine.Length
            $this.Lines[$this.CursorY - 1] = $prevLine + $currentLine
            $this.Lines.RemoveAt($this.CursorY)
            $this.CursorY--
        }
        
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Delete() {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.CursorX -lt $line.Length) {
            # Save undo state if this is first edit on this line
            if ($this.ShouldSaveUndoForLine()) {
                $this.SaveUndoState()
            }
            # Delete character at cursor
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX, 1)
        } elseif ($this.CursorY -lt $this.Lines.Count - 1) {
            # Always save undo state before joining lines
            $this.SaveUndoState()
            # Join with next line
            $nextLine = $this.Lines[$this.CursorY + 1]
            $this.Lines[$this.CursorY] = $line + $nextLine
            $this.Lines.RemoveAt($this.CursorY + 1)
        }
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] InsertTab() {
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
    
    [void] PageUp() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] PageDown() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Min($this.Lines.Count - 1, $this.CursorY + $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] EnsureCursorVisible() {
        $editorHeight = $this.Height - 6
        $editorWidth = $this.Width - $this.LineNumberWidth
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # When bounds change, ensure cursor is still visible
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096  # Text editor can have large content
        
        # Get theme colors
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
        $lineNumColor = if ($this.Theme) { $this.Theme.GetColor("linenumber") } else { $fgColor }
        $statusBg = if ($this.Theme) { $this.Theme.GetBgColor("status") } else { $bgColor }
        $statusFg = if ($this.Theme) { $this.Theme.GetColor("status.foreground") } else { $fgColor }
        $cursorBg = if ($this.Theme) { $this.Theme.GetBgColor("cursor") } else { $fgColor }
        
        # Calculate content area
        $contentHeight = $this.Height - 3  # Reserve space for title and status
        $contentWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartX = $this.X + ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartY = $this.Y + 1
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        # Draw title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        $titleText = $this.Title
        if ($this.Modified) { $titleText += " *" }
        $titleText = $titleText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($titleText)
        
        # Render text lines
        $endY = [Math]::Min($this.ScrollOffsetY + $contentHeight, $this.Lines.Count)
        for ($lineIdx = $this.ScrollOffsetY; $lineIdx -lt $endY; $lineIdx++) {
            $screenY = $contentStartY + ($lineIdx - $this.ScrollOffsetY)
            $line = $this.Lines[$lineIdx]
            
            # Draw line numbers if enabled
            if ($this.ShowLineNumbers) {
                $sb.Append([VT]::MoveTo($this.X, $screenY))
                $sb.Append($lineNumColor)
                $lineNum = ($lineIdx + 1).ToString().PadLeft($this.LineNumberWidth - 1) + " "
                $sb.Append($lineNum)
            }
            
            # Draw line content
            $sb.Append([VT]::MoveTo($contentStartX, $screenY))
            $sb.Append($fgColor)
            
            if ($line.Length -gt $this.ScrollOffsetX) {
                $visibleText = $line.Substring($this.ScrollOffsetX)
                if ($visibleText.Length -gt $contentWidth) {
                    $visibleText = $visibleText.Substring(0, $contentWidth)
                }
                $sb.Append($visibleText)
            }
        }
        
        # Draw cursor if this screen is focused
        if ($this.IsFocused) {
            $cursorScreenX = $contentStartX + ($this.CursorX - $this.ScrollOffsetX)
            $cursorScreenY = $contentStartY + ($this.CursorY - $this.ScrollOffsetY)
            
            # Only draw cursor if it's visible
            if ($cursorScreenX -ge $contentStartX -and $cursorScreenX -lt $contentStartX + $contentWidth -and
                $cursorScreenY -ge $contentStartY -and $cursorScreenY -lt $contentStartY + $contentHeight) {
                
                $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
                $sb.Append($cursorBg)
                
                # Get character under cursor
                $charUnderCursor = " "
                if ($this.CursorY -lt $this.Lines.Count) {
                    $line = $this.Lines[$this.CursorY]
                    if ($this.CursorX -lt $line.Length) {
                        $charUnderCursor = $line[$this.CursorX]
                    }
                }
                $sb.Append($charUnderCursor)
            }
        }
        
        # Draw status line
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        
        $statusText = ""
        if ($this.StatusMessage) {
            $statusText = $this.StatusMessage
        } else {
            $modeText = if ($this.InTextMode) { "[TEXT]" } else { "[COMMAND]" }
            $statusText = "$modeText Line $($this.CursorY + 1), Col $($this.CursorX + 1)"
            if ($this.FilePath) {
                $statusText += " | $([System.IO.Path]::GetFileName($this.FilePath))"
            }
        }
        $statusText = $statusText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($statusText)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/TextEditorScreenNew.ps1
# TextEditorScreenNew.ps1 - Refactored text editor with Buffer/View architecture
# Implements the professional architecture from the upgrade plan

class TextEditorScreenNew : Screen {
    # Buffer/View separation - DocumentBuffer or GapBufferDocumentBuffer handles all text logic
    hidden [object]$_buffer
    
    # Cursor and viewport state (UI concerns only)
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$StatusMessage = ""
    
    # Line-level render cache for performance
    hidden [hashtable]$_lineRenderCache
    hidden [hashtable]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Selection state for block selection
    [bool]$HasSelection = $false
    [int]$SelectionStartX = 0
    [int]$SelectionStartY = 0
    [int]$SelectionEndX = 0
    [int]$SelectionEndY = 0
    [bool]$InSelectionMode = $false
    
    # PRAXIS service integration
    hidden [object]$ThemeManager
    hidden [object]$EventBus
    
    # Proper undo system - tracks complete document state
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [bool]$_groupingInserts = $false
    hidden [datetime]$_lastActionTime = [datetime]::MinValue
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    [bool]$AutoSaveOnFocusLoss = $true
    
    # Clipboard system
    hidden [string]$_clipboard = ""
    
    TextEditorScreenNew() : base() {
        $this.Title = "Text Editor"
        $this._buffer = [GapBufferDocumentBuffer]::new()
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        
        # Initialize simple undo system
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        
        # Add some sample content for testing
        $this.AddSampleContent()
    }
    
    TextEditorScreenNew([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this._buffer = [GapBufferDocumentBuffer]::new($filePath)
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        $this.UpdateTitle()
    }
    
    TextEditorScreenNew([string]$filePath, [bool]$useGapBuffer) : base() {
        $this.Title = "Text Editor"
        if ($useGapBuffer) {
            $this._buffer = [GapBufferDocumentBuffer]::new($filePath)
        } else {
            $this._buffer = [DocumentBuffer]::new($filePath)
        }
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        $this.UpdateTitle()
    }
    
    [void] OnInitialize() {
        # Get PRAXIS services
        $this.ThemeManager = $this.ServiceContainer.GetService("ThemeManager")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
    }
    
    hidden [void] InitializeRenderCache() {
        $this._lineRenderCache = @{}
        $this._dirtyLines = @{}
    }
    
    hidden [void] SetupBufferEventHandlers() {
        # Buffer notifies us when content changes
        $screen = $this
        $this._buffer.OnContentChanged = {
            $screen.OnBufferContentChanged()
        }.GetNewClosure()
        
        $this._buffer.OnModifiedStateChanged = {
            param($isModified)
            $screen.OnBufferModifiedStateChanged($isModified)
        }.GetNewClosure()
    }
    
    hidden [void] OnBufferContentChanged() {
        # Mark lines dirty based on buffer's dirty tracking
        for ($i = 0; $i -lt $this._buffer.GetLineCount(); $i++) {
            if ($this._buffer.IsLineDirty($i)) {
                $this._dirtyLines[$i] = $true
            }
        }
        $this.Invalidate()
    }
    
    hidden [void] OnBufferModifiedStateChanged([bool]$isModified) {
        $this.UpdateTitle()
        $this.Invalidate()
    }
    
    hidden [void] UpdateTitle() {
        $fileName = if ($this._buffer.FilePath) { 
            [System.IO.Path]::GetFileName($this._buffer.FilePath) 
        } else { 
            "Untitled" 
        }
        $modifiedIndicator = if ($this._buffer.IsModified) { "*" } else { "" }
        $this.Title = "Text Editor - $fileName$modifiedIndicator"
    }
    
    hidden [void] AddSampleContent() {
        # Add some sample content to test the editor
        $sampleText = @"
Welcome to PRAXIS Text Editor!

This is the new Buffer/View architecture with:
 Gap Buffer for high-performance editing
 Line-level render caching for performance
 Block selection with visual highlighting
 Find/Replace with comprehensive search
 Professional copy/paste system

Try these features:
 Shift+Arrow keys for block selection
 Ctrl+C/X/V for copy/cut/paste
 Ctrl+F for find, Ctrl+H for replace
 Ctrl+U/R for undo/redo
 Ctrl+A to select all

The architecture is now professional-grade!
"@
        
        # Set the content using the buffer's proper interface
        # This bypasses the command system intentionally so it doesn't affect undo
        if ($this._buffer.GetType().Name -eq "GapBufferDocumentBuffer") {
            # Use GapBuffer's SetText method
            $this._buffer._gapBuffer.SetText($sampleText + "`n")
            $this._buffer.InvalidateLineIndex()
        } else {
            # Use DocumentBuffer's Lines property
            $this._buffer.Lines.Clear()
            $lines = $sampleText -split "`r?`n"
            foreach ($line in $lines) {
                $this._buffer.Lines.Add($line) | Out-Null
            }
        }
        
        # Clear the undo/redo stacks since this is initial content
        $this._buffer.ClearUndoHistory()
        $this._buffer.IsModified = $false
        
        $this._allLinesDirty = $true
    }
    
    # --- Input Handling - Translates keys to commands ---
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle special keys first
        if ($this.HandleSpecialKeys($keyInfo)) {
            return $true
        }
        
        # Handle character insertion
        if ($keyInfo.KeyChar -and -not [char]::IsControl($keyInfo.KeyChar)) {
            $this.InsertCharacter($keyInfo.KeyChar)
            return $true
        }
        
        return $false
    }
    
    hidden [bool] HandleSpecialKeys([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Backspace) {
                $this.HandleBackspace()
                return $true
            }
            ([System.ConsoleKey]::Delete) {
                $this.HandleDelete()
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $this.HandleEnter()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                $this.HandleTab()
                return $true
            }
            ([System.ConsoleKey]::LeftArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorLeft($extend)
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorRight($extend)
                return $true
            }
            ([System.ConsoleKey]::UpArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorUp($extend)
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                $extend = $keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift
                $this.MoveCursorDown($extend)
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.MoveCursorHome($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.MoveCursorEnd($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::PageUp) {
                $this.MoveCursorPageUp($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::PageDown) {
                $this.MoveCursorPageDown($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
        }
        
        # Handle Ctrl combinations
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([System.ConsoleKey]::S) {
                    $this.SaveFile()
                    return $true
                }
                ([System.ConsoleKey]::O) {
                    $this.OpenFile()
                    return $true
                }
                ([System.ConsoleKey]::N) {
                    $this.NewFile()
                    return $true
                }
                ([System.ConsoleKey]::U) {
                    $this.UndoEdit()
                    return $true
                }
                ([System.ConsoleKey]::R) {
                    $this.RedoEdit()
                    return $true
                }
                ([System.ConsoleKey]::C) {
                    $this.CopySelection()
                    return $true
                }
                ([System.ConsoleKey]::X) {
                    $this.CutSelection()
                    return $true
                }
                ([System.ConsoleKey]::V) {
                    $this.PasteClipboard()
                    return $true
                }
                ([System.ConsoleKey]::A) {
                    $this.SelectAll()
                    return $true
                }
                ([System.ConsoleKey]::F) {
                    $this.ShowFindReplaceDialog()
                    return $true
                }
                ([System.ConsoleKey]::H) {
                    $this.ShowFindReplaceDialog()
                    return $true
                }
                ([System.ConsoleKey]::I) {
                    $this.ShowBufferInfo()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    # --- Text Editing Operations (Command Pattern) ---
    
    hidden [void] InsertCharacter([char]$char) {
        try {
            # Delete selection first if it exists (standard text editor behavior)
            if ($this.HasSelection) {
                $this.DeleteSelection()
            }
            
            # Check if we should group this insert with previous ones
            $now = [datetime]::Now
            $timeDiff = $now - $this._lastActionTime
            $shouldGroup = $this._groupingInserts -and $timeDiff.TotalMilliseconds -lt 1000
            
            if (-not $shouldGroup) {
                # Save complete document state before making changes
                $this.SaveDocumentState()
                $this._groupingInserts = $true
            }
            
            # Insert character
            $this._buffer.InsertTextAt($this.CursorY, $this.CursorX, [string]$char)
            $this.CursorX++
            $this._lastActionTime = $now
            
            # Mark as modified
            $this._buffer.IsModified = $true
            $this._allLinesDirty = $true
            if ($this._lineRenderCache) {
                $this._lineRenderCache.Clear()
            }
            
            $this.EnsureCursorVisible()
            $this.Invalidate()
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("InsertCharacter failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Character insertion failed"
        }
    }
    
    hidden [void] HandleBackspace() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
            return
        }
        
        # Stop grouping inserts when user starts deleting
        $this._groupingInserts = $false
        $this.SaveDocumentState()
        
        if ($this.CursorX -gt 0) {
            # Delete character before cursor
            $this._buffer.DeleteTextAt($this.CursorY, $this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Join with previous line
            $prevLineLength = $this._buffer.GetLine($this.CursorY - 1).Length
            $currentLineText = $this._buffer.GetLine($this.CursorY)
            $this._buffer.JoinLinesAt($this.CursorY - 1, "")
            $this.CursorY--
            $this.CursorX = $prevLineLength
        }
        
        $this._buffer.IsModified = $true
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    hidden [void] HandleDelete() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
            return
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        if ($this.CursorX -lt $currentLine.Length) {
            # Delete character at cursor
            $charToDelete = $this._buffer.GetTextAt($this.CursorY, $this.CursorX, 1)
            $command = [DeleteTextCommand]::new($this.CursorY, $this.CursorX, $charToDelete)
            $this._buffer.ExecuteCommand($command)
        } elseif ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            # Join with next line
            $nextLineText = $this._buffer.GetLine($this.CursorY + 1)
            $command = [JoinLinesCommand]::new($this.CursorY, $nextLineText)
            $this._buffer.ExecuteCommand($command)
        }
    }
    
    hidden [void] HandleEnter() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $rightText = $currentLine.Substring($this.CursorX)
        $command = [InsertNewlineCommand]::new($this.CursorY, $this.CursorX, $rightText)
        $this._buffer.ExecuteCommand($command)
        $this.CursorY++
        $this.CursorX = 0
        $this.EnsureCursorVisible()
        $this.ClearSelection()
    }
    
    hidden [void] HandleTab() {
        # Delete selection first if it exists
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        $spaces = " " * $this.TabWidth
        $command = [InsertTextCommand]::new($this.CursorY, $this.CursorX, $spaces)
        $this._buffer.ExecuteCommand($command)
        $this.CursorX += $this.TabWidth
        $this.EnsureCursorVisible()
    }
    
    # --- File Operations ---
    
    [void] SaveFile([string]$filePath = "") {
        try {
            if ([string]::IsNullOrEmpty($filePath)) {
                $filePath = $this._buffer.FilePath
            }
            if ([string]::IsNullOrEmpty($filePath)) {
                # TODO: Open file dialog
                $this.StatusMessage = "No file path specified"
                return
            }
            
            $this._buffer.SaveToFile($filePath)
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($filePath))"
            $this.UpdateTitle()
        } catch {
            $this.StatusMessage = "Error saving file: $($_.Exception.Message)"
        }
    }
    
    [void] OpenFile([string]$filePath = "") {
        # TODO: Implement file dialog
        $this.StatusMessage = "Open file not yet implemented"
    }
    
    [void] NewFile() {
        $this._buffer = [DocumentBuffer]::new()
        $this.SetupBufferEventHandlers()
        $this.CursorX = 0
        $this.CursorY = 0
        $this.ScrollOffsetX = 0
        $this.ScrollOffsetY = 0
        $this.ClearSelection()
        $this._allLinesDirty = $true
        $this._lineRenderCache.Clear()
        $this.UpdateTitle()
        $this.StatusMessage = "New file created"
        $this.Invalidate()
    }
    
    # --- Find/Replace Dialog ---
    
    [void] ShowFindReplaceDialog() {
        try {
            # Create the find/replace dialog
            $findDialog = [FindReplaceDialog]::new($this)
            
            # Set up callback for when dialog closes
            $editor = $this
            $findDialog.OnClose = {
                # Focus returns to editor when dialog closes
                $editor.Focus()
            }.GetNewClosure()
            
            # Push the dialog onto the screen stack
            $screenManager = $this.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Push($findDialog)
            } else {
                $this.StatusMessage = "Cannot open find dialog: ScreenManager not available"
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ShowFindReplaceDialog failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Error opening find dialog: $($_.Exception.Message)"
        }
    }
    
    # --- Buffer Information ---
    
    [void] ShowBufferInfo() {
        try {
            if ($this._buffer.GetType().Name -eq "GapBufferDocumentBuffer") {
                $stats = $this._buffer.GetStatistics()
                $gapStats = $stats.GapBuffer
                
                $info = @"
Gap Buffer Performance Statistics:

Buffer Info:
 Length: $($gapStats.Length) characters
 Capacity: $($gapStats.Capacity) characters  
 Gap Size: $($gapStats.GapSize) characters
 Gap Position: $($gapStats.GapStart)-$($gapStats.GapEnd)

Operations:
 Inserts: $($gapStats.InsertCount)
 Deletes: $($gapStats.DeleteCount)  
 Gap Moves: $($gapStats.MoveCount)
 Buffer Grows: $($gapStats.GrowCount)
 Efficiency: $($gapStats.Efficiency) ops/move

Document Info:
 Lines: $($stats.LineCount)
 Line Index Rebuilds: $($stats.LineIndexRebuildCount)
 Undo Stack: $($stats.UndoStackSize)
 Redo Stack: $($stats.RedoStackSize)
"@
            } else {
                $info = @"
ArrayList Document Buffer:

Buffer Info:
 Lines: $($this._buffer.GetLineCount())
 Total Characters: $($this._buffer.Lines | ForEach-Object { $_.Length } | Measure-Object -Sum | Select-Object -ExpandProperty Sum)
 Undo Stack: $($this._buffer._undoStack.Count)
 Redo Stack: $($this._buffer._redoStack.Count)

Note: Using basic ArrayList implementation.
Switch to GapBufferDocumentBuffer for better performance.
"@
            }
            
            $this.StatusMessage = "Buffer statistics shown. Press any key to continue editing."
            $this.Invalidate()
            
            # Simple info display in status - in a real implementation you might want a dialog
            if ($global:Logger) {
                $global:Logger.Info("Buffer Statistics:`n$info")
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ShowBufferInfo failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Error retrieving buffer information"
        }
    }
    
    # --- Undo/Redo ---
    
    [void] UndoEdit() {
        if ($this._undoStack.Count -eq 0) {
            $this.StatusMessage = "Nothing to undo"
            return
        }
        
        try {
            # Stop any current grouping
            $this._groupingInserts = $false
            
            # Save current document state for redo
            $currentState = $this.GetDocumentState()
            $this._redoStack.Add($currentState) | Out-Null
            
            # Get and apply previous state
            $previousState = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            
            $this.RestoreDocumentState($previousState)
            $this.StatusMessage = "Undo"
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("UndoEdit failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Undo failed"
        }
    }
    
    [void] RedoEdit() {
        if ($this._redoStack.Count -eq 0) {
            $this.StatusMessage = "Nothing to redo"
            return
        }
        
        try {
            # Stop any current grouping
            $this._groupingInserts = $false
            
            # Save current document state for undo
            $currentState = $this.GetDocumentState()
            $this._undoStack.Add($currentState) | Out-Null
            
            # Get and apply redo state
            $redoState = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            
            $this.RestoreDocumentState($redoState)
            $this.StatusMessage = "Redo"
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("RedoEdit failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Redo failed"
        }
    }
    
    hidden [void] SaveDocumentState() {
        $state = $this.GetDocumentState()
        $this._undoStack.Add($state) | Out-Null
        
        # Clear redo stack when new action is performed
        $this._redoStack.Clear()
        
        # Limit undo history
        if ($this._undoStack.Count -gt 50) {
            $this._undoStack.RemoveAt(0)
        }
    }
    
    hidden [hashtable] GetDocumentState() {
        # Create a deep copy of the document state
        $linesCopy = [System.Collections.ArrayList]::new()
        foreach ($line in $this._buffer.Lines) {
            $linesCopy.Add([string]$line) | Out-Null
        }
        
        return @{
            Lines = $linesCopy
            CursorX = $this.CursorX
            CursorY = $this.CursorY
            ScrollOffsetX = $this.ScrollOffsetX
            ScrollOffsetY = $this.ScrollOffsetY
            IsModified = $this._buffer.IsModified
        }
    }
    
    hidden [void] RestoreDocumentState([hashtable]$state) {
        # Restore the complete document state
        $this._buffer.Lines.Clear()
        foreach ($line in $state.Lines) {
            $this._buffer.Lines.Add([string]$line) | Out-Null
        }
        
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        $this._buffer.IsModified = $state.IsModified
        
        # Mark all lines dirty and refresh
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    
    # --- Selection and Clipboard (Stub implementations) ---
    
    hidden [void] ClearSelection() {
        $this.HasSelection = $false
        $this.InSelectionMode = $false
        $this.SelectionStartX = 0
        $this.SelectionStartY = 0
        $this.SelectionEndX = 0
        $this.SelectionEndY = 0
    }
    
    hidden [void] StartSelection() {
        $this.HasSelection = $true
        $this.InSelectionMode = $true
        $this.SelectionStartX = $this.CursorX
        $this.SelectionStartY = $this.CursorY
        $this.SelectionEndX = $this.CursorX
        $this.SelectionEndY = $this.CursorY
    }
    
    hidden [void] UpdateSelection() {
        if ($this.HasSelection) {
            $this.SelectionEndX = $this.CursorX
            $this.SelectionEndY = $this.CursorY
            $this._allLinesDirty = $true  # Selection changes require full redraw
            $this.Invalidate()
        }
    }
    
    hidden [void] DeleteSelection() {
        if (-not $this.HasSelection) {
            return
        }
        
        # Get normalized selection bounds
        $bounds = $this.GetSelectionBounds()
        
        # Save state for undo
        $this.SaveDocumentState()
        
        # Delete the selected text
        if ($bounds.StartY -eq $bounds.EndY) {
            # Single line selection
            $this._buffer.DeleteTextAt($bounds.StartY, $bounds.StartX, $bounds.EndX - $bounds.StartX)
        } else {
            # Multi-line selection - delete from end to start to preserve positions
            for ($y = $bounds.EndY; $y -ge $bounds.StartY; $y--) {
                if ($y -eq $bounds.EndY -and $y -eq $bounds.StartY) {
                    # Same line (shouldn't happen but safety check)
                    $this._buffer.DeleteTextAt($y, $bounds.StartX, $bounds.EndX - $bounds.StartX)
                } elseif ($y -eq $bounds.EndY) {
                    # Last line - delete from start to EndX
                    $this._buffer.DeleteTextAt($y, 0, $bounds.EndX)
                } elseif ($y -eq $bounds.StartY) {
                    # First line - delete from StartX to end, then join with next line
                    $line = $this._buffer.GetLine($y)
                    $this._buffer.DeleteTextAt($y, $bounds.StartX, $line.Length - $bounds.StartX)
                    # Remove the now-empty lines that were in between
                    for ($i = $bounds.EndY; $i -gt $bounds.StartY; $i--) {
                        $this._buffer.Lines.RemoveAt($i)
                    }
                    break  # We've handled the deletion
                }
            }
        }
        
        # Move cursor to selection start
        $this.CursorX = $bounds.StartX
        $this.CursorY = $bounds.StartY
        
        $this.ClearSelection()
        $this._buffer.IsModified = $true
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.Invalidate()
    }
    
    hidden [hashtable] GetSelectionBounds() {
        if (-not $this.HasSelection) {
            return @{ StartX = 0; StartY = 0; EndX = 0; EndY = 0 }
        }
        
        # Normalize selection (start should be before end)
        if ($this.SelectionStartY -lt $this.SelectionEndY -or 
            ($this.SelectionStartY -eq $this.SelectionEndY -and $this.SelectionStartX -le $this.SelectionEndX)) {
            return @{
                StartX = $this.SelectionStartX
                StartY = $this.SelectionStartY
                EndX = $this.SelectionEndX
                EndY = $this.SelectionEndY
            }
        } else {
            return @{
                StartX = $this.SelectionEndX
                StartY = $this.SelectionEndY
                EndX = $this.SelectionStartX
                EndY = $this.SelectionStartY
            }
        }
    }
    
    [void] CopySelection() {
        if (-not $this.HasSelection) {
            $this.StatusMessage = "No selection to copy"
            return
        }
        
        $bounds = $this.GetSelectionBounds()
        $copiedText = ""
        
        if ($bounds.StartY -eq $bounds.EndY) {
            # Single line selection
            $line = $this._buffer.GetLine($bounds.StartY)
            $copiedText = $line.Substring($bounds.StartX, $bounds.EndX - $bounds.StartX)
        } else {
            # Multi-line selection
            $lines = [System.Collections.ArrayList]::new()
            
            for ($y = $bounds.StartY; $y -le $bounds.EndY; $y++) {
                $line = $this._buffer.GetLine($y)
                if ($y -eq $bounds.StartY) {
                    # First line - from StartX to end
                    $lines.Add($line.Substring($bounds.StartX)) | Out-Null
                } elseif ($y -eq $bounds.EndY) {
                    # Last line - from start to EndX
                    $lines.Add($line.Substring(0, $bounds.EndX)) | Out-Null
                } else {
                    # Middle lines - entire line
                    $lines.Add($line) | Out-Null
                }
            }
            $copiedText = $lines -join "`n"
        }
        
        # Store in global clipboard
        if (-not $global:TuiClipboard) {
            $global:TuiClipboard = ""
        }
        $global:TuiClipboard = $copiedText
        $this._clipboard = $copiedText
        
        $this.StatusMessage = "Copied to clipboard"
    }
    
    [void] CutSelection() {
        if (-not $this.HasSelection) {
            $this.StatusMessage = "No selection to cut"
            return
        }
        
        # Copy first, then delete
        $this.CopySelection()
        $this.DeleteSelection()
        $this.StatusMessage = "Cut to clipboard"
    }
    
    [void] PasteClipboard() {
        # Get text from global clipboard or internal clipboard
        $textToPaste = ""
        if ($global:TuiClipboard) {
            $textToPaste = $global:TuiClipboard
        } elseif ($this._clipboard) {
            $textToPaste = $this._clipboard
        } else {
            $this.StatusMessage = "Clipboard is empty"
            return
        }
        
        # Delete any existing selection first
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        # Save state for undo
        $this.SaveDocumentState()
        
        # Insert the pasted text
        $lines = $textToPaste -split "`n"
        if ($lines.Count -eq 1) {
            # Single line paste
            $this._buffer.InsertTextAt($this.CursorY, $this.CursorX, $textToPaste)
            $this.CursorX += $textToPaste.Length
        } else {
            # Multi-line paste
            $currentLine = $this._buffer.GetLine($this.CursorY)
            $leftPart = $currentLine.Substring(0, $this.CursorX)
            $rightPart = $currentLine.Substring($this.CursorX)
            
            # Replace current line with first line of paste
            $this._buffer.Lines[$this.CursorY] = $leftPart + $lines[0]
            
            # Insert middle lines
            for ($i = 1; $i -lt $lines.Count - 1; $i++) {
                $this._buffer.Lines.Insert($this.CursorY + $i, $lines[$i])
            }
            
            # Insert last line and append remaining text
            if ($lines.Count -gt 1) {
                $lastLine = $lines[$lines.Count - 1] + $rightPart
                $this._buffer.Lines.Insert($this.CursorY + $lines.Count - 1, $lastLine)
                $this.CursorY += $lines.Count - 1
                $this.CursorX = $lines[$lines.Count - 1].Length
            }
        }
        
        $this._buffer.IsModified = $true
        $this._allLinesDirty = $true
        if ($this._lineRenderCache) {
            $this._lineRenderCache.Clear()
        }
        $this.EnsureCursorVisible()
        $this.Invalidate()
        $this.StatusMessage = "Pasted from clipboard"
    }
    
    [void] SelectAll() {
        $this.StartSelection()
        
        # Set selection to entire document
        $this.SelectionStartX = 0
        $this.SelectionStartY = 0
        
        $lastLineIndex = $this._buffer.GetLineCount() - 1
        $this.SelectionEndY = $lastLineIndex
        $this.SelectionEndX = $this._buffer.GetLine($lastLineIndex).Length
        
        # Move cursor to end
        $this.CursorY = $this.SelectionEndY
        $this.CursorX = $this.SelectionEndX
        
        $this._allLinesDirty = $true
        $this.Invalidate()
        $this.StatusMessage = "Selected all text"
    }
    
    # --- Cursor Movement (Stub implementations) ---
    
    hidden [void] MoveCursorLeft([bool]$extend) {
        # Start selection if shift is held and no selection exists
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        if ($this.CursorX -gt 0) {
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            $this.CursorY--
            $this.CursorX = $this._buffer.GetLine($this.CursorY).Length
        }
        
        # Update or clear selection
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorRight([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        if ($this.CursorX -lt $currentLine.Length) {
            $this.CursorX++
        } elseif ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            $this.CursorY++
            $this.CursorX = 0
        }
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorUp([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        if ($this.CursorY -gt 0) {
            $this.CursorY--
            $prevLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Min($this.CursorX, $prevLine.Length)
        }
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorDown([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        if ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            $this.CursorY++
            $nextLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Min($this.CursorX, $nextLine.Length)
        }
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorHome([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $this.CursorX = 0
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorEnd([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $this.CursorX = $this._buffer.GetLine($this.CursorY).Length
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorPageUp([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $pageSize = $this.Height - 4
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        
        # Ensure cursor X is within bounds of the new line
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $this.CursorX = [Math]::Min($this.CursorX, $currentLine.Length)
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorPageDown([bool]$extend) {
        if ($extend -and -not $this.HasSelection) {
            $this.StartSelection()
        }
        
        $pageSize = $this.Height - 4
        $this.CursorY = [Math]::Min($this._buffer.GetLineCount() - 1, $this.CursorY + $pageSize)
        
        # Ensure cursor X is within bounds of the new line
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $this.CursorX = [Math]::Min($this.CursorX, $currentLine.Length)
        
        if ($extend) {
            $this.UpdateSelection()
        } else {
            $this.ClearSelection()
        }
        
        $this.EnsureCursorVisible()
    }
    
    hidden [void] ValidateCursorPosition() {
        # Ensure cursor is within valid bounds
        $lineCount = $this._buffer.GetLineCount()
        if ($lineCount -eq 0) {
            $this.CursorX = 0
            $this.CursorY = 0
            return
        }
        
        # Clamp cursor Y to valid range
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.CursorY, $lineCount - 1))
        
        # Clamp cursor X to current line length
        try {
            $currentLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Max(0, [Math]::Min($this.CursorX, $currentLine.Length))
        } catch {
            # If we can't get the line, reset cursor to safe position
            $this.CursorX = 0
            $this.CursorY = 0
        }
    }
    
    hidden [void] EnsureCursorVisible() {
        # Implement viewport scrolling to keep cursor visible
        $editorHeight = $this.Height - 2  # Account for status line
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        $editorWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
        
        # Ensure scroll offsets are valid
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY)
        $this.ScrollOffsetX = [Math]::Max(0, $this.ScrollOffsetX)
        
        $this.Invalidate()
    }
    
    # --- Optimized Rendering with Line-Level Caching ---
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Render with line caching for performance
        $this.RenderWithCache($sb)
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    hidden [void] RenderWithCache([System.Text.StringBuilder]$sb) {
        # Clear the entire screen area first with background color
        $bgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("background") } else { "" }
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        # Calculate editor area
        $editorHeight = $this.Height - 1  # Reserve bottom for status
        $editorWidth = $this.Width
        $lineNumWidth = if ($this.ShowLineNumbers) { $this.LineNumberWidth } else { 0 }
        $textWidth = $editorWidth - $lineNumWidth
        
        # Render visible lines with caching
        $startLine = $this.ScrollOffsetY
        $endLine = [Math]::Min($startLine + $editorHeight, $this._buffer.GetLineCount())
        
        for ($lineIndex = $startLine; $lineIndex -lt $endLine; $lineIndex++) {
            $y = $lineIndex - $startLine
            $renderLine = ""
            
            # Check if line needs re-rendering
            if ($this._allLinesDirty -or $this._dirtyLines.ContainsKey($lineIndex) -or -not $this._lineRenderCache.ContainsKey($lineIndex)) {
                # Render line from scratch
                $renderLine = $this.RenderLine($lineIndex, $lineNumWidth, $textWidth)
                $this._lineRenderCache[$lineIndex] = $renderLine
            } else {
                # Use cached version
                $renderLine = $this._lineRenderCache[$lineIndex]
            }
            
            # Output the line
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($renderLine)
        }
        
        # Clear dirty flags
        $this._buffer.ClearDirtyLines()
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
        
        # Render cursor if focused and visible
        if ($this.IsFocused) {
            $this.RenderCursor($sb, $lineNumWidth, $editorHeight)
        }
        
        # Render status line
        $statusY = $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $statusY))
        $statusColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("status") } else { "" }
        $statusBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("status") } else { "" }
        $sb.Append($statusBgColor)
        $sb.Append($statusColor)
        $statusText = $this.GetStatusText()
        $sb.Append($statusText.PadRight($this.Width).Substring(0, $this.Width))
    }
    
    hidden [string] RenderLine([int]$lineNumber, [int]$lineNumberWidth, [int]$textWidth) {
        $sb = [System.Text.StringBuilder]::new()
        
        # Get colors
        $textColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("normal") } else { "" }
        $lineNumColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("linenumber") } else { $textColor }
        $bgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("background") } else { "" }
        $selectionBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("selection") } else { "\e[0;7m" }
        $selectionTextColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("selection.text") } else { "" }
        
        # Apply background color
        $sb.Append($bgColor)
        
        # Line number
        if ($this.ShowLineNumbers) {
            $sb.Append($lineNumColor)
            $lineNumText = ($lineNumber + 1).ToString().PadLeft($lineNumberWidth - 1) + " "
            $sb.Append($lineNumText)
        }
        
        # Get line text and determine what's visible
        $lineText = $this._buffer.GetLine($lineNumber)
        $visibleText = $lineText
        if ($this.ScrollOffsetX -gt 0 -and $this.ScrollOffsetX -lt $lineText.Length) {
            $visibleText = $lineText.Substring($this.ScrollOffsetX)
        } elseif ($this.ScrollOffsetX -ge $lineText.Length) {
            $visibleText = ""
        }
        
        if ($visibleText.Length -gt $textWidth) {
            $visibleText = $visibleText.Substring(0, $textWidth)
        }
        
        # Check if this line has selection
        if ($this.HasSelection) {
            $bounds = $this.GetSelectionBounds()
            
            # Check if current line intersects with selection
            if ($lineNumber -ge $bounds.StartY -and $lineNumber -le $bounds.EndY) {
                # Line has selection - render with highlighting
                $this.RenderLineWithSelection($sb, $lineNumber, $visibleText, $textWidth, $bounds, $textColor, $selectionBgColor, $selectionTextColor)
            } else {
                # No selection on this line - render normally
                $sb.Append($textColor)
                $sb.Append($visibleText)
            }
        } else {
            # No selection at all - render normally
            $sb.Append($textColor)
            $sb.Append($visibleText)
        }
        
        # Pad to full width
        $totalRendered = $lineNumberWidth + $visibleText.Length
        if ($totalRendered -lt $this.Width) {
            $sb.Append($bgColor)  # Ensure padding uses background color
            $sb.Append([StringCache]::GetSpaces($this.Width - $totalRendered))
        }
        
        return $sb.ToString()
    }
    
    hidden [void] RenderLineWithSelection([System.Text.StringBuilder]$sb, [int]$lineNumber, [string]$visibleText, [int]$textWidth, [hashtable]$bounds, [string]$textColor, [string]$selectionBgColor, [string]$selectionTextColor) {
        if ($bounds.StartY -eq $bounds.EndY -and $bounds.StartY -eq $lineNumber) {
            # Single line selection
            $selStart = [Math]::Max(0, $bounds.StartX - $this.ScrollOffsetX)
            $selEnd = [Math]::Min($visibleText.Length, $bounds.EndX - $this.ScrollOffsetX)
            
            if ($selStart -ge 0 -and $selStart -lt $visibleText.Length) {
                # Before selection
                if ($selStart -gt 0) {
                    $sb.Append($textColor)
                    $sb.Append($visibleText.Substring(0, $selStart))
                }
                
                # Selection
                if ($selEnd -gt $selStart) {
                    $sb.Append($selectionBgColor)
                    $sb.Append($selectionTextColor)
                    $sb.Append($visibleText.Substring($selStart, $selEnd - $selStart))
                    $sb.Append($textColor)  # Reset to normal colors
                }
                
                # After selection
                if ($selEnd -lt $visibleText.Length) {
                    $sb.Append($visibleText.Substring($selEnd))
                }
            } else {
                # Selection not visible on this part of the line
                $sb.Append($textColor)
                $sb.Append($visibleText)
            }
        } elseif ($lineNumber -eq $bounds.StartY) {
            # First line of multi-line selection
            $selStart = [Math]::Max(0, $bounds.StartX - $this.ScrollOffsetX)
            
            if ($selStart -ge 0 -and $selStart -lt $visibleText.Length) {
                # Before selection
                if ($selStart -gt 0) {
                    $sb.Append($textColor)
                    $sb.Append($visibleText.Substring(0, $selStart))
                }
                
                # Selection from start to end of visible text
                $sb.Append($selectionBgColor)
                $sb.Append($selectionTextColor)
                $sb.Append($visibleText.Substring($selStart))
            } else {
                # Selection starts beyond visible area - whole line is selected
                $sb.Append($selectionBgColor)
                $sb.Append($selectionTextColor)
                $sb.Append($visibleText)
            }
        } elseif ($lineNumber -eq $bounds.EndY) {
            # Last line of multi-line selection
            $selEnd = [Math]::Min($visibleText.Length, $bounds.EndX - $this.ScrollOffsetX)
            
            if ($selEnd -gt 0) {
                # Selection from start to EndX
                $sb.Append($selectionBgColor)
                $sb.Append($selectionTextColor)
                $sb.Append($visibleText.Substring(0, $selEnd))
                $sb.Append($textColor)  # Reset colors
                
                # After selection
                if ($selEnd -lt $visibleText.Length) {
                    $sb.Append($visibleText.Substring($selEnd))
                }
            } else {
                # Selection ends before visible area - no selection on visible part
                $sb.Append($textColor)
                $sb.Append($visibleText)
            }
        } else {
            # Middle line of multi-line selection - entire line is selected
            $sb.Append($selectionBgColor)
            $sb.Append($selectionTextColor)
            $sb.Append($visibleText)
        }
    }
    
    hidden [void] RenderCursor([System.Text.StringBuilder]$sb, [int]$lineNumWidth, [int]$editorHeight) {
        # Check if cursor is within visible viewport
        if ($this.CursorY -lt $this.ScrollOffsetY -or $this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            return  # Cursor not visible
        }
        
        # Calculate cursor screen position
        $cursorScreenY = $this.Y + ($this.CursorY - $this.ScrollOffsetY)
        $cursorScreenX = $this.X + $lineNumWidth + ($this.CursorX - $this.ScrollOffsetX)
        
        # Ensure cursor X is within visible area
        $editorWidth = $this.Width - $lineNumWidth
        if ($this.CursorX -lt $this.ScrollOffsetX -or $this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            return  # Cursor not horizontally visible
        }
        
        # Get colors
        $cursorBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("cursor") } else { "\e[0;7m" }
        $cursorTextColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("cursor.text") } else { "" }
        
        # Get character under cursor
        $charUnderCursor = " "
        if ($this.CursorY -lt $this._buffer.GetLineCount()) {
            $currentLine = $this._buffer.GetLine($this.CursorY)
            if ($this.CursorX -lt $currentLine.Length) {
                $charUnderCursor = $currentLine[$this.CursorX]
            }
        }
        
        # Render cursor
        $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
        $sb.Append($cursorBgColor)
        $sb.Append($cursorTextColor)
        $sb.Append($charUnderCursor)
        
        # Reset colors
        $resetColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("normal") } else { "\e[0m" }
        $sb.Append($resetColor)
    }
    
    hidden [string] GetStatusText() {
        $line = $this.CursorY + 1
        $col = $this.CursorX + 1
        $total = $this._buffer.GetLineCount()
        $modified = if ($this._buffer.IsModified) { " [Modified]" } else { "" }
        $undoStatus = ""
        if ($this._buffer.CanUndo()) {
            $undoStatus += " [Undo]"
        }
        if ($this._buffer.CanRedo()) {
            $undoStatus += " [Redo]"
        }
        
        # Add buffer type indicator
        $bufferType = if ($this._buffer.GetType().Name -eq "GapBufferDocumentBuffer") { " [GapBuffer]" } else { " [ArrayList]" }
        
        # Add selection indicator
        $selectionStatus = if ($this.HasSelection) { " [Selection]" } else { "" }
        
        $status = "Line $line/$total, Col $col$modified$undoStatus$bufferType$selectionStatus"
        if ($this.StatusMessage) {
            $status += " | $($this.StatusMessage)"
        }
        
        return $status
    }
}


####\Screens/TextInputDialog.ps1
# TextInputDialog.ps1 - Simple dialog for text input

class TextInputDialog : Screen {
    [string]$Prompt
    [string]$DefaultValue
    [string]$Placeholder
    [MinimalTextBox]$InputBox
    [MinimalButton]$OkButton
    [MinimalButton]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    TextInputDialog([string]$prompt) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = ""
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    TextInputDialog([string]$prompt, [string]$defaultValue) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [MinimalTextBox]::new()
        $this.InputBox.Text = $this.DefaultValue
        $this.InputBox.Placeholder = $this.Placeholder
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [MinimalButton]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            if ($dialog.OnSubmit) {
                & $dialog.OnSubmit $dialog.InputBox.Text
            }
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [MinimalButton]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box and select all text
        $this.InputBox.Focus()
        # TODO: Add SelectAll method to TextBox
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 10 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/TimeEntryDialog.ps1
# TimeEntryDialog - Dialog for adding/editing time entries
# Based on tracker.txt time tracking structure

class TimeEntryDialog : BaseDialog {
    [Project]$Project = $null
    [PSCustomObject]$TimeEntry = $null  # For editing existing entries
    [bool]$IsEditMode = $false
    
    # Input fields
    [MinimalTextBox]$DateTextBox
    [MinimalTextBox]$HoursTextBox
    [MinimalTextBox]$DescriptionTextBox
    
    # Buttons
    [MinimalButton]$SaveButton
    [MinimalButton]$CancelButton
    
    # Callbacks
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    TimeEntryDialog() : base("Add Time Entry") {
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project) : base("Add Time Entry") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project, [PSCustomObject]$timeEntry) : base("Edit Time Entry") {
        $this.Project = $project
        $this.TimeEntry = $timeEntry
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.DateTextBox = [MinimalTextBox]::new()
        $this.DateTextBox.Title = "Date (MM/DD/YYYY)"
        $this.DateTextBox.ShowBorder = $true
        
        # Set default date to today
        if (-not $this.IsEditMode) {
            $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
        } else {
            # Convert from YYYYMMDD format to MM/dd/yyyy
            try {
                $entryDate = [DateTime]::ParseExact($this.TimeEntry.Date, "yyyyMMdd", $null)
                $this.DateTextBox.Text = $entryDate.ToString("MM/dd/yyyy")
            } catch {
                $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
            }
        }
        
        $this.HoursTextBox = [MinimalTextBox]::new()
        $this.HoursTextBox.Title = "Hours (e.g., 8.5)"
        $this.HoursTextBox.ShowBorder = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Total) {
            $this.HoursTextBox.Text = $this.TimeEntry.Total
        }
        
        $this.DescriptionTextBox = [MinimalTextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Description) {
            $this.DescriptionTextBox.Text = $this.TimeEntry.Description
        }
        
        # Initialize components
        if ($this.ServiceContainer) {
            $this.DateTextBox.Initialize($this.ServiceContainer)
            $this.HoursTextBox.Initialize($this.ServiceContainer)
            $this.DescriptionTextBox.Initialize($this.ServiceContainer)
        }
        
        # Create buttons
        $saveText = if ($this.IsEditMode) { "Update Entry" } else { "Add Entry" }
        $this.SaveButton = [MinimalButton]::new($saveText)
        $this.SaveButton.IsDefault = $true
        $this.SaveButton.OnClick = { $this.HandleSave() }
        
        $this.CancelButton = [MinimalButton]::new("Cancel")
        $this.CancelButton.OnClick = { $this.HandleCancel() }
        
        if ($this.ServiceContainer) {
            $this.SaveButton.Initialize($this.ServiceContainer)
            $this.CancelButton.Initialize($this.ServiceContainer)
        }
        
        # Add children
        $this.AddChild($this.DateTextBox)
        $this.AddChild($this.HoursTextBox)
        $this.AddChild($this.DescriptionTextBox)
        $this.AddChild($this.SaveButton)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.DateTextBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Stack inputs vertically with buttons at bottom
        $margin = 2
        $buttonHeight = 3
        $inputHeight = 3
        $descriptionHeight = 5
        
        $currentY = $this.Y + $margin
        $inputWidth = $this.Width - ($margin * 2)
        
        # Date input
        $this.DateTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Hours input
        $this.HoursTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $descriptionHeight
        )
        $currentY += $descriptionHeight + 2
        
        # Buttons at bottom
        $buttonWidth = 15
        $buttonSpacing = 4
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - 1
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create time entry data
        $timeEntryData = $this.CreateTimeEntryData()
        
        if ($this.OnSave) {
            & $this.OnSave $timeEntryData
        }
    }
    
    [void] HandleCancel() {
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }
    
    [string] ValidateInputs() {
        # Validate date
        $dateStr = $this.DateTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Date is required"
        }
        
        try {
            [DateTime]::Parse($dateStr) | Out-Null
        } catch {
            return "Invalid date format. Use MM/DD/YYYY"
        }
        
        # Validate hours
        $hoursStr = $this.HoursTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($hoursStr)) {
            return "Hours is required"
        }
        
        $hours = 0.0
        if (-not [double]::TryParse($hoursStr, [ref]$hours) -or $hours -le 0) {
            return "Hours must be a positive number"
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateTimeEntryData() {
        # Parse and format date to YYYYMMDD
        $entryDate = [DateTime]::Parse($this.DateTextBox.Text.Trim())
        $internalDate = $entryDate.ToString("yyyyMMdd")
        
        # Parse hours
        $hours = [double]::Parse($this.HoursTextBox.Text.Trim())
        
        # Get day of week for hour distribution
        $dayOfWeek = $entryDate.DayOfWeek
        
        # Create time entry following tracker.txt structure
        $newTimeEntry = [PSCustomObject]@{
            Date = $internalDate
            Nickname = $this.Project.Nickname
            ID1 = if ($this.Project.ID1) { $this.Project.ID1 } else { "" }
            ID2 = $this.FormatID2($this.Project.ID2)
            MonHours = if ($dayOfWeek -eq "Monday") { $hours.ToString("F2") } else { "" }
            TueHours = if ($dayOfWeek -eq "Tuesday") { $hours.ToString("F2") } else { "" }
            WedHours = if ($dayOfWeek -eq "Wednesday") { $hours.ToString("F2") } else { "" }
            ThuHours = if ($dayOfWeek -eq "Thursday") { $hours.ToString("F2") } else { "" }
            FriHours = if ($dayOfWeek -eq "Friday") { $hours.ToString("F2") } else { "" }
            Total = $hours.ToString("F2")
            Description = $this.DescriptionTextBox.Text.Trim()
        }
        
        return $newTimeEntry
    }
    
    [string] FormatID2([string]$id2) {
        # Format ID2 with V0 prefix, S suffix, padded to 12 characters
        # Following tracker.txt format
        if ([string]::IsNullOrWhiteSpace($id2)) {
            return ""
        }
        
        $id2Text = $id2.Trim()
        $paddingNeeded = 12 - ($id2Text.Length + 2)
        
        if ($paddingNeeded > 0) {
            return "V" + ("0" * $paddingNeeded) + $id2Text + "S"
        } else {
            return "V" + $id2Text + "S"
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Enter) {
                if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.HandleSave()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleCancel()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                # Handle tab navigation between fields
                $focused = $this.FindFocused()
                if ($focused -eq $this.DateTextBox) {
                    $this.HoursTextBox.Focus()
                } elseif ($focused -eq $this.HoursTextBox) {
                    $this.DescriptionTextBox.Focus()
                } elseif ($focused -eq $this.DescriptionTextBox) {
                    $this.SaveButton.Focus()
                } else {
                    $this.DateTextBox.Focus()
                }
                return $true
            }
        }
        
        # Let base class handle other input
        return $false
    }
}


####\Screens/TimeEntryScreen.ps1
# TimeEntryScreen.ps1 - Time entry screen based on working ProjectsScreen

class TimeEntryScreen : Screen {
    [MinimalDataGrid]$TimeGrid
    [MinimalButton]$PrevWeekButton
    [MinimalButton]$NextWeekButton  
    [MinimalButton]$CurrentWeekButton
    [MinimalButton]$QuickEntryButton
    [DateTime]$CurrentWeekFriday
    [TimeTrackingService]$TimeService
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    TimeEntryScreen() : base() {
        $this.Title = "Time Entry"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
        $this.ProjectService = $this.ServiceContainer.GetService("ProjectService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Set current week
        $this.CurrentWeekFriday = $this.TimeService.GetCurrentWeekFriday()
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to time entry updates
            $this.EventSubscriptions['TimeEntryUpdated'] = $this.EventBus.Subscribe('timeentry.updated', {
                param($sender, $eventData)
                $screen.RefreshGrid()
            }.GetNewClosure())
        }
        
        # Create MinimalDataGrid with columns
        $this.TimeGrid = [MinimalDataGrid]::new()
        $this.TimeGrid.Title = $this.GetWeekTitle()
        $this.TimeGrid.ShowBorder = $false  # MainScreen draws the border
        $this.TimeGrid.BorderType = [BorderType]::None
        
        # Initialize the TimeGrid with ServiceContainer to get theme
        $this.TimeGrid.Initialize($this.ServiceContainer)
        
        # Define columns for time entry grid
        $columns = @(
            @{ Name = "Name"; Header = "Name"; Width = 30; Getter = { param($item) $item.Name } }
            @{ Name = "ID1"; Header = "ID1"; Width = 10; Getter = { param($item) $item.ID1 } }
            @{ Name = "ID2"; Header = "ID2"; Width = 15; Getter = { param($item) $item.ID2 } }
            @{ Name = "Monday"; Header = "Mon"; Width = 6; Getter = { param($item) if ($item.Monday -gt 0) { $item.Monday.ToString("F1") } else { "" } } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 6; Getter = { param($item) if ($item.Tuesday -gt 0) { $item.Tuesday.ToString("F1") } else { "" } } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 6; Getter = { param($item) if ($item.Wednesday -gt 0) { $item.Wednesday.ToString("F1") } else { "" } } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 6; Getter = { param($item) if ($item.Thursday -gt 0) { $item.Thursday.ToString("F1") } else { "" } } }
            @{ Name = "Friday"; Header = "Fri"; Width = 6; Getter = { param($item) if ($item.Friday -gt 0) { $item.Friday.ToString("F1") } else { "" } } }
            @{ Name = "Total"; Header = "Total"; Width = 7; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.TimeGrid.SetColumns($columns)
        $this.AddChild($this.TimeGrid)
        
        # Create navigation buttons
        $screen = $this  # Capture reference for closures
        
        $this.PrevWeekButton = [MinimalButton]::new("< Prev Week")
        $this.PrevWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.PrevWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.PrevWeekButton)
        
        $this.CurrentWeekButton = [MinimalButton]::new("Current Week")
        $this.CurrentWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.TimeService.GetCurrentWeekFriday()
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.CurrentWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.CurrentWeekButton)
        
        $this.NextWeekButton = [MinimalButton]::new("Next Week >")
        $this.NextWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.NextWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.NextWeekButton)
        
        $this.QuickEntryButton = [MinimalButton]::new("Quick Entry (Q)")
        $this.QuickEntryButton.IsDefault = $true
        $this.QuickEntryButton.OnClick = { $screen.ShowQuickEntry() }.GetNewClosure()
        $this.QuickEntryButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.QuickEntryButton)
        
        # Load initial data
        $this.RefreshGrid()
        
        # Focus the grid
        if ($this.TimeGrid.Items.Count -gt 0) {
            $this.TimeGrid.Focus()
        }
        
        # Register shortcuts
        $this.RegisterShortcuts()
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.TimeGrid) { return }
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Calculate layout
        $gridHeight = $this.Height - $this.ButtonHeight - 1
        
        # Position grid - use relative positioning within the screen bounds
        $this.TimeGrid.SetBounds(0, 0, $this.Width, $gridHeight)
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        $buttonWidth = 16
        $totalButtonWidth = ($buttonWidth * 4) + ($this.ButtonSpacing * 3)
        
        # Center buttons
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        $this.PrevWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.CurrentWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.NextWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.QuickEntryButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Refresh data when activated
        $this.RefreshGrid()
        if ($this.TimeGrid) {
            $this.TimeGrid.Focus()
        }
    }
    
    [string] GetWeekTitle() {
        $monday = $this.CurrentWeekFriday.AddDays(-4)
        return "Time Entry - Week of $($monday.ToString('MM/dd/yyyy')) to $($this.CurrentWeekFriday.ToString('MM/dd/yyyy'))"
    }
    
    [void] RefreshGrid() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Starting refresh for week $($this.CurrentWeekFriday.ToString('yyyyMMdd'))")
        }
        
        # Update title
        $this.TimeGrid.Title = $this.GetWeekTitle()
        
        # Get entries for current week
        $weekString = $this.CurrentWeekFriday.ToString("yyyyMMdd")
        $entries = $this.TimeService.GetWeekEntries($weekString)
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Got $($entries.Count) entries")
            if ($entries.Count -gt 0) {
                $global:Logger.Debug("TimeEntryScreen.RefreshGrid: First entry: Name=$($entries[0].Name) ID2=$($entries[0].ID2)")
            }
        }
        
        # Sort by: Projects first (by name), then non-projects (by ID2)
        $sorted = $entries | Sort-Object @(
            @{Expression = {if ($_.ID1 -eq "Internal") {1} else {0}}},
            @{Expression = {$_.Name}},
            @{Expression = {$_.ID2}}
        )
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: TimeGrid exists: $($this.TimeGrid -ne $null)")
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: TimeGrid bounds: ($($this.TimeGrid.X),$($this.TimeGrid.Y),$($this.TimeGrid.Width),$($this.TimeGrid.Height))")
        }
        
        # Clear and repopulate grid using proper DataGrid method
        $this.TimeGrid.SetItems($sorted)
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: After SetItems, TimeGrid.Items.Count = $($this.TimeGrid.Items.Count)")
        }
        
        $this.TimeGrid.Invalidate()
        $this.Invalidate()
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Refresh complete, invalidated grid and screen")
        }
    }
    
    [void] ShowQuickEntry() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Starting quick entry")
        }
        
        try {
            # Create quick entry dialog
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: CurrentWeekFriday = $($this.CurrentWeekFriday)")
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: QuickTimeEntryDialog type exists: $([QuickTimeEntryDialog] -as [type] -ne $null)")
            }
            
            # Try explicit casting
            $weekFriday = [DateTime]$this.CurrentWeekFriday
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: weekFriday type = $($weekFriday.GetType().Name), value = $weekFriday")
            }
            
            # Try workaround - create via Invoke-Expression or reflection
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Attempting workaround creation")
            }
            
            # Workaround attempt
            $dialog = New-Object QuickTimeEntryDialog -ArgumentList $weekFriday
            
            # Initialize dialog with ServiceContainer for theme
            $dialog.Initialize($this.ServiceContainer)
            
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Dialog created successfully")
            }
            
            $screen = $this
            $dialog.OnSave = {
                param($timeEntry)
                # Save the entry
                $screen.TimeService.UpdateTimeEntry($timeEntry)
                $screen.RefreshGrid()
            }.GetNewClosure()
            
            # Show dialog
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
                if ($global:Logger) {
                    $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Dialog pushed to ScreenManager")
                }
            }
        }
        catch {
            if ($global:Logger) {
                $global:Logger.Error("TimeEntryScreen.ShowQuickEntry: Error creating dialog: $_")
            }
        }
    }
    
    [void] EditSelectedEntry() {
        $selected = $this.TimeGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit dialog - TimeEntryDialog expects a Project parameter, not DateTime and ID2
        # For now, use the parameterless constructor
        $dialog = [TimeEntryDialog]::new()
        $dialog.OnSave = {
            $this.RefreshGrid()
        }.GetNewClosure()
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnRender: Starting render, Children.Count = $($this.Children.Count)")
            $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid exists = $($this.TimeGrid -ne $null)")
            if ($this.TimeGrid) {
                $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid.Items.Count = $($this.TimeGrid.Items.Count)")
                $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid bounds = ($($this.TimeGrid.X),$($this.TimeGrid.Y),$($this.TimeGrid.Width),$($this.TimeGrid.Height))")
            }
        }
        
        $result = ([Screen]$this).OnRender()
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnRender: Rendered content length = $($result.Length)")
        }
        return $result
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if ($shortcutManager) {
            $screen = $this
            
            # Q - Quick entry
            $quickAction = { $screen.ShowQuickEntry() }.GetNewClosure()
            
            $shortcutManager.RegisterShortcut(@{
                Id = "time.quick"
                Name = "Quick Entry"
                Description = "Quick time entry"
                KeyChar = 'q'
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = $quickAction
            })
            
            # E - Edit entry
            $shortcutManager.RegisterShortcut(@{
                Id = "time.edit"
                Name = "Edit Entry"
                Description = "Edit time entry"
                KeyChar = 'e'
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = { $screen.EditSelectedEntry() }.GetNewClosure()
            })
            
            # Left/Right arrows for week navigation
            $shortcutManager.RegisterShortcut(@{
                Id = "time.prevweek"
                Name = "Previous Week"
                Description = "Navigate to previous week"
                Key = [System.ConsoleKey]::LeftArrow
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = {
                    $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
                    $screen.RefreshGrid()
                }.GetNewClosure()
            })
            
            $shortcutManager.RegisterShortcut(@{
                Id = "time.nextweek"
                Name = "Next Week"
                Description = "Navigate to next week"
                Key = [System.ConsoleKey]::RightArrow
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = {
                    $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
                    $screen.RefreshGrid()
                }.GetNewClosure()
            })
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Let base handle first (for child components)
        if (([Screen]$this).HandleInput($key)) {
            return $true
        }
        
        # Handle screen-specific keys
        switch ($key.Key) {
            ([ConsoleKey]::Q) {
                if ($global:Logger) {
                    $global:Logger.Debug("TimeEntryScreen.HandleInput: Q key detected, calling ShowQuickEntry()")
                }
                $this.ShowQuickEntry()
                return $true
            }
            ([ConsoleKey]::E) {
                $this.EditSelectedEntry()
                return $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($key.Modifiers -eq [ConsoleModifiers]::None) {
                    $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(-7)
                    $this.RefreshGrid()
                    return $true
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($key.Modifiers -eq [ConsoleModifiers]::None) {
                    $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(7)
                    $this.RefreshGrid()
                    return $true
                }
            }
            ([ConsoleKey]::Enter) {
                $this.EditSelectedEntry()
                return $true
            }
        }
        
        return $false
    }
}


####\Screens/VisualMacroFactoryScreen.ps1
# VisualMacroFactoryScreen.ps1 - Visual macro builder for IDEA scripts
# Three-pane interface: Component Library | Macro Sequence | Context Panel

class VisualMacroFactoryScreen : Screen {
    # UI Components - Three panes
    [SearchableListBox]$ComponentLibrary      # Left pane
    [DataGrid]$MacroSequence                  # Center pane
    [DataGrid]$ContextPanel                   # Right pane
    
    # Services
    [MacroContextManager]$ContextManager
    [FunctionRegistry]$FunctionRegistry
    [CommandService]$CommandService
    [EventBus]$EventBus
    [ShortcutManager]$ShortcutManager
    
    # Available actions
    [System.Collections.ArrayList]$AvailableActions
    [int]$SelectedSequenceIndex = -1
    
    VisualMacroFactoryScreen() : base() {
        $this.Title = "Visual Macro Factory"
        $this.DrawBackground = $true
        $this.AvailableActions = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        $this.ShortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        
        # Initialize macro services
        $this.ContextManager = [MacroContextManager]::new()
        $this.FunctionRegistry = [FunctionRegistry]::new()
        $this.FunctionRegistry.SetCommandService($this.CommandService)
        $this.ContextManager.SetFunctionRegistry($this.FunctionRegistry)
        
        # Create UI components
        $this.CreateComponentLibrary()
        $this.CreateMacroSequence()
        $this.CreateContextPanel()
        
        # Register shortcuts
        $this.RegisterShortcuts()
    }
    
    [void] LoadAvailableActions() {
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.LoadAvailableActions: Starting to load actions")
        }
        
        # Load built-in actions
        $this.AvailableActions.Add([SummarizationAction]::new()) | Out-Null
        $this.AvailableActions.Add([AppendFieldAction]::new()) | Out-Null
        $this.AvailableActions.Add([ExportToExcelAction]::new()) | Out-Null
        
        # Add custom IDEA@ command action
        $this.AvailableActions.Add([CustomIdeaCommandAction]::new()) | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.LoadAvailableActions: Loaded $($this.AvailableActions.Count) actions")
        }
        
        # Populate the component library with the loaded actions
        $this.ComponentLibrary.SetItems($this.AvailableActions)
        
        # TODO: Load additional actions from Actions/ directory
    }
    
    [void] CreateComponentLibrary() {
        $this.ComponentLibrary = [SearchableListBox]::new()
        $this.ComponentLibrary.Title = " Component Library"
        $this.ComponentLibrary.ShowBorder = $true
        $this.ComponentLibrary.SearchPrompt = "Search actions... (category:core type:export)"
        
        # Custom renderer for actions
        $this.ComponentLibrary.ItemRenderer = {
            param($action)
            if (-not $action) { return "" }
            return $action.GetDisplayText()
        }
        
        # Handle double-click to add action
        $this.ComponentLibrary.OnItemActivated = {
            param($action)
            $this.AddActionToSequence($action)
        }.GetNewClosure()
        
        $this.ComponentLibrary.Initialize($this.ServiceContainer)
        $this.AddChild($this.ComponentLibrary)
        
        # Load available actions
        $this.LoadAvailableActions()
    }
    
    [void] CreateMacroSequence() {
        $this.MacroSequence = [DataGrid]::new()
        $this.MacroSequence.Title = " Macro Sequence"
        $this.MacroSequence.ShowBorder = $true
        
        # Define columns for macro sequence
        $columns = @(
            @{ Name = "Step"; Width = 6; Alignment = "Center" },
            @{ Name = "Action"; Width = 20; Alignment = "Left" },
            @{ Name = "Description"; Width = 30; Alignment = "Left" },
            @{ Name = "Status"; Width = 10; Alignment = "Center" }
        )
        $this.MacroSequence.SetColumns($columns)
        
        # Handle selection changes
        $this.MacroSequence.OnSelectionChanged = {
            $this.SelectedSequenceIndex = $this.MacroSequence.SelectedIndex
            $this.UpdateContextPanel()
        }.GetNewClosure()
        
        $this.MacroSequence.Initialize($this.ServiceContainer)
        $this.AddChild($this.MacroSequence)
    }
    
    [void] CreateContextPanel() {
        $this.ContextPanel = [DataGrid]::new()
        $this.ContextPanel.Title = " Macro Context"
        $this.ContextPanel.ShowBorder = $true
        
        # Define columns for context variables
        $columns = @(
            @{ Name = "Variable"; Width = 15; Alignment = "Left" },
            @{ Name = "Type"; Width = 10; Alignment = "Left" },
            @{ Name = "Value"; Width = 25; Alignment = "Left" },
            @{ Name = "Source"; Width = 15; Alignment = "Left" }
        )
        $this.ContextPanel.SetColumns($columns)
        
        $this.ContextPanel.Initialize($this.ServiceContainer)
        $this.AddChild($this.ContextPanel)
        
        # Initial context update
        $this.UpdateContextPanel()
        
        # Set initial focus to component library
        if ($this.ComponentLibrary) {
            $this.ComponentLibrary.Focus()
        }
    }
    
    [void] RegisterShortcuts() {
        if (-not $this.ShortcutManager) { return }
        
        # Delete: Remove selected action from sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_delete"
            Name = "Delete Action"
            Description = "Remove selected action from macro sequence"
            Key = [System.ConsoleKey]::Delete
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and $this.SelectedSequenceIndex -ge 0) {
                    $this.RemoveActionFromSequence($this.SelectedSequenceIndex)
                }
            }.GetNewClosure()
        })
        
        # Ctrl+Up: Move action up in sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_move_up"
            Name = "Move Action Up"
            Description = "Move selected action up in sequence"
            Key = [System.ConsoleKey]::UpArrow
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and $this.SelectedSequenceIndex -gt 0) {
                    $this.ContextManager.MoveAction($this.SelectedSequenceIndex, $this.SelectedSequenceIndex - 1)
                    $this.SelectedSequenceIndex--
                    $this.UpdateMacroSequence()
                    $this.UpdateContextPanel()
                }
            }.GetNewClosure()
        })
        
        # Ctrl+Down: Move action down in sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_move_down"
            Name = "Move Action Down"
            Description = "Move selected action down in sequence"
            Key = [System.ConsoleKey]::DownArrow
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and 
                    $this.SelectedSequenceIndex -ge 0 -and 
                    $this.SelectedSequenceIndex -lt $this.ContextManager.Actions.Count - 1) {
                    $this.ContextManager.MoveAction($this.SelectedSequenceIndex, $this.SelectedSequenceIndex + 1)
                    $this.SelectedSequenceIndex++
                    $this.UpdateMacroSequence()
                    $this.UpdateContextPanel()
                }
            }.GetNewClosure()
        })
        
        # F5: Generate and preview script
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_preview"
            Name = "Preview Script"
            Description = "Generate and preview the IDEAScript"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.PreviewGeneratedScript()
            }.GetNewClosure()
        })
        
        # Ctrl+S: Save macro
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_save"
            Name = "Save Macro"
            Description = "Save the current macro"
            Key = [System.ConsoleKey]::S
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.SaveMacro()
            }.GetNewClosure()
        })
        
        # Ctrl+O: Open macro
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_open"
            Name = "Open Macro"
            Description = "Open an existing macro"
            Key = [System.ConsoleKey]::O
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.OpenMacro()
            }.GetNewClosure()
        })
        
        # Ctrl+N: New macro (clear)
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_new"
            Name = "New Macro"
            Description = "Start a new macro (clear current)"
            Key = [System.ConsoleKey]::N
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.NewMacro()
            }.GetNewClosure()
        })
    }
    
    [void] AddActionToSequence([BaseAction]$action) {
        # Clone the action to avoid modifying the template
        $newAction = $action.GetType()::new()
        
        $this.ContextManager.AddAction($newAction)
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
        
        # Focus the macro sequence and select the new item
        $this.MacroSequence.Focus()
        $this.MacroSequence.SelectedIndex = $this.ContextManager.Actions.Count - 1
        $this.SelectedSequenceIndex = $this.MacroSequence.SelectedIndex
    }
    
    [void] RemoveActionFromSequence([int]$index) {
        $this.ContextManager.RemoveAction($index)
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
        
        # Adjust selection
        if ($this.SelectedSequenceIndex -ge $this.ContextManager.Actions.Count) {
            $this.SelectedSequenceIndex = $this.ContextManager.Actions.Count - 1
        }
        $this.MacroSequence.SelectedIndex = $this.SelectedSequenceIndex
    }
    
    [void] UpdateMacroSequence() {
        $rows = @()
        
        for ($i = 0; $i -lt $this.ContextManager.Actions.Count; $i++) {
            $action = $this.ContextManager.Actions[$i]
            $context = $this.ContextManager.GetContextAtStep($i)
            
            # Check if action requirements are met
            $isValid = $action.ValidateContext($context)
            $status = if ($isValid) { " Ready" } else { " Issues" }
            
            $rows += @{
                Step = ($i + 1).ToString()
                Action = $action.Name
                Description = $action.Description
                Status = $status
            }
        }
        
        $this.MacroSequence.SetItems($rows)
    }
    
    [void] UpdateContextPanel() {
        $rows = @()
        
        # Get context for the selected step (or full context if none selected)
        $context = if ($this.SelectedSequenceIndex -ge 0) {
            $this.ContextManager.GetContextAtStep($this.SelectedSequenceIndex)
        } else {
            $this.ContextManager.GetFullContext()
        }
        
        foreach ($varName in $context.Keys) {
            $varInfo = $context[$varName]
            $source = if ($varInfo.ContainsKey('ProducedBy')) { $varInfo.ProducedBy } else { "System" }
            
            $rows += @{
                Variable = $varName
                Type = $varInfo.Type
                Value = if ($varInfo.ContainsKey('Value')) { $varInfo.Value } else { "<undefined>" }
                Source = $source
            }
        }
        
        $this.ContextPanel.SetItems($rows)
        
        # Update title to show context step
        if ($this.SelectedSequenceIndex -ge 0) {
            $this.ContextPanel.Title = " Context at Step $($this.SelectedSequenceIndex + 1)"
        } else {
            $this.ContextPanel.Title = " Full Macro Context"
        }
    }
    
    [void] PreviewGeneratedScript() {
        try {
            $script = $this.ContextManager.GenerateScript()
            
            # TODO: Show script in a dialog or new screen
            # For now, just log the script
            if ($global:Logger) {
                $global:Logger.Info("Generated Script: $script")
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Script Generation Error: $($_.Exception.Message)")
            }
        }
    }
    
    [void] SaveMacro() {
        # TODO: Implement macro saving to file
        if ($global:Logger) {
            $global:Logger.Info("Save Macro: Not yet implemented")
        }
    }
    
    [void] OpenMacro() {
        # TODO: Implement macro loading from file
        if ($global:Logger) {
            $global:Logger.Info("Open Macro: Not yet implemented")
        }
    }
    
    [void] NewMacro() {
        $this.ContextManager.Clear()
        $this.SelectedSequenceIndex = -1
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
    }
    
    [void] OnBoundsChanged() {
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: Width=$($this.Width) Height=$($this.Height)")
        }
        
        if ($this.Width -le 0 -or $this.Height -le 0) { 
            if ($global:Logger) {
                $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: Skipping due to zero bounds")
            }
            return 
        }
        
        # Three-pane layout: 30% | 40% | 30%
        $leftWidth = [int]($this.Width * 0.3)
        $centerWidth = [int]($this.Width * 0.4)
        $rightWidth = $this.Width - $leftWidth - $centerWidth
        
        $contentHeight = $this.Height - 2  # Account for title
        
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: leftWidth=$leftWidth centerWidth=$centerWidth rightWidth=$rightWidth contentHeight=$contentHeight")
        }
        
        # Position Component Library (left pane)
        if ($this.ComponentLibrary) {
            $this.ComponentLibrary.SetBounds(0, 1, $leftWidth, $contentHeight)
        }
        
        # Position Macro Sequence (center pane)
        if ($this.MacroSequence) {
            $this.MacroSequence.SetBounds($leftWidth, 1, $centerWidth, $contentHeight)
        }
        
        # Position Context Panel (right pane)
        if ($this.ContextPanel) {
            $this.ContextPanel.SetBounds($leftWidth + $centerWidth, 1, $rightWidth, $contentHeight)
        }
    }
}


####\Services/CommandService.ps1
# CommandService.ps1 - Service for managing command library
# Handles JSON storage, CRUD operations, and clipboard functionality

class CommandService {
    [string]$DataPath
    [System.Collections.ArrayList]$Commands
    [Logger]$Logger
    
    CommandService() {
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/commands.json"
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.Logger = $global:Logger
        $this.LoadCommands()
    }
    
    # Load commands from JSON file
    [void] LoadCommands() {
        try {
            if (Test-Path $this.DataPath) {
                $jsonContent = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                $this.Commands.Clear()
                
                foreach ($commandData in $jsonContent) {
                    # Convert PSCustomObject to hashtable
                    $hashtable = @{}
                    $commandData.PSObject.Properties | ForEach-Object {
                        $hashtable[$_.Name] = $_.Value
                    }
                    $command = [Command]::FromHashtable($hashtable)
                    $this.Commands.Add($command) | Out-Null
                }
                
                if ($this.Logger) {
                    $this.Logger.Info("Loaded $($this.Commands.Count) commands from $($this.DataPath)")
                }
            } else {
                if ($this.Logger) {
                    $this.Logger.Info("No existing commands file found, starting with empty library")
                }
                # Add some default IDEA commands
                $this.CreateDefaultCommands()
            }
        } catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to load commands: $($_.Exception.Message)")
            }
        }
    }
    
    # Create default IDEA commands for new installations
    [void] CreateDefaultCommands() {
        # Add some common IDEA@ functions and commands
        $defaultCommands = @(
            @{
                Title = "@CurrentDate_YYYYMMDD"
                Description = "Returns current date in YYYYMMDD format"
                Tags = @("function", "date", "idea")
                Group = "Built-in Functions"
                CommandText = "@CurrentDate_YYYYMMDD"
            },
            @{
                Title = "@PromptForField"
                Description = "Prompts user to select a field from the current database"
                Tags = @("function", "field", "input", "idea")
                Group = "Built-in Functions"
                CommandText = "@PromptForField(`"Select field:`")"
            },
            @{
                Title = "Open Database"
                Description = "Opens a database file in IDEA"
                Tags = @("database", "open", "idea")
                Group = "Database Operations"
                CommandText = "Set db = Client.OpenDatabase(`"database.IMD`")"
            },
            @{
                Title = "Summarize by Field"
                Description = "Creates a summarization by specified field"
                Tags = @("summarize", "group", "analysis", "idea")
                Group = "Analysis"
                CommandText = "Set task = db.Summarization`nTask.AddFieldToSummarize `"FIELD_NAME`"`nTask.OutputDBName = `"Summary_Output`"`ndbName = task.Run()"
            },
            @{
                Title = "Export to Excel"
                Description = "Exports current database to Excel format"
                Tags = @("export", "excel", "output", "idea")
                Group = "Export"
                CommandText = "Set task = db.ExportToExcel`nTask.OutputFile = `"output.xlsx`"`nTask.Run()"
            }
        )
        
        foreach ($cmdData in $defaultCommands) {
            $command = $this.AddCommand($cmdData.Title, $cmdData.Description, $cmdData.Tags, $cmdData.Group, $cmdData.CommandText)
        }
        
        if ($this.Logger) {
            $this.Logger.Info("Created $($defaultCommands.Count) default IDEA commands")
        }
    }
    
    # Save commands to JSON file
    [void] SaveCommands() {
        try {
            $commandsData = @()
            foreach ($command in $this.Commands) {
                $commandsData += $command.ToHashtable()
            }
            
            $json = $commandsData | ConvertTo-Json -Depth 10
            $json | Set-Content $this.DataPath -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Saved $($this.Commands.Count) commands to $($this.DataPath)")
            }
        } catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save commands: $($_.Exception.Message)")
            }
        }
    }
    
    # Get all commands
    [System.Collections.ArrayList] GetAllCommands() {
        return $this.Commands
    }
    
    # Get command by ID
    [Command] GetCommand([string]$id) {
        foreach ($command in $this.Commands) {
            if ($command.Id -eq $id) {
                return $command
            }
        }
        return $null
    }
    
    # Add new command
    [Command] AddCommand([string]$commandText) {
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            throw "Command text is required"
        }
        
        $command = [Command]::new($commandText)
        $this.Commands.Add($command) | Out-Null
        $this.SaveCommands()
        
        if ($this.Logger) {
            $this.Logger.Info("Added new command: $($command.Id)")
        }
        
        return $command
    }
    
    # Add command with full details
    [Command] AddCommand([string]$title, [string]$description, [string[]]$tags, [string]$group, [string]$commandText) {
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            throw "Command text is required"
        }
        
        $command = [Command]::new()
        $command.Title = $title ?? ""
        $command.Description = $description ?? ""
        $command.Tags = $tags ?? @()
        $command.Group = $group ?? ""
        $command.CommandText = $commandText
        
        $this.Commands.Add($command) | Out-Null
        $this.SaveCommands()
        
        if ($this.Logger) {
            $this.Logger.Info("Added new command: $($command.GetDisplayText())")
        }
        
        return $command
    }
    
    # Update existing command
    [bool] UpdateCommand([Command]$command) {
        if (-not $command.IsValid()) {
            throw "Command text is required"
        }
        
        $existingIndex = -1
        for ($i = 0; $i -lt $this.Commands.Count; $i++) {
            if ($this.Commands[$i].Id -eq $command.Id) {
                $existingIndex = $i
                break
            }
        }
        
        if ($existingIndex -ge 0) {
            $this.Commands[$existingIndex] = $command
            $this.SaveCommands()
            
            if ($this.Logger) {
                $this.Logger.Info("Updated command: $($command.GetDisplayText())")
            }
            return $true
        }
        
        return $false
    }
    
    # Delete command
    [bool] DeleteCommand([string]$id) {
        for ($i = 0; $i -lt $this.Commands.Count; $i++) {
            if ($this.Commands[$i].Id -eq $id) {
                $command = $this.Commands[$i]
                $this.Commands.RemoveAt($i)
                $this.SaveCommands()
                
                if ($this.Logger) {
                    $this.Logger.Info("Deleted command: $($command.GetDisplayText())")
                }
                return $true
            }
        }
        
        return $false
    }
    
    # Copy command to clipboard and record usage
    [void] CopyToClipboard([string]$id) {
        $command = $this.GetCommand($id)
        if ($command) {
            try {
                Set-Clipboard -Value $command.CommandText
                $command.RecordUsage()
                $this.SaveCommands()
                
                if ($this.Logger) {
                    $this.Logger.Info("Copied command to clipboard: $($command.GetDisplayText())")
                }
            } catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to copy to clipboard: $($_.Exception.Message)")
                }
                throw "Failed to copy to clipboard: $($_.Exception.Message)"
            }
        } else {
            throw "Command not found: $id"
        }
    }
    
    # Search commands with enhanced syntax
    [System.Collections.ArrayList] SearchCommands([string]$query) {
        $results = [System.Collections.ArrayList]::new()
        
        if ([string]::IsNullOrWhiteSpace($query)) {
            # Return all commands if no query
            foreach ($command in $this.Commands) {
                $results.Add($command) | Out-Null
            }
            return $results
        }
        
        # Parse search query
        $searchCriteria = $this.ParseSearchQuery($query)
        
        foreach ($command in $this.Commands) {
            if ($this.MatchesSearchCriteria($command, $searchCriteria)) {
                $results.Add($command) | Out-Null
            }
        }
        
        return $results
    }
    
    # Parse search query into criteria
    hidden [hashtable] ParseSearchQuery([string]$query) {
        $criteria = @{
            DefaultSearch = @()
            TitleSearch = @()
            DescriptionSearch = @()
            TagSearch = @()
            GroupSearch = @()
            AndMode = $false
        }
        
        # Check for AND mode (+)
        if ($query -match '\+') {
            $criteria.AndMode = $true
        }
        
        # Split by spaces and process each term
        $terms = $query -split '\s+' | Where-Object { $_ -ne '' }
        
        foreach ($term in $terms) {
            if ($term -match '^(\+?)([tdg]):(.+)$') {
                $isAnd = $matches[1] -eq '+'
                $type = $matches[2]
                $searchTerm = $matches[3]
                
                # Handle OR within the search term (|)
                $searchValues = $searchTerm -split '\|'
                
                switch ($type) {
                    't' { $criteria.TagSearch += $searchValues }
                    'd' { $criteria.DescriptionSearch += $searchValues }
                    'g' { $criteria.GroupSearch += $searchValues }
                }
            } else {
                # Default search (title and general)
                $cleanTerm = $term -replace '^\+', ''
                $criteria.DefaultSearch += $cleanTerm
            }
        }
        
        return $criteria
    }
    
    # Check if command matches search criteria
    hidden [bool] MatchesSearchCriteria([Command]$command, [hashtable]$criteria) {
        $matches = @()
        
        # Default search (title and general text)
        if ($criteria.DefaultSearch.Count -gt 0) {
            $titleMatch = $false
            $generalMatch = $false
            
            foreach ($term in $criteria.DefaultSearch) {
                if ($command.Title -and $command.Title -match [regex]::Escape($term)) {
                    $titleMatch = $true
                }
                if ($command.GetSearchableText() -match [regex]::Escape($term)) {
                    $generalMatch = $true
                }
            }
            
            $matches += ($titleMatch -or $generalMatch)
        }
        
        # Tag search
        if ($criteria.TagSearch.Count -gt 0) {
            $tagMatch = $false
            $tagText = ($command.Tags -join ' ')
            
            foreach ($term in $criteria.TagSearch) {
                if ($tagText -match [regex]::Escape($term)) {
                    $tagMatch = $true
                    break
                }
            }
            
            $matches += $tagMatch
        }
        
        # Description search
        if ($criteria.DescriptionSearch.Count -gt 0) {
            $descMatch = $false
            
            foreach ($term in $criteria.DescriptionSearch) {
                if ($command.Description -and $command.Description -match [regex]::Escape($term)) {
                    $descMatch = $true
                    break
                }
            }
            
            $matches += $descMatch
        }
        
        # Group search
        if ($criteria.GroupSearch.Count -gt 0) {
            $groupMatch = $false
            
            foreach ($term in $criteria.GroupSearch) {
                if ($command.Group -and $command.Group -match [regex]::Escape($term)) {
                    $groupMatch = $true
                    break
                }
            }
            
            $matches += $groupMatch
        }
        
        # Return based on AND/OR logic
        if ($matches.Count -eq 0) {
            return $true  # No specific criteria, match all
        }
        
        if ($criteria.AndMode) {
            # AND: all criteria must match
            return ($matches | Where-Object { $_ -eq $false }).Count -eq 0
        } else {
            # OR: any criteria can match
            return ($matches | Where-Object { $_ -eq $true }).Count -gt 0
        }
    }
    
    # Get all unique groups
    [string[]] GetGroups() {
        $groups = @()
        foreach ($command in $this.Commands) {
            if (-not [string]::IsNullOrWhiteSpace($command.Group) -and $groups -notcontains $command.Group) {
                $groups += $command.Group
            }
        }
        return $groups | Sort-Object
    }
    
    # Get all unique tags
    [string[]] GetTags() {
        $tags = @()
        foreach ($command in $this.Commands) {
            foreach ($tag in $command.Tags) {
                if (-not [string]::IsNullOrWhiteSpace($tag) -and $tags -notcontains $tag) {
                    $tags += $tag
                }
            }
        }
        return $tags | Sort-Object
    }
}


####\Services/ConfigurationService.ps1
# ConfigurationService.ps1 - Configuration management with persistence

class ConfigurationService {
    hidden [string]$ConfigPath
    hidden [hashtable]$Config
    hidden [hashtable]$Defaults
    hidden [bool]$AutoSave = $true
    
    ConfigurationService() {
        $this.ConfigPath = Join-Path $global:PraxisRoot "_Config" "settings.json"
        $this.InitializeDefaults()
        $this.Load()
    }
    
    ConfigurationService([string]$configPath) {
        $this.ConfigPath = $configPath
        $this.InitializeDefaults()
        $this.Load()
    }
    
    hidden [void] InitializeDefaults() {
        $this.Defaults = @{
            Theme = @{
                CurrentTheme = "matrix"  # Changed to matrix as requested
                AvailableThemes = @("default", "matrix", "custom")
                CustomColors = @{
                    background = @(0, 0, 0)
                    foreground = @(0, 255, 0)
                    accent = @(0, 200, 0)
                    border = @(0, 100, 0)
                }
            }
            Editor = @{
                TabSize = 4
                WordWrap = $false
                ShowLineNumbers = $true
                HighlightCurrentLine = $true
                AutoSaveInterval = 0  # 0 = disabled, otherwise minutes
                SyntaxHighlighting = $true
            }
            FileBrowser = @{
                DefaultPath = (Get-Location).Path
                ShowHiddenFiles = $false
                IgnoredExtensions = @(".tmp", ".cache", ".log")
                SortBy = "Name"  # Name, Date, Size
                SortDescending = $false
                ShowFileSize = $true
                ShowModifiedDate = $false
            }
            UI = @{
                AnimationsEnabled = $true
                ShowScrollbars = $true
                CompactMode = $false
            }
            Projects = @{
                DefaultPath = Join-Path $global:PraxisRoot "_ProjectData"
                AutoSave = $true
                BackupEnabled = $true
                BackupCount = 5
            }
            Tasks = @{
                DefaultPriority = "Medium"
                ShowCompletedTasks = $true
                CompletedTaskRetention = 30  # days
            }
            Performance = @{
                EnableCaching = $true
                MaxCacheSize = 100  # MB
                RenderOptimization = $true
            }
            Logging = @{
                Level = "Info"
                MaxFileSize = 10  # MB
                MaxFiles = 5
            }
        }
    }
    
    [void] Load() {
        # Ensure config directory exists
        $configDir = Split-Path -Parent $this.ConfigPath
        if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir -Force | Out-Null
        }
        
        # Load config from file or use defaults
        if (Test-Path $this.ConfigPath) {
            try {
                $json = Get-Content -Path $this.ConfigPath -Raw
                $loaded = $json | ConvertFrom-Json -AsHashtable
                
                # Merge with defaults to ensure all keys exist
                $this.Config = $this.MergeHashtables($this.Defaults, $loaded)
                
                if ($global:Logger) {
                    $global:Logger.Info("Configuration loaded from: $($this.ConfigPath)")
                }
            } catch {
                Write-Warning "Failed to load configuration: $_"
                $this.Config = $this.Defaults.Clone()
            }
        } else {
            # No config file, use defaults and save
            $this.Config = $this.Defaults.Clone()
            $this.Save()
        }
    }
    
    [void] Save() {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $this.ConfigPath -Value $json -Encoding UTF8
            
            if ($global:Logger) {
                $global:Logger.Debug("Configuration saved to: $($this.ConfigPath)")
            }
        } catch {
            Write-Warning "Failed to save configuration: $_"
        }
    }
    
    # Deep merge hashtables, preserving structure
    hidden [hashtable] MergeHashtables([hashtable]$base, [hashtable]$overlay) {
        $result = $base.Clone()
        
        foreach ($key in $overlay.Keys) {
            if ($base.ContainsKey($key) -and $base[$key] -is [hashtable] -and $overlay[$key] -is [hashtable]) {
                # Recursively merge nested hashtables
                $result[$key] = $this.MergeHashtables($base[$key], $overlay[$key])
            } else {
                # Overlay value takes precedence
                $result[$key] = $overlay[$key]
            }
        }
        
        return $result
    }
    
    # Get configuration value with dot notation support
    [object] Get([string]$path) {
        return $this.Get($path, $null)
    }
    
    [object] Get([string]$path, $default) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $default
            }
        }
        
        return $current
    }
    
    # Set configuration value with dot notation support
    [void] Set([string]$path, $value) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            } elseif ($current[$part] -isnot [hashtable]) {
                # Path conflict - convert to hashtable
                $current[$part] = @{}
            }
            
            $current = $current[$part]
        }
        
        # Set the final value
        $lastPart = $parts[-1]
        $current[$lastPart] = $value
        
        # Auto-save if enabled
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Check if configuration key exists
    [bool] Has([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $false
            }
        }
        
        return $true
    }
    
    # Remove configuration key
    [void] Remove([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                # Path doesn't exist
                return
            }
        }
        
        # Remove the final key
        $lastPart = $parts[-1]
        if ($current -is [hashtable] -and $current.ContainsKey($lastPart)) {
            $current.Remove($lastPart)
            
            # Auto-save if enabled
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Reset to defaults
    [void] Reset() {
        $this.Config = $this.Defaults.Clone()
        $this.Save()
    }
    
    # Reset specific section to defaults
    [void] ResetSection([string]$section) {
        if ($this.Defaults.ContainsKey($section)) {
            $this.Config[$section] = $this.Defaults[$section].Clone()
            
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Get all configuration as hashtable
    [hashtable] GetAll() {
        return $this.Config.Clone()
    }
    
    # Import configuration from hashtable
    [void] Import([hashtable]$config) {
        $this.Config = $this.MergeHashtables($this.Defaults, $config)
        
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Export configuration to file
    [void] Export([string]$path) {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $path -Value $json -Encoding UTF8
        } catch {
            throw "Failed to export configuration: $_"
        }
    }
}


####\Services/EventBus.ps1
# EventBus Service for PRAXIS
# Based on AxiomPhoenix EventManager with adaptations for PRAXIS architecture
# Provides pub/sub event system for decoupled communication between components

class EventBus {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $false  # Disabled by default for performance
    [ServiceContainer]$ServiceContainer
    [bool]$EnableDebugLogging = $false  # Enable detailed event logging
    hidden [int]$TotalEventsPublished = 0
    hidden [int]$TotalHandlersCalled = 0
    
    EventBus() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.ServiceContainer = $container
        $logger = $container.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus initialized", "Info")
        }
    }
    
    # Subscribe to an event with a handler
    # Returns a subscription ID that can be used to unsubscribe
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            if ($global:Logger) {
                $global:Logger.Error("EventBus.Subscribe: Event name is null or empty")
                $global:Logger.Error("Stack trace: " + [System.Environment]::StackTrace)
            }
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("Handler cannot be null")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        $logger = $this.ServiceContainer.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus: Subscribed handler '$handlerId' to event '$eventName'", "Debug")
        }
        
        return $handlerId
    }
    
    # Subscribe with a weak reference to an object
    # Automatically unsubscribes if the object is garbage collected
    [string] SubscribeWeak([string]$eventName, [object]$target, [scriptblock]$handler) {
        $weakRef = [System.WeakReference]::new($target)
        $wrappedHandler = {
            param($sender, $eventData)
            $strongRef = $weakRef.Target
            if ($strongRef) {
                & $handler $sender $eventData
            } else {
                # Target has been garbage collected, unsubscribe
                $eventBus = $sender
                $eventBus.Unsubscribe($eventName, $args[0])
            }
        }.GetNewClosure()
        
        return $this.Subscribe($eventName, $wrappedHandler)
    }
    
    # Unsubscribe a specific handler
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
                
                $logger = $this.ServiceContainer.GetService('Logger')
                if ($logger) {
                    $logger.Log("EventBus: Unsubscribed handler '$handlerId' from event '$eventName'", "Debug")
                }
            }
        }
    }
    
    # Unsubscribe all handlers for an event
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Unsubscribed all $handlerCount handlers from event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event with optional data
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        # Add timestamp to event data
        $eventData['Timestamp'] = [DateTime]::Now
        $eventData['EventName'] = $eventName
        
        $this.TotalEventsPublished++
        
        # Debug logging
        if ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Publishing event '$eventName' with data: $($eventData | ConvertTo-Json -Compress)", "Debug")
            }
        }
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $this.AddToHistory($eventName, $eventData)
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            
            if ($this.EnableDebugLogging) {
                $debugLogger = $this.ServiceContainer.GetService('Logger')
                if ($debugLogger) {
                    $debugLogger.Log("EventBus: Found $($handlers.Count) handlers for event '$eventName'", "Debug")
                }
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    $this.TotalHandlersCalled++
                    
                    if ($this.EnableDebugLogging) {
                        $debugLogger = $this.ServiceContainer.GetService('Logger')
                        if ($debugLogger) {
                            $debugLogger.Log("EventBus: Calling handler '$($entry.Key)' for event '$eventName'", "Debug")
                        }
                    }
                    
                    # Call handler with EventBus as sender and eventData
                    & $handlerData.Handler $this $eventData
                }
                catch {
                    $logger = $this.ServiceContainer.GetService('Logger')
                    if ($logger) {
                        $logger.Log("EventBus: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)", "Error")
                    }
                }
            }
        }
        elseif ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: No handlers registered for event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event asynchronously (returns immediately)
    [void] PublishAsync([string]$eventName, [hashtable]$eventData = @{}) {
        $job = Start-Job -ScriptBlock {
            param($eventBus, $eventName, $eventData)
            $eventBus.Publish($eventName, $eventData)
        } -ArgumentList $this, $eventName, $eventData
        
        # Clean up job after completion
        Register-ObjectEvent -InputObject $job -EventName StateChanged -Action {
            if ($Event.SourceEventArgs.JobStateInfo.State -eq 'Completed') {
                Remove-Job -Job $Event.SourceEventArgs
                Unregister-Event -SourceIdentifier $Event.SourceIdentifier
            }
        } | Out-Null
    }
    
    # Add event to history
    hidden [void] AddToHistory([string]$eventName, [hashtable]$eventData) {
        # Sanitize event data to prevent circular references
        $sanitizedData = @{}
        foreach ($key in $eventData.Keys) {
            $value = $eventData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [double] -or 
                $value -is [bool] -or $value -is [datetime] -or $value -eq $null) {
                $sanitizedData[$key] = $value
            }
            elseif ($value.GetType().Name -eq 'UIElement' -or $value.GetType().BaseType.Name -eq 'UIElement') {
                # Handle UIElement without requiring the type to be loaded
                $name = if ($value.PSObject.Properties['Name']) { $value.Name } else { 'Unknown' }
                $sanitizedData[$key] = "[UIElement: $name]"
            }
            else {
                $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
            }
        }
        
        $historyEntry = @{
            EventName = $eventName
            EventData = $sanitizedData
            Timestamp = [DateTime]::Now
            HandlerCount = if ($this.EventHandlers.ContainsKey($eventName)) { 
                $this.EventHandlers[$eventName].Count 
            } else { 0 }
        }
        
        $this.EventHistory.Add($historyEntry)
        
        if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
            $this.EventHistory.RemoveAt(0)
        }
    }
    
    # Get event history
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory.Where({ $_.EventName -eq $eventName })
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    # Clear event history
    [void] ClearHistory() {
        $this.EventHistory.Clear()
    }
    
    # Get information about registered events
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
            TotalEventsPublished = $this.TotalEventsPublished
            TotalHandlersCalled = $this.TotalHandlersCalled
            EnableHistory = $this.EnableHistory
            EnableDebugLogging = $this.EnableDebugLogging
            HistorySize = $this.EventHistory.Count
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { 
                    @{
                        Id = $_
                        ExecutionCount = $handlers[$_].ExecutionCount
                        SubscribedAt = $handlers[$_].SubscribedAt
                    }
                }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
    
    # Get debug report
    [string] GetDebugReport() {
        $sb = [System.Text.StringBuilder]::new()
        $info = $this.GetEventInfo()
        
        $sb.AppendLine("EventBus Debug Report")
        $sb.AppendLine("====================")
        $sb.AppendLine("Total Events Published: $($info.TotalEventsPublished)")
        $sb.AppendLine("Total Handlers Called: $($info.TotalHandlersCalled)")
        $sb.AppendLine("Active Handlers: $($info.TotalHandlers)")
        $sb.AppendLine("History Enabled: $($info.EnableHistory)")
        $sb.AppendLine("Debug Logging: $($info.EnableDebugLogging)")
        $sb.AppendLine("History Size: $($info.HistorySize)/$($this.MaxHistorySize)")
        $sb.AppendLine("")
        $sb.AppendLine("Registered Events:")
        
        foreach ($eventName in $info.RegisteredEvents.Keys | Sort-Object) {
            $eventInfo = $info.RegisteredEvents[$eventName]
            $sb.AppendLine("  $eventName : $($eventInfo.HandlerCount) handler(s)")
            
            foreach ($handler in $eventInfo.Handlers) {
                $sb.AppendLine("    - $($handler.Id): $($handler.ExecutionCount) executions")
            }
        }
        
        return $sb.ToString()
    }
}

# Common Event Names (for consistency across the application)
class EventNames {
    # Project Events
    static [string]$ProjectCreated = 'project.created'
    static [string]$ProjectUpdated = 'project.updated'
    static [string]$ProjectDeleted = 'project.deleted'
    static [string]$ProjectSelected = 'project.selected'
    
    # Task Events
    static [string]$TaskCreated = 'task.created'
    static [string]$TaskUpdated = 'task.updated'
    static [string]$TaskDeleted = 'task.deleted'
    static [string]$TaskSelected = 'task.selected'
    static [string]$TaskStatusChanged = 'task.statusChanged'
    
    # Navigation Events
    static [string]$TabChanged = 'navigation.tabChanged'
    static [string]$ScreenChanged = 'navigation.screenChanged'
    static [string]$DialogOpened = 'navigation.dialogOpened'
    static [string]$DialogClosed = 'navigation.dialogClosed'
    
    # Application Events
    static [string]$AppInitialized = 'app.initialized'
    static [string]$AppShutdown = 'app.shutdown'
    static [string]$ThemeChanged = 'app.themeChanged'
    static [string]$ConfigChanged = 'app.configChanged'
    static [string]$RefreshRequested = 'app.refreshRequested'
    static [string]$DataChanged = 'app.dataChanged'
    
    # Command Events
    static [string]$CommandExecuted = 'command.executed'
    static [string]$CommandRegistered = 'command.registered'
    
    # UI Events
    static [string]$FocusChanged = 'ui.focusChanged'
    static [string]$SelectionChanged = 'ui.selectionChanged'
}

# Helper class for command registration
class CommandRegistration {
    static [void] RegisterCommand([string]$name, [string]$description, [scriptblock]$action) {
        $eventBus = $global:ServiceContainer.GetService('EventBus')
        if ($eventBus) {
            $eventBus.Publish([EventNames]::CommandRegistered, @{
                Name = $name
                Description = $description
                Action = $action
            })
        }
    }
}


####\Services/ExcelImportService.ps1
class ExcelImportService {
    $ServiceContainer
    [hashtable] $FieldMappings
    
    ExcelImportService() {
        $this.InitializeFieldMappings()
    }
    
    [void] Initialize($container) {
        $this.ServiceContainer = $container
    }
    
    [void] InitializeFieldMappings() {
        # Based on changes.txt mappings
        $this.FieldMappings = @{
            'RequestDate' = @{ Cell = 'W23'; Type = 'Date' }
            'AuditType' = @{ Cell = 'W78'; Type = 'String' }
            'AuditorName' = @{ Cell = 'W10'; Type = 'String' }
            'AuditorPhone' = @{ Cell = 'W12'; Type = 'String' }
            'AuditorTL' = @{ Cell = 'W15'; Type = 'String' }
            'AuditorTLPhone' = @{ Cell = 'W16'; Type = 'String' }
            'TPName' = @{ Cell = 'W3'; Type = 'String' }
            'TPNum' = @{ Cell = 'W4'; Type = 'String' }
            'Address' = @{ Cell = 'W5'; Type = 'String' }
            'City' = @{ Cell = 'W6'; Type = 'String' }
            'Province' = @{ Cell = 'W7'; Type = 'String' }
            'PostalCode' = @{ Cell = 'W8'; Type = 'String' }
            'Country' = @{ Cell = 'W9'; Type = 'String' }
            'AuditPeriodFrom' = @{ Cell = 'W27'; Type = 'Date' }
            'AuditPeriodTo' = @{ Cell = 'W28'; Type = 'Date' }
            'AuditPeriod1Start' = @{ Cell = 'W29'; Type = 'Date' }
            'AuditPeriod1End' = @{ Cell = 'W30'; Type = 'Date' }
            'AuditPeriod2Start' = @{ Cell = 'W31'; Type = 'Date' }
            'AuditPeriod2End' = @{ Cell = 'W32'; Type = 'Date' }
            'AuditPeriod3Start' = @{ Cell = 'W33'; Type = 'Date' }
            'AuditPeriod3End' = @{ Cell = 'W34'; Type = 'Date' }
            'AuditPeriod4Start' = @{ Cell = 'W35'; Type = 'Date' }
            'AuditPeriod4End' = @{ Cell = 'W36'; Type = 'Date' }
            'AuditPeriod5Start' = @{ Cell = 'W37'; Type = 'Date' }
            'AuditPeriod5End' = @{ Cell = 'W38'; Type = 'Date' }
            'Contact1Name' = @{ Cell = 'W54'; Type = 'String' }
            'Contact1Phone' = @{ Cell = 'W55'; Type = 'String' }
            'Contact1Ext' = @{ Cell = 'W56'; Type = 'String' }
            'Contact1Address' = @{ Cell = 'W57'; Type = 'String' }
            'Contact1Title' = @{ Cell = 'W58'; Type = 'String' }
            'Contact2Name' = @{ Cell = 'W59'; Type = 'String' }
            'Contact2Phone' = @{ Cell = 'W60'; Type = 'String' }
            'Contact2Ext' = @{ Cell = 'W61'; Type = 'String' }
            'Contact2Address' = @{ Cell = 'W62'; Type = 'String' }
            'Contact2Title' = @{ Cell = 'W63'; Type = 'String' }
            'AuditProgram' = @{ Cell = 'W72'; Type = 'String' }
            'AuditCase' = @{ Cell = 'W18'; Type = 'String' }
            'CASCase' = @{ Cell = 'W17'; Type = 'String' }  # Critical ID2 field
            'AuditStartDate' = @{ Cell = 'W24'; Type = 'Date' }
            'AccountingSoftware1' = @{ Cell = 'W98'; Type = 'String' }
            'AccountingSoftware1Other' = @{ Cell = 'W100'; Type = 'String' }
            'AccountingSoftware1Type' = @{ Cell = 'W101'; Type = 'String' }
            'AccountingSoftware2' = @{ Cell = 'W102'; Type = 'String' }
            'AccountingSoftware2Other' = @{ Cell = 'W104'; Type = 'String' }
            'AccountingSoftware2Type' = @{ Cell = 'W105'; Type = 'String' }
            'FXInfo' = @{ Cell = 'W129'; Type = 'String' }
            'ShipToAddress' = @{ Cell = 'W130'; Type = 'String' }
            'Comments' = @{ Cell = 'W108'; Type = 'String' }
        }
    }
    
    [hashtable] ImportFromExcel([string]$FilePath) {
        # Validate file exists
        if (-not (Test-Path $FilePath)) {
            throw "Excel file not found: $FilePath"
        }
        
        # Initialize COM objects
        $excel = $null
        $workbook = $null
        $importedData = @{}
        
        try {
            # Create Excel application
            $excel = New-Object -ComObject Excel.Application
            $excel.Visible = $false
            $excel.DisplayAlerts = $false
            
            # Open workbook
            $workbook = $excel.Workbooks.Open($FilePath, 0, $true) # ReadOnly
            
            # Try to find SVI-CAS worksheet
            $worksheet = $null
            try {
                $worksheet = $workbook.Worksheets.Item('SVI-CAS')
            }
            catch {
                # Use first worksheet if SVI-CAS not found
                $worksheet = $workbook.Worksheets.Item(1)
                Write-Warning "SVI-CAS worksheet not found, using first worksheet: $($worksheet.Name)"
            }
            
            # Extract data based on mappings
            foreach ($field in $this.FieldMappings.Keys) {
                $mapping = $this.FieldMappings[$field]
                try {
                    $cellValue = $worksheet.Range($mapping.Cell).Value2
                    
                    # Convert based on type
                    if ($null -ne $cellValue -and $cellValue -ne '') {
                        switch ($mapping.Type) {
                            'Date' {
                                if ($cellValue -is [double]) {
                                    $importedData[$field] = [DateTime]::FromOADate($cellValue)
                                }
                                else {
                                    $importedData[$field] = [DateTime]::Parse($cellValue.ToString())
                                }
                            }
                            'String' {
                                $importedData[$field] = $cellValue.ToString().Trim()
                            }
                            default {
                                $importedData[$field] = $cellValue
                            }
                        }
                    }
                }
                catch {
                    Write-Warning "Failed to extract $field from cell $($mapping.Cell): $_"
                }
            }
            
            return $importedData
        }
        finally {
            # Clean up COM objects
            if ($workbook) {
                try { $workbook.Close($false) } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($workbook) | Out-Null
            }
            if ($excel) {
                try { $excel.Quit() } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
            }
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
        }
    }
    
    [object] CreateProjectFromImport([hashtable]$ImportedData) {
        $projectService = $this.ServiceContainer.GetService('ProjectService')
        
        # Create new project with imported data
        $project = [Project]::new()
        
        # Map basic fields
        $project.FullProjectName = $ImportedData.TPName
        $project.Nickname = $ImportedData.TPName  # Can be changed later
        $project.ID2 = $ImportedData.CASCase  # CAS Case# is the ID2
        $project.ClientID = $ImportedData.TPNum
        $project.Status = 'Active'
        
        # Map audit information
        $project.AuditType = $ImportedData.AuditType
        $project.AuditProgram = $ImportedData.AuditProgram
        $project.AuditCase = $ImportedData.AuditCase
        $project.AuditStartDate = $ImportedData.AuditStartDate
        $project.AuditPeriodFrom = $ImportedData.AuditPeriodFrom
        $project.AuditPeriodTo = $ImportedData.AuditPeriodTo
        
        # Map additional audit periods
        $project.AuditPeriod1Start = $ImportedData.AuditPeriod1Start
        $project.AuditPeriod1End = $ImportedData.AuditPeriod1End
        $project.AuditPeriod2Start = $ImportedData.AuditPeriod2Start
        $project.AuditPeriod2End = $ImportedData.AuditPeriod2End
        $project.AuditPeriod3Start = $ImportedData.AuditPeriod3Start
        $project.AuditPeriod3End = $ImportedData.AuditPeriod3End
        $project.AuditPeriod4Start = $ImportedData.AuditPeriod4Start
        $project.AuditPeriod4End = $ImportedData.AuditPeriod4End
        $project.AuditPeriod5Start = $ImportedData.AuditPeriod5Start
        $project.AuditPeriod5End = $ImportedData.AuditPeriod5End
        
        # Map address information
        $project.Address = $ImportedData.Address
        $project.City = $ImportedData.City
        $project.Province = $ImportedData.Province
        $project.PostalCode = $ImportedData.PostalCode
        $project.Country = $ImportedData.Country
        $project.ShipToAddress = $ImportedData.ShipToAddress
        
        # Map auditor information
        $project.AuditorName = $ImportedData.AuditorName
        $project.AuditorPhone = $ImportedData.AuditorPhone
        $project.AuditorTL = $ImportedData.AuditorTL
        $project.AuditorTLPhone = $ImportedData.AuditorTLPhone
        
        # Map contact information directly to project fields
        $project.Contact1Name = $ImportedData.Contact1Name
        $project.Contact1Phone = $ImportedData.Contact1Phone
        $project.Contact1Ext = $ImportedData.Contact1Ext
        $project.Contact1Address = $ImportedData.Contact1Address
        $project.Contact1Title = $ImportedData.Contact1Title
        $project.Contact2Name = $ImportedData.Contact2Name
        $project.Contact2Phone = $ImportedData.Contact2Phone
        $project.Contact2Ext = $ImportedData.Contact2Ext
        $project.Contact2Address = $ImportedData.Contact2Address
        $project.Contact2Title = $ImportedData.Contact2Title
        
        # Map software information
        $project.AccountingSoftware1 = $ImportedData.AccountingSoftware1
        $project.AccountingSoftware1Other = $ImportedData.AccountingSoftware1Other
        $project.AccountingSoftware1Type = $ImportedData.AccountingSoftware1Type
        $project.AccountingSoftware2 = $ImportedData.AccountingSoftware2
        $project.AccountingSoftware2Other = $ImportedData.AccountingSoftware2Other
        $project.AccountingSoftware2Type = $ImportedData.AccountingSoftware2Type
        
        # Map additional fields
        $project.RequestDate = $ImportedData.RequestDate
        $project.FXInfo = $ImportedData.FXInfo
        $project.Comments = $ImportedData.Comments
        
        return $project
    }
}


####\Services/FocusManager.ps1
using namespace System.Collections.Generic

class FocusManager {
    # Singleton focus management with O(1) focus lookups
    [UIElement] $CurrentFocused
    [HashSet[UIElement]] $FocusableElements
    [Queue[UIElement]] $FocusHistory
    [bool] $NavigationLocked
    [ThemeManager] $ThemeManager
    
    # Visual style settings
    [string] $FocusIndicatorStyle = 'minimal'  # minimal, border, glow
    [string] $CachedFocusPrefix
    [string] $CachedFocusSuffix
    
    FocusManager() {
        $this.FocusableElements = [HashSet[UIElement]]::new()
        $this.FocusHistory = [Queue[UIElement]]::new()
        $this.NavigationLocked = $false
    }
    
    [void] Initialize([ServiceContainer] $container) {
        $this.ThemeManager = $container.GetService('ThemeManager')
        $this.UpdateFocusStyle()
    }
    
    [void] UpdateFocusStyle() {
        # Pre-cache minimal focus indicators for speed
        $focusColor = $this.ThemeManager.GetColor('focus')
        
        switch ($this.FocusIndicatorStyle) {
            'minimal' {
                # Subtle underline for minimal look
                $this.CachedFocusPrefix = [VT]::Underline() + $focusColor
                $this.CachedFocusSuffix = [VT]::NoUnderline() + [VT]::Reset()
            }
            'border' {
                # Clean border focus (will be rendered by components)
                $this.CachedFocusPrefix = $focusColor
                $this.CachedFocusSuffix = [VT]::Reset()
            }
            'glow' {
                # Bright background for high visibility
                $bgColor = $this.ThemeManager.GetColor('focus.background')
                $this.CachedFocusPrefix = $bgColor + $focusColor
                $this.CachedFocusSuffix = [VT]::Reset()
            }
        }
    }
    
    # Register a focusable element (O(1))
    [void] RegisterFocusable([UIElement] $element) {
        if ($element.IsFocusable) {
            [void]$this.FocusableElements.Add($element)
        }
    }
    
    # Unregister element (O(1))
    [void] UnregisterFocusable([UIElement] $element) {
        [void]$this.FocusableElements.Remove($element)
        if ($this.CurrentFocused -eq $element) {
            $this.CurrentFocused = $null
        }
    }
    
    # Set focus with O(1) performance
    [bool] SetFocus([UIElement] $element) {
        if ($this.NavigationLocked) { return $false }
        if (-not $element -or -not $element.IsFocusable) { return $false }
        if ($this.CurrentFocused -eq $element) { return $true }
        
        # Clear previous focus
        if ($this.CurrentFocused) {
            $this.CurrentFocused.IsFocused = $false
            $this.CurrentFocused.OnLostFocus()
            $this.CurrentFocused.InvalidateFocusOnly()
        }
        
        # Set new focus
        $this.CurrentFocused = $element
        $element.IsFocused = $true
        $element.OnGotFocus()
        $element.InvalidateFocusOnly()
        
        # Maintain history (keep last 10)
        $this.FocusHistory.Enqueue($element)
        if ($this.FocusHistory.Count -gt 10) {
            [void]$this.FocusHistory.Dequeue()
        }
        
        return $true
    }
    
    # Get currently focused element (O(1))
    [UIElement] GetFocused() {
        return $this.CurrentFocused
    }
    
    # Navigate to next focusable element
    [bool] FocusNext([UIElement] $container) {
        if ($this.NavigationLocked) { return $false }
        
        $focusables = $this.GetFocusableChildren($container)
        if ($focusables.Count -eq 0) { return $false }
        
        $currentIndex = -1
        if ($this.CurrentFocused) {
            for ($i = 0; $i -lt $focusables.Count; $i++) {
                if ($focusables[$i] -eq $this.CurrentFocused) {
                    $currentIndex = $i
                    break
                }
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusables.Count
        return $this.SetFocus($focusables[$nextIndex])
    }
    
    # Navigate to previous focusable element
    [bool] FocusPrevious([UIElement] $container) {
        if ($this.NavigationLocked) { return $false }
        
        $focusables = $this.GetFocusableChildren($container)
        if ($focusables.Count -eq 0) { return $false }
        
        $currentIndex = -1
        if ($this.CurrentFocused) {
            for ($i = 0; $i -lt $focusables.Count; $i++) {
                if ($focusables[$i] -eq $this.CurrentFocused) {
                    $currentIndex = $i
                    break
                }
            }
        }
        
        $prevIndex = if ($currentIndex -le 0) { $focusables.Count - 1 } else { $currentIndex - 1 }
        return $this.SetFocus($focusables[$prevIndex])
    }
    
    # Get focusable children in tab order
    [List[UIElement]] GetFocusableChildren([UIElement] $container) {
        $result = [List[UIElement]]::new()
        $this.CollectFocusables($container, $result)
        
        # Sort by TabIndex if specified
        $sorted = $result | Sort-Object -Property @{
            Expression = { if ($_.TabIndex -ge 0) { $_.TabIndex } else { [int]::MaxValue } }
        }, @{
            Expression = { $result.IndexOf($_) }
        }
        
        return [List[UIElement]]::new($sorted)
    }
    
    [void] CollectFocusables([UIElement] $element, [List[UIElement]] $list) {
        if ($element.IsFocusable -and $element.IsVisible) {
            $list.Add($element)
        }
        
        if ($element -is [Container]) {
            foreach ($child in $element.Children) {
                $this.CollectFocusables($child, $list)
            }
        }
    }
    
    # Lock navigation during operations
    [void] LockNavigation() {
        $this.NavigationLocked = $true
    }
    
    [void] UnlockNavigation() {
        $this.NavigationLocked = $false
    }
    
    # Clear all focus
    [void] ClearFocus() {
        if ($this.CurrentFocused) {
            $this.CurrentFocused.IsFocused = $false
            $this.CurrentFocused.OnLostFocus()
            $this.CurrentFocused.InvalidateFocusOnly()
            $this.CurrentFocused = $null
        }
    }
    
    # Get focus style strings for rendering
    [string] GetFocusPrefix() { return $this.CachedFocusPrefix }
    [string] GetFocusSuffix() { return $this.CachedFocusSuffix }
}


####\Services/FunctionRegistry.ps1
# FunctionRegistry.ps1 - Registry for @functions used in Visual Macro Factory
# Integrates with CommandService to provide both built-in and custom @functions

class FunctionRegistry {
    [hashtable]$BuiltInFunctions = @{}
    [CommandService]$CommandService
    [Logger]$Logger
    
    FunctionRegistry() {
        $this.Logger = $global:Logger
        $this.RegisterBuiltInFunctions()
    }
    
    # Set the CommandService reference for accessing custom commands
    [void] SetCommandService([CommandService]$commandService) {
        $this.CommandService = $commandService
    }
    
    # Register built-in @functions
    [void] RegisterBuiltInFunctions() {
        # User input functions
        $this.BuiltInFunctions["PromptForField"] = @{
            Name = "PromptForField"
            Description = "Prompts user to select a field from the current database"
            Category = "User Input"
            Usage = "@PromptForField"
            Template = "@PromptForField"
        }
        
        $this.BuiltInFunctions["PromptForValue"] = @{
            Name = "PromptForValue"
            Description = "Prompts user for a text value"
            Category = "User Input"
            Usage = "@PromptForValue(""Enter value:"")"
            Template = "@PromptForValue(""Enter description"")"
        }
        
        $this.BuiltInFunctions["PromptForNumber"] = @{
            Name = "PromptForNumber"
            Description = "Prompts user for a numeric value"
            Category = "User Input"
            Usage = "@PromptForNumber(""Enter amount:"")"
            Template = "@PromptForNumber(""Enter description"")"
        }
        
        # System functions
        $this.BuiltInFunctions["CurrentDate_YYYYMMDD"] = @{
            Name = "CurrentDate_YYYYMMDD"
            Description = "Current date in YYYYMMDD format"
            Category = "System"
            Usage = "@CurrentDate_YYYYMMDD"
            Template = "@CurrentDate_YYYYMMDD"
        }
        
        $this.BuiltInFunctions["CurrentDate_MMDDYYYY"] = @{
            Name = "CurrentDate_MMDDYYYY"
            Description = "Current date in MM/DD/YYYY format"
            Category = "System"
            Usage = "@CurrentDate_MMDDYYYY"
            Template = "@CurrentDate_MMDDYYYY"
        }
        
        $this.BuiltInFunctions["CurrentUser"] = @{
            Name = "CurrentUser"
            Description = "Current Windows username"
            Category = "System"
            Usage = "@CurrentUser"
            Template = "@CurrentUser"
        }
        
        $this.BuiltInFunctions["CurrentTime_HHMMSS"] = @{
            Name = "CurrentTime_HHMMSS"
            Description = "Current time in HHMMSS format"
            Category = "System"
            Usage = "@CurrentTime_HHMMSS"
            Template = "@CurrentTime_HHMMSS"
        }
        
        # File functions
        $this.BuiltInFunctions["TempFile"] = @{
            Name = "TempFile"
            Description = "Generate a temporary file path"
            Category = "File"
            Usage = "@TempFile(.xlsx)"
            Template = "@TempFile(.xlsx)"
        }
    }
    
    # Get all available @functions (built-in + custom from CommandService)
    [hashtable[]] GetAllFunctions() {
        $functions = @()
        
        # Add built-in functions
        foreach ($func in $this.BuiltInFunctions.Values) {
            $functions += $func
        }
        
        # Add custom functions from CommandService if available
        if ($this.CommandService) {
            $customFunctions = $this.GetCustomFunctions()
            $functions += $customFunctions
        }
        
        return $functions
    }
    
    # Get custom @functions from CommandService
    [hashtable[]] GetCustomFunctions() {
        $functions = @()
        
        if (-not $this.CommandService) {
            return $functions
        }
        
        # Look for commands that define @functions
        foreach ($command in $this.CommandService.Commands) {
            # Check if command defines a @function (starts with @)
            if ($command.Command -match '^@(\w+)') {
                $funcName = $matches[1]
                $functions += @{
                    Name = $funcName
                    Description = $command.Description
                    Category = "Custom"
                    Usage = $command.Command
                    Template = $command.Command
                    Source = "CommandLibrary"
                    Tags = $command.Tags
                }
            }
            
            # Also check for commands tagged as functions
            if ($command.Tags -contains "function" -or $command.Tags -contains "@function") {
                $functions += @{
                    Name = $command.Name
                    Description = $command.Description
                    Category = "Custom"
                    Usage = $command.Command
                    Template = $command.Command
                    Source = "CommandLibrary"
                    Tags = $command.Tags
                }
            }
        }
        
        return $functions
    }
    
    # Search functions by name or description
    [hashtable[]] SearchFunctions([string]$query) {
        $allFunctions = $this.GetAllFunctions()
        $results = @()
        
        $query = $query.ToLower()
        
        foreach ($func in $allFunctions) {
            $name = $func.Name.ToLower()
            $desc = $func.Description.ToLower()
            
            if ($name.Contains($query) -or $desc.Contains($query)) {
                $results += $func
            }
        }
        
        return $results
    }
    
    # Get functions by category
    [hashtable[]] GetFunctionsByCategory([string]$category) {
        $allFunctions = $this.GetAllFunctions()
        $results = @()
        
        foreach ($func in $allFunctions) {
            if ($func.Category -eq $category) {
                $results += $func
            }
        }
        
        return $results
    }
    
    # Resolve @function at runtime (for script generation)
    [string] ResolveFunction([string]$functionCall, [hashtable]$context = @{}) {
        # This would be called during macro execution to replace @functions with actual values
        # For now, return the function call as-is for the IDEAScript to handle
        return $functionCall
    }
}


####\Services/Logger.ps1
# Logger.ps1 - Fast logging service adapted from AxiomPhoenix
# Optimized for speed - no console output, minimal file I/O

class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 100  # Smaller queue for faster flushing
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false  # Never log to console in TUI
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    hidden [System.Text.StringBuilder]$_buffer
    hidden [int]$_unflushedCount = 0
    hidden [int]$_flushThreshold = 10  # Flush every N messages
    
    Logger() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { (Get-Location).Path }
        $logDir = Join-Path $praxisDir "_Logs"
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        $this.LogPath = Join-Path $logDir "praxis.log"
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        $this._buffer = [System.Text.StringBuilder]::new(4096)  # Pre-allocate buffer
        
        # Check for debug mode
        if ($global:PraxisDebug -or $env:PRAXIS_DEBUG) {
            $this.MinimumLevel = "Debug"
        }
        
        # Rotate log if too large (>10MB)
        try {
            if ((Test-Path $this.LogPath) -and (Get-Item $this.LogPath).Length -gt 10MB) {
                $backupPath = $this.LogPath + ".old"
                Move-Item $this.LogPath $backupPath -Force -ErrorAction SilentlyContinue
            }
        } catch {
            # Ignore rotation errors
        }
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Fast level check
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        # Format timestamp efficiently
        $timestamp = [DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
        $levelPadded = $level.ToUpper().PadRight(7)
        
        # Build log line
        $logLine = "$timestamp [$levelPadded] $message"
        
        # Add to buffer instead of queue for speed
        $this._buffer.AppendLine($logLine)
        $this._unflushedCount++
        
        # Auto-flush on threshold or error/fatal
        if ($this._unflushedCount -ge $this._flushThreshold -or 
            $level -eq "Error" -or $level -eq "Fatal") {
            $this.Flush()
        }
    }
    
    [void] LogException([Exception]$exception, [string]$context = "") {
        $message = if ($context) { "$context - " } else { "" }
        $message += "$($exception.GetType().Name): $($exception.Message)"
        $this.Log($message, "Error")
        
        # Log stack trace as debug
        if ($exception.StackTrace) {
            $this.Log("Stack: $($exception.StackTrace -replace "`n", " ")", "Debug")
        }
    }
    
    [void] Flush() {
        if ($this._buffer.Length -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            # Write buffer to file in one operation
            [System.IO.File]::AppendAllText($this.LogPath, $this._buffer.ToString())
            $this._buffer.Clear()
            $this._unflushedCount = 0
        }
        catch {
            # Ignore logging errors to prevent crashes
        }
    }
    
    # Quick logging methods
    [void] Debug([string]$message) { $this.Log($message, "Debug") }
    [void] Info([string]$message) { $this.Log($message, "Info") }
    [void] Warning([string]$message) { $this.Log($message, "Warning") }
    [void] Error([string]$message) { $this.Log($message, "Error") }
    
    [void] Cleanup() {
        $this.Flush()
    }
}

# Global Write-Log function for compatibility
function global:Write-Log {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    if ($global:Logger) {
        $global:Logger.Log($Message, $Level)
    }
}


####\Services/MacroContextManager.ps1
# MacroContextManager.ps1 - Manages macro state and variable context
# The "smart conductor" that ensures temporal safety and handles name collisions

class MacroContextManager {
    [System.Collections.ArrayList]$Actions = [System.Collections.ArrayList]::new()
    [hashtable]$GlobalContext = @{}
    [Logger]$Logger
    [FunctionRegistry]$FunctionRegistry
    
    MacroContextManager() {
        $this.Logger = $global:Logger
        $this.InitializeGlobalContext()
    }
    
    # Set the FunctionRegistry reference
    [void] SetFunctionRegistry([FunctionRegistry]$functionRegistry) {
        $this.FunctionRegistry = $functionRegistry
    }
    
    # Initialize with common IDEA context variables
    [void] InitializeGlobalContext() {
        $this.GlobalContext = @{
            # Common IDEA database context
            "ActiveDatabase" = @{
                Type = "Database"
                Description = "Currently active database in IDEA"
                Available = $true
            }
            
            # System variables
            "CurrentUser" = @{
                Type = "String"
                Description = "Current Windows username"
                Available = $true
            }
            
            "CurrentDate" = @{
                Type = "Date"
                Description = "Current system date"
                Available = $true
            }
        }
    }
    
    # Add an action to the macro sequence
    [void] AddAction([BaseAction]$action) {
        $this.AddAction($action, $this.Actions.Count)
    }
    
    # Add an action at a specific position
    [void] AddAction([BaseAction]$action, [int]$position) {
        if ($position -lt 0 -or $position -gt $this.Actions.Count) {
            $position = $this.Actions.Count
        }
        
        $this.Actions.Insert($position, $action)
        $this.UpdateProducedVariables()
        
        if ($this.Logger) {
            $this.Logger.Debug("Added action '$($action.Name)' at position $position")
        }
    }
    
    # Remove an action from the sequence
    [void] RemoveAction([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Actions.Count) {
            $action = $this.Actions[$index]
            $this.Actions.RemoveAt($index)
            $this.UpdateProducedVariables()
            
            if ($this.Logger) {
                $this.Logger.Debug("Removed action '$($action.Name)' from position $index")
            }
        }
    }
    
    # Move an action to a different position
    [void] MoveAction([int]$fromIndex, [int]$toIndex) {
        if ($fromIndex -eq $toIndex -or 
            $fromIndex -lt 0 -or $fromIndex -ge $this.Actions.Count -or
            $toIndex -lt 0 -or $toIndex -ge $this.Actions.Count) {
            return
        }
        
        $action = $this.Actions[$fromIndex]
        $this.Actions.RemoveAt($fromIndex)
        
        # Adjust target index if we removed an item before it
        if ($fromIndex -lt $toIndex) {
            $toIndex--
        }
        
        $this.Actions.Insert($toIndex, $action)
        $this.UpdateProducedVariables()
        
        if ($this.Logger) {
            $this.Logger.Debug("Moved action '$($action.Name)' from $fromIndex to $toIndex")
        }
    }
    
    # Get the context available at a specific step (temporal safety)
    [hashtable] GetContextAtStep([int]$stepIndex) {
        $context = $this.GlobalContext.Clone()
        
        # Add variables produced by all previous actions
        for ($i = 0; $i -lt $stepIndex -and $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            foreach ($produced in $action.Produces) {
                $varName = $this.ResolveVariableName($produced.Name, $i)
                $context[$varName] = @{
                    Type = $produced.Type
                    Description = $produced.Description
                    ProducedBy = $action.Name
                    StepIndex = $i
                    Available = $true
                }
            }
        }
        
        return $context
    }
    
    # Get all variables available in the macro (for final context view)
    [hashtable] GetFullContext() {
        return $this.GetContextAtStep($this.Actions.Count)
    }
    
    # Resolve variable name with automatic collision handling
    [string] ResolveVariableName([string]$baseName, [int]$actionIndex) {
        $context = $this.GetContextAtStep($actionIndex)
        
        # If no collision, use base name
        if (-not $context.ContainsKey($baseName)) {
            return $baseName
        }
        
        # Handle collision by appending action name and counter
        $action = $this.Actions[$actionIndex]
        $actionName = $action.Name -replace '\s+', ''  # Remove spaces
        $suffix = 1
        
        do {
            $candidateName = "${baseName}_${actionName}_${suffix}"
            $suffix++
        } while ($context.ContainsKey($candidateName))
        
        return $candidateName
    }
    
    # Update all produced variables after sequence changes
    [void] UpdateProducedVariables() {
        # This ensures variable names are recalculated when actions are added/removed/moved
        # The actual resolution happens in GetContextAtStep, so no action needed here
        # But we could invalidate any cached contexts if we implement caching
    }
    
    # Validate that all actions have their required context
    [hashtable] ValidateMacro() {
        $validation = @{
            IsValid = $true
            Errors = @()
            Warnings = @()
        }
        
        for ($i = 0; $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            $availableContext = $this.GetContextAtStep($i)
            
            # Check if all required variables are available
            foreach ($requirement in $action.Consumes) {
                if (-not $availableContext.ContainsKey($requirement.Name)) {
                    $validation.IsValid = $false
                    $validation.Errors += "Step $($i + 1) ($($action.Name)): Missing required variable '$($requirement.Name)'"
                }
            }
        }
        
        return $validation
    }
    
    # Generate the final IDEAScript
    [string] GenerateScript() {
        $validation = $this.ValidateMacro()
        if (-not $validation.IsValid) {
            throw "Cannot generate script: Macro validation failed. Errors: $($validation.Errors -join '; ')"
        }
        
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine("' Generated by PRAXIS Visual Macro Factory")
        $sb.AppendLine("' Generated on: $(Get-Date)")
        $sb.AppendLine("' Total steps: $($this.Actions.Count)")
        $sb.AppendLine("")
        
        for ($i = 0; $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            $context = $this.GetContextAtStep($i + 1)  # Context after this action runs
            
            $sb.AppendLine("' Step $($i + 1): $($action.Name)")
            if ($action.Description) {
                $sb.AppendLine("' $($action.Description)")
            }
            $sb.AppendLine("")
            
            try {
                $actionScript = $action.RenderScript($context)
                $sb.AppendLine($actionScript)
            } catch {
                $sb.AppendLine("' ERROR generating script for $($action.Name): $($_.Exception.Message)")
            }
            
            $sb.AppendLine("")
        }
        
        return $sb.ToString()
    }
    
    # Clear all actions and reset context
    [void] Clear() {
        $this.Actions.Clear()
        $this.InitializeGlobalContext()
        
        if ($this.Logger) {
            $this.Logger.Debug("Cleared macro context")
        }
    }
    
    # Get summary of current macro
    [hashtable] GetSummary() {
        return @{
            ActionCount = $this.Actions.Count
            TotalVariables = $this.GetFullContext().Count
            IsValid = $this.ValidateMacro().IsValid
            Actions = $this.Actions | ForEach-Object { $_.Name }
        }
    }
}


####\Services/ProjectService.ps1
# ProjectService - Business logic for project management
# Lightweight service focusing on project-related operations

class ProjectService {
    hidden [System.Collections.ArrayList]$Projects = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile
    
    ProjectService() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PSScriptRoot }
        $this.DataFile = Join-Path $praxisDir "_ProjectData/projects.json"
        
        # Ensure directory exists
        $dataDir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        $this.LoadProjects()
    }
    
    [void] LoadProjects() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Projects.Clear()
                foreach ($projData in $data) {
                    # Handle both old and new format
                    if ($projData.PSObject.Properties['FullProjectName']) {
                        # New PMC format
                        $project = [Project]::new($projData.FullProjectName, $projData.Nickname)
                        $project.Id = $projData.Id
                        $project.ID1 = $projData.ID1 ?? ""
                        $project.ID2 = $projData.ID2 ?? ""
                        if ($projData.DateAssigned) { $project.DateAssigned = [DateTime]::Parse($projData.DateAssigned) }
                        if ($projData.BFDate) { $project.BFDate = [DateTime]::Parse($projData.BFDate) }
                        if ($projData.DateDue) { $project.DateDue = [DateTime]::Parse($projData.DateDue) }
                        $project.Note = $projData.Note ?? ""
                        $project.CAAPath = $projData.CAAPath ?? ""
                        $project.RequestPath = $projData.RequestPath ?? ""
                        $project.T2020Path = $projData.T2020Path ?? ""
                        $project.CumulativeHrs = $projData.CumulativeHrs ?? 0
                        if ($projData.ClosedDate -and $projData.ClosedDate -ne "0001-01-01T00:00:00") { 
                            $project.ClosedDate = [DateTime]::Parse($projData.ClosedDate) 
                        }
                        
                        # Load all the new fields
                        $project.Status = $projData.Status ?? "Active"
                        $project.ClientID = $projData.ClientID ?? ""
                        
                        # Audit fields
                        $project.AuditType = $projData.AuditType ?? ""
                        $project.AuditProgram = $projData.AuditProgram ?? ""
                        $project.AuditCase = $projData.AuditCase ?? ""
                        if ($projData.AuditStartDate -and $projData.AuditStartDate -ne "0001-01-01T00:00:00") {
                            $project.AuditStartDate = [DateTime]::Parse($projData.AuditStartDate)
                        }
                        if ($projData.AuditPeriodFrom -and $projData.AuditPeriodFrom -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodFrom = [DateTime]::Parse($projData.AuditPeriodFrom)
                        }
                        if ($projData.AuditPeriodTo -and $projData.AuditPeriodTo -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodTo = [DateTime]::Parse($projData.AuditPeriodTo)
                        }
                        
                        # Additional audit periods
                        for ($i = 1; $i -le 5; $i++) {
                            $startProp = "AuditPeriod${i}Start"
                            $endProp = "AuditPeriod${i}End"
                            if ($projData.$startProp -and $projData.$startProp -ne "0001-01-01T00:00:00") {
                                $project.$startProp = [DateTime]::Parse($projData.$startProp)
                            }
                            if ($projData.$endProp -and $projData.$endProp -ne "0001-01-01T00:00:00") {
                                $project.$endProp = [DateTime]::Parse($projData.$endProp)
                            }
                        }
                        
                        # Address fields
                        $project.Address = $projData.Address ?? ""
                        $project.City = $projData.City ?? ""
                        $project.Province = $projData.Province ?? ""
                        $project.PostalCode = $projData.PostalCode ?? ""
                        $project.Country = $projData.Country ?? ""
                        $project.ShipToAddress = $projData.ShipToAddress ?? ""
                        
                        # Auditor fields
                        $project.AuditorName = $projData.AuditorName ?? ""
                        $project.AuditorPhone = $projData.AuditorPhone ?? ""
                        $project.AuditorTL = $projData.AuditorTL ?? ""
                        $project.AuditorTLPhone = $projData.AuditorTLPhone ?? ""
                        
                        # Contact fields
                        $project.Contact1Name = $projData.Contact1Name ?? ""
                        $project.Contact1Phone = $projData.Contact1Phone ?? ""
                        $project.Contact1Ext = $projData.Contact1Ext ?? ""
                        $project.Contact1Address = $projData.Contact1Address ?? ""
                        $project.Contact1Title = $projData.Contact1Title ?? ""
                        $project.Contact2Name = $projData.Contact2Name ?? ""
                        $project.Contact2Phone = $projData.Contact2Phone ?? ""
                        $project.Contact2Ext = $projData.Contact2Ext ?? ""
                        $project.Contact2Address = $projData.Contact2Address ?? ""
                        $project.Contact2Title = $projData.Contact2Title ?? ""
                        
                        # Software fields
                        $project.AccountingSoftware1 = $projData.AccountingSoftware1 ?? ""
                        $project.AccountingSoftware1Other = $projData.AccountingSoftware1Other ?? ""
                        $project.AccountingSoftware1Type = $projData.AccountingSoftware1Type ?? ""
                        $project.AccountingSoftware2 = $projData.AccountingSoftware2 ?? ""
                        $project.AccountingSoftware2Other = $projData.AccountingSoftware2Other ?? ""
                        $project.AccountingSoftware2Type = $projData.AccountingSoftware2Type ?? ""
                        
                        # Other fields
                        if ($projData.RequestDate -and $projData.RequestDate -ne "0001-01-01T00:00:00") {
                            $project.RequestDate = [DateTime]::Parse($projData.RequestDate)
                        }
                        $project.FXInfo = $projData.FXInfo ?? ""
                        $project.Comments = $projData.Comments ?? ""
                        
                        $project.Deleted = $projData.Deleted ?? $false
                    } else {
                        # Legacy format
                        $project = [Project]::new($projData.Name)
                        $project.Id = $projData.Id
                        if ($projData.Description) { $project.Note = $projData.Description }
                    }
                    $this.Projects.Add($project) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load projects: $_"
            }
        }
        
        # Ensure default project exists
        if (-not ($this.Projects | Where-Object { $_.Nickname -eq "Default" })) {
            $default = [Project]::new("Default")
            $default.Note = "Default project for uncategorized tasks"
            $this.Projects.Add($default) | Out-Null
            $this.SaveProjects()
        }
    }
    
    [void] SaveProjects() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($project in $this.Projects) {
            $data += @{
                Id = $project.Id
                FullProjectName = $project.FullProjectName
                Nickname = $project.Nickname
                ID1 = $project.ID1
                ID2 = $project.ID2
                DateAssigned = $project.DateAssigned.ToString("yyyy-MM-ddTHH:mm:ss")
                BFDate = $project.BFDate.ToString("yyyy-MM-ddTHH:mm:ss")
                DateDue = $project.DateDue.ToString("yyyy-MM-ddTHH:mm:ss")
                Note = $project.Note
                CAAPath = $project.CAAPath
                RequestPath = $project.RequestPath
                T2020Path = $project.T2020Path
                CumulativeHrs = $project.CumulativeHrs
                ClosedDate = $project.ClosedDate.ToString("yyyy-MM-ddTHH:mm:ss")
                Deleted = $project.Deleted
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Project[]] GetAllProjects() {
        return $this.Projects.ToArray()
    }
    
    [Project] GetProject([string]$id) {
        return $this.Projects | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Project] GetProjectByName([string]$name) {
        return $this.Projects | Where-Object { $_.Nickname -eq $name -or $_.FullProjectName -eq $name } | Select-Object -First 1
    }
    
    [Project] AddProject([string]$name) {
        # Check if already exists
        $existing = $this.GetProjectByName($name)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($name)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([string]$fullName, [string]$nickname) {
        # Check if already exists
        $existing = $this.GetProjectByName($nickname)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($fullName, $nickname)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([Project]$project) {
        # Check if already exists by nickname
        $existing = $this.GetProjectByName($project.Nickname)
        if ($existing) {
            return $existing
        }
        
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [void] UpdateProject([Project]$project) {
        $this.SaveProjects()
    }
    
    [void] DeleteProject([string]$id) {
        $project = $this.GetProject($id)
        if ($project -and $project.Nickname -ne "Default") {
            $this.Projects.Remove($project)
            $this.SaveProjects()
        }
    }
    
    [hashtable[]] GetProjectsWithStats([object]$taskService) {
        $result = @()
        
        foreach ($project in $this.Projects) {
            $tasks = $taskService.GetTasksByProject($project.Nickname)
            $completed = ($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $total = $tasks.Count
            
            $result += @{
                Project = $project
                Name = $project.Nickname  # Use nickname for compatibility
                FullName = $project.FullProjectName
                TaskCount = $total
                CompletedCount = $completed
                Progress = if ($total -gt 0) { $completed / $total } else { 0 }
            }
        }
        
        return $result
    }
}


####\Services/ShortcutManager.ps1
# ShortcutManager.ps1 - Centralized keyboard shortcut management service

enum ShortcutScope {
    Global      # Available everywhere
    Screen      # Available in specific screen types
    Context     # Available in specific contexts (e.g., when dialog is open)
}

class ShortcutDefinition {
    [string]$Id
    [string]$Name
    [string]$Description
    [System.ConsoleKey]$Key
    [System.ConsoleModifiers]$Modifiers
    [char]$KeyChar
    [ShortcutScope]$Scope
    [string]$ScreenType  # For Screen scope
    [string]$Context     # For Context scope
    [scriptblock]$Action
    [bool]$Enabled = $true
    [int]$Priority = 0   # Higher priority shortcuts are checked first
    
    ShortcutDefinition() {}
    
    [bool] Matches([System.ConsoleKeyInfo]$keyInfo) {
        # Check if this shortcut matches the pressed key
        if ($this.Key -ne [System.ConsoleKey]::None) {
            if ($keyInfo.Key -ne $this.Key) {
                return $false
            }
            if ($this.Modifiers -ne [System.ConsoleModifiers]::None) {
                if (($keyInfo.Modifiers -band $this.Modifiers) -ne $this.Modifiers) {
                    return $false
                }
            }
            return $true
        }
        elseif ($this.KeyChar -ne [char]0) {
            # Character-based shortcut
            return $keyInfo.KeyChar -eq $this.KeyChar
        }
        return $false
    }
    
    [string] GetDisplayText() {
        $parts = @()
        
        if ($this.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        if ($this.Key -ne [System.ConsoleKey]::None) {
            $parts += $this.Key.ToString()
        }
        elseif ($this.KeyChar -ne [char]0) {
            $parts += $this.KeyChar.ToString()
        }
        
        return $parts -join "+"
    }
}

class ShortcutManager {
    hidden [System.Collections.Generic.List[ShortcutDefinition]]$Shortcuts
    hidden [Logger]$Logger
    hidden [EventBus]$EventBus
    
    ShortcutManager() {
        $this.Shortcuts = [System.Collections.Generic.List[ShortcutDefinition]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService('Logger')
        $this.EventBus = $container.GetService('EventBus')
        
        # Register default global shortcuts
        $this.RegisterDefaultShortcuts()
    }
    
    [void] RegisterDefaultShortcuts() {
        # Global shortcuts
        $this.RegisterShortcut(@{
            Id = "global.quit"
            Name = "Quit Application"
            Description = "Exit the application"
            Key = [System.ConsoleKey]::Q
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Global
            Priority = 100
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.RequestExit()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette"
            Name = "Command Palette"
            Description = "Open the command palette"
            KeyChar = ':'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette_alt"
            Name = "Command Palette (Alt)"
            Description = "Open the command palette"
            KeyChar = '/'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
    }
    
    [void] RegisterShortcut([hashtable]$definition) {
        $shortcut = [ShortcutDefinition]::new()
        
        # Map hashtable properties to object
        foreach ($key in $definition.Keys) {
            if ($null -ne $shortcut.PSObject.Properties[$key]) {
                $shortcut.$key = $definition[$key]
            }
        }
        
        # Validate required properties
        if ([string]::IsNullOrEmpty($shortcut.Id)) {
            throw "Shortcut ID is required"
        }
        if (-not $shortcut.Action) {
            throw "Shortcut action is required"
        }
        
        # Remove existing shortcut with same ID
        $this.UnregisterShortcut($shortcut.Id)
        
        # Add new shortcut
        $this.Shortcuts.Add($shortcut)
        
        # Sort by priority (descending)
        $this.Shortcuts.Sort({ param($a, $b) $b.Priority.CompareTo($a.Priority) })
        
        if ($this.Logger) {
            $this.Logger.Debug("Registered shortcut: $($shortcut.Id) - $($shortcut.GetDisplayText())")
        }
    }
    
    [void] UnregisterShortcut([string]$id) {
        $existing = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($existing) {
            $this.Shortcuts.Remove($existing) | Out-Null
        }
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen, [string]$currentContext) {
        if ($this.Logger) {
            $this.Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' Screen=$currentScreen Context=$currentContext")
            $this.Logger.Debug("ShortcutManager: Total shortcuts registered: $($this.Shortcuts.Count)")
        }
        
        # Find matching shortcuts
        $candidates = $this.Shortcuts | Where-Object {
            $_.Enabled -and $_.Matches($keyInfo)
        }
        
        if ($this.Logger -and $candidates.Count -gt 0) {
            $this.Logger.Debug("ShortcutManager: Found $($candidates.Count) matching shortcuts")
        }
        
        # Filter by scope
        $applicable = @()
        foreach ($shortcut in $candidates) {
            if ($this.Logger) {
                $this.Logger.Debug("Checking shortcut: $($shortcut.Id) Scope=$($shortcut.Scope) ScreenType=$($shortcut.ScreenType)")
            }
            
            switch ($shortcut.Scope) {
                ([ShortcutScope]::Global) {
                    $applicable += $shortcut
                }
                ([ShortcutScope]::Screen) {
                    if ($shortcut.ScreenType -eq $currentScreen -or 
                        [string]::IsNullOrEmpty($shortcut.ScreenType)) {
                        if ($this.Logger) {
                            $this.Logger.Debug("Screen shortcut matches: $($shortcut.Id)")
                        }
                        $applicable += $shortcut
                    }
                }
                ([ShortcutScope]::Context) {
                    if ($shortcut.Context -eq $currentContext -or
                        [string]::IsNullOrEmpty($shortcut.Context)) {
                        $applicable += $shortcut
                    }
                }
            }
        }
        
        # Execute the highest priority applicable shortcut
        if ($applicable.Count -gt 0) {
            $shortcut = $applicable[0]  # Already sorted by priority
            
            if ($this.Logger) {
                $this.Logger.Debug("Executing shortcut: $($shortcut.Id)")
            }
            
            # Publish event before execution
            if ($this.EventBus) {
                $this.EventBus.Publish('shortcut.executing', @{
                    ShortcutId = $shortcut.Id
                    Key = $keyInfo
                })
            }
            
            try {
                # Execute the action
                & $shortcut.Action
                
                # Publish success event
                if ($this.EventBus) {
                    $this.EventBus.Publish('shortcut.executed', @{
                        ShortcutId = $shortcut.Id
                        Key = $keyInfo
                    })
                }
                
                return $true
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Error executing shortcut $($shortcut.Id): $_")
                }
                return $false
            }
        }
        
        return $false
    }
    
    [ShortcutDefinition[]] GetShortcuts([ShortcutScope]$scope, [string]$screenType) {
        return $this.Shortcuts | Where-Object {
            $_.Scope -eq $scope -and
            ($_.ScreenType -eq $screenType -or [string]::IsNullOrEmpty($_.ScreenType))
        }
    }
    
    [ShortcutDefinition[]] GetAllShortcuts() {
        return $this.Shortcuts
    }
    
    [hashtable] GetShortcutMap() {
        # Returns a hashtable for easy display in UI
        $map = @{}
        
        foreach ($shortcut in $this.Shortcuts) {
            $key = $shortcut.GetDisplayText()
            if (-not $map.ContainsKey($key)) {
                $map[$key] = @()
            }
            $map[$key] += @{
                Name = $shortcut.Name
                Description = $shortcut.Description
                Scope = $shortcut.Scope
                ScreenType = $shortcut.ScreenType
            }
        }
        
        return $map
    }
    
    [void] EnableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $true
        }
    }
    
    [void] DisableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $false
        }
    }
    
    [string] GetShortcutHelp([ShortcutScope]$scope = [ShortcutScope]::Global, [string]$screenType = "") {
        $sb = [System.Text.StringBuilder]::new()
        $shortcutList = $this.GetShortcuts($scope, $screenType)
        
        if ($shortcutList.Count -gt 0) {
            $grouped = $shortcutList | Group-Object { $_.GetDisplayText() }
            
            foreach ($group in $grouped | Sort-Object Name) {
                $sb.AppendLine("$($group.Name):")
                foreach ($shortcut in $group.Group) {
                    $sb.AppendLine("  - $($shortcut.Name): $($shortcut.Description)")
                }
            }
        }
        
        return $sb.ToString()
    }
}


####\Services/SimpleShortcutHandler.ps1
# SimpleShortcutHandler.ps1 - Direct keyboard shortcuts via EventBus

class SimpleShortcutHandler {
    hidden [EventBus]$EventBus
    hidden [Logger]$Logger
    
    [void] Initialize([ServiceContainer]$container) {
        $this.EventBus = $container.GetService('EventBus')
        $this.Logger = $container.GetService('Logger')
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen) {
        # Only handle character keys when no modifiers are pressed
        if ($keyInfo.Modifiers -ne [System.ConsoleModifiers]::None) {
            return $false
        }
        
        $char = [char]::ToLower($keyInfo.KeyChar)
        
        # Handle shortcuts based on current screen
        switch ($currentScreen) {
            "ProjectsScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewProject', 'ProjectsScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditProject', 'ProjectsScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteProject', 'ProjectsScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshProjects', 'ProjectsScreen')
                        return $true
                    }
                    'v' {
                        $this.PublishCommand('ViewProject', 'ProjectsScreen')
                        return $true
                    }
                }
            }
            "TaskScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewTask', 'TaskScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditTask', 'TaskScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteTask', 'TaskScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshTasks', 'TaskScreen')
                        return $true
                    }
                }
            }
        }
        
        return $false
    }
    
    hidden [void] PublishCommand([string]$command, [string]$target) {
        if ($this.Logger) {
            $this.Logger.Debug("SimpleShortcutHandler: Publishing command $command for $target")
        }
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::CommandExecuted, @{
                Command = $command
                Target = $target
            })
        }
    }
}


####\Services/StateManager.ps1
# StateManager.ps1 - Fast, robust, PowerShell-native state management
# Based on AxiomPhoenix patterns with PRAXIS optimizations

class StateManager {
    # Core state storage - PowerShell hashtables for maximum speed
    hidden [hashtable]$_state = @{}
    hidden [hashtable]$_subscribers = @{}
    hidden [hashtable]$_indexes = @{}
    
    # Performance optimization
    hidden [System.Collections.Generic.Dictionary[string, object]]$_fastIndex
    hidden [bool]$_isDirty = $false
    hidden [datetime]$_lastSave = [datetime]::MinValue
    
    # Transaction support
    hidden [int]$_transactionDepth = 0
    hidden [bool]$_pendingSave = $false
    hidden [hashtable]$_transactionChanges = @{}
    
    # Event integration
    [EventBus]$EventBus
    [Logger]$Logger
    
    # Configuration
    [string]$StatePath = ""
    [bool]$AutoSave = $true
    [int]$AutoSaveIntervalMs = 5000
    [int]$MaxBackups = 5
    [bool]$EnableCompression = $true
    
    # Performance metrics
    hidden [int]$_getOperations = 0
    hidden [int]$_setOperations = 0
    hidden [datetime]$_lastStatsReset = [datetime]::Now
    
    StateManager() {
        $this._fastIndex = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.InitializeDefaultState()
    }
    
    [void] Initialize([ServiceContainer]$services) {
        try {
            # Get required services
            $this.EventBus = $services.GetService("EventBus")
            $this.Logger = $services.GetService("Logger")
            
            # Set default state path
            if ([string]::IsNullOrEmpty($this.StatePath)) {
                $praxisRoot = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PWD }
                $this.StatePath = Join-Path $praxisRoot "_State/application.json"
            }
            
            # Ensure state directory exists
            $stateDir = Split-Path $this.StatePath -Parent
            if (-not (Test-Path $stateDir)) {
                New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
            }
            
            # Load existing state
            $this.LoadState()
            
            # Start auto-save if enabled
            if ($this.AutoSave) {
                $this.StartAutoSave()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager initialized: Path=$($this.StatePath), AutoSave=$($this.AutoSave)")
            }
            
        } catch {
            $this.LogError("StateManager initialization failed", @{ Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== CORE STATE OPERATIONS ====================
    
    # FAST: Direct hashtable access with error handling
    [object] GetState([string]$key) {
        return $this.GetState($key, $null)
    }
    
    [object] GetState([string]$key, [object]$defaultValue) {
        if ([string]::IsNullOrEmpty($key)) {
            return $defaultValue
        }
        
        try {
            $this._getOperations++
            
            # Try fast index first (Dictionary lookup - microseconds)
            if ($this._fastIndex.ContainsKey($key)) {
                return $this._fastIndex[$key]
            }
            
            # Fall back to dot-notation path traversal
            $keys = $key -split '\.'
            $current = $this._state
            
            foreach ($k in $keys) {
                if ($current -eq $null -or -not $current.ContainsKey($k)) {
                    return $defaultValue
                }
                $current = $current[$k]
            }
            
            # Cache in fast index for next time
            $this._fastIndex[$key] = $current
            
            return if ($current -eq $null) { $defaultValue } else { $current }
            
        } catch {
            $this.LogError("GetState failed", @{ Key = $key; Error = $_.Exception.Message })
            return $defaultValue
        }
    }
    
    # FAST: Direct state updates with smart change detection
    [void] SetState([string]$key, [object]$value) {
        $this.SetState($key, $value, $true)
    }
    
    [void] SetState([string]$key, [object]$value, [bool]$publishEvents) {
        if ([string]::IsNullOrEmpty($key)) {
            return
        }
        
        try {
            $this._setOperations++
            
            # Fast equality check to avoid unnecessary updates
            $currentValue = $this.GetState($key)
            if ($this.AreEqual($currentValue, $value)) {
                return  # No change, skip update
            }
            
            # Store old value for events
            $oldValue = $currentValue
            
            # Update both storage mechanisms
            $this.SetStateInternal($key, $value)
            $this._fastIndex[$key] = $value
            
            # Track transaction changes
            if ($this._transactionDepth -gt 0) {
                $this._transactionChanges[$key] = @{ 
                    NewValue = $value
                    OldValue = $oldValue 
                }
            }
            
            # Mark as dirty and trigger save
            $this.MarkDirty()
            
            # Publish change events
            if ($publishEvents -and $this.EventBus) {
                $this.PublishStateChange($key, $value, $oldValue)
            }
            
        } catch {
            $this.LogError("SetState failed", @{ Key = $key; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== TRANSACTION SUPPORT ====================
    
    [void] BeginTransaction() {
        $this._transactionDepth++
        if ($this._transactionDepth -eq 1) {
            $this._transactionChanges.Clear()
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Transaction started")
            }
        }
    }
    
    [void] EndTransaction() {
        if ($this._transactionDepth -gt 0) {
            $this._transactionDepth--
            
            # Process all changes when transaction completes
            if ($this._transactionDepth -eq 0) {
                try {
                    # Batch save
                    if ($this._pendingSave) {
                        $this.SaveState()
                        $this._pendingSave = $false
                    }
                    
                    # Batch event publishing
                    if ($this._transactionChanges.Count -gt 0 -and $this.EventBus) {
                        $this.EventBus.Publish("State.TransactionComplete", @{
                            Changes = $this._transactionChanges
                            ChangeCount = $this._transactionChanges.Count
                        })
                    }
                    
                    if ($this.Logger) {
                        $this.Logger.Debug("StateManager: Transaction completed with $($this._transactionChanges.Count) changes")
                    }
                    
                } catch {
                    $this.LogError("Transaction completion failed", @{ Error = $_.Exception.Message })
                    throw
                } finally {
                    $this._transactionChanges.Clear()
                }
            }
        }
    }
    
    [void] RollbackTransaction() {
        if ($this._transactionDepth -gt 0) {
            try {
                # Restore all changed values to their original state
                foreach ($change in $this._transactionChanges.GetEnumerator()) {
                    $key = $change.Key
                    $oldValue = $change.Value.OldValue
                    
                    # Directly restore without triggering events or new transaction tracking
                    $this.SetStateInternal($key, $oldValue)
                    $this._fastIndex[$key] = $oldValue
                }
                
                if ($this.Logger) {
                    $this.Logger.Debug("StateManager: Transaction rolled back, $($this._transactionChanges.Count) changes reverted")
                }
                
            } catch {
                $this.LogError("Transaction rollback failed", @{ Error = $_.Exception.Message })
                throw
            } finally {
                $this._transactionChanges.Clear()
                $this._transactionDepth = 0
                $this._pendingSave = $false
            }
        }
    }
    
    # ==================== PERSISTENCE ====================
    
    [void] LoadState() {
        if (-not (Test-Path $this.StatePath)) {
            if ($this.Logger) {
                $this.Logger.Info("StateManager: No existing state file, using defaults")
            }
            return
        }
        
        try {
            $json = Get-Content $this.StatePath -Raw -ErrorAction Stop
            if ([string]::IsNullOrEmpty($json)) {
                return
            }
            
            $data = $json | ConvertFrom-Json -AsHashtable -ErrorAction Stop
            if ($data -and $data.ContainsKey("State")) {
                $this._state = $data.State
                $this.RebuildFastIndex()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager: State loaded successfully from $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to load state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            
            # Try to load from backup
            $this.LoadFromBackup()
        }
    }
    
    [void] SaveState() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Create backup before save
            $this.CreateBackup()
            
            # Prepare data for serialization
            $data = @{
                State = $this._state
                Metadata = @{
                    Version = "1.0.0"
                    SavedAt = [datetime]::Now.ToString('o')
                    StateKeys = @($this._state.Keys)
                    FastIndexKeys = @($this._fastIndex.Keys) 
                    Stats = @{
                        GetOperations = $this._getOperations
                        SetOperations = $this._setOperations
                    }
                }
            }
            
            # Convert to JSON with compression option
            $jsonParams = @{
                Depth = 10
                Compress = $this.EnableCompression
            }
            $json = $data | ConvertTo-Json @jsonParams
            
            # Atomic write (write to temp file, then replace)
            $tempPath = "$($this.StatePath).tmp"
            [System.IO.File]::WriteAllText($tempPath, $json, [System.Text.Encoding]::UTF8)
            Move-Item $tempPath $this.StatePath -Force
            
            # Update tracking
            $this._isDirty = $false
            $this._lastSave = [datetime]::Now
            
            # Publish save event
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Saved", @{
                    Path = $this.StatePath
                    StateKeyCount = $data.Metadata.StateKeys.Count
                    SaveTime = $this._lastSave
                })
            }
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: State saved to $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to save state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== PERFORMANCE OPTIMIZATIONS ====================
    
    [void] RebuildFastIndex() {
        try {
            $this._fastIndex.Clear()
            $this.BuildFastIndexRecursive("", $this._state)
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Fast index rebuilt with $($this._fastIndex.Count) entries")
            }
            
        } catch {
            $this.LogError("Fast index rebuild failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] BuildFastIndexRecursive([string]$prefix, [hashtable]$data) {
        foreach ($key in $data.Keys) {
            $fullKey = if ($prefix) { "$prefix.$key" } else { $key }
            $value = $data[$key]
            
            # Add to fast index
            $this._fastIndex[$fullKey] = $value
            
            # Recurse into nested hashtables
            if ($value -is [hashtable]) {
                $this.BuildFastIndexRecursive($fullKey, $value)
            }
        }
    }
    
    [bool] AreEqual([object]$a, [object]$b) {
        # Fast reference equality check first
        if ([object]::ReferenceEquals($a, $b)) {
            return $true
        }
        
        # Null checks
        if ($a -eq $null -or $b -eq $null) {
            return ($a -eq $null -and $b -eq $null)
        }
        
        # Use PowerShell's efficient comparison
        try {
            # For complex objects, try Equals method first
            if ($a.GetType().GetMethod("Equals", @([object]))) {
                return $a.Equals($b)
            }
            
            # Fall back to PowerShell comparison
            return $a -eq $b
            
        } catch {
            # If comparison fails, assume not equal
            return $false
        }
    }
    
    # ==================== EVENT SYSTEM ====================
    
    [void] OnStateChanged([string]$pattern, [scriptblock]$handler) {
        if ([string]::IsNullOrEmpty($pattern) -or $handler -eq $null) {
            return
        }
        
        try {
            if (-not $this._subscribers.ContainsKey($pattern)) {
                $this._subscribers[$pattern] = @()
            }
            
            $this._subscribers[$pattern] += $handler
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Subscriber added for pattern '$pattern'")
            }
            
        } catch {
            $this.LogError("Failed to add state subscriber", @{ Pattern = $pattern; Error = $_.Exception.Message })
        }
    }
    
    hidden [void] PublishStateChange([string]$key, [object]$newValue, [object]$oldValue) {
        if ($this._transactionDepth -gt 0) {
            return  # Don't publish during transactions
        }
        
        try {
            # Publish to EventBus
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Changed", @{
                    Key = $key
                    NewValue = $newValue
                    OldValue = $oldValue
                    Timestamp = [datetime]::Now
                })
            }
            
            # Publish to pattern subscribers
            foreach ($pattern in $this._subscribers.Keys) {
                if ($this.MatchesPattern($key, $pattern)) {
                    foreach ($handler in $this._subscribers[$pattern]) {
                        try {
                            & $handler @{
                                Key = $key
                                NewValue = $newValue
                                OldValue = $oldValue
                            }
                        } catch {
                            $this.LogError("State subscriber handler failed", @{ 
                                Pattern = $pattern
                                Key = $key
                                Error = $_.Exception.Message 
                            })
                        }
                    }
                }
            }
            
        } catch {
            $this.LogError("Failed to publish state change", @{ Key = $key; Error = $_.Exception.Message })
        }
    }
    
    [bool] MatchesPattern([string]$key, [string]$pattern) {
        # Simple wildcard pattern matching
        if ($pattern -eq "*") {
            return $true
        }
        
        if ($pattern.EndsWith("*")) {
            $prefix = $pattern.Substring(0, $pattern.Length - 1)
            return $key.StartsWith($prefix)
        }
        
        return $key -eq $pattern
    }
    
    # ==================== INTERNAL HELPERS ====================
    
    [void] InitializeDefaultState() {
        $this._state = @{
            app = @{
                version = "1.0.0"
                startTime = [datetime]::Now
                sessionId = [System.Guid]::NewGuid().ToString()
            }
            ui = @{
                currentScreen = ""
                selectedItems = @{}
                viewStates = @{}
            }
            data = @{
                projects = @{}
                tasks = @{}
                config = @{}
            }
        }
        
        $this.RebuildFastIndex()
    }
    
    hidden [void] SetStateInternal([string]$key, [object]$value) {
        $keys = $key -split '\.'
        $current = $this._state
        
        # Navigate to parent container
        for ($i = 0; $i -lt $keys.Count - 1; $i++) {
            $k = $keys[$i]
            if (-not $current.ContainsKey($k)) {
                $current[$k] = @{}
            }
            $current = $current[$k]
        }
        
        # Set the final value
        $finalKey = $keys[-1]
        $current[$finalKey] = $value
    }
    
    [void] MarkDirty() {
        $this._isDirty = $true
        
        if ($this._transactionDepth -gt 0) {
            $this._pendingSave = $true
        } elseif ($this.AutoSave) {
            # Immediate save for non-transaction updates
            $this.SaveState()
        }
    }
    
    hidden [void] CreateBackup() {
        if (-not (Test-Path $this.StatePath)) {
            return
        }
        
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
            }
            
            $timestamp = [datetime]::Now.ToString("yyyyMMdd_HHmmss")
            $backupPath = Join-Path $backupDir "application_$timestamp.json"
            
            Copy-Item $this.StatePath $backupPath
            
            # Clean old backups
            $this.CleanOldBackups($backupDir)
            
        } catch {
            $this.LogError("Backup creation failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] CleanOldBackups([string]$backupDir) {
        try {
            $backups = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending
            
            if ($backups.Count -gt $this.MaxBackups) {
                $toDelete = $backups | Select-Object -Skip $this.MaxBackups
                foreach ($file in $toDelete) {
                    Remove-Item $file.FullName -Force
                }
            }
            
        } catch {
            $this.LogError("Backup cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] LoadFromBackup() {
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                return
            }
            
            $latestBackup = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending | Select-Object -First 1
            
            if ($latestBackup) {
                $json = Get-Content $latestBackup.FullName -Raw
                $data = $json | ConvertFrom-Json -AsHashtable
                
                if ($data -and $data.ContainsKey("State")) {
                    $this._state = $data.State
                    $this.RebuildFastIndex()
                    
                    if ($this.Logger) {
                        $this.Logger.Info("StateManager: Recovered from backup: $($latestBackup.Name)")
                    }
                }
            }
            
        } catch {
            $this.LogError("Backup recovery failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] StartAutoSave() {
        # Note: PowerShell doesn't have great built-in timer support
        # This could be enhanced with System.Timers.Timer if needed
        # For now, auto-save happens on each SetState call
    }
    
    hidden [void] LogError([string]$message, [hashtable]$context = @{}) {
        if ($this.Logger) {
            $this.Logger.Error("$message - Context: $($context | ConvertTo-Json -Compress)")
        }
    }
    
    # ==================== PUBLIC API METHODS ====================
    
    [hashtable] GetPerformanceStats() {
        $uptime = [datetime]::Now - $this._lastStatsReset
        
        return @{
            GetOperations = $this._getOperations
            SetOperations = $this._setOperations
            FastIndexSize = $this._fastIndex.Count
            StateKeyCount = $this._state.Keys.Count
            TransactionDepth = $this._transactionDepth
            IsDirty = $this._isDirty
            LastSave = $this._lastSave
            Uptime = $uptime.ToString()
            OperationsPerSecond = if ($uptime.TotalSeconds -gt 0) { ($this._getOperations + $this._setOperations) / $uptime.TotalSeconds } else { 0 }
        }
    }
    
    [void] ResetPerformanceStats() {
        $this._getOperations = 0
        $this._setOperations = 0
        $this._lastStatsReset = [datetime]::Now
    }
    
    [void] ClearState() {
        $this.BeginTransaction()
        try {
            $this._state.Clear()
            $this._fastIndex.Clear()
            $this.InitializeDefaultState()
            
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Cleared", @{ Timestamp = [datetime]::Now })
            }
            
        } finally {
            $this.EndTransaction()
        }
    }
    
    [void] Cleanup() {
        try {
            if ($this._isDirty) {
                $this.SaveState()
            }
            
            $this._subscribers.Clear()
            $this._fastIndex.Clear()
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager cleanup completed")
            }
            
        } catch {
            $this.LogError("Cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
}


####\Services/SubtaskService.ps1
# SubtaskService.ps1 - Service for managing subtasks

class SubtaskService {
    [System.Collections.Generic.List[Subtask]]$Subtasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    SubtaskService() {
        $this.Subtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "subtasks.json"
        
        # Load existing subtasks
        $this.Load()
    }
    
    # CRUD Operations
    [Subtask] AddSubtask([string]$parentTaskId, [string]$title) {
        $subtask = [Subtask]::new($parentTaskId)
        $subtask.Title = $title
        
        # Set sort order to be last among siblings
        $siblings = $this.GetSubtasksForTask($parentTaskId)
        if ($siblings.Count -gt 0) {
            $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
            $subtask.SortOrder = $maxOrder + 1
        } else {
            $subtask.SortOrder = 0
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] CreateSubtask([hashtable]$properties) {
        $subtask = [Subtask]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($key -eq 'Progress') {
                # Use UpdateProgress to auto-handle status changes
                $subtask.UpdateProgress($properties[$key])
            } elseif ($subtask.PSObject.Properties.Name -contains $key) {
                $subtask.$key = $properties[$key]
            }
        }
        
        # Ensure sort order is set
        if (-not $properties.ContainsKey('SortOrder')) {
            $siblings = $this.GetSubtasksForTask($subtask.ParentTaskId)
            if ($siblings.Count -gt 0) {
                $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
                $subtask.SortOrder = $maxOrder + 1
            } else {
                $subtask.SortOrder = 0
            }
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] GetSubtask([string]$id) {
        return $this.Subtasks | Where-Object { $_.Id -eq $id -and -not $_.Deleted } | Select-Object -First 1
    }
    
    [System.Collections.Generic.List[Subtask]] GetSubtasksForTask([string]$parentTaskId) {
        $taskSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if ($subtask.ParentTaskId -eq $parentTaskId -and -not $subtask.Deleted) {
                $taskSubtasks.Add($subtask)
            }
        }
        
        # Sort by SortOrder
        return $taskSubtasks | Sort-Object SortOrder
    }
    
    [System.Collections.Generic.List[Subtask]] GetAllSubtasks() {
        $activeSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if (-not $subtask.Deleted) {
                $activeSubtasks.Add($subtask)
            }
        }
        
        return $activeSubtasks
    }
    
    [void] UpdateSubtask([Subtask]$subtask) {
        $existingSubtask = $this.GetSubtask($subtask.Id)
        if ($existingSubtask) {
            $existingSubtask.Title = $subtask.Title
            $existingSubtask.Description = $subtask.Description
            $existingSubtask.Status = $subtask.Status
            $existingSubtask.Priority = $subtask.Priority
            $existingSubtask.UpdateProgress($subtask.Progress)  # Use UpdateProgress to auto-handle status
            $existingSubtask.DueDate = $subtask.DueDate
            $existingSubtask.Tags = $subtask.Tags
            $existingSubtask.EstimatedMinutes = $subtask.EstimatedMinutes
            $existingSubtask.ActualMinutes = $subtask.ActualMinutes
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] DeleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Deleted = $true
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] CompleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Status = [TaskStatus]::Completed
            $subtask.Progress = 100
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] ReorderSubtasks([string]$parentTaskId, [string[]]$subtaskIds) {
        $sortOrder = 0
        foreach ($subtaskId in $subtaskIds) {
            $subtask = $this.GetSubtask($subtaskId)
            if ($subtask -and $subtask.ParentTaskId -eq $parentTaskId) {
                $subtask.SortOrder = $sortOrder
                $subtask.UpdatedAt = Get-Date
                $sortOrder++
            }
        }
        $this._isDirty = $true
        $this.Save()
    }
    
    # Calculate parent task progress based on subtask completion
    [int] CalculateTaskProgress([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        if ($taskSubtasks.Count -eq 0) {
            return 0
        }
        
        $totalProgress = 0
        foreach ($subtask in $taskSubtasks) {
            $totalProgress += $subtask.Progress
        }
        
        return [Math]::Floor($totalProgress / $taskSubtasks.Count)
    }
    
    [hashtable] GetTaskStatistics([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        $stats = @{
            Total = $taskSubtasks.Count
            Completed = 0
            InProgress = 0
            Pending = 0
            Overdue = 0
            EstimatedMinutes = 0
            ActualMinutes = 0
        }
        
        foreach ($subtask in $taskSubtasks) {
            switch ($subtask.Status) {
                ([TaskStatus]::Completed) { $stats.Completed++ }
                ([TaskStatus]::InProgress) { $stats.InProgress++ }
                ([TaskStatus]::Pending) { $stats.Pending++ }
            }
            
            if ($subtask.IsOverdue()) {
                $stats.Overdue++
            }
            
            $stats.EstimatedMinutes += $subtask.EstimatedMinutes
            $stats.ActualMinutes += $subtask.ActualMinutes
        }
        
        return $stats
    }
    
    # Data persistence
    [void] Save() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Convert to serializable format
            $data = @()
            foreach ($subtask in $this.Subtasks) {
                $data += @{
                    Id = $subtask.Id
                    ParentTaskId = $subtask.ParentTaskId
                    Title = $subtask.Title
                    Description = $subtask.Description
                    Status = [int]$subtask.Status
                    Priority = [int]$subtask.Priority
                    Progress = $subtask.Progress
                    SortOrder = $subtask.SortOrder
                    Tags = $subtask.Tags
                    DueDate = if ($subtask.DueDate -eq [DateTime]::MinValue) { "" } else { $subtask.DueDate.ToString("yyyy-MM-ddTHH:mm:ss") }
                    CreatedAt = $subtask.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    UpdatedAt = $subtask.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    EstimatedMinutes = $subtask.EstimatedMinutes
                    ActualMinutes = $subtask.ActualMinutes
                    Deleted = $subtask.Deleted
                }
            }
            
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to save subtasks: $($_.Exception.Message)"
        }
    }
    
    [void] Load() {
        if (-not (Test-Path $this.DataPath)) {
            return
        }
        
        try {
            $json = Get-Content -Path $this.DataPath -Raw -Encoding UTF8
            $data = $json | ConvertFrom-Json
            
            $this.Subtasks.Clear()
            
            foreach ($item in $data) {
                $subtask = [Subtask]::new()
                $subtask.Id = $item.Id
                $subtask.ParentTaskId = $item.ParentTaskId
                $subtask.Title = $item.Title
                $subtask.Description = $item.Description
                $subtask.Status = [TaskStatus]$item.Status
                $subtask.Priority = [TaskPriority]$item.Priority
                $subtask.Progress = $item.Progress
                $subtask.SortOrder = $item.SortOrder
                $subtask.Tags = $item.Tags
                $subtask.DueDate = if ([string]::IsNullOrEmpty($item.DueDate)) { [DateTime]::MinValue } else { [DateTime]::Parse($item.DueDate) }
                $subtask.CreatedAt = [DateTime]::Parse($item.CreatedAt)
                $subtask.UpdatedAt = [DateTime]::Parse($item.UpdatedAt)
                $subtask.EstimatedMinutes = if ($item.PSObject.Properties.Name -contains 'EstimatedMinutes') { $item.EstimatedMinutes } else { 0 }
                $subtask.ActualMinutes = if ($item.PSObject.Properties.Name -contains 'ActualMinutes') { $item.ActualMinutes } else { 0 }
                $subtask.Deleted = if ($item.PSObject.Properties.Name -contains 'Deleted') { $item.Deleted } else { $false }
                
                $this.Subtasks.Add($subtask)
            }
            
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to load subtasks: $($_.Exception.Message)"
        }
    }
}


####\Services/TaskService.ps1
# TaskService.ps1 - Service for managing tasks

class TaskService {
    [System.Collections.Generic.List[Task]]$Tasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    TaskService() {
        $this.Tasks = [System.Collections.Generic.List[Task]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "tasks.json"
        
        # Load existing tasks
        $this.Load()
    }
    
    # CRUD Operations
    [Task] AddTask([string]$title, [string]$projectId) {
        $task = [Task]::new()
        $task.Title = $title
        $task.ProjectId = $projectId
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] CreateTask([hashtable]$properties) {
        $task = [Task]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($task.PSObject.Properties.Name -contains $key) {
                $task.$key = $properties[$key]
            }
        }
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] GetTask([string]$id) {
        return $this.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Task[]] GetAllTasks() {
        return $this.Tasks.ToArray()
    }
    
    [Task[]] GetTasksByProject([string]$projectId) {
        return $this.Tasks | Where-Object { $_.ProjectId -eq $projectId -and -not $_.Deleted }
    }
    
    [Task[]] GetActiveTasks() {
        return $this.Tasks | Where-Object { 
            -not $_.Deleted -and 
            $_.Status -ne [TaskStatus]::Completed -and 
            $_.Status -ne [TaskStatus]::Cancelled 
        }
    }
    
    [void] UpdateTask([Task]$task) {
        $task.MarkAsUpdated()  # Use BaseModel method
        $this._isDirty = $true
        $this.Save()
    }
    
    [void] DeleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.SoftDelete()  # Use BaseModel method
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Status management
    [void] UpdateTaskStatus([string]$id, [TaskStatus]$status) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.Status = $status
            $task.MarkAsUpdated()  # Use BaseModel method
            
            # Auto-update progress
            if ($status -eq [TaskStatus]::Completed) {
                $task.Progress = 100
            } elseif ($status -eq [TaskStatus]::Pending) {
                $task.Progress = 0
            }
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Priority management
    [void] CyclePriority([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            switch ($task.Priority) {
                ([TaskPriority]::Low) { $task.Priority = [TaskPriority]::Medium }
                ([TaskPriority]::Medium) { $task.Priority = [TaskPriority]::High }
                ([TaskPriority]::High) { $task.Priority = [TaskPriority]::Low }
            }
            $task.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Persistence
    [void] Save() {
        if (-not $this._isDirty) { return }
        
        try {
            $json = $this.Tasks | ConvertTo-Json -Depth 10
            $json | Set-Content -Path $this.DataPath -Encoding UTF8
            $this._isDirty = $false
            
            if ($global:Logger) {
                $global:Logger.Debug("TaskService: Saved $($this.Tasks.Count) tasks")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TaskService: Failed to save tasks: $_")
            }
        }
    }
    
    [void] Load() {
        if (Test-Path $this.DataPath) {
            try {
                $json = Get-Content -Path $this.DataPath -Raw
                $data = $json | ConvertFrom-Json
                
                $this.Tasks.Clear()
                foreach ($item in $data) {
                    $task = [Task]::new()
                    
                    # Map properties
                    $task.Id = $item.Id
                    $task.Title = $item.Title
                    $task.Description = $item.Description
                    $task.Status = [TaskStatus]$item.Status
                    $task.Priority = [TaskPriority]$item.Priority
                    $task.Progress = $item.Progress
                    $task.ProjectId = $item.ProjectId
                    $task.Tags = $item.Tags
                    $task.DueDate = if ($item.DueDate) { [DateTime]$item.DueDate } else { [DateTime]::MinValue }
                    $task.CreatedAt = [DateTime]$item.CreatedAt
                    $task.UpdatedAt = [DateTime]$item.UpdatedAt
                    $task.Deleted = $item.Deleted
                    
                    $this.Tasks.Add($task)
                }
                
                if ($global:Logger) {
                    $global:Logger.Debug("TaskService: Loaded $($this.Tasks.Count) tasks")
                }
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("TaskService: Failed to load tasks: $_")
                }
                # Start with empty list on error
                $this.Tasks.Clear()
            }
        } else {
            # Create sample tasks for testing
            $this.CreateSampleTasks()
        }
    }
    
    hidden [void] CreateSampleTasks() {
        # Create a few sample tasks
        $task1 = $this.AddTask("Implement user authentication", "")
        $task1.Description = "Add login/logout functionality with session management"
        $task1.Priority = [TaskPriority]::High
        $task1.Status = [TaskStatus]::InProgress
        $task1.Progress = 45
        
        $task2 = $this.AddTask("Write API documentation", "")
        $task2.Description = "Document all REST endpoints with examples"
        $task2.Priority = [TaskPriority]::Medium
        $task2.DueDate = (Get-Date).AddDays(7)
        
        $task3 = $this.AddTask("Fix navigation bug", "")
        $task3.Description = "Users report navigation not working after login"
        $task3.Priority = [TaskPriority]::High
        $task3.Status = [TaskStatus]::Completed
        $task3.Progress = 100
        
        $this.Save()
    }
}


####\Services/ThemeManager.ps1
# ThemeManager.ps1 - Fast theme management with pre-cached ANSI sequences
# All colors are pre-computed to avoid runtime lookups

class ThemeManager {
    hidden [hashtable]$_themes = @{}
    hidden [string]$_currentTheme = "default"
    hidden [hashtable]$_cache = @{}
    hidden [System.Collections.Generic.List[scriptblock]]$_listeners
    hidden [EventBus]$EventBus
    
    ThemeManager() {
        $this._listeners = [System.Collections.Generic.List[scriptblock]]::new()
        $this.InitializeDefaultTheme()
        
        # EventBus will be set later via SetEventBus
    }
    
    [void] InitializeDefaultTheme() {
        # Define default theme with RGB values
        $defaultTheme = @{
            # Base colors
            "background" = @(24, 24, 24)        # Dark background
            "foreground" = @(204, 204, 204)     # Light gray text
            "accent" = @(0, 150, 255)           # Blue accent
            "success" = @(0, 200, 83)           # Green
            "warning" = @(255, 195, 0)          # Yellow
            "error" = @(255, 85, 85)            # Red
            
            # UI elements
            "border" = @(68, 68, 68)           # Dark gray
            "border.focused" = @(0, 150, 255)   # Blue
            "selection" = @(60, 60, 60)         # Selection background
            "disabled" = @(128, 128, 128)       # Gray
            
            # Focus system colors
            "focus" = @(0, 150, 255)            # Minimalist focus color
            "focus.background" = @(40, 40, 40)  # Subtle focus background
            "focus.accent" = @(0, 200, 255)     # Brighter focus accent
            
            # Generic component colors (for backward compatibility)
            "title" = @(0, 150, 255)              # Blue titles
            "normal" = @(204, 204, 204)           # Normal text
            "selected" = @(60, 60, 60)            # Alias for selection
            
            # Component specific
            "button.background" = @(48, 48, 48)
            "button.foreground" = @(204, 204, 204)
            "button.focused.background" = @(0, 150, 255)
            "button.focused.foreground" = @(255, 255, 255)
            
            "input.background" = @(32, 32, 32)
            "input.foreground" = @(204, 204, 204)
            "input.focused.border" = @(0, 150, 255)
            
            "menu.background" = @(32, 32, 32)
            "menu.foreground" = @(204, 204, 204)
            "menu.selected.background" = @(0, 150, 255)
            "menu.selected.foreground" = @(255, 255, 255)
            
            "tab.background" = @(48, 48, 48)
            "tab.foreground" = @(170, 170, 170)
            "tab.active.background" = @(24, 24, 24)
            "tab.active.foreground" = @(255, 255, 255)
            "tab.active.accent" = @(0, 150, 255)
            
            # DataGrid specific colors
            "header.background" = @(48, 48, 48)
            "header.foreground" = @(0, 150, 255)
            "scrollbar" = @(68, 68, 68)
            "scrollbar.thumb" = @(128, 128, 128)
            
            # Additional component colors
            "checkbox" = @(0, 150, 255)
            "checkbox.selected" = @(0, 200, 255)
            "search" = @(255, 195, 0)
            "highlight" = @(255, 255, 0)
            "directory" = @(0, 150, 255)
            "file" = @(204, 204, 204)
            "input.border" = @(68, 68, 68)
            "input.placeholder" = @(128, 128, 128)
            "progress.active" = @(0, 150, 255)
            "progress.complete" = @(0, 200, 83)
            "progress.text" = @(204, 204, 204)
        }
        
        $this.RegisterTheme("default", $defaultTheme)
        
        # Define matrix theme - black background with green text
        $matrixTheme = @{
            # Base colors
            "background" = @(0, 0, 0)             # Pure black background
            "foreground" = @(0, 255, 0)           # Bright green text
            "accent" = @(0, 200, 0)               # Darker green accent
            "success" = @(0, 255, 0)              # Bright green
            "warning" = @(255, 255, 0)            # Yellow
            "error" = @(255, 0, 0)                # Red
            
            # UI elements
            "border" = @(0, 100, 0)               # Dark green borders
            "border.focused" = @(0, 255, 0)       # Bright green when focused
            "selection" = @(0, 100, 0)            # Dark green selection - more visible
            "disabled" = @(0, 128, 0)             # Medium green for disabled
            
            # Focus system colors
            "focus" = @(0, 255, 0)                # Matrix green focus
            "focus.background" = @(0, 40, 0)      # Subtle green focus background
            "focus.accent" = @(100, 255, 100)     # Brighter green accent
            
            # Generic component colors (for backward compatibility)
            "title" = @(0, 255, 0)                # Bright green for titles
            "normal" = @(0, 200, 0)               # Normal text (slightly dimmer green)
            "selected" = @(0, 100, 0)             # Alias for selection
            
            # Component specific
            "button.background" = @(0, 20, 0)
            "button.foreground" = @(0, 255, 0)
            "button.focused.background" = @(0, 100, 0)
            "button.focused.foreground" = @(0, 255, 0)
            
            "input.background" = @(0, 10, 0)
            "input.foreground" = @(0, 255, 0)
            "input.focused.border" = @(0, 255, 0)
            
            "menu.background" = @(0, 0, 0)
            "menu.foreground" = @(0, 200, 0)
            "menu.selected.background" = @(0, 80, 0)
            "menu.selected.foreground" = @(0, 255, 0)
            
            "tab.background" = @(0, 30, 0)
            "tab.foreground" = @(0, 150, 0)
            "tab.active.background" = @(0, 0, 0)
            "tab.active.foreground" = @(0, 255, 0)
            "tab.active.accent" = @(0, 255, 0)
            
            # DataGrid specific colors
            "header.background" = @(0, 30, 0)
            "header.foreground" = @(0, 255, 0)
            "scrollbar" = @(0, 100, 0)
            "scrollbar.thumb" = @(0, 150, 0)
            
            # Additional component colors
            "checkbox" = @(0, 255, 0)
            "checkbox.selected" = @(0, 255, 100)
            "search" = @(255, 255, 0)
            "highlight" = @(255, 255, 0)
            "directory" = @(0, 255, 0)
            "file" = @(0, 200, 0)
            "input.border" = @(0, 100, 0)
            "input.placeholder" = @(0, 128, 0)
            "progress.active" = @(0, 255, 0)
            "progress.complete" = @(0, 255, 0)
            "progress.text" = @(0, 200, 0)
            
            # Dialog colors
            "dialog.background" = @(0, 0, 0)
            "dialog.border" = @(0, 150, 0)
            "dialog.title" = @(0, 255, 0)
        }
        
        $this.RegisterTheme("matrix", $matrixTheme)
        $this.SetTheme("matrix")
    }
    
    # Register a new theme
    [void] RegisterTheme([string]$name, [hashtable]$colors) {
        $this._themes[$name] = $colors
        
        # If this is the current theme, rebuild cache
        if ($name -eq $this._currentTheme) {
            $this.RebuildCache()
        }
    }
    
    # Switch to a different theme
    [void] SetTheme([string]$name) {
        if (-not $this._themes.ContainsKey($name)) {
            throw "Theme '$name' not found"
        }
        
        $oldTheme = $this._currentTheme
        $this._currentTheme = $name
        $this.RebuildCache()
        
        # Notify via EventBus if available
        if ($this.EventBus) {
            $this.EventBus.Publish('app.themeChanged', @{
                OldTheme = $oldTheme
                NewTheme = $name
                ThemeManager = $this
            })
        }
        
        # Also notify legacy listeners for backward compatibility
        $this.NotifyListeners()
    }
    
    # Get pre-computed ANSI color sequence
    [string] GetColor([string]$key) {
        if ($this._cache.ContainsKey($key)) {
            return $this._cache[$key]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$key] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get background color sequence
    [string] GetBgColor([string]$key) {
        $bgKey = "$key.bg"
        if ($this._cache.ContainsKey($bgKey)) {
            return $this._cache[$bgKey]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$bgKey] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get raw RGB values
    [int[]] GetRGB([string]$key) {
        $theme = $this._themes[$this._currentTheme]
        
        if ($theme.ContainsKey($key)) {
            return $theme[$key]
        }
        
        # Try parent keys (e.g., "button" for "button.focused.background")
        $parts = $key -split '\.'
        for ($i = $parts.Count - 1; $i -gt 0; $i--) {
            $parentKey = $parts[0..($i-1)] -join '.'
            if ($theme.ContainsKey($parentKey)) {
                return $theme[$parentKey]
            }
        }
        
        return $null
    }
    
    # Rebuild the entire cache
    hidden [void] RebuildCache() {
        $this._cache.Clear()
        $theme = $this._themes[$this._currentTheme]
        
        # Pre-compute all theme colors
        foreach ($key in $theme.Keys) {
            $rgb = $theme[$key]
            if ($rgb -is [array] -and $rgb.Count -eq 3) {
                # Foreground
                $this._cache[$key] = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
                # Background
                $this._cache["$key.bg"] = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            }
        }
        
        # Add common combinations
        $this._cache["reset"] = [VT]::Reset()
        $this._cache["clear"] = [VT]::Clear()
        $this._cache["clearline"] = [VT]::ClearLine()
    }
    
    # Subscribe to theme changes (legacy method - use EventBus instead)
    [void] Subscribe([scriptblock]$callback) {
        # Always use legacy listeners for now to avoid initialization order issues
        # EventBus subscription happens too early
        $this._listeners.Add($callback)
    }
    
    # Notify all listeners of theme change (legacy method)
    hidden [void] NotifyListeners() {
        # Only notify legacy listeners if EventBus is not available
        if (-not $this.EventBus) {
            foreach ($listener in $this._listeners) {
                try {
                    & $listener
                } catch {
                    # Ignore listener errors
                }
            }
        }
    }
    
    # Set EventBus after initialization (called by ServiceContainer)
    [void] SetEventBus([EventBus]$eventBus) {
        $this.EventBus = $eventBus
    }
    
    # Get list of available themes
    [string[]] GetThemeNames() {
        return $this._themes.Keys | Sort-Object
    }
    
    # Get current theme name
    [string] GetCurrentTheme() {
        return $this._currentTheme
    }
}


####\Services/TimeTrackingService.ps1
# TimeTrackingService - Manages all time entries and calculations

class TimeTrackingService {
    [string]$DataPath
    [System.Collections.ArrayList]$TimeEntries
    [System.Collections.ArrayList]$TimeCodes
    [Logger]$Logger
    [EventBus]$EventBus
    [ProjectService]$ProjectService
    
    TimeTrackingService() {
        $this.TimeEntries = [System.Collections.ArrayList]::new()
        $this.TimeCodes = [System.Collections.ArrayList]::new()
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/timeentries.json"
        $this.LoadData()
        $this.InitializeCommonTimeCodes()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService("Logger")
        $this.EventBus = $container.GetService("EventBus")
        $this.ProjectService = $container.GetService("ProjectService")
    }
    
    [void] InitializeCommonTimeCodes() {
        # Add common codes if not already present
        $commonCodes = [TimeCode]::GetCommonCodes()
        foreach ($code in $commonCodes) {
            if (-not ($this.TimeCodes | Where-Object { $_.ID2 -eq $code.ID2 })) {
                $this.TimeCodes.Add($code) | Out-Null
            }
        }
    }
    
    [void] LoadData() {
        if (Test-Path $this.DataPath) {
            try {
                $data = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                
                # Load time entries
                if ($data.TimeEntries) {
                    foreach ($entry in $data.TimeEntries) {
                        $timeEntry = [TimeEntry]::new()
                        foreach ($prop in $entry.PSObject.Properties) {
                            if ($timeEntry.PSObject.Properties[$prop.Name]) {
                                $timeEntry.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeEntries.Add($timeEntry) | Out-Null
                    }
                }
                
                # Load time codes
                if ($data.TimeCodes) {
                    foreach ($code in $data.TimeCodes) {
                        $timeCode = [TimeCode]::new()
                        foreach ($prop in $code.PSObject.Properties) {
                            if ($timeCode.PSObject.Properties[$prop.Name]) {
                                $timeCode.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeCodes.Add($timeCode) | Out-Null
                    }
                }
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to load time tracking data: $_")
                }
            }
        }
    }
    
    [void] SaveData() {
        $data = @{
            TimeEntries = $this.TimeEntries
            TimeCodes = $this.TimeCodes
            LastUpdated = [DateTime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        }
        
        try {
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Time tracking data saved")
            }
        }
        catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save time tracking data: $_")
            }
        }
    }
    
    # Get or create time entry for a specific week and ID2
    [TimeEntry] GetOrCreateTimeEntry([string]$weekEndingFriday, [string]$id2) {
        $existing = $this.TimeEntries | Where-Object { 
            $_.WeekEndingFriday -eq $weekEndingFriday -and $_.ID2 -eq $id2 
        } | Select-Object -First 1
        
        if ($existing) {
            return $existing
        }
        
        # Create new entry
        $entry = [TimeEntry]::new($weekEndingFriday, $id2)
        
        # If it's a project ID2, populate project info
        if ($id2.Length -gt 5) {
            $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
            if ($project) {
                $entry.Name = $project.Nickname
                $entry.ID1 = $project.ID1
            }
        }
        
        $this.TimeEntries.Add($entry) | Out-Null
        return $entry
    }
    
    # Get entries for a specific week
    [TimeEntry[]] GetWeekEntries([string]$weekEndingFriday) {
        return $this.TimeEntries | Where-Object { $_.WeekEndingFriday -eq $weekEndingFriday }
    }
    
    # Get entries for current week
    [TimeEntry[]] GetCurrentWeekEntries() {
        $friday = $this.GetCurrentWeekFriday()
        return $this.GetWeekEntries($friday.ToString("yyyyMMdd"))
    }
    
    # Update time entry
    [void] UpdateTimeEntry([TimeEntry]$entry) {
        $entry.CalculateTotal()
        $entry.CalculateFiscalYear()
        $entry.UpdatedAt = [DateTime]::Now
        
        $this.SaveData()
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TimeEntryUpdated, $this, @{ TimeEntry = $entry })
        }
    }
    
    # Add hours for today
    [void] AddHoursForToday([string]$id2, [decimal]$hours, [string]$description = "") {
        $today = [DateTime]::Now
        $friday = $this.GetWeekFridayForDate($today)
        
        $entry = $this.GetOrCreateTimeEntry($friday.ToString("yyyyMMdd"), $id2)
        
        # Add hours to appropriate day
        switch ($today.DayOfWeek) {
            Monday { $entry.Monday += $hours }
            Tuesday { $entry.Tuesday += $hours }
            Wednesday { $entry.Wednesday += $hours }
            Thursday { $entry.Thursday += $hours }
            Friday { $entry.Friday += $hours }
            default {
                if ($this.Logger) {
                    $this.Logger.Warning("Cannot add time for weekend day")
                }
                return
            }
        }
        
        $this.UpdateTimeEntry($entry)
    }
    
    # Get Friday date for current week
    [DateTime] GetCurrentWeekFriday() {
        $today = [DateTime]::Now
        return $this.GetWeekFridayForDate($today)
    }
    
    # Get Friday date for any date's week
    [DateTime] GetWeekFridayForDate([DateTime]$date) {
        $friday = $date
        while ($friday.DayOfWeek -ne [DayOfWeek]::Friday) {
            if ($friday.DayOfWeek -eq [DayOfWeek]::Saturday) {
                $friday = $friday.AddDays(-1)
            } else {
                $friday = $friday.AddDays(1)
            }
        }
        return $friday
    }
    
    # Calculate total hours for a project
    [decimal] GetProjectTotalHours([string]$id2) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { $_.ID2 -eq $id2 }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Calculate fiscal year total for non-project code
    [decimal] GetFiscalYearTotal([string]$id2, [string]$fiscalYear) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { 
            $_.ID2 -eq $id2 -and $_.FiscalYear -eq $fiscalYear 
        }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Get current fiscal year string
    [string] GetCurrentFiscalYear() {
        $today = [DateTime]::Now
        if ($today.Month -ge 4) {
            return "$($today.Year)-$($today.Year + 1)"
        } else {
            return "$($today.Year - 1)-$($today.Year)"
        }
    }
    
    # Get all unique ID2s (both project and non-project)
    [string[]] GetAllID2s() {
        $id2s = @()
        
        # Add project ID2s
        $projects = $this.ProjectService.GetAllProjects() | Where-Object { -not $_.Deleted -and $_.ID2 }
        foreach ($project in $projects) {
            $id2s += $project.ID2
        }
        
        # Add time code ID2s
        foreach ($code in $this.TimeCodes) {
            if ($code.IsActive) {
                $id2s += $code.ID2
            }
        }
        
        return $id2s | Select-Object -Unique | Sort-Object
    }
    
    # Get display info for an ID2
    [hashtable] GetID2DisplayInfo([string]$id2) {
        # Check if it's a project
        $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($project) {
            return @{
                Name = $project.Nickname
                ID1 = $project.ID1
                ID2 = $id2
                IsProject = $true
            }
        }
        
        # It's a non-project code
        $timeCode = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        return @{
            Name = ""
            ID1 = ""
            ID2 = $id2
            IsProject = $false
            Description = if ($timeCode) { $timeCode.Description } else { "" }
        }
    }
    
    # Add or update time code
    [void] AddTimeCode([string]$id2, [string]$description = "") {
        $existing = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($existing) {
            $existing.Description = $description
            $existing.UpdatedAt = [DateTime]::Now
        } else {
            $code = [TimeCode]::new($id2, $description)
            $this.TimeCodes.Add($code) | Out-Null
        }
        $this.SaveData()
    }
}


####\Services/ToastService.ps1
# ToastService.ps1 - Minimal toast notification system

enum ToastType {
    Info = 0
    Success = 1
    Warning = 2
    Error = 3
}

class Toast {
    [string]$Message
    [ToastType]$Type
    [DateTime]$CreatedAt
    [int]$Duration  # Milliseconds
    [double]$Progress  # 0.0 to 1.0 for fade animation
    [bool]$IsExpired
    
    Toast([string]$message, [ToastType]$type, [int]$duration) {
        $this.Message = $message
        $this.Type = $type
        $this.Duration = $duration
        $this.CreatedAt = [DateTime]::Now
        $this.Progress = 0.0
        $this.IsExpired = $false
    }
    
    [void] Update() {
        $elapsed = ([DateTime]::Now - $this.CreatedAt).TotalMilliseconds
        $this.Progress = [Math]::Min(1.0, $elapsed / $this.Duration)
        
        if ($elapsed -ge $this.Duration) {
            $this.IsExpired = $true
        }
    }
    
    [double] GetOpacity() {
        # Fade in for first 10%, solid for 80%, fade out for last 10%
        if ($this.Progress -lt 0.1) {
            return $this.Progress * 10
        } elseif ($this.Progress -gt 0.9) {
            return (1.0 - $this.Progress) * 10
        }
        return 1.0
    }
}

class ToastService {
    hidden [System.Collections.Generic.Queue[Toast]]$_toasts
    hidden [int]$MaxToasts = 5
    hidden [int]$DefaultDuration = 3000  # 3 seconds
    hidden [ThemeManager]$Theme
    hidden [EventBus]$EventBus
    hidden [System.Timers.Timer]$UpdateTimer
    
    # Toast position
    [string]$Position = "TopRight"  # TopLeft, TopRight, BottomLeft, BottomRight
    [int]$MarginX = 2
    [int]$MarginY = 1
    [int]$Spacing = 1
    [int]$MaxWidth = 40
    
    ToastService() {
        $this._toasts = [System.Collections.Generic.Queue[Toast]]::new()
        
        # Update timer for animations
        $this.UpdateTimer = [System.Timers.Timer]::new(50)  # 20 FPS
        $this.UpdateTimer.AutoReset = $true
        
        # Add event handler
        Register-ObjectEvent -InputObject $this.UpdateTimer -EventName Elapsed -Action {
            $Event.MessageData.UpdateToasts()
        } -MessageData $this | Out-Null
        
        $this.UpdateTimer.Start()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Theme = $container.GetService('ThemeManager')
        $this.EventBus = $container.GetService('EventBus')
        
        # Subscribe to events that might trigger toasts
        if ($this.EventBus) {
            $this.EventBus.Subscribe('project.created', {
                param($sender, $data)
                $this.ShowSuccess("Project created successfully")
            }.GetNewClosure())
            
            $this.EventBus.Subscribe('task.completed', {
                param($sender, $data)
                $this.ShowSuccess("Task completed")
            }.GetNewClosure())
            
            $this.EventBus.Subscribe('error', {
                param($sender, $data)
                if ($data.Message) {
                    $this.ShowError($data.Message)
                }
            }.GetNewClosure())
        }
    }
    
    [void] UpdateToasts() {
        $changed = $false
        
        # Update all toasts
        foreach ($toast in $this._toasts) {
            $toast.Update()
            if ($toast.IsExpired) {
                $changed = $true
            }
        }
        
        # Remove expired toasts
        while ($this._toasts.Count -gt 0 -and $this._toasts.Peek().IsExpired) {
            [void]$this._toasts.Dequeue()
            $changed = $true
        }
        
        # Trigger re-render if changed
        if ($changed -and $this.EventBus) {
            $this.EventBus.Publish('toast.changed', $this, @{})
        }
    }
    
    [void] Show([string]$message, [ToastType]$type = [ToastType]::Info, [int]$duration = 0) {
        if ($duration -eq 0) {
            $duration = $this.DefaultDuration
        }
        
        $toast = [Toast]::new($message, $type, $duration)
        $this._toasts.Enqueue($toast)
        
        # Limit number of toasts
        while ($this._toasts.Count -gt $this.MaxToasts) {
            [void]$this._toasts.Dequeue()
        }
        
        # Trigger render
        if ($this.EventBus) {
            $this.EventBus.Publish('toast.changed', $this, @{})
        }
    }
    
    [void] ShowInfo([string]$message) {
        $this.Show($message, [ToastType]::Info)
    }
    
    [void] ShowSuccess([string]$message) {
        $this.Show($message, [ToastType]::Success)
    }
    
    [void] ShowWarning([string]$message) {
        $this.Show($message, [ToastType]::Warning)
    }
    
    [void] ShowError([string]$message) {
        $this.Show($message, [ToastType]::Error)
    }
    
    [string] Render([int]$screenWidth, [int]$screenHeight) {
        if ($this._toasts.Count -eq 0) { return "" }
        
        $sb = Get-PooledStringBuilder 2048
        
        # Calculate base position
        $baseX = switch -Wildcard ($this.Position) {
            "*Left" { $this.MarginX }
            "*Right" { $screenWidth - $this.MaxWidth - $this.MarginX }
        }
        
        $baseY = switch -Wildcard ($this.Position) {
            "Top*" { $this.MarginY }
            "Bottom*" { $screenHeight - ($this._toasts.Count * 3) - $this.MarginY }
        }
        
        # Render each toast
        $y = $baseY
        foreach ($toast in $this._toasts) {
            $this.RenderToast($sb, $toast, $baseX, $y)
            $y += 3 + $this.Spacing
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] RenderToast([System.Text.StringBuilder]$sb, [Toast]$toast, [int]$x, [int]$y) {
        if (-not $this.Theme) { return }
        
        # Get colors based on type
        $colors = switch ($toast.Type) {
            ([ToastType]::Success) { @{
                bg = $this.Theme.GetBgColor('success')
                fg = [VT]::RGB(255, 255, 255)
                icon = ""
            }}
            ([ToastType]::Warning) { @{
                bg = $this.Theme.GetBgColor('warning')
                fg = [VT]::RGB(0, 0, 0)
                icon = "!"
            }}
            ([ToastType]::Error) { @{
                bg = $this.Theme.GetBgColor('error')
                fg = [VT]::RGB(255, 255, 255)
                icon = ""
            }}
            default { @{
                bg = $this.Theme.GetBgColor('accent')
                fg = [VT]::RGB(255, 255, 255)
                icon = "i"
            }}
        }
        
        # Apply opacity for fade effect
        $opacity = $toast.GetOpacity()
        if ($opacity -lt 1.0) {
            # Simple fade by dimming
            if ($opacity -lt 0.5) {
                $sb.Append([VT]::Dim())
            }
        }
        
        # Truncate message if needed
        $message = $toast.Message
        $maxMessageLength = $this.MaxWidth - 6  # Account for icon and padding
        if ($message.Length -gt $maxMessageLength) {
            $message = $message.Substring(0, $maxMessageLength - 1) + ""
        }
        
        # Render toast box
        $width = [Math]::Min($this.MaxWidth, $message.Length + 6)
        
        # Top border
        $sb.Append([VT]::MoveTo($x, $y))
        $sb.Append($colors.bg)
        $sb.Append($colors.fg)
        $sb.Append("" + ("" * ($width - 4)) + "")
        
        # Content line
        $sb.Append([VT]::MoveTo($x, $y + 1))
        $sb.Append(" ")
        $sb.Append($colors.icon)
        $sb.Append("  ")
        $sb.Append($message.PadRight($width - 6))
        $sb.Append(" ")
        
        # Bottom border
        $sb.Append([VT]::MoveTo($x, $y + 2))
        $sb.Append("" + ("" * ($width - 4)) + "")
        
        $sb.Append([VT]::Reset())
    }
    
    [void] Clear() {
        $this._toasts.Clear()
        if ($this.EventBus) {
            $this.EventBus.Publish('toast.changed', $this, @{})
        }
    }
}

# Toast overlay component for screens
class ToastOverlay : UIElement {
    hidden [ToastService]$ToastService
    
    [void] OnInitialize() {
        $this.ToastService = $this.ServiceContainer.GetService('ToastService')
        
        # Subscribe to toast changes
        $eventBus = $this.ServiceContainer.GetService('EventBus')
        if ($eventBus -and $this.ToastService) {
            $eventBus.Subscribe('toast.changed', {
                $this.Invalidate()
            }.GetNewClosure())
        }
    }
    
    [string] OnRender() {
        if (-not $this.ToastService) { return "" }
        
        # Get screen dimensions from parent
        $width = $this.Width
        $height = $this.Height
        if ($this.Parent) {
            $width = $this.Parent.Width
            $height = $this.Parent.Height
        }
        
        return $this.ToastService.Render($width, $height)
    }
}


####\apply-final-fixes.ps1
#!/usr/bin/env pwsh
# Apply final fixes for shortcuts and focus

Write-Host "Applying final fixes..." -ForegroundColor Cyan

# 1. Clean up debug output from ScreenManager
Write-Host "  Cleaning up ScreenManager..." -ForegroundColor Yellow
$content = Get-Content "Core/ScreenManager.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n', ''
$content | Set-Content "Core/ScreenManager.ps1" -Force

# 2. Clean up debug output from ShortcutManager  
Write-Host "  Cleaning up ShortcutManager..." -ForegroundColor Yellow
$content = Get-Content "Services/ShortcutManager.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Services/ShortcutManager.ps1" -Force

# 3. Clean up debug output from screens
Write-Host "  Cleaning up ProjectsScreen..." -ForegroundColor Yellow
$content = Get-Content "Screens/ProjectsScreen.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Screens/ProjectsScreen.ps1" -Force

Write-Host "  Cleaning up TaskScreen..." -ForegroundColor Yellow
$content = Get-Content "Screens/TaskScreen.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Screens/TaskScreen.ps1" -Force

Write-Host "`nFixes applied!" -ForegroundColor Green
Write-Host @"

The following issues have been fixed:

1. SHORTCUTS: Fixed case-sensitive matching bug
   - Shortcuts now work with both uppercase and lowercase keys
   - 'e' and 'E' both trigger edit, 'd' and 'D' both trigger delete

2. FOCUS: Fixed focus initialization on all screens
   - Each screen now properly sets initial focus when activated
   - Tab navigation works across all screens

3. CTRL+ARROWS: Added tab navigation shortcuts
   - Ctrl+Right Arrow = Tab (next focus)
   - Ctrl+Left Arrow = Shift+Tab (previous focus)

To test:
- Run: pwsh -File Start.ps1
- Navigate to any screen (1-6)
- Try shortcuts: n=new, e=edit, d=delete
- Try Ctrl+Arrows for navigation

"@ -ForegroundColor Cyan


####\check-syntax.ps1
#!/usr/bin/env pwsh

# Check syntax of TimeEntryScreen
try {
    $null = [System.Management.Automation.Language.Parser]::ParseFile(
        "$PSScriptRoot/Screens/TimeEntryScreen.ps1",
        [ref]$null,
        [ref]$null
    )
    Write-Host "TimeEntryScreen.ps1 syntax is valid" -ForegroundColor Green
} catch {
    Write-Host "Syntax error in TimeEntryScreen.ps1: $_" -ForegroundColor Red
}


####\debug-vmf-init.ps1
#!/usr/bin/env pwsh

# Debug VisualMacroFactoryScreen initialization using the proper load order from Start.ps1
param([switch]$LoadOnly)

# Load order from Start.ps1
$loadOrder = @(
    "Core/StringCache.ps1"
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Core/StringBuilderPool.ps1"
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    "Base/BaseModel.ps1"
    "Services/ShortcutManager.ps1"
    "Models/Command.ps1"
    "Models/BaseAction.ps1"
    "Actions/CustomIdeaCommandAction.ps1"
    "Actions/SummarizationAction.ps1"
    "Actions/AppendFieldAction.ps1"
    "Actions/ExportToExcelAction.ps1"
    "Services/CommandService.ps1"
    "Services/FunctionRegistry.ps1"
    "Services/MacroContextManager.ps1"
    "Components/ListBox.ps1"
    "Components/SearchableListBox.ps1"
    "Components/DataGrid.ps1"
    "Screens/VisualMacroFactoryScreen.ps1"
)

Write-Host "Loading components for VisualMacroFactoryScreen test..." -ForegroundColor Cyan

foreach ($file in $loadOrder) {
    $path = Join-Path $PSScriptRoot $file
    if (Test-Path $path) {
        try {
            . $path
            Write-Host "   $file" -ForegroundColor Green
        } catch {
            Write-Host "   $file - $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "   $file - File not found" -ForegroundColor Red
        exit 1
    }
}

Write-Host "`nInitializing services..." -ForegroundColor Cyan

# Set global variables that services need
$global:PraxisRoot = $PSScriptRoot

# Initialize global ServiceContainer
$global:ServiceContainer = [ServiceContainer]::new()

# Create services in proper order
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)

$commandService = [CommandService]::new()
$global:ServiceContainer.Register("CommandService", $commandService)

Write-Host "`nTesting VisualMacroFactoryScreen..." -ForegroundColor Green

try {
    Write-Host "Creating VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen = [VisualMacroFactoryScreen]::new()
    Write-Host " Constructor completed" -ForegroundColor Green
    
    Write-Host "Available Actions before init: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    Write-Host "Calling Initialize..." -ForegroundColor Yellow
    $screen.Initialize($global:ServiceContainer)
    Write-Host " Initialize completed" -ForegroundColor Green
    
    Write-Host "Available Actions after init: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    if ($screen.AvailableActions.Count -gt 0) {
        Write-Host " Actions loaded successfully:" -ForegroundColor Green
        foreach ($action in $screen.AvailableActions) {
            Write-Host "  - $($action.Name) [$($action.GetType().Name)]" -ForegroundColor DarkGray
        }
    } else {
        Write-Host " No actions loaded - investigating LoadAvailableActions..." -ForegroundColor Red
        
        # Test action creation manually
        Write-Host "Testing manual action creation:" -ForegroundColor Yellow
        try {
            $testAction = [SummarizationAction]::new()
            Write-Host "   SummarizationAction: $($testAction.Name)" -ForegroundColor Green
        } catch {
            Write-Host "   SummarizationAction failed: $_" -ForegroundColor Red
        }
    }
    
    # Check if shortcuts were registered
    Write-Host "Checking shortcut registration..." -ForegroundColor Yellow
    $shortcuts = $shortcutManager.GetShortcuts([ShortcutScope]::Screen, "VisualMacroFactoryScreen")
    Write-Host "Registered shortcuts: $($shortcuts.Count)" -ForegroundColor Cyan
    foreach ($shortcut in $shortcuts) {
        Write-Host "  - $($shortcut.Id): $($shortcut.GetDisplayText())" -ForegroundColor DarkGray
    }
    
} catch {
    Write-Host " Test failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Cyan


####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}



####\force-test-tab7.ps1
#!/usr/bin/env pwsh

# Force test tab 7 by directly creating and testing the screen
Write-Host "Testing VisualMacroFactoryScreen directly..." -ForegroundColor Cyan

# Load full framework
. "$PSScriptRoot/Start.ps1" -LoadOnly 2>/dev/null

# Create and initialize the screen directly
try {
    Write-Host "Creating VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen = [VisualMacroFactoryScreen]::new()
    
    Write-Host "Initializing screen..." -ForegroundColor Yellow  
    $screen.Initialize($global:ServiceContainer)
    
    Write-Host "Screen created successfully" -ForegroundColor Green
    Write-Host "  ComponentLibrary exists: $($null -ne $screen.ComponentLibrary)" -ForegroundColor Cyan
    Write-Host "  MacroSequence exists: $($null -ne $screen.MacroSequence)" -ForegroundColor Cyan
    Write-Host "  ContextPanel exists: $($null -ne $screen.ContextPanel)" -ForegroundColor Cyan
    Write-Host "  AvailableActions count: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    if ($screen.ComponentLibrary) {
        Write-Host "  ComponentLibrary Items count: $($screen.ComponentLibrary.Items.Count)" -ForegroundColor Cyan
        Write-Host "  ComponentLibrary _filteredItems count: $($screen.ComponentLibrary._filteredItems.Count)" -ForegroundColor Cyan
    }
    
    # Test bounds
    Write-Host "Setting test bounds..." -ForegroundColor Yellow
    $screen.SetBounds(0, 0, 120, 30)
    Write-Host "  Screen bounds: $($screen.X),$($screen.Y) - $($screen.Width)x$($screen.Height)" -ForegroundColor Cyan
    
    if ($screen.ComponentLibrary) {
        Write-Host "  ComponentLibrary bounds: $($screen.ComponentLibrary.X),$($screen.ComponentLibrary.Y) - $($screen.ComponentLibrary.Width)x$($screen.ComponentLibrary.Height)" -ForegroundColor Cyan
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "Test completed!" -ForegroundColor Green


####\RUN_THIS_TEST.ps1
#!/usr/bin/env pwsh
Write-Host @"

SHORTCUT AND FOCUS TEST INSTRUCTIONS
====================================

The debug output has been added to help diagnose the issues.

When you run Start.ps1, you will see:
- [REG] messages when shortcuts are registered
- [UNREG] messages when shortcuts are unregistered  
- [DEBUG] messages for each key press
- [SM] messages from ShortcutManager processing
- [MATCH] messages when checking if shortcuts match
- Screen activation messages

To test:
1. Run: pwsh -File Start.ps1
2. Press 1 to go to Projects screen
3. Press 'e' - watch for debug output
4. Press 2 to go to Tasks screen  
5. Press 'e' again

The debug output will show exactly what's happening with shortcuts.

"@ -ForegroundColor Yellow


####\simple-action-test.ps1
#!/usr/bin/env pwsh

# Simple action creation test without starting PRAXIS
param([switch]$LoadOnly)

# Load framework components without starting UI
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"

# Services
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"

# Base classes
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Base/BaseModel.ps1"

# Models
. "$PSScriptRoot/Models/BaseAction.ps1"

# Actions
. "$PSScriptRoot/Actions/CustomIdeaCommandAction.ps1"
. "$PSScriptRoot/Actions/SummarizationAction.ps1"
. "$PSScriptRoot/Actions/AppendFieldAction.ps1"
. "$PSScriptRoot/Actions/ExportToExcelAction.ps1"

Write-Host "Testing Action class creation..." -ForegroundColor Green

try {
    Write-Host "Testing BaseAction..." -ForegroundColor Yellow
    $baseAction = [BaseAction]::new()
    Write-Host " BaseAction created successfully" -ForegroundColor Green
} catch {
    Write-Host " BaseAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing SummarizationAction..." -ForegroundColor Yellow
    $summarizationAction = [SummarizationAction]::new()
    Write-Host " SummarizationAction created successfully: $($summarizationAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " SummarizationAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing AppendFieldAction..." -ForegroundColor Yellow
    $appendFieldAction = [AppendFieldAction]::new()
    Write-Host " AppendFieldAction created successfully: $($appendFieldAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " AppendFieldAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing ExportToExcelAction..." -ForegroundColor Yellow
    $exportAction = [ExportToExcelAction]::new()
    Write-Host " ExportToExcelAction created successfully: $($exportAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " ExportToExcelAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing CustomIdeaCommandAction..." -ForegroundColor Yellow
    $customAction = [CustomIdeaCommandAction]::new()
    Write-Host " CustomIdeaCommandAction created successfully: $($customAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " CustomIdeaCommandAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

Write-Host "`nAction creation test completed!" -ForegroundColor Cyan


####\Start.ps1
#!/usr/bin/env pwsh
# PRAXIS - Performance-focused TUI Framework
# Entry point and bootstrapper

param(
    [switch]$Debug,
    [switch]$Performance,
    [string]$Theme = "default",
    [switch]$LoadOnly
)

# Enable debug output if requested
if ($Debug) {
    $global:PraxisDebug = $true
}

# Ensure we're in the right directory
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Ensure data directory exists
$dataDir = Join-Path $script:PraxisRoot "_ProjectData"
if (-not (Test-Path $dataDir)) {
    New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
}

# Load order is critical for class inheritance
$loadOrder = @(
    # Core modules first
    "Core/StringCache.ps1"
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Core/StringBuilderPool.ps1"
    "Core/GapBuffer.ps1"
    "Core/DocumentBuffer.ps1"
    "Core/GapBufferDocumentBuffer.ps1"
    "Core/EditorCommands.ps1"
    
    # Services (needed by base classes)
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    
    # Base classes
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/FocusableComponent.ps1"
    "Base/Screen.ps1"
    "Base/BaseModel.ps1"
    
    # Core UI systems (needed by components)
    "Core/BorderStyle.ps1"
    "Core/KeyboardShortcuts.ps1"
    "Core/AnimationHelper.ps1"
    
    # Services that depend on base classes
    "Services/FocusManager.ps1"
    "Services/ShortcutManager.ps1"
    
    # Models
    "Models/Project.ps1"
    "Models/Task.ps1"
    "Models/Subtask.ps1"
    "Models/TimeEntry.ps1"
    "Models/TimeCode.ps1"
    "Models/Command.ps1"
    "Models/BaseAction.ps1"
    
    # Actions (after BaseAction)
    "Actions/CustomIdeaCommandAction.ps1"
    "Actions/SummarizationAction.ps1"
    "Actions/AppendFieldAction.ps1"
    "Actions/ExportToExcelAction.ps1"
    
    # Services
    "Services/ToastService.ps1"
    "Services/ProjectService.ps1"
    "Services/TaskService.ps1"
    "Services/SubtaskService.ps1"
    "Services/TimeTrackingService.ps1"
    "Services/CommandService.ps1"
    "Services/ConfigurationService.ps1"
    "Services/StateManager.ps1"
    "Services/FunctionRegistry.ps1"
    "Services/MacroContextManager.ps1"
    
    # Components
    "Components/ListBox.ps1"
    "Components/TextBox.ps1"
    "Components/Button.ps1"
    "Components/MinimalButton.ps1"
    "Components/MinimalListBox.ps1"
    "Components/MinimalTextBox.ps1"
    "Components/MinimalDataGrid.ps1"
    "Components/MinimalStatusBar.ps1"
    "Components/MinimalModal.ps1"
    "Components/MinimalContextMenu.ps1"
    "Components/DataGrid.ps1"
    "Components/ProgressBar.ps1"
    "Components/FastFileTree.ps1"
    "Components/RangerFileTree.ps1"
    "Components/SearchableListBox.ps1"
    "Components/MultiSelectListBox.ps1"
    "Components/TabContainer.ps1"
    "Components/MinimalTabContainer.ps1"
    
    # Layout Components (NEW!)
    "Components/HorizontalSplit.ps1"
    "Components/VerticalSplit.ps1"
    "Components/GridPanel.ps1"
    "Components/DockPanel.ps1"
    
    # BaseDialog (after components are loaded)
    "Base/BaseDialog.ps1"
    
    # Dialogs (must be loaded before screens that use them)
    "Screens/FilePickerDialog.ps1",
    "Screens/TextInputDialog.ps1",
    "Screens/NumberInputDialog.ps1",
    "Screens/ConfirmationDialog.ps1",
    "Screens/NewProjectDialog.ps1",
    "Screens/EditProjectDialog.ps1",
    "Screens/NewTaskDialog.ps1",
    "Screens/EditTaskDialog.ps1",
    "Screens/SubtaskDialog.ps1",
    "Screens/TimeEntryDialog.ps1",
    "Screens/QuickTimeEntryDialog.ps1",
    "Screens/CommandEditDialog.ps1",
    "Screens/FindReplaceDialog.ps1",
    "Screens/EventBusMonitor.ps1",
    
    # Screens (after dialogs they depend on)
    "Screens/TestScreen.ps1",
    "Screens/ProjectDetailScreen.ps1",
    "Screens/ProjectsScreen.ps1",
    "Screens/TaskScreen.ps1",
    "Screens/DashboardScreen.ps1",
    "Screens/SettingsScreen.ps1",
    "Screens/FileBrowserScreen.ps1",
    "Screens/TextEditorScreenNew.ps1",
    "Screens/TimeEntryScreen.ps1",
    "Screens/CommandLibraryScreen.ps1",
    "Screens/VisualMacroFactoryScreen.ps1",
    "Screens/MinimalShowcaseScreen.ps1",
    "Screens/LayoutExamplesScreen.ps1",
    "Screens/KeyboardHelpOverlay.ps1",
    
    # Core systems (after KeyboardHelpOverlay)
    "Core/ScreenManager.ps1",
    
    # CommandPalette (after screens it references)
    "Components/CommandPalette.ps1",
    
    # Main screen
    "Screens/MainScreen.ps1"
)

# Load all modules
Write-Host "Loading PRAXIS framework..." -ForegroundColor Cyan
foreach ($file in $loadOrder) {
    $path = Join-Path $script:PraxisRoot $file
    if (Test-Path $path) {
        try {
            . $path
            if ($Debug) {
                Write-Host "   $file" -ForegroundColor Green
            }
        } catch {
            Write-Host "   $file - $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "   $file - File not found" -ForegroundColor Red
        exit 1
    }
}

# Initialize services
Write-Host "Initializing services..." -ForegroundColor Cyan

# Logger (first so other services can use it)
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
if ($Debug) {
    Write-Host "  Logger created at: $($logger.LogPath)" -ForegroundColor DarkGray
}

# Theme manager
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# EventBus (after Logger and ThemeManager, before other services)
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# ShortcutManager
$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)
if ($Debug) {
    Write-Host "  EventBus initialized" -ForegroundColor DarkGray
}

# Connect ThemeManager to EventBus
$themeManager.SetEventBus($eventBus)

# FocusManager - Fast O(1) focus management
$focusManager = [FocusManager]::new()
$focusManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("FocusManager", $focusManager)
if ($Debug) {
    Write-Host "  FocusManager initialized" -ForegroundColor DarkGray
}

# KeyboardShortcutManager - Standardized keyboard shortcuts
$keyboardShortcutManager = [KeyboardShortcutManager]::new()
$keyboardShortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("KeyboardShortcutManager", $keyboardShortcutManager)
if ($Debug) {
    Write-Host "  KeyboardShortcutManager initialized" -ForegroundColor DarkGray
}

# AnimationManager - Smooth animations
$animationManager = [AnimationManager]::new()
$animationManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("AnimationManager", $animationManager)
if ($Debug) {
    Write-Host "  AnimationManager initialized" -ForegroundColor DarkGray
}

# ToastService - Notification system
$toastService = [ToastService]::new()
$toastService.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ToastService", $toastService)
if ($Debug) {
    Write-Host "  ToastService initialized" -ForegroundColor DarkGray
}

# Project service
$projectService = [ProjectService]::new()
$global:ServiceContainer.Register("ProjectService", $projectService)

# Task service
$taskService = [TaskService]::new()
$global:ServiceContainer.Register("TaskService", $taskService)

# Subtask service
$subtaskService = [SubtaskService]::new()
$global:ServiceContainer.Register("SubtaskService", $subtaskService)
# Time tracking service
$timeTrackingService = [TimeTrackingService]::new()
$global:ServiceContainer.Register("TimeTrackingService", $timeTrackingService)

# Command service
$commandService = [CommandService]::new()
$global:ServiceContainer.Register("CommandService", $commandService)

# Configuration service
$configService = [ConfigurationService]::new()
$global:ServiceContainer.Register("ConfigurationService", $configService)

# Apply theme from configuration
$currentTheme = $configService.Get("Theme.CurrentTheme", "matrix")
if ($themeManager._themes.ContainsKey($currentTheme)) {
    $themeManager.SetTheme($currentTheme)
} else {
    # Fallback to matrix theme if configured theme doesn't exist
    $themeManager.SetTheme("matrix")
}

# State manager - high-performance centralized state
$stateManager = [StateManager]::new()
$stateManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("StateManager", $stateManager)

# Screen manager
$screenManager = [ScreenManager]::new($global:ServiceContainer)
$global:ScreenManager = $screenManager
$global:ServiceContainer.Register("ScreenManager", $screenManager)

# Create main screen with tabs
Write-Host "Creating main interface..." -ForegroundColor Cyan

# Create and run main screen
if ($Debug) { Write-Host "  Creating MainScreen..." -ForegroundColor DarkGray }
$mainScreen = [MainScreen]::new()

if ($Debug) { Write-Host "  Pushing to ScreenManager..." -ForegroundColor DarkGray }
$screenManager.Push($mainScreen)

if ($Debug) { Write-Host "  Main screen initialized" -ForegroundColor DarkGray }

# Exit early if LoadOnly is requested
if ($LoadOnly) {
    Write-Host "Framework loaded successfully (LoadOnly mode)" -ForegroundColor Green
    return
}

Write-Host "Starting PRAXIS..." -ForegroundColor Green
Write-Host "   Press 1-6 to switch tabs (Projects, Tasks, Dashboard, Files, Editor, Settings)" -ForegroundColor DarkGray
Write-Host "   Press Ctrl+Tab to cycle tabs" -ForegroundColor DarkGray
Write-Host "   Press / or : for command palette" -ForegroundColor DarkGray
Write-Host "   Press Q or Escape to quit" -ForegroundColor DarkGray
Write-Host ""

# Run the application
try {
    $global:Logger.Info("Starting PRAXIS main loop")
    $screenManager.Run()
} catch {
    if ($global:Logger) {
        if ($_.Exception) {
            $global:Logger.LogException($_.Exception, "Fatal error in main loop")
        } else {
            $global:Logger.Error("Fatal error in main loop: $_")
        }
    }
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    if ($global:Logger) {
        Write-Host "`nCheck log file at: $($global:Logger.LogPath)" -ForegroundColor Yellow
    }
} finally {
    # Cleanup
    $global:Logger.Info("Shutting down PRAXIS")
    $stateManager = $global:ServiceContainer.GetService("StateManager")
    if ($stateManager) {
        $stateManager.Cleanup()
    }
    $global:Logger.Cleanup()
    $global:ServiceContainer.Cleanup()
    Write-Host "`nPRAXIS terminated." -ForegroundColor Cyan
}


####\test-action-creation.ps1
#!/usr/bin/env pwsh

# Test action creation to see what's failing
. "$PSScriptRoot/Start.ps1" -LoadOnly

Write-Host "Testing Action class creation..." -ForegroundColor Green

try {
    Write-Host "Testing BaseAction..." -ForegroundColor Yellow
    $baseAction = [BaseAction]::new()
    Write-Host " BaseAction created successfully" -ForegroundColor Green
} catch {
    Write-Host " BaseAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing SummarizationAction..." -ForegroundColor Yellow
    $summarizationAction = [SummarizationAction]::new()
    Write-Host " SummarizationAction created successfully: $($summarizationAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " SummarizationAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing AppendFieldAction..." -ForegroundColor Yellow
    $appendFieldAction = [AppendFieldAction]::new()
    Write-Host " AppendFieldAction created successfully: $($appendFieldAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " AppendFieldAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing ExportToExcelAction..." -ForegroundColor Yellow
    $exportAction = [ExportToExcelAction]::new()
    Write-Host " ExportToExcelAction created successfully: $($exportAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " ExportToExcelAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing CustomIdeaCommandAction..." -ForegroundColor Yellow
    $customAction = [CustomIdeaCommandAction]::new()
    Write-Host " CustomIdeaCommandAction created successfully: $($customAction.Name)" -ForegroundColor Green
} catch {
    Write-Host " CustomIdeaCommandAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

Write-Host "`nAction creation test completed!" -ForegroundColor Cyan


####\test-button-debug.ps1
#!/usr/bin/env pwsh

# Test CommandEditDialog button with detailed debugging
Write-Host "Starting PRAXIS for button debugging..." -ForegroundColor Cyan
Write-Host "Navigate to Commands tab, press 'n' to create new command" -ForegroundColor Green
Write-Host "Try clicking the OK button to see detailed error logs" -ForegroundColor Green
Write-Host "Press Ctrl+Q to exit when done" -ForegroundColor Yellow

# Clear log file to see only current session
if (Test-Path "$PSScriptRoot/_Logs/praxis.log") {
    Clear-Content "$PSScriptRoot/_Logs/praxis.log"
}

# Run the application
& "$PSScriptRoot/Start.ps1"

# Show logs after exit
Write-Host "`n=== LOGS ===" -ForegroundColor Cyan
Get-Content "$PSScriptRoot/_Logs/praxis.log" | Select-Object -Last 20


####\test-button-handlers.ps1
#!/usr/bin/env pwsh

# Test CommandEditDialog button handlers specifically
Write-Host "Testing CommandEditDialog button handlers..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    $dialog.Initialize($global:ServiceContainer)
    $dialog.SetBounds(0, 0, 120, 40)
    $dialog.SetCommand($null)  # New command
    
    # Set some test data
    $dialog.CommandBox.Text = "echo 'test command'"
    $dialog.TitleBox.Text = "Test Command"
    
    Write-Host "Testing HandlePrimaryAction (Save button)..." -ForegroundColor Yellow
    try {
        $dialog.HandlePrimaryAction()
        Write-Host "   HandlePrimaryAction executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   HandlePrimaryAction failed: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "    Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
    }
    
    Write-Host "Testing HandleSecondaryAction (Cancel button)..." -ForegroundColor Yellow
    try {
        $dialog.HandleSecondaryAction()
        Write-Host "   HandleSecondaryAction executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   HandleSecondaryAction failed: $($_.Exception.Message)" -ForegroundColor Red
        Write-Host "    Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
    }
    
    Write-Host "Testing button OnClick handlers directly..." -ForegroundColor Yellow
    if ($dialog.PrimaryButton -and $dialog.PrimaryButton.OnClick) {
        try {
            & $dialog.PrimaryButton.OnClick
            Write-Host "   Primary button OnClick executed successfully" -ForegroundColor Green
        } catch {
            Write-Host "   Primary button OnClick failed: $($_.Exception.Message)" -ForegroundColor Red
        }
    } else {
        Write-Host "  - Primary button or OnClick not found" -ForegroundColor Yellow
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-class-loading.ps1
#!/usr/bin/env pwsh

# Test if dialog classes are properly loaded
Write-Host "Testing class loading..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

Write-Host "`nChecking if classes exist..." -ForegroundColor Yellow

# Test BaseDialog
try {
    $test = [BaseDialog] -as [type]
    if ($test) {
        Write-Host "   BaseDialog class found" -ForegroundColor Green
    } else {
        Write-Host "   BaseDialog class not found" -ForegroundColor Red
    }
} catch {
    Write-Host "   BaseDialog error: $($_.Exception.Message)" -ForegroundColor Red
}

# Test CommandEditDialog
try {
    $test = [CommandEditDialog] -as [type]
    if ($test) {
        Write-Host "   CommandEditDialog class found" -ForegroundColor Green
    } else {
        Write-Host "   CommandEditDialog class not found" -ForegroundColor Red
    }
} catch {
    Write-Host "   CommandEditDialog error: $($_.Exception.Message)" -ForegroundColor Red
}

# Test ConfirmationDialog
try {
    $test = [ConfirmationDialog] -as [type]
    if ($test) {
        Write-Host "   ConfirmationDialog class found" -ForegroundColor Green
    } else {
        Write-Host "   ConfirmationDialog class not found" -ForegroundColor Red
    }
} catch {
    Write-Host "   ConfirmationDialog error: $($_.Exception.Message)" -ForegroundColor Red
}

# Try creating instances
Write-Host "`nTesting instance creation..." -ForegroundColor Yellow

if ([CommandEditDialog] -as [type]) {
    try {
        $dialog = [CommandEditDialog]::new()
        Write-Host "   CommandEditDialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "   CommandEditDialog creation failed: $($_.Exception.Message)" -ForegroundColor Red
    }
} else {
    Write-Host "   Cannot test CommandEditDialog creation - class not found" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-closure-debug.ps1
#!/usr/bin/env pwsh

# Debug the closure creation issue
Write-Host "Testing closure creation..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    
    Write-Host "Checking if dialog exists..." -ForegroundColor Yellow
    if ($dialog) {
        Write-Host "   Dialog created" -ForegroundColor Green
    } else {
        Write-Host "   Dialog is null" -ForegroundColor Red
        return
    }
    
    Write-Host "Checking if SaveCommand method exists..." -ForegroundColor Yellow
    try {
        $method = $dialog | Get-Member -Name "SaveCommand" -MemberType Method
        if ($method) {
            Write-Host "   SaveCommand method found" -ForegroundColor Green
        } else {
            Write-Host "   SaveCommand method not found" -ForegroundColor Red
        }
    } catch {
        Write-Host "   Error checking SaveCommand: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host "Testing simple closure creation..." -ForegroundColor Yellow
    try {
        $testClosure = { Write-Host "Test closure" }.GetNewClosure()
        if ($testClosure) {
            Write-Host "   Simple closure created successfully" -ForegroundColor Green
        }
    } catch {
        Write-Host "   Simple closure failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host "Testing closure with method call..." -ForegroundColor Yellow
    try {
        $methodClosure = { $dialog.GetType().Name }.GetNewClosure()
        if ($methodClosure) {
            Write-Host "   Method closure created successfully" -ForegroundColor Green
            $result = & $methodClosure
            Write-Host "   Closure result: $result" -ForegroundColor Green
        }
    } catch {
        Write-Host "   Method closure failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-direct.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen directly
Write-Host "Testing CommandLibraryScreen directly..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    
    Write-Host "Initializing screen..." -ForegroundColor Yellow  
    $screen.Initialize($global:ServiceContainer)
    
    Write-Host "Screen created successfully" -ForegroundColor Green
    Write-Host "  CommandList exists: $($null -ne $screen.CommandList)" -ForegroundColor Cyan
    
    if ($screen.CommandList) {
        Write-Host "  CommandList Items count: $($screen.CommandList.Items.Count)" -ForegroundColor Cyan
        Write-Host "  CommandList _filteredItems count: $($screen.CommandList._filteredItems.Count)" -ForegroundColor Cyan
        
        Write-Host "  Commands from service:" -ForegroundColor Cyan
        $commands = $screen.CommandService.GetAllCommands()
        Write-Host "    CommandService.GetAllCommands() count: $($commands.Count)" -ForegroundColor Cyan
        
        foreach ($cmd in $commands) {
            Write-Host "    - $($cmd.Title): $($cmd.Description)" -ForegroundColor DarkGray
        }
    }
    
    # Test bounds
    Write-Host "Setting test bounds..." -ForegroundColor Yellow
    $screen.SetBounds(0, 0, 80, 20)
    Write-Host "  Screen bounds: $($screen.X),$($screen.Y) - $($screen.Width)x$($screen.Height)" -ForegroundColor Cyan
    
    if ($screen.CommandList) {
        Write-Host "  CommandList bounds: $($screen.CommandList.X),$($screen.CommandList.Y) - $($screen.CommandList.Width)x$($screen.CommandList.Height)" -ForegroundColor Cyan
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "Test completed!" -ForegroundColor Green


####\test-commandlibrary-focus.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen focus
Write-Host "Testing CommandLibraryScreen focus..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    Write-Host "CommandList has focus: $($screen.CommandList.IsFocused)" -ForegroundColor Cyan
    Write-Host "CommandList is focusable: $($screen.CommandList.IsFocusable)" -ForegroundColor Cyan
    Write-Host "Selected index: $($screen.CommandList.SelectedIndex)" -ForegroundColor Cyan
    
    # Test OnActivated
    Write-Host "`nTesting OnActivated..." -ForegroundColor Yellow
    $screen.OnActivated()
    Write-Host "After OnActivated - CommandList has focus: $($screen.CommandList.IsFocused)" -ForegroundColor Cyan
    
    # Test cursor navigation simulation
    Write-Host "`nTesting cursor navigation..." -ForegroundColor Yellow
    $downKey = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::DownArrow, $false, $false, $false)
    $oldIndex = $screen.CommandList.SelectedIndex
    
    $handled = $screen.CommandList.HandleInput($downKey)
    $newIndex = $screen.CommandList.SelectedIndex
    
    Write-Host "Down arrow handled: $handled" -ForegroundColor Cyan
    Write-Host "Index changed from $oldIndex to $newIndex" -ForegroundColor Cyan
    
    if ($newIndex -ne $oldIndex) {
        Write-Host " Cursor navigation working!" -ForegroundColor Green
    } else {
        Write-Host " Cursor navigation not working" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-render.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen rendering
Write-Host "Testing CommandLibraryScreen rendering output..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating and setting up CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test rendering
    Write-Host "`nTesting render output (first 500 chars)..." -ForegroundColor Cyan
    $renderOutput = $screen.OnRender()
    
    if ($renderOutput.Length -gt 0) {
        Write-Host " Render output generated: $($renderOutput.Length) characters" -ForegroundColor Green
        
        # Show a sample of the render output (strip ANSI for readability)
        $sample = $renderOutput.Substring(0, [Math]::Min(500, $renderOutput.Length))
        $cleanSample = $sample -replace '\e\[[0-9;]*m', '' -replace '\e\[[0-9;]*[A-Za-z]', ''
        Write-Host "`nSample output (ANSI stripped):" -ForegroundColor Cyan
        Write-Host $cleanSample -ForegroundColor DarkGray
        
        # Check if it contains command titles
        $containsCommands = $renderOutput -match "@CurrentDate_YYYYMMDD"
        Write-Host "`nContains command titles: $containsCommands" -ForegroundColor $(if ($containsCommands) { "Green" } else { "Red" })
        
    } else {
        Write-Host " No render output generated!" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-shortcuts.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen shortcuts
Write-Host "Testing CommandLibraryScreen keyboard shortcuts..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 20)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test shortcut registration
    $shortcutManager = $global:ServiceContainer.GetService('ShortcutManager')
    $shortcuts = $shortcutManager.GetShortcuts([ShortcutScope]::Screen, "CommandLibraryScreen")
    
    Write-Host "`nRegistered shortcuts for CommandLibraryScreen:" -ForegroundColor Cyan
    foreach ($shortcut in $shortcuts) {
        Write-Host "  $($shortcut.GetDisplayText()): $($shortcut.Name)" -ForegroundColor Yellow
    }
    
    # Test NewCommand method directly
    Write-Host "`nTesting NewCommand method..." -ForegroundColor Cyan
    try {
        # Mock ScreenManager for the test
        $global:ScreenManager = [PSCustomObject]@{
            GetScreen = { return $null }
            RegisterScreen = { }
            PushScreen = { 
                param($screen)
                Write-Host "   PushScreen called with: $($screen.GetType().Name)" -ForegroundColor Green
            }
        }
        
        $screen.NewCommand()
        Write-Host "   NewCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-simple.ps1
#!/usr/bin/env pwsh

# Simple test of CommandLibraryScreen functionality
Write-Host "Testing CommandLibraryScreen with fixed ScreenManager API..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test NewCommand directly
    Write-Host "`nTesting NewCommand..." -ForegroundColor Yellow
    try {
        $screen.NewCommand()
        Write-Host "   NewCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test EditCommand (no selection)
    Write-Host "`nTesting EditCommand (no selection)..." -ForegroundColor Yellow
    try {
        $screen.EditCommand()
        Write-Host "   EditCommand handled no selection correctly" -ForegroundColor Green
    } catch {
        Write-Host "   EditCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test DeleteCommand (no selection)
    Write-Host "`nTesting DeleteCommand (no selection)..." -ForegroundColor Yellow
    try {
        $screen.DeleteCommand()
        Write-Host "   DeleteCommand handled no selection correctly" -ForegroundColor Green
    } catch {
        Write-Host "   DeleteCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-copy-command.ps1
#!/usr/bin/env pwsh

# Test copy command functionality
Write-Host "Testing CopySelectedCommand..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Select first command
    $screen.CommandList.SelectedIndex = 0
    $selectedCommand = $screen.CommandList.GetSelectedItem()
    Write-Host "Selected: $($selectedCommand.GetDisplayText())" -ForegroundColor Yellow
    
    # Test copy
    Write-Host "`nTesting CopySelectedCommand..." -ForegroundColor Yellow
    try {
        $screen.CopySelectedCommand()
        Write-Host "   Copy executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   Copy failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-cursor-validation-crash.ps1
#!/usr/bin/env pwsh

# Test cursor validation crash scenario
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load dependencies
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Testing cursor validation after undo..." -ForegroundColor Red

# Create the scenario
$buffer = [DocumentBuffer]::new()

# Add sample content
$sampleLines = @(
    "Welcome to PRAXIS Text Editor!",
    "",
    "This is line 2"
)
$buffer.Lines.Clear()
foreach ($line in $sampleLines) {
    $buffer.Lines.Add($line) | Out-Null
}
$buffer.ClearUndoHistory()
$buffer.IsModified = $false

# Set cursor position like editor would
$CursorX = 0
$CursorY = 0

Write-Host "Initial state:"
Write-Host "  Lines: $($buffer.GetLineCount())"
Write-Host "  Cursor: ($CursorX,$CursorY)"

# Type a character
Write-Host "`nTyping 'H' at cursor position..."
$insertCmd = [InsertTextCommand]::new($CursorY, $CursorX, "H")
$buffer.ExecuteCommand($insertCmd)
$CursorX++  # Move cursor like editor does

Write-Host "After typing:"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"
Write-Host "  Cursor: ($CursorX,$CursorY)"

# Now undo and validate cursor like TextEditorScreenNew.UndoEdit() does
Write-Host "`nPerforming undo with cursor validation..."
try {
    # This is what UndoEdit does
    $buffer.Undo()
    
    # Simulate ValidateCursorPosition
    Write-Host "Validating cursor position..."
    $lineCount = $buffer.GetLineCount()
    if ($lineCount -eq 0) {
        $CursorX = 0
        $CursorY = 0
    } else {
        # Clamp cursor Y
        $CursorY = [Math]::Max(0, [Math]::Min($CursorY, $lineCount - 1))
        
        # Get current line for X validation
        Write-Host "  Getting line $CursorY..."
        $currentLine = $buffer.GetLine($CursorY)
        Write-Host "  Current line: '$currentLine'"
        Write-Host "  Current line length: $($currentLine.Length)"
        Write-Host "  Cursor X before clamp: $CursorX"
        
        # Clamp cursor X
        $CursorX = [Math]::Max(0, [Math]::Min($CursorX, $currentLine.Length))
        Write-Host "  Cursor X after clamp: $CursorX"
    }
    
    Write-Host " Undo and validation completed successfully!"
    Write-Host "  Final cursor: ($CursorX,$CursorY)"
    Write-Host "  Line 0: '$($buffer.GetLine(0))'"
    
} catch {
    Write-Host " CRASH during undo/validation!" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-dialog-buttons.ps1
#!/usr/bin/env pwsh

# Test CommandEditDialog button functionality
Write-Host "Testing CommandEditDialog button functionality..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    $dialog.Initialize($global:ServiceContainer)
    $dialog.SetBounds(0, 0, 120, 40)
    $dialog.SetCommand($null)  # New command
    
    Write-Host "Testing SaveCommand method..." -ForegroundColor Yellow
    
    # Set some sample data
    $dialog.TitleBox.Text = "Test Command"
    $dialog.DescriptionBox.Text = "Test Description"
    $dialog.TagsBox.Text = "test, example"
    $dialog.GroupBox.Text = "Test Group"
    $dialog.CommandBox.Text = "echo 'Hello World'"
    
    try {
        $dialog.SaveCommand()
        Write-Host "   SaveCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   SaveCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host "Testing Cancel method..." -ForegroundColor Yellow
    try {
        $dialog.Cancel()
        Write-Host "   Cancel executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   Cancel failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test button handlers via BaseDialog
    Write-Host "Testing BaseDialog button handlers..." -ForegroundColor Yellow
    try {
        $dialog.HandlePrimaryAction()
        Write-Host "   Primary button handler executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   Primary button handler failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    try {
        $dialog.HandleSecondaryAction()
        Write-Host "   Secondary button handler executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   Secondary button handler failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-dialog-creation.ps1
#!/usr/bin/env pwsh

# Test dialog creation and initialization
Write-Host "Testing dialog creation and initialization..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    $dialog.Initialize($global:ServiceContainer)
    $dialog.SetBounds(0, 0, 80, 25)
    
    Write-Host "   CommandEditDialog created and initialized successfully" -ForegroundColor Green
    
    # Test SetCommand
    Write-Host "`nTesting SetCommand with null (new command)..." -ForegroundColor Yellow
    try {
        $dialog.SetCommand($null)
        Write-Host "   SetCommand(null) successful" -ForegroundColor Green
    } catch {
        Write-Host "   SetCommand(null) failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test with existing command
    Write-Host "`nTesting SetCommand with existing command..." -ForegroundColor Yellow
    $commandService = $global:ServiceContainer.GetService("CommandService")
    $commands = $commandService.GetAllCommands()
    if ($commands.Count -gt 0) {
        try {
            $dialog.SetCommand($commands[0])
            Write-Host "   SetCommand(existing) successful" -ForegroundColor Green
        } catch {
            Write-Host "   SetCommand(existing) failed: $($_.Exception.Message)" -ForegroundColor Red
        }
    } else {
        Write-Host "  - No commands available to test with" -ForegroundColor Yellow
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-dialog-keys.ps1
#!/usr/bin/env pwsh
# Simple test to verify dialog keyboard shortcuts

Write-Host @"
Testing Dialog Keyboard Shortcuts
=================================

Instructions:
1. Run: pwsh Start.ps1
2. On Projects tab (press 1), test these keys:
   - N: Should open New Project dialog
   - E: Should open Edit Project dialog (select a project first)
   - D: Should open Delete confirmation dialog

3. On Tasks tab (press 2), test these keys:
   - N: Should open New Task dialog
   - E: Should open Edit Task dialog (select a task first)
   - D: Should open Delete confirmation dialog
   - Shift+A: Should open Add Subtask dialog

4. In any dialog:
   - Tab/Shift+Tab: Should navigate between fields
   - All text boxes should have rounded borders
   - Escape: Should close dialog

All dialogs should:
- Have rounded borders
- Support Tab navigation between fields
- Have MinimalTextBox with rounded borders
- Not throw any VT method errors

"@ -ForegroundColor Cyan

Read-Host "Press Enter to start the application..."
pwsh Start.ps1


####\test-dialog-render.ps1
#!/usr/bin/env pwsh

# Test dialog rendering to make sure no substring errors
Write-Host "Testing CommandEditDialog rendering..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating and initializing CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    $dialog.Initialize($global:ServiceContainer)
    $dialog.SetBounds(0, 0, 120, 40)  # Give it plenty of space
    
    Write-Host "Testing OnBoundsChanged..." -ForegroundColor Yellow
    $dialog.OnBoundsChanged()
    Write-Host "   OnBoundsChanged successful" -ForegroundColor Green
    
    Write-Host "Testing SetCommand(null)..." -ForegroundColor Yellow
    $dialog.SetCommand($null)
    Write-Host "   SetCommand successful" -ForegroundColor Green
    
    Write-Host "Testing dialog rendering..." -ForegroundColor Yellow
    $rendered = $dialog.Render()
    if ($rendered -and $rendered.Length -gt 0) {
        Write-Host "   Dialog rendered successfully (length: $($rendered.Length))" -ForegroundColor Green
    } else {
        Write-Host "   Dialog render returned empty or null" -ForegroundColor Red
    }
    
    Write-Host "Testing with existing command..." -ForegroundColor Yellow
    $commandService = $global:ServiceContainer.GetService("CommandService")
    $commands = $commandService.GetAllCommands()
    if ($commands.Count -gt 0) {
        $dialog.SetCommand($commands[0])
        $rendered2 = $dialog.Render()
        if ($rendered2 -and $rendered2.Length -gt 0) {
            Write-Host "   Dialog with existing command rendered successfully" -ForegroundColor Green
        } else {
            Write-Host "   Dialog with existing command failed to render" -ForegroundColor Red
        }
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-dialog-shortcuts.ps1
#!/usr/bin/env pwsh
# Test script to verify dialog shortcuts work without errors

$ErrorActionPreference = "Stop"

Write-Host "Testing Dialog Shortcuts..." -ForegroundColor Green

# Load components directly without starting UI
$ErrorActionPreference = "Stop"

# Load all required files in correct order
$files = @(
    "Core/ServiceContainer.ps1",
    "Core/StringBuilderPool.ps1",
    "Core/StringCache.ps1",
    "Core/VT100.ps1",
    "Core/BorderStyle.ps1",
    "Base/UIElement.ps1",
    "Base/Container.ps1",
    "Base/FocusableComponent.ps1",
    "Base/Screen.ps1",
    "Base/BaseDialog.ps1",
    "Components/MinimalButton.ps1",
    "Components/MinimalTextBox.ps1",
    "Components/MinimalListBox.ps1",
    "Components/MinimalDataGrid.ps1",
    "Models/Project.ps1",
    "Models/Task.ps1",
    "Services/ProjectService.ps1",
    "Services/TaskService.ps1",
    "Services/SubtaskService.ps1",
    "Services/EventBus.ps1",
    "Services/ThemeManager.ps1",
    "Services/Logger.ps1",
    "Screens/NewProjectDialog.ps1",
    "Screens/EditProjectDialog.ps1", 
    "Screens/ConfirmationDialog.ps1",
    "Screens/NewTaskDialog.ps1",
    "Screens/EditTaskDialog.ps1",
    "Screens/SubtaskDialog.ps1",
    "Screens/ProjectsScreen.ps1",
    "Screens/TaskScreen.ps1"
)

foreach ($file in $files) {
    if (Test-Path $file) {
        . ./$file
    }
}

# Create minimal service container
$global:ServiceContainer = [ServiceContainer]::new()
$global:ServiceContainer.RegisterService('Logger', [Logger]::new())
$global:ServiceContainer.RegisterService('EventBus', [EventBus]::new())
$global:ServiceContainer.RegisterService('ThemeManager', [ThemeManager]::new())
$global:ServiceContainer.RegisterService('ProjectService', [ProjectService]::new())
$global:ServiceContainer.RegisterService('TaskService', [TaskService]::new())
$global:ServiceContainer.RegisterService('SubtaskService', [SubtaskService]::new())

# Simulate being on ProjectsScreen
Write-Host "`nSimulating ProjectsScreen..." -ForegroundColor Yellow
$projectsScreen = [ProjectsScreen]::new()
$projectsScreen.Initialize($global:ServiceContainer)

# Test N key (NewProjectDialog)
Write-Host "Testing N key (New Project)..." -ForegroundColor Cyan
try {
    $projectsScreen.NewProject()
    Write-Host " NewProject() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " NewProject() failed: $_" -ForegroundColor Red
}

# Test E key (EditProjectDialog) - need a project first
Write-Host "`nTesting E key (Edit Project)..." -ForegroundColor Cyan
try {
    # Add a dummy project to the grid
    $project = [Project]::new("Test Project")
    $projectsScreen.ProjectGrid.SetItems(@($project))
    $projectsScreen.ProjectGrid.SelectIndex(0)
    
    $projectsScreen.EditProject()
    Write-Host " EditProject() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " EditProject() failed: $_" -ForegroundColor Red
}

# Test D key (DeleteProject with ConfirmationDialog)
Write-Host "`nTesting D key (Delete Project)..." -ForegroundColor Cyan
try {
    $projectsScreen.DeleteProject()
    Write-Host " DeleteProject() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " DeleteProject() failed: $_" -ForegroundColor Red
}

# Simulate being on TaskScreen
Write-Host "`n`nSimulating TaskScreen..." -ForegroundColor Yellow
$taskScreen = [TaskScreen]::new()
$taskScreen.Initialize($global:ServiceContainer)

# Test N key (NewTaskDialog)
Write-Host "Testing N key (New Task)..." -ForegroundColor Cyan
try {
    $taskScreen.NewTask()
    Write-Host " NewTask() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " NewTask() failed: $_" -ForegroundColor Red
}

# Test E key (EditTaskDialog) - need a task first
Write-Host "`nTesting E key (Edit Task)..." -ForegroundColor Cyan
try {
    # Add a dummy task to the grid
    $task = [Task]::new()
    $task.Title = "Test Task"
    $taskScreen.TaskGrid.SetItems(@($task))
    $taskScreen.TaskGrid.SelectIndex(0)
    
    $taskScreen.EditTask()
    Write-Host " EditTask() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " EditTask() failed: $_" -ForegroundColor Red
}

# Test D key (DeleteTask with ConfirmationDialog)
Write-Host "`nTesting D key (Delete Task)..." -ForegroundColor Cyan
try {
    $taskScreen.DeleteTask()
    Write-Host " DeleteTask() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " DeleteTask() failed: $_" -ForegroundColor Red
}

# Test A key (SubtaskDialog)
Write-Host "`nTesting Shift+A key (Add Subtask)..." -ForegroundColor Cyan
try {
    $taskScreen.AddSubtask()
    Write-Host " AddSubtask() executed successfully" -ForegroundColor Green
} catch {
    Write-Host " AddSubtask() failed: $_" -ForegroundColor Red
}

Write-Host "`n`nAll dialog shortcut tests completed!" -ForegroundColor Green


####\test-exact-undo-crash.ps1
#!/usr/bin/env pwsh

# Test exact TextEditorScreenNew scenario that crashes
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load only what we need
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Reproducing exact TextEditorScreenNew undo scenario..." -ForegroundColor Red

# Create buffer exactly like TextEditorScreenNew constructor
Write-Host "Step 1: Creating buffer with empty line..."
$buffer = [DocumentBuffer]::new()
Write-Host "  Initial lines: $($buffer.GetLineCount())"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"
Write-Host "  Can undo: $($buffer.CanUndo())"

# Simulate AddSampleContent exactly like TextEditorScreenNew does
Write-Host "`nStep 2: Simulating AddSampleContent()..."
$sampleLines = @(
    "Welcome to PRAXIS Text Editor!",
    "",
    "This is the new Buffer/View architecture with:",
    " Command Pattern for robust undo/redo",
    " Line-level render caching for performance", 
    " Proper Buffer/View separation",
    "",
    "Try typing text, using arrow keys, or:",
    " Ctrl+Z to undo",
    " Ctrl+Y to redo", 
    " Ctrl+S to save (when implemented)",
    "",
    "The architecture is now professional-grade!"
)

# This is what AddSampleContent does
$buffer.Lines.Clear()
foreach ($line in $sampleLines) {
    $buffer.Lines.Add($line) | Out-Null
}
$buffer.ClearUndoHistory()
$buffer.IsModified = $false

Write-Host "  After sample content:"
Write-Host "  Lines: $($buffer.GetLineCount())"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"
Write-Host "  Can undo: $($buffer.CanUndo()) (should be false)"

# Now simulate typing a character like InsertCharacter does
Write-Host "`nStep 3: Simulating typing 'H' at position (0,0)..."
$insertCmd = [InsertTextCommand]::new(0, 0, "H")
$buffer.ExecuteCommand($insertCmd)

Write-Host "  After insert:"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"  
Write-Host "  Can undo: $($buffer.CanUndo()) (should be true)"

# Now try undo - this is where it might crash
Write-Host "`nStep 4: Attempting undo (this might crash)..."
try {
    Write-Host "  Calling buffer.Undo()..."
    $buffer.Undo()
    Write-Host "   Undo completed successfully!"
    Write-Host "  Line 0 after undo: '$($buffer.GetLine(0))'"
    Write-Host "  Can undo: $($buffer.CanUndo())"
    Write-Host "  Can redo: $($buffer.CanRedo())"
} catch {
    Write-Host "   UNDO CRASHED!" -ForegroundColor Red
    Write-Host "  Exception Type: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "  Stack Trace:" -ForegroundColor Red
    Write-Host "  $($_.ScriptStackTrace)" -ForegroundColor Red
    
    # Show the command details that failed
    Write-Host "`n  Debug info:" -ForegroundColor Yellow
    Write-Host "  Undo stack count: $($buffer._undoStack.Count)"
    if ($buffer._undoStack.Count -gt 0) {
        $lastCmd = $buffer._undoStack[$buffer._undoStack.Count - 1]
        Write-Host "  Last command type: $($lastCmd.GetType().Name)"
        Write-Host "  Command Line: $($lastCmd.Line)"
        Write-Host "  Command Col: $($lastCmd.Col)" 
        Write-Host "  Command Text: '$($lastCmd.Text)'"
    }
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-final-shortcuts.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen shortcuts with ScreenManager fix
Write-Host "Testing CommandLibraryScreen shortcuts with fixed ScreenManager..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test NewCommand with global ScreenManager
    Write-Host "`nTesting NewCommand with proper ScreenManager..." -ForegroundColor Yellow
    
    # Mock global ScreenManager
    $global:ScreenManager = [PSCustomObject]@{
        GetScreen = { 
            param($name)
            return $null  # Force creation of new dialog
        }
        RegisterScreen = { 
            param($name, $screen)
            Write-Host "   RegisterScreen called: $name" -ForegroundColor Green
        }
        Push = { 
            param($screen)
            Write-Host "   Push called with: $($screen.GetType().Name)" -ForegroundColor Green
        }
    }
    
    try {
        $screen.NewCommand()
        Write-Host "   NewCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test EditCommand (should warn about no selection)
    Write-Host "`nTesting EditCommand (no selection)..." -ForegroundColor Yellow
    try {
        $screen.EditCommand()
        Write-Host "   EditCommand handled no selection correctly" -ForegroundColor Green
    } catch {
        Write-Host "   EditCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test with a selection
    Write-Host "`nTesting EditCommand with selection..." -ForegroundColor Yellow
    $screen.CommandList.SelectedIndex = 0  # Select first command
    try {
        $screen.EditCommand()
        Write-Host "   EditCommand with selection executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   EditCommand with selection failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-full-commandlibrary.ps1
#!/usr/bin/env pwsh

# Comprehensive test of CommandLibraryScreen functionality
Write-Host "Testing full CommandLibraryScreen functionality..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test all shortcut key handling
    Write-Host "`nTesting shortcut key handling..." -ForegroundColor Yellow
    
    # Test 'n' key (NewCommand)
    $nKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    $handled = $screen.HandleScreenInput($nKey)
    Write-Host "  'n' key (NewCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'e' key (EditCommand) 
    $eKey = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
    $handled = $screen.HandleScreenInput($eKey)
    Write-Host "  'e' key (EditCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'd' key (DeleteCommand)
    $dKey = [System.ConsoleKeyInfo]::new('d', [System.ConsoleKey]::D, $false, $false, $false)
    $handled = $screen.HandleScreenInput($dKey)
    Write-Host "  'd' key (DeleteCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test Enter key (CopySelectedCommand)
    $enterKey = [System.ConsoleKeyInfo]::new([char]13, [System.ConsoleKey]::Enter, $false, $false, $false)
    $handled = $screen.HandleScreenInput($enterKey)
    Write-Host "  Enter key (CopyCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test with selection
    Write-Host "`nTesting with command selected..." -ForegroundColor Yellow
    $screen.CommandList.SelectedIndex = 0
    $selectedCommand = $screen.CommandList.GetSelectedItem()
    Write-Host "  Selected: $($selectedCommand.GetDisplayText())" -ForegroundColor Cyan
    
    # Test copy with selection
    try {
        $screen.CopySelectedCommand()
        Write-Host "   Copy with selection successful" -ForegroundColor Green
    } catch {
        Write-Host "   Copy failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test that SearchableListBox excludes shortcut keys
    Write-Host "`nTesting SearchableListBox key exclusion..." -ForegroundColor Yellow
    $listHandled = $screen.CommandList.HandleInput($nKey)
    Write-Host "  SearchableListBox handles 'n': $listHandled" -ForegroundColor $(if (-not $listHandled) { "Green" } else { "Red" })
    
    # Test search with normal characters
    $aKey = [System.ConsoleKeyInfo]::new('a', [System.ConsoleKey]::A, $false, $false, $false)
    $listHandled = $screen.CommandList.HandleInput($aKey)
    Write-Host "  SearchableListBox handles 'a': $listHandled" -ForegroundColor $(if ($listHandled) { "Green" } else { "Red" })
    
    Write-Host "`n All CommandLibraryScreen functionality working!" -ForegroundColor Green
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-full-dialog-flow.ps1
#!/usr/bin/env pwsh

# Test complete CommandLibraryScreen + Dialog flow
Write-Host "Testing complete CommandLibraryScreen with dialogs..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 120, 40)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test NewCommand dialog creation and rendering
    Write-Host "`nTesting NewCommand dialog creation..." -ForegroundColor Yellow
    try {
        $screen.NewCommand()
        Write-Host "   NewCommand dialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "   NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test EditCommand with selection
    Write-Host "`nTesting EditCommand with selection..." -ForegroundColor Yellow
    $screen.CommandList.SelectedIndex = 0
    try {
        $screen.EditCommand()
        Write-Host "   EditCommand dialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "   EditCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test DeleteCommand with selection
    Write-Host "`nTesting DeleteCommand with selection..." -ForegroundColor Yellow
    try {
        $screen.DeleteCommand()
        Write-Host "   DeleteCommand dialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "   DeleteCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test CopySelectedCommand
    Write-Host "`nTesting CopySelectedCommand..." -ForegroundColor Yellow
    try {
        $screen.CopySelectedCommand()
        Write-Host "   CopySelectedCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "   CopySelectedCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host "`n All CommandLibraryScreen functionality working perfectly!" -ForegroundColor Green
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-full-editor-undo.ps1
#!/usr/bin/env pwsh

# Test the full TextEditorScreenNew undo crash
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

Write-Host "Testing full TextEditorScreenNew undo crash..." -ForegroundColor Red

# Load all required dependencies in correct order
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize services like PRAXIS does
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)

$eventBus = [EventBus]::new()
$global:ServiceContainer.Register("EventBus", $eventBus)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

Write-Host " All dependencies loaded and services initialized"

# Create editor exactly like PRAXIS does
Write-Host "`nCreating TextEditorScreenNew..." 
try {
    $editor = [TextEditorScreenNew]::new()
    $editor.Initialize($global:ServiceContainer)
    $editor.SetBounds(0, 0, 80, 24)
    Write-Host " Editor created and initialized"
} catch {
    Write-Host " Failed to create editor: $_" -ForegroundColor Red
    exit 1
}

# Show initial state
Write-Host "`nInitial state:"
Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "  Lines: $($editor._buffer.GetLineCount())"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
Write-Host "  Can undo: $($editor._buffer.CanUndo())"

# Simulate typing exactly like the real editor
Write-Host "`nSimulating typing 'A'..."
try {
    $keyInfo = [System.ConsoleKeyInfo]::new('A', [System.ConsoleKey]::A, $false, $false, $false)
    $handled = $editor.HandleScreenInput($keyInfo)
    Write-Host " Character typed, handled: $handled"
    Write-Host "  New cursor: ($($editor.CursorX),$($editor.CursorY))"
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Can undo: $($editor._buffer.CanUndo())"
} catch {
    Write-Host " Failed to type character: $_" -ForegroundColor Red
    exit 1
}

# Now try to undo - this is where it should crash
Write-Host "`nAttempting undo (this may crash)..."
try {
    Write-Host "  Calling editor.UndoEdit()..."
    $editor.UndoEdit()
    Write-Host "   Undo completed successfully!"
    Write-Host "  Final cursor: ($($editor.CursorX),$($editor.CursorY))" 
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Status: '$($editor.StatusMessage)'"
} catch {
    Write-Host "   UNDO CRASHED IN FULL EDITOR!" -ForegroundColor Red
    Write-Host "  Exception Type: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "  Inner Exception: $($_.Exception.InnerException)" -ForegroundColor Red
    Write-Host "  Stack Trace:" -ForegroundColor Red
    $_.ScriptStackTrace -split "`n" | ForEach-Object { Write-Host "    $_" -ForegroundColor Red }
    
    Write-Host "`n  Additional debug info:" -ForegroundColor Yellow
    Write-Host "  Editor cursor: ($($editor.CursorX),$($editor.CursorY))"
    Write-Host "  Buffer lines: $($editor._buffer.GetLineCount())"
    Write-Host "  Buffer can undo: $($editor._buffer.CanUndo())"
    Write-Host "  Editor status: '$($editor.StatusMessage)'"
    
    exit 1
}

Write-Host "`nTest completed successfully!" -ForegroundColor Green


####\test-keypress-undo.ps1
#!/usr/bin/env pwsh

# Test if the crash is related to the keypress handling context
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

Write-Host "Testing keypress context undo crash..." -ForegroundColor Red

# Load the full editor with all dependencies
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
$eventBus = [EventBus]::new()
$global:ServiceContainer.Register("EventBus", $eventBus)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# Create editor
$editor = [TextEditorScreenNew]::new()
$editor.Initialize($global:ServiceContainer)
$editor.SetBounds(0, 0, 80, 24)

Write-Host "Editor initialized. Initial state:"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
Write-Host "  Can undo: $($editor._buffer.CanUndo())"

# Type a character using HandleScreenInput (the actual input mechanism)
Write-Host "`nTyping 'T' using HandleScreenInput..."
$keyInfo = [System.ConsoleKeyInfo]::new('T', [System.ConsoleKey]::T, $false, $false, $false)
$handled = $editor.HandleScreenInput($keyInfo)
Write-Host "Character handled: $handled"
Write-Host "After typing: '$($editor._buffer.GetLine(0))'"
Write-Host "Can undo: $($editor._buffer.CanUndo())"

# Now simulate the exact Ctrl+Z keypress that crashes in the real app
Write-Host "`nSimulating Ctrl+Z keypress using HandleScreenInput..."
Write-Host "This might crash immediately..."

try {
    # Create the exact same keypress as the real application would receive
    $ctrlZ = [System.ConsoleKeyInfo]::new([char]26, [System.ConsoleKey]::Z, $false, $false, $true)
    Write-Host "Created Ctrl+Z keyinfo: Key=$($ctrlZ.Key), Modifiers=$($ctrlZ.Modifiers)"
    
    Write-Host "Calling HandleScreenInput with Ctrl+Z..."
    $handled = $editor.HandleScreenInput($ctrlZ)
    
    Write-Host " Ctrl+Z handled successfully: $handled"
    Write-Host "Final state: '$($editor._buffer.GetLine(0))'"
    Write-Host "Status: '$($editor.StatusMessage)'"
    
} catch {
    Write-Host " CTRL+Z CRASHED!" -ForegroundColor Red
    Write-Host "Exception Type: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Inner Exception: $($_.Exception.InnerException)" -ForegroundColor Red
    $_.ScriptStackTrace -split "`n" | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-live-commandlibrary.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen in live application environment
Write-Host "Testing CommandLibraryScreen in live application..." -ForegroundColor Cyan

# Start the application normally
Write-Host "Starting PRAXIS application..." -ForegroundColor Yellow
Write-Host "- Navigate to Commands tab and test keyboard shortcuts" -ForegroundColor Green
Write-Host "- Press 'n' to create new command" -ForegroundColor Green  
Write-Host "- Press 'e' to edit selected command" -ForegroundColor Green
Write-Host "- Press 'd' to delete selected command" -ForegroundColor Green
Write-Host "- Press Enter to copy command to clipboard" -ForegroundColor Green
Write-Host "- Use arrow keys to navigate commands" -ForegroundColor Green
Write-Host "- Type to search commands (excludes n/e/d)" -ForegroundColor Green
Write-Host "" -ForegroundColor White
Write-Host "Press Ctrl+Q to exit when done testing" -ForegroundColor Yellow

# Run the actual application
& "$PSScriptRoot/Start.ps1"


####\test-macro-factory-ui.ps1
#!/usr/bin/env pwsh

# Test the VisualMacroFactoryScreen in PRAXIS to verify actions are visible
param([switch]$LoadOnly)

# Provide instruction to user
Write-Host "This will start PRAXIS. To test the Macro Factory:" -ForegroundColor Cyan
Write-Host "1. Press '7' to go to Macro Factory tab" -ForegroundColor Yellow  
Write-Host "2. Check if the left pane shows 4 actions:" -ForegroundColor Yellow
Write-Host "   -  Summarization" -ForegroundColor Green
Write-Host "   -  Append Calculated Field" -ForegroundColor Green
Write-Host "   -  Export to Excel" -ForegroundColor Green  
Write-Host "   -  Custom IDEA@ Command" -ForegroundColor Green
Write-Host "3. Test if keyboard shortcuts work:" -ForegroundColor Yellow
Write-Host "   - F5 should trigger preview" -ForegroundColor Green
Write-Host "   - Ctrl+S should trigger save" -ForegroundColor Green
Write-Host "   - Ctrl+N should trigger new macro" -ForegroundColor Green
Write-Host "4. Press Q to quit when done testing" -ForegroundColor Yellow
Write-Host ""
Write-Host "Starting PRAXIS..." -ForegroundColor Green

# Start PRAXIS
. "$PSScriptRoot/Start.ps1"


####\test-minimal-ui-undo.ps1
#!/usr/bin/env pwsh

# Minimal reproduction of the UI undo crash
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load dependencies first
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

# Create a minimal class that mimics the exact pattern from TextEditorScreenNew
class MinimalEditor {
    hidden [object]$_buffer
    [int]$CursorX = 0
    [int]$CursorY = 0
    [string]$StatusMessage = ""
    
    MinimalEditor() {
        
        $this._buffer = [DocumentBuffer]::new()
        
        # Exactly mimic AddSampleContent
        $sampleLines = @(
            "Welcome to PRAXIS Text Editor!",
            "",
            "This is the new Buffer/View architecture with:",
            " Command Pattern for robust undo/redo"
        )
        
        $this._buffer.Lines.Clear()
        foreach ($line in $sampleLines) {
            $this._buffer.Lines.Add($line) | Out-Null
        }
        $this._buffer.ClearUndoHistory()
        $this._buffer.IsModified = $false
    }
    
    [void] TypeCharacter([char]$char) {
        Write-Host "Typing '$char' at ($($this.CursorX),$($this.CursorY))"
        $command = [InsertTextCommand]::new($this.CursorY, $this.CursorX, [string]$char)
        $this._buffer.ExecuteCommand($command)
        $this.CursorX++
        Write-Host "  After typing: Line 0 = '$($this._buffer.GetLine(0))'"
        Write-Host "  Can undo: $($this._buffer.CanUndo())"
    }
    
    [void] UndoEdit() {
        Write-Host "Starting undo operation..."
        
        if (-not $this._buffer.CanUndo()) {
            Write-Host "  Nothing to undo"
            return
        }
        
        try {
            Write-Host "  Calling buffer.Undo()..."
            $this._buffer.Undo()
            Write-Host "  Buffer undo completed"
            
            Write-Host "  Validating cursor position..."
            $this.ValidateCursorPosition()
            Write-Host "  Cursor validation completed"
            
            $this.StatusMessage = "Undo"
            Write-Host "   Undo operation completed successfully"
            Write-Host "  Final state: Line 0 = '$($this._buffer.GetLine(0))'"
            Write-Host "  Final cursor: ($($this.CursorX),$($this.CursorY))"
            
        } catch {
            Write-Host "   UNDO CRASHED!" -ForegroundColor Red
            Write-Host "  Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
            Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "  Stack: $($_.ScriptStackTrace)" -ForegroundColor Red
            throw $_
        }
    }
    
    [void] ValidateCursorPosition() {
        $lineCount = $this._buffer.GetLineCount()
        if ($lineCount -eq 0) {
            $this.CursorX = 0
            $this.CursorY = 0
            return
        }
        
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.CursorY, $lineCount - 1))
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $this.CursorX = [Math]::Max(0, [Math]::Min($this.CursorX, $currentLine.Length))
    }
}

Write-Host "Creating minimal editor..." -ForegroundColor Yellow
$editor = [MinimalEditor]::new()

Write-Host "`nInitial state:"
Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"

Write-Host "`nTyping character 'X'..." -ForegroundColor Green
$editor.TypeCharacter('X')

Write-Host "`nAttempting undo..." -ForegroundColor Red
$editor.UndoEdit()

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-minimal-ui.ps1
#!/usr/bin/env pwsh
# Test script for minimal UI improvements

# Load the framework
. ./Start.ps1 -LoadOnly

try {
    # Clear screen
    [Console]::Clear()
    [Console]::CursorVisible = $false
    
    Write-Host "Testing Minimal UI Components..." -ForegroundColor Cyan
    Write-Host ""
    
    # Test 1: FocusManager Performance
    Write-Host "1. Testing FocusManager (O(1) focus operations)..." -ForegroundColor Yellow
    $focusManager = $global:ServiceContainer.GetService('FocusManager')
    
    # Create test elements
    $elements = @()
    for ($i = 0; $i -lt 100; $i++) {
        $elem = [MinimalButton]::new("Button $i")
        $elem.Initialize($global:ServiceContainer)
        $elements += $elem
    }
    
    # Measure focus operations
    $sw = [System.Diagnostics.Stopwatch]::StartNew()
    foreach ($elem in $elements) {
        $focusManager.RegisterFocusable($elem)
    }
    $registerTime = $sw.ElapsedMilliseconds
    
    $sw.Restart()
    for ($i = 0; $i -lt 100; $i++) {
        $focusManager.SetFocus($elements[$i])
    }
    $focusTime = $sw.ElapsedMilliseconds
    
    Write-Host "   Registered 100 elements in ${registerTime}ms" -ForegroundColor Green
    Write-Host "   Focused 100 elements in ${focusTime}ms" -ForegroundColor Green
    Write-Host "   Average focus time: $([Math]::Round($focusTime / 100, 2))ms" -ForegroundColor Green
    Write-Host ""
    
    # Test 2: Minimal Components
    Write-Host "2. Testing Minimal Components..." -ForegroundColor Yellow
    
    # Test MinimalButton
    $button = [MinimalButton]::new("Test Button")
    $button.Initialize($global:ServiceContainer)
    $button.SetBounds(5, 10, 20, 1)
    $buttonRender = $button.Render()
    Write-Host "   MinimalButton renders in $($buttonRender.Length) chars" -ForegroundColor Green
    
    # Test MinimalListBox
    $list = [MinimalListBox]::new()
    $list.Initialize($global:ServiceContainer)
    $list.SetItems(@("Item 1", "Item 2", "Item 3"))
    $list.SetBounds(5, 12, 30, 10)
    $listRender = $list.Render()
    Write-Host "   MinimalListBox renders in $($listRender.Length) chars" -ForegroundColor Green
    
    # Test MinimalTextBox
    $textbox = [MinimalTextBox]::new()
    $textbox.Initialize($global:ServiceContainer)
    $textbox.Placeholder = "Enter text..."
    $textbox.SetBounds(5, 23, 30, 1)
    $textboxRender = $textbox.Render()
    Write-Host "   MinimalTextBox renders in $($textboxRender.Length) chars" -ForegroundColor Green
    Write-Host ""
    
    # Test 3: TabContainer without artifacts
    Write-Host "3. Testing MinimalTabContainer (artifact-free)..." -ForegroundColor Yellow
    $tabs = [MinimalTabContainer]::new()
    $tabs.Initialize($global:ServiceContainer)
    $tabs.SetBounds(0, 0, 80, 24)
    
    # Add test tabs
    for ($i = 1; $i -le 3; $i++) {
        $content = [Container]::new()
        $content.DrawBackground = $true
        $tabs.AddTab("Tab $i", $content)
    }
    
    # Test tab switching
    $sw.Restart()
    for ($i = 0; $i -lt 10; $i++) {
        $tabs.ActivateTab($i % 3)
    }
    $switchTime = $sw.ElapsedMilliseconds
    Write-Host "   Switched tabs 10 times in ${switchTime}ms" -ForegroundColor Green
    Write-Host "   Double-buffering prevents artifacts" -ForegroundColor Green
    Write-Host ""
    
    # Test 4: Theme consistency
    Write-Host "4. Testing Theme Consistency..." -ForegroundColor Yellow
    $theme = $global:ServiceContainer.GetService('ThemeManager')
    $requiredColors = @('focus', 'focus.background', 'focus.accent')
    $missing = @()
    
    foreach ($color in $requiredColors) {
        try {
            $value = $theme.GetColor($color)
            if (-not $value) { $missing += $color }
        } catch {
            $missing += $color
        }
    }
    
    if ($missing.Count -eq 0) {
        Write-Host "   All required focus colors defined" -ForegroundColor Green
    } else {
        Write-Host "   Missing colors: $($missing -join ', ')" -ForegroundColor Red
    }
    Write-Host ""
    
    # Test 5: Focus navigation performance
    Write-Host "5. Testing Focus Navigation Performance..." -ForegroundColor Yellow
    $container = [Container]::new()
    $container.Initialize($global:ServiceContainer)
    
    # Add many focusable children
    for ($i = 0; $i -lt 50; $i++) {
        $btn = [MinimalButton]::new("Button $i")
        $btn.Initialize($global:ServiceContainer)
        $container.AddChild($btn)
    }
    
    $sw.Restart()
    $focusables = $focusManager.GetFocusableChildren($container)
    $collectTime = $sw.ElapsedMilliseconds
    
    Write-Host "   Collected 50 focusable elements in ${collectTime}ms" -ForegroundColor Green
    Write-Host "   TabIndex sorting supported" -ForegroundColor Green
    Write-Host ""
    
    Write-Host "All tests completed successfully!" -ForegroundColor Green
    Write-Host ""
    Write-Host "Press any key to launch the Minimal UI Showcase..." -ForegroundColor Cyan
    [Console]::ReadKey($true) | Out-Null
    
    # Launch showcase
    [Console]::Clear()
    $screenManager = [ScreenManager]::new($global:ServiceContainer)
    $global:ScreenManager = $screenManager
    
    $showcase = [MinimalShowcaseScreen]::new()
    $screenManager.Push($showcase)
    $screenManager.Run()
    
} catch {
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkGray
} finally {
    [Console]::CursorVisible = $true
    [Console]::Clear()
}


####\test-screen-input.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen HandleScreenInput method
Write-Host "Testing CommandLibraryScreen HandleScreenInput..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    # Test HandleScreenInput method
    Write-Host "Testing HandleScreenInput method..." -ForegroundColor Yellow
    
    # Test 'n' key
    $nKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    $handled = $screen.HandleScreenInput($nKey)
    Write-Host "HandleScreenInput('n') returned: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'e' key  
    $eKey = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
    $handled = $screen.HandleScreenInput($eKey)
    Write-Host "HandleScreenInput('e') returned: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'd' key
    $dKey = [System.ConsoleKeyInfo]::new('d', [System.ConsoleKey]::D, $false, $false, $false)
    $handled = $screen.HandleScreenInput($dKey)
    Write-Host "HandleScreenInput('d') returned: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test full HandleInput flow (should try child first, then screen shortcuts)
    Write-Host "`nTesting full HandleInput flow..." -ForegroundColor Yellow
    
    # First, child (SearchableListBox) should NOT handle n/e/d
    $childHandled = $screen.CommandList.HandleInput($nKey)
    Write-Host "Child CommandList.HandleInput('n'): $childHandled" -ForegroundColor $(if (-not $childHandled) { "Green" } else { "Red" })
    
    # Then, screen HandleInput should handle it via shortcuts
    $screenHandled = $screen.HandleInput($nKey)
    Write-Host "Screen HandleInput('n'): $screenHandled" -ForegroundColor $(if ($screenHandled) { "Green" } else { "Red" })
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-searchable-with-actions.ps1
#!/usr/bin/env pwsh

# Test SearchableListBox with actual actions to isolate the issue
param([switch]$LoadOnly)

# Load minimal components needed for test
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Models/BaseAction.ps1"
. "$PSScriptRoot/Actions/SummarizationAction.ps1"
. "$PSScriptRoot/Components/ListBox.ps1"
. "$PSScriptRoot/Components/SearchableListBox.ps1"

Write-Host "Testing SearchableListBox with actions..." -ForegroundColor Green

# Set up minimal services
$global:PraxisRoot = $PSScriptRoot
$global:ServiceContainer = [ServiceContainer]::new()

$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

try {
    Write-Host "Creating actions..." -ForegroundColor Yellow
    $actions = @()
    $actions += [SummarizationAction]::new()
    Write-Host " Created $($actions.Count) actions" -ForegroundColor Green
    
    Write-Host "Testing action GetDisplayText..." -ForegroundColor Yellow
    foreach ($action in $actions) {
        $displayText = $action.GetDisplayText()
        Write-Host "  Action: $displayText" -ForegroundColor Cyan
    }
    
    Write-Host "Creating SearchableListBox..." -ForegroundColor Yellow
    $listBox = [SearchableListBox]::new()
    $listBox.Title = "Test Actions"
    
    # Set up item renderer
    $listBox.ItemRenderer = {
        param($action)
        if (-not $action) { return "" }
        return $action.GetDisplayText()
    }
    
    Write-Host "Initializing SearchableListBox..." -ForegroundColor Yellow
    $listBox.Initialize($global:ServiceContainer)
    
    Write-Host "Setting items on SearchableListBox..." -ForegroundColor Yellow
    $listBox.SetItems($actions)
    
    Write-Host "SearchableListBox state:" -ForegroundColor Cyan
    Write-Host "  Items.Count: $($listBox.Items.Count)" -ForegroundColor DarkGray
    Write-Host "  _filteredItems.Count: $($listBox._filteredItems.Count)" -ForegroundColor DarkGray
    Write-Host "  SelectedIndex: $($listBox.SelectedIndex)" -ForegroundColor DarkGray
    
    if ($listBox.Items.Count -gt 0) {
        Write-Host " Items loaded successfully" -ForegroundColor Green
    } else {
        Write-Host " No items in SearchableListBox!" -ForegroundColor Red
    }
    
    if ($listBox._filteredItems.Count -gt 0) {
        Write-Host " Filtered items available" -ForegroundColor Green
    } else {
        Write-Host " No filtered items!" -ForegroundColor Red
    }
    
} catch {
    Write-Host " Test failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Cyan


####\test-shortcut-debug.ps1
#!/usr/bin/env pwsh

# Debug shortcut issue with CommandLibraryScreen
Write-Host "Debugging CommandLibraryScreen shortcuts..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    
    # Check screen type name
    $screenTypeName = $screen.GetType().Name
    Write-Host "Screen type name: '$screenTypeName'" -ForegroundColor Cyan
    
    # Check registered shortcuts
    $shortcutManager = $global:ServiceContainer.GetService('ShortcutManager')
    $shortcuts = $shortcutManager.GetShortcuts([ShortcutScope]::Screen, "CommandLibraryScreen")
    
    Write-Host "`nShortcuts registered for 'CommandLibraryScreen':" -ForegroundColor Yellow
    foreach ($shortcut in $shortcuts) {
        Write-Host "  $($shortcut.Id): '$($shortcut.KeyChar)' -> $($shortcut.Name)" -ForegroundColor Cyan
    }
    
    # Test if ShortcutManager would find these shortcuts
    Write-Host "`nTesting shortcut matching..." -ForegroundColor Yellow
    $nKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    
    # Simulate what ScreenManager would pass
    $handled = $shortcutManager.HandleKeyPress($nKey, $screenTypeName, "")
    Write-Host "Key 'n' handled by ShortcutManager: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Check if there are conflicting shortcuts
    $allShortcuts = $shortcutManager.GetAllShortcuts()
    $nShortcuts = $allShortcuts | Where-Object { $_.KeyChar -eq 'n' }
    
    Write-Host "`nAll shortcuts with key 'n':" -ForegroundColor Yellow
    foreach ($shortcut in $nShortcuts) {
        Write-Host "  $($shortcut.Id): Scope=$($shortcut.Scope) ScreenType='$($shortcut.ScreenType)' Priority=$($shortcut.Priority)" -ForegroundColor Cyan
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-shortcut-fix.ps1
#!/usr/bin/env pwsh

# Test SearchableListBox shortcut key exclusion
Write-Host "Testing SearchableListBox shortcut key exclusion..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating SearchableListBox..." -ForegroundColor Yellow
    $listBox = [SearchableListBox]::new()
    $listBox.SetItems(@("Item 1", "Item 2", "Item 3"))
    
    Write-Host "ExcludedSearchKeys: $($listBox.ExcludedSearchKeys -join ', ')" -ForegroundColor Cyan
    
    # Test excluded keys
    $excludedKeys = @('n', 'e', 'd')
    foreach ($keyChar in $excludedKeys) {
        $key = [System.ConsoleKeyInfo]::new($keyChar, [System.ConsoleKey]::($keyChar.ToString().ToUpper()), $false, $false, $false)
        $handled = $listBox.HandleInput($key)
        
        Write-Host "Key '$keyChar' handled by SearchableListBox: $handled" -ForegroundColor $(if (-not $handled) { "Green" } else { "Red" })
        Write-Host "  Search mode active: $($listBox._searchMode)" -ForegroundColor Cyan
        Write-Host "  Search query: '$($listBox.SearchQuery)'" -ForegroundColor Cyan
    }
    
    # Test non-excluded key
    Write-Host "`nTesting non-excluded key 's'..." -ForegroundColor Yellow
    $sKey = [System.ConsoleKeyInfo]::new('s', [System.ConsoleKey]::S, $false, $false, $false)
    $handled = $listBox.HandleInput($sKey)
    
    Write-Host "Key 's' handled by SearchableListBox: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    Write-Host "  Search mode active: $($listBox._searchMode)" -ForegroundColor Cyan
    Write-Host "  Search query: '$($listBox.SearchQuery)'" -ForegroundColor Cyan
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-simple-dialog.ps1
#!/usr/bin/env pwsh

# Simple test of CommandEditDialog functionality
Write-Host "Testing CommandEditDialog functionality..." -ForegroundColor Cyan

# Manual class loading for testing
try {
    # Load core dependencies
    . "$PSScriptRoot/Base/UIElement.ps1"
    . "$PSScriptRoot/Base/Container.ps1"
    . "$PSScriptRoot/Base/Screen.ps1"
    . "$PSScriptRoot/Base/BaseDialog.ps1"
    . "$PSScriptRoot/Components/TextBox.ps1"
    . "$PSScriptRoot/Components/Button.ps1"
    . "$PSScriptRoot/Screens/CommandEditDialog.ps1"
    
    Write-Host "Classes loaded successfully" -ForegroundColor Green
    
    # Test methods directly
    Write-Host "Testing SaveCommand logic..." -ForegroundColor Yellow
    
    # Create a mock dialog object for testing
    $mockCommandService = [PSCustomObject]@{
        AddCommand = { 
            param($title, $desc, $tags, $group, $text)
            Write-Host "  AddCommand called with: $text" -ForegroundColor Cyan
            return [PSCustomObject]@{ Id = "test-id"; CommandText = $text }
        }
    }
    
    # Test the logic without actual UI
    $commandText = "echo 'test command'"
    if ([string]::IsNullOrWhiteSpace($commandText)) {
        Write-Host "  Command text validation failed" -ForegroundColor Red
    } else {
        Write-Host "   Command text validation passed" -ForegroundColor Green
    }
    
    # Test tag parsing
    $tagsText = "test, example, demo"
    $tags = $tagsText -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
    Write-Host "   Tags parsed: $($tags -join ', ')" -ForegroundColor Green
    
    Write-Host " Dialog logic tests passed!" -ForegroundColor Green
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-simple-editor.ps1
#!/usr/bin/env pwsh

# Simple test for DocumentBuffer and Commands
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load minimal components
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Testing DocumentBuffer and Command Pattern..." -ForegroundColor Green

# Test DocumentBuffer
Write-Host "`n1. Testing DocumentBuffer:" -ForegroundColor Yellow
$buffer = [DocumentBuffer]::new()
Write-Host "    DocumentBuffer created"
Write-Host "   Initial line count: $($buffer.GetLineCount())"
Write-Host "   First line: '$($buffer.GetLine(0))'"

# Test InsertTextCommand
Write-Host "`n2. Testing InsertTextCommand:" -ForegroundColor Yellow
$insertCmd = [InsertTextCommand]::new(0, 0, "Hello World")
$buffer.ExecuteCommand($insertCmd)
Write-Host "    Insert command executed"
Write-Host "   Line after insert: '$($buffer.GetLine(0))'"
Write-Host "   Is modified: $($buffer.IsModified)"

# Test Undo
Write-Host "`n3. Testing Undo:" -ForegroundColor Yellow
Write-Host "   Can undo: $($buffer.CanUndo())"
$buffer.Undo()
Write-Host "    Undo executed"
Write-Host "   Line after undo: '$($buffer.GetLine(0))'"
Write-Host "   Can redo: $($buffer.CanRedo())"

# Test Redo
Write-Host "`n4. Testing Redo:" -ForegroundColor Yellow
$buffer.Redo()
Write-Host "    Redo executed"
Write-Host "   Line after redo: '$($buffer.GetLine(0))'"

# Test DeleteTextCommand
Write-Host "`n5. Testing DeleteTextCommand:" -ForegroundColor Yellow
$deleteCmd = [DeleteTextCommand]::new(0, 0, "Hello")
$buffer.ExecuteCommand($deleteCmd)
Write-Host "    Delete command executed"
Write-Host "   Line after delete: '$($buffer.GetLine(0))'"

# Test InsertNewlineCommand
Write-Host "`n6. Testing InsertNewlineCommand:" -ForegroundColor Yellow
$newlineCmd = [InsertNewlineCommand]::new(0, 3, "")
$buffer.ExecuteCommand($newlineCmd)
Write-Host "    Newline command executed"
Write-Host "   Line count: $($buffer.GetLineCount())"
Write-Host "   Line 0: '$($buffer.GetLine(0))'"
Write-Host "   Line 1: '$($buffer.GetLine(1))'"

# Test file operations
Write-Host "`n7. Testing file operations:" -ForegroundColor Yellow
$testFile = "$PSScriptRoot/test-buffer.txt"

try {
    $buffer.SaveToFile($testFile)
    Write-Host "    File saved successfully"
    
    $buffer2 = [DocumentBuffer]::new($testFile)
    Write-Host "    File loaded successfully"
    Write-Host "   Loaded line count: $($buffer2.GetLineCount())"
    Write-Host "   Loaded line 0: '$($buffer2.GetLine(0))'"
    Write-Host "   Loaded line 1: '$($buffer2.GetLine(1))'"
    
    Remove-Item -Path $testFile -Force
    Write-Host "    Test file cleaned up"
} catch {
    Write-Host "    File operation failed: $_" -ForegroundColor Red
}

Write-Host "`nAll core tests completed successfully! " -ForegroundColor Green
Write-Host "Buffer/View architecture and Command Pattern are working." -ForegroundColor Cyan


####\test-tab7-bounds.ps1
#!/usr/bin/env pwsh

Write-Host "Testing tab 7 bounds by starting PRAXIS, going to tab 7, and checking logs..." -ForegroundColor Cyan

# Start PRAXIS in background
$job = Start-Job -ScriptBlock {
    Set-Location $using:PSScriptRoot
    . "./Start.ps1" -Debug
}

# Wait for startup
Start-Sleep -Seconds 3

# Try to send key 7 to switch to tab 7 (this might not work reliably)
Write-Host "PRAXIS should be running. Manually press '7' to go to tab 7, then 'q' to quit." -ForegroundColor Yellow
Write-Host "Press Enter here when you've tested tab 7..." -ForegroundColor Green
Read-Host

# Stop the job
Stop-Job $job -Force
Remove-Job $job -Force

# Check recent logs for VisualMacroFactory
Write-Host "`nRecent VisualMacroFactory log entries:" -ForegroundColor Cyan
$logContent = Get-Content "/home/teej/projects/github/praxis/_Logs/praxis.log" -Tail 100
$relevantEntries = $logContent | Where-Object { $_ -match "VisualMacroFactory|LoadAvailable|ComponentLibrary|OnBoundsChanged.*Width" }

if ($relevantEntries) {
    $relevantEntries | ForEach-Object { Write-Host $_ -ForegroundColor Yellow }
} else {
    Write-Host "No VisualMacroFactory entries found in recent logs" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Cyan


####\test-tab7-debug.ps1
#!/usr/bin/env pwsh

# Test tab 7 initialization with debug output
Write-Host "Starting PRAXIS with debug to test Tab 7 initialization..." -ForegroundColor Cyan
Write-Host "This will:" -ForegroundColor Yellow
Write-Host "1. Start PRAXIS with debug mode" -ForegroundColor Green
Write-Host "2. Automatically switch to tab 7 (Macro Factory)" -ForegroundColor Green 
Write-Host "3. Show debug logs to see what's happening" -ForegroundColor Green
Write-Host "4. Auto-quit after 5 seconds" -ForegroundColor Green
Write-Host ""

# Start PRAXIS with debug and capture output
$process = Start-Process -FilePath "pwsh" -ArgumentList "-File", "$PSScriptRoot/Start.ps1", "-Debug" -PassThru -RedirectStandardOutput "$PSScriptRoot/debug-output.txt" -RedirectStandardError "$PSScriptRoot/debug-error.txt"

# Wait a moment for startup
Start-Sleep -Seconds 2

# Send key to switch to tab 7
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.SendKeys]::SendWait("7")

# Wait a moment for tab switch
Start-Sleep -Seconds 2

# Send quit command
[System.Windows.Forms.SendKeys]::SendWait("q")

# Wait for process to end
$process.WaitForExit(5000)

# Show debug output
Write-Host "Debug Output:" -ForegroundColor Cyan
Get-Content "$PSScriptRoot/debug-output.txt" | Select-Object -Last 50

Write-Host "`nError Output:" -ForegroundColor Red
Get-Content "$PSScriptRoot/debug-error.txt" | Select-Object -Last 20

# Clean up
Remove-Item "$PSScriptRoot/debug-output.txt" -ErrorAction SilentlyContinue
Remove-Item "$PSScriptRoot/debug-error.txt" -ErrorAction SilentlyContinue


####\test-texteditor-new.ps1
#!/usr/bin/env pwsh

# Test script for the new text editor architecture
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load essential components only
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize minimal services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

Write-Host "Testing new TextEditorScreenNew architecture..." -ForegroundColor Green

# Test DocumentBuffer
Write-Host "`n1. Testing DocumentBuffer:" -ForegroundColor Yellow
$buffer = [DocumentBuffer]::new()
Write-Host "    DocumentBuffer created, line count: $($buffer.GetLineCount())"

# Test commands
Write-Host "   Testing InsertTextCommand..."
$insertCmd = [InsertTextCommand]::new(0, 0, "Hello World")
$buffer.ExecuteCommand($insertCmd)
Write-Host "    Insert command executed: '$($buffer.GetLine(0))'"

Write-Host "   Testing undo..."
$buffer.Undo()
Write-Host "    Undo executed: '$($buffer.GetLine(0))'"

Write-Host "   Testing redo..."
$buffer.Redo()
Write-Host "    Redo executed: '$($buffer.GetLine(0))'"

# Test newline command
Write-Host "   Testing newline command..."
$newlineCmd = [InsertNewlineCommand]::new(0, 5, "")
$buffer.ExecuteCommand($newlineCmd)
Write-Host "    Newline inserted, line count: $($buffer.GetLineCount())"
Write-Host "     Line 0: '$($buffer.GetLine(0))'"
Write-Host "     Line 1: '$($buffer.GetLine(1))'"

# Test TextEditorScreen
Write-Host "`n2. Testing TextEditorScreenNew:" -ForegroundColor Yellow
$editor = [TextEditorScreenNew]::new()
$editor.Initialize($global:ServiceContainer)
Write-Host "    TextEditorScreenNew created and initialized"

# Test bounds and rendering
$editor.SetBounds(0, 0, 80, 24)
Write-Host "    Bounds set to 80x24"

try {
    $renderOutput = $editor.Render()
    Write-Host "    Render successful, output length: $($renderOutput.Length)"
} catch {
    Write-Host "    Render failed: $_" -ForegroundColor Red
}

Write-Host "`n3. Testing file operations:" -ForegroundColor Yellow
$testFile = "$PSScriptRoot/test-editor-content.txt"

# Create test content
$testContent = @"
Line 1: Hello World
Line 2: This is a test
Line 3: New architecture works!
"@

Set-Content -Path $testFile -Value $testContent
Write-Host "    Test file created: $testFile"

# Test file loading
$editorWithFile = [TextEditorScreenNew]::new($testFile)
Write-Host "    Editor with file created"
Write-Host "     Lines loaded: $($editorWithFile._buffer.GetLineCount())"
Write-Host "     First line: '$($editorWithFile._buffer.GetLine(0))'"

# Clean up
Remove-Item -Path $testFile -Force
Write-Host "    Test file cleaned up"

Write-Host "`nAll tests completed successfully! " -ForegroundColor Green
Write-Host "New text editor architecture is working." -ForegroundColor Cyan


####\test-typing-undo.ps1
#!/usr/bin/env pwsh

# Test typing and undo scenario
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load essential components
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

Write-Host "Testing typing and undo scenario..." -ForegroundColor Yellow

# Create editor like PRAXIS does
$editor = [TextEditorScreenNew]::new()
$editor.Initialize($global:ServiceContainer)
$editor.SetBounds(0, 0, 80, 24)

Write-Host " Editor created and initialized"
Write-Host "Initial cursor position: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "Buffer line count: $($editor._buffer.GetLineCount())"
Write-Host "Can undo: $($editor._buffer.CanUndo())"

# Simulate typing some text
Write-Host "`nSimulating typing 'Hello'..."
$testChars = @('H', 'e', 'l', 'l', 'o')
foreach ($char in $testChars) {
    $keyInfo = [System.ConsoleKeyInfo]::new($char, [System.ConsoleKey]::$char, $false, $false, $false)
    try {
        $handled = $editor.HandleScreenInput($keyInfo)
        Write-Host "  Typed '$char', handled: $handled"
    } catch {
        Write-Host "   Error typing '$char': $_" -ForegroundColor Red
    }
}

Write-Host "After typing:"
Write-Host "  Cursor position: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
Write-Host "  Can undo: $($editor._buffer.CanUndo())"

# Try to undo
Write-Host "`nTesting undo..."
try {
    $editor.UndoEdit()
    Write-Host " Undo 1 completed"
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
    
    $editor.UndoEdit()
    Write-Host " Undo 2 completed" 
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
    
} catch {
    Write-Host " Undo crashed: $_" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-undo-debug.ps1
#!/usr/bin/env pwsh

# Debug script for undo crash
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load minimal components
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Testing undo crash scenario..." -ForegroundColor Red

# Create buffer like TextEditorScreenNew does
$buffer = [DocumentBuffer]::new()
Write-Host "Initial buffer created with $($buffer.GetLineCount()) lines"

# Simulate AddSampleContent
$sampleLines = @("Line 1", "Line 2", "Line 3")
$buffer.Lines.Clear()
foreach ($line in $sampleLines) {
    $buffer.Lines.Add($line) | Out-Null
}
$buffer.ClearUndoHistory()
$buffer.IsModified = $false

Write-Host "Sample content added: $($buffer.GetLineCount()) lines"
Write-Host "Can undo: $($buffer.CanUndo())"
Write-Host "Can redo: $($buffer.CanRedo())"

# Try to undo - this should be safe since we cleared history
Write-Host "`nTrying to undo (should be safe)..."
try {
    $buffer.Undo()
    Write-Host " Undo completed successfully"
} catch {
    Write-Host " Undo crashed: $_" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
}

# Now add some real content and try undo
Write-Host "`nAdding real content via command..."
$insertCmd = [InsertTextCommand]::new(0, 0, "TEST")
$buffer.ExecuteCommand($insertCmd)
Write-Host "Line 0 after insert: '$($buffer.GetLine(0))'"
Write-Host "Can undo: $($buffer.CanUndo())"

# Try to undo the real command
Write-Host "`nTrying to undo real command..."
try {
    $buffer.Undo()
    Write-Host " Undo completed successfully"
    Write-Host "Line 0 after undo: '$($buffer.GetLine(0))'"
} catch {
    Write-Host " Undo crashed: $_" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}


####\test-vmf-screen.ps1
#!/usr/bin/env pwsh

# Test VisualMacroFactoryScreen initialization
param([switch]$LoadOnly)

# Load necessary components
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"

# Services needed for initialization
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Services/ShortcutManager.ps1"
. "$PSScriptRoot/Services/CommandService.ps1"
. "$PSScriptRoot/Services/FunctionRegistry.ps1"
. "$PSScriptRoot/Services/MacroContextManager.ps1"

# Base classes
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Base/BaseModel.ps1"

# Models
. "$PSScriptRoot/Models/BaseAction.ps1"
. "$PSScriptRoot/Models/Command.ps1"

# Actions
. "$PSScriptRoot/Actions/CustomIdeaCommandAction.ps1"
. "$PSScriptRoot/Actions/SummarizationAction.ps1"
. "$PSScriptRoot/Actions/AppendFieldAction.ps1"
. "$PSScriptRoot/Actions/ExportToExcelAction.ps1"

# Components
. "$PSScriptRoot/Components/SearchableListBox.ps1"
. "$PSScriptRoot/Components/DataGrid.ps1"

# VisualMacroFactoryScreen
. "$PSScriptRoot/Screens/VisualMacroFactoryScreen.ps1"

Write-Host "Testing VisualMacroFactoryScreen initialization..." -ForegroundColor Green

# Initialize global ServiceContainer
$global:ServiceContainer = [ServiceContainer]::new()

# Create required services
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)

$commandService = [CommandService]::new()
$global:ServiceContainer.Register("CommandService", $commandService)

try {
    Write-Host "Creating VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen = [VisualMacroFactoryScreen]::new()
    Write-Host " VisualMacroFactoryScreen created successfully" -ForegroundColor Green
    
    Write-Host "Initializing VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen.Initialize($global:ServiceContainer)
    Write-Host " VisualMacroFactoryScreen initialized successfully" -ForegroundColor Green
    
    Write-Host "Checking AvailableActions count: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    if ($screen.AvailableActions.Count -gt 0) {
        Write-Host " Actions loaded successfully" -ForegroundColor Green
        foreach ($action in $screen.AvailableActions) {
            Write-Host "  - $($action.Name)" -ForegroundColor DarkGray
        }
    } else {
        Write-Host " No actions loaded!" -ForegroundColor Red
    }
    
} catch {
    Write-Host " VisualMacroFactoryScreen failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nVisualMacroFactoryScreen test completed!" -ForegroundColor Cyan


