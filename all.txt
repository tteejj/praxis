####\Base/Container.ps1
# Container.ps1 - Base class for components that contain other components
# Optimized for fast string aggregation

class Container : UIElement {
    # Optional background
    [bool]$DrawBackground = $false
    hidden [string]$_cachedBackground = ""
    hidden [string]$_cachedBgColor = ""
    hidden [ThemeManager]$Theme
    
    Container() : base() {
    }
    
    # Initialize method for containers that need it
    [void] Initialize([ServiceContainer]$services) {
        # Get theme service if available
        try {
            $this.Theme = $services.GetService("ThemeManager")
        } catch {
            # Theme not available yet, ignore
        }
        
        # Derived classes can override for additional initialization
    }
    
    # Efficient child rendering with string builder
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Draw background if enabled
        if ($this.DrawBackground -and $this._cachedBackground) {
            $sb.Append($this._cachedBackground)
        }
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        return $sb.ToString()
    }
    
    # Pre-compute background
    [void] SetBackgroundColor([string]$ansiColor) {
        $this._cachedBgColor = $ansiColor
        $this.InvalidateBackground()
    }
    
    [void] InvalidateBackground() {
        if (-not $this.DrawBackground -or $this.Width -le 0 -or $this.Height -le 0) { 
            $this._cachedBackground = ""
            return 
        }
        
        $sb = [System.Text.StringBuilder]::new()
        $line = " " * $this.Width
        
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            if ($this._cachedBgColor) {
                $sb.Append($this._cachedBgColor)
            }
            $sb.Append($line)
        }
        
        if ($this._cachedBgColor) {
            $sb.Append([VT]::Reset())
        }
        
        $this._cachedBackground = $sb.ToString()
    }
    
    [void] OnBoundsChanged() {
        # Recalculate background when size changes
        if ($this.DrawBackground) {
            $this.InvalidateBackground()
        }
        
        # Let derived classes handle child layout
        $this.LayoutChildren()
    }
    
    # Override in derived classes for custom layouts
    [void] LayoutChildren() {
        # Base implementation does nothing
        # Derived classes like HorizontalSplit, VerticalSplit, etc. will implement
    }
    
    # Find child at specific coordinates
    [UIElement] HitTest([int]$x, [int]$y) {
        # Check if point is within our bounds
        if ($x -lt $this.X -or $x -ge ($this.X + $this.Width) -or
            $y -lt $this.Y -or $y -ge ($this.Y + $this.Height)) {
            return $null
        }
        
        # Check children in reverse order (top to bottom)
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                $hit = if ($child -is [Container]) {
                    $child.HitTest($x, $y)
                } else {
                    # Non-containers do simple bounds check
                    if ($x -ge $child.X -and $x -lt ($child.X + $child.Width) -and
                        $y -ge $child.Y -and $y -lt ($child.Y + $child.Height)) {
                        $child
                    } else {
                        $null
                    }
                }
                
                if ($hit) { return $hit }
            }
        }
        
        # No child hit, return self
        return $this
    }
    
    # Route input to focused child
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Type=$($this.GetType().Name)")
        }
        
        # First try focused child
        $focused = $this.FindFocused()
        if ($global:Logger -and $focused) {
            $global:Logger.Debug("Container: Focused child is $($focused.GetType().Name)")
        }
        
        if ($focused -and $focused -ne $this) {
            if ($focused.HandleInput($key)) {
                if ($global:Logger) {
                    $global:Logger.Debug("Container: Input handled by focused child")
                }
                return $true
            }
        }
        
        # If no child is focused but we have children, try the first focusable one
        if (-not $focused -and $this.Children.Count -gt 0) {
            if ($global:Logger) {
                $global:Logger.Debug("Container: No focused child, trying to focus first focusable")
            }
            foreach ($child in $this.Children) {
                if ($child.IsFocusable -and $child.Visible) {
                    $child.Focus()
                    if ($child.HandleInput($key)) {
                        return $true
                    }
                }
            }
        }
        
        # Then handle at this level
        return $false
    }
}


####\Base/Screen.ps1
# Screen.ps1 - Base class for all screens
# Simplified from ALCAR with focus on speed

class Screen : Container {
    [string]$Title = "Screen"
    [bool]$Active = $true
    hidden [hashtable]$_keyBindings = @{}
    hidden [ThemeManager]$Theme
    
    Screen() : base() {
        $this.IsFocusable = $true
        $this.DrawBackground = $true
    }
    
    # Initialize with services
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
        $this.OnInitialize()
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Theme change handler
    [void] OnThemeChanged() {
        $this.SetBackgroundColor($this.Theme.GetColor("background"))
        $this.Invalidate()
    }
    
    # Key binding management
    [void] BindKey([object]$key, [scriptblock]$action) {
        if ($key -is [System.ConsoleKey]) {
            $this._keyBindings[$key] = $action
        } elseif ($key -is [char]) {
            $this._keyBindings[[int]$key] = $action
        } elseif ($key -is [string] -and $key.Length -eq 1) {
            $this._keyBindings[[int]$key[0]] = $action
        } else {
            throw "Invalid key type for binding"
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($global:Logger) {
            $global:Logger.Debug("Screen.HandleInput: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)'")
        }
        
        # Check key bindings
        if ($this._keyBindings.ContainsKey($keyInfo.Key)) {
            if ($global:Logger) {
                $global:Logger.Debug("Screen: Found key binding for $($keyInfo.Key)")
            }
            & $this._keyBindings[$keyInfo.Key]
            return $true
        }
        
        # Check char bindings
        if ($keyInfo.KeyChar) {
            $charCode = [int]$keyInfo.KeyChar
            if ($this._keyBindings.ContainsKey($charCode)) {
                if ($global:Logger) {
                    $global:Logger.Debug("Screen: Found char binding for '$($keyInfo.KeyChar)'")
                }
                & $this._keyBindings[$charCode]
                return $true
            }
        }
        
        # Let base class handle it
        return ([Container]$this).HandleInput($keyInfo)
    }
    
    # Lifecycle methods
    [void] OnActivated() {
        # Force a render when screen is activated
        $this.Invalidate()
    }
    [void] OnDeactivated() {}
    
    # Request a re-render
    [void] RequestRender() {
        $this.Invalidate()
        # The ScreenManager will handle the actual rendering
    }
}


####\Base/UIElement.ps1
# UIElement.ps1 - Fast base class for all UI components
# Inspired by AxiomPhoenix architecture but optimized for string-based rendering

class UIElement {
    # Position and dimensions
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 0
    [int]$Height = 0
    
    # Visibility and focus
    [bool]$Visible = $true
    [bool]$IsFocusable = $false
    [bool]$IsFocused = $false
    [int]$TabIndex = 0
    
    # Hierarchy
    [UIElement]$Parent = $null
    [System.Collections.Generic.List[UIElement]]$Children
    
    # Caching for maximum speed
    hidden [string]$_renderCache = ""
    hidden [bool]$_cacheInvalid = $true
    
    # Pre-computed values
    hidden [string]$_cachedPosition = ""
    hidden [string]$_cachedClear = ""
    
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Fast render - returns cached string if valid
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        if ($this._cacheInvalid) {
            # Rebuild cache only when needed
            $this._renderCache = $this.OnRender()
            $this._cacheInvalid = $false
        }
        
        return $this._renderCache
    }
    
    # Override in derived classes
    [string] OnRender() {
        return ""
    }
    
    # Mark this element (and parents) as needing re-render
    [void] Invalidate() {
        if ($this._cacheInvalid) { return }  # Already invalid
        
        $this._cacheInvalid = $true
        $this.InvalidatePosition()  # Position might have changed too
        
        
        # Propagate up the tree
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
    }
    
    # Pre-compute position strings
    [void] InvalidatePosition() {
        # Pre-compute ANSI sequences for this element's position
        $this._cachedPosition = [VT]::MoveTo($this.X, $this.Y)
        
        # Pre-compute clear sequence for this element's area
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $clearLine = " " * $this.Width
            $clearSeq = [System.Text.StringBuilder]::new()
            for ($i = 0; $i -lt $this.Height; $i++) {
                $clearSeq.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $clearSeq.Append($clearLine)
            }
            $this._cachedClear = $clearSeq.ToString()
        } else {
            $this._cachedClear = ""
        }
    }
    
    # Layout management
    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($this.X -eq $x -and $this.Y -eq $y -and 
            $this.Width -eq $width -and $this.Height -eq $height) {
            return  # No change
        }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        
        $this.InvalidatePosition()
        $this.Invalidate()
        $this.OnBoundsChanged()
    }
    
    # Override for custom layout logic
    [void] OnBoundsChanged() {
        # Base implementation does nothing
    }
    
    # Child management
    [void] AddChild([UIElement]$child) {
        $child.Parent = $this
        $this.Children.Add($child)
        $this.Invalidate()
    }
    
    [void] RemoveChild([UIElement]$child) {
        $child.Parent = $null
        $this.Children.Remove($child)
        $this.Invalidate()
    }
    
    # Focus management
    [void] Focus() {
        if (-not $this.IsFocusable) { 
            if ($global:Logger) {
                $global:Logger.Debug("UIElement.Focus: $($this.GetType().Name) is not focusable")
            }
            return 
        }
        
        # If already focused, nothing to do
        if ($this.IsFocused) {
            if ($global:Logger) {
                $global:Logger.Debug("UIElement.Focus: $($this.GetType().Name) is already focused")
            }
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("UIElement.Focus: Focusing $($this.GetType().Name)")
        }
        
        # Unfocus currently focused element
        $root = $this.GetRoot()
        $focused = $root.FindFocused()
        if ($focused -and $focused -ne $this) {
            if ($global:Logger) {
                $global:Logger.Debug("UIElement.Focus: Unfocusing $($focused.GetType().Name)")
            }
            $focused.IsFocused = $false
            $focused.OnLostFocus()
            $focused.Invalidate()
        }
        
        $this.IsFocused = $true
        $this.OnGotFocus()
        $this.Invalidate()
        
        if ($global:Logger) {
            $global:Logger.Debug("UIElement.Focus: $($this.GetType().Name) is now focused")
        }
    }
    
    [UIElement] GetRoot() {
        $current = $this
        while ($current.Parent) {
            $current = $current.Parent
        }
        return $current
    }
    
    [UIElement] FindFocused() {
        if ($this.IsFocused) { return $this }
        
        foreach ($child in $this.Children) {
            $focused = $child.FindFocused()
            if ($focused) { return $focused }
        }
        
        return $null
    }
    
    # Override for focus behavior
    [void] OnGotFocus() {}
    [void] OnLostFocus() {}
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Base implementation does nothing
        return $false
    }
}


####\Components/Button.ps1
# Button.ps1 - Fast button component with theming

class Button : UIElement {
    [string]$Text = "Button"
    [scriptblock]$OnClick = {}
    [bool]$IsDefault = $false
    
    # Cached rendering
    hidden [string]$_cachedRender = ""
    hidden [ThemeManager]$Theme
    
    Button() : base() {
        $this.IsFocusable = $true
        $this.Height = 3  # Default button height
    }
    
    Button([string]$text) : base() {
        $this.Text = $text
        $this.IsFocusable = $true
        $this.Height = 3
        if ($global:Logger) {
            $global:Logger.Debug("Button created with text: '$text'")
        }
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
        $this.Invalidate()  # Force initial render
    }
    
    [void] OnThemeChanged() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        # Debug logging
        if ($global:Logger) {
            $global:Logger.Debug("Button.RebuildCache: Text='$($this.Text)' Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Determine colors based on state
        $bgColor = ""
        $fgColor = ""
        $borderColor = ""
        
        if ($this.IsFocused) {
            $bgColor = $this.Theme.GetBgColor("button.focused.background")
            $fgColor = $this.Theme.GetColor("button.focused.foreground")
            $borderColor = $this.Theme.GetColor("border.focused")
        } else {
            $bgColor = $this.Theme.GetBgColor("button.background")
            $fgColor = $this.Theme.GetColor("button.foreground")
            $borderColor = $this.Theme.GetColor("border")
        }
        
        # Calculate text position (centered)
        $textX = $this.X + [Math]::Max(1, [int](($this.Width - $this.Text.Length) / 2))
        $textY = $this.Y + 1  # For height=3, text should be on the middle line
        
        if ($global:Logger -and $this.Text -eq "New Project") {
            $global:Logger.Debug("Button text position: textX=$textX, textY=$textY for button at ($($this.X),$($this.Y)) with height $($this.Height)")
        }
        
        # Draw button box
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $borderWidth = [Math]::Max(0, $this.Width - 2)
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::TL() + ([VT]::H() * $borderWidth) + [VT]::TR())
        } else {
            $sb.Append([VT]::TL() + [VT]::TR())
        }
        
        # Middle lines
        for ($y = $this.Y + 1; $y -lt $this.Y + $this.Height - 1; $y++) {
            if ($global:Logger -and $this.Text -eq "New Project") {
                $global:Logger.Debug("Button middle line: y=$y, textY=$textY, Text='$($this.Text)'")
            }
            
            $sb.Append([VT]::MoveTo($this.X, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Fill line with background, but handle text line specially
            if ($y -eq $textY -and $this.Text) {
                # Draw background up to text
                $sb.Append($bgColor)
                $textStartOffset = [Math]::Max(0, ($this.Width - $this.Text.Length) / 2) - 1
                if ($textStartOffset -gt 0) {
                    $sb.Append(" " * [int]$textStartOffset)
                }
                
                # Draw text
                $sb.Append($fgColor)
                $sb.Append($this.Text)
                
                # Fill rest of line
                $sb.Append($bgColor)
                $remainingSpace = $this.Width - 2 - [int]$textStartOffset - $this.Text.Length
                if ($remainingSpace -gt 0) {
                    $sb.Append(" " * $remainingSpace)
                }
            } else {
                # Non-text lines - just fill with background
                $sb.Append($bgColor)
                $paddingWidth = [Math]::Max(0, $this.Width - 2)
                if ($paddingWidth -gt 0) {
                    $sb.Append(" " * $paddingWidth)
                }
            }
            
            # Draw right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            $sb.Append([VT]::Reset())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::BL() + ([VT]::H() * $borderWidth) + [VT]::BR())
        } else {
            $sb.Append([VT]::BL() + [VT]::BR())
        }
        
        # Add default indicator if needed
        if ($this.IsDefault) {
            $sb.Append([VT]::MoveTo($this.X + 1, $this.Y))
            $sb.Append($this.Theme.GetColor("accent"))
            $sb.Append("*")
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [System.ConsoleKey]::Enter -or 
            $key.Key -eq [System.ConsoleKey]::Spacebar) {
            $this.Click()
            return $true
        }
        return $false
    }
    
    [void] Click() {
        if ($this.OnClick) {
            & $this.OnClick
        }
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/CommandPalette.ps1
# CommandPalette.ps1 - Fast command palette overlay

class CommandPalette : Container {
    [string]$SearchText = ""
    [ListBox]$ResultsList
    [System.Collections.ArrayList]$AllCommands
    [System.Collections.ArrayList]$FilteredCommands
    [scriptblock]$OnCommandSelected = {}
    [bool]$IsVisible = $false
    [EventBus]$EventBus
    
    # Layout
    hidden [int]$PaletteWidth = 60
    hidden [int]$PaletteHeight = 20
    hidden [int]$MaxResults = 15
    
    CommandPalette() : base() {
        $this.AllCommands = [System.Collections.ArrayList]::new()
        $this.FilteredCommands = [System.Collections.ArrayList]::new()
        $this.DrawBackground = $true
        
        # Create results list
        $this.ResultsList = [ListBox]::new()
        $this.ResultsList.ShowBorder = $false
        $this.ResultsList.ShowScrollbar = $true
        $this.ResultsList.ItemRenderer = {
            param($cmd)
            $name = $cmd.Name.PadRight(20)
            $desc = if ($cmd.Description.Length -gt 35) {
                $cmd.Description.Substring(0, 32) + "..."
            } else {
                $cmd.Description
            }
            return "$name $desc"
        }
        $this.AddChild($this.ResultsList)
    }
    
    [void] Initialize([ServiceContainer]$services) {
        # Call base initialization
        ([Container]$this).Initialize($services)
        
        # Get EventBus
        $this.EventBus = $services.GetService('EventBus')
        
        # Subscribe to command registration events
        if ($this.EventBus) {
            $this.EventBus.Subscribe([EventNames]::CommandRegistered, {
                param($sender, $eventData)
                if ($eventData.Name -and $eventData.Description -and $eventData.Action) {
                    $this.AddCommand($eventData.Name, $eventData.Description, $eventData.Action)
                }
            }.GetNewClosure())
        }
        
        # Initialize child components
        if ($this.ResultsList) {
            $this.ResultsList.Initialize($services)
        }
        
        # Set palette background if theme is available
        if ($this.Theme) {
            $this.SetBackgroundColor($this.Theme.GetBgColor("menu.background"))
        }
        
        # Load default commands
        $this.LoadDefaultCommands()
    }
    
    [void] LoadDefaultCommands() {
        # Store reference to this palette for use in scriptblocks
        $palette = $this
        
        # Add some default commands
        $this.AddCommand("new project", "Create a new project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new project command")
            }
            
            # Publish event to switch to projects tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
            }
            
            # Create and show the dialog
            $dialog = [NewProjectDialog]::new()
            $dialog.OnCreate = {
                param($project)
                if ($global:Logger) {
                    $global:Logger.Info("Creating project: $($project.Name)")
                }
                # Add project via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    # Use the AddProject method which creates the project properly
                    $nickname = $project.Name -replace '\s+', ''  # Remove spaces for nickname
                    $newProject = $projectService.AddProject($project.Name, $nickname)
                    
                    # Publish project created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::ProjectCreated, @{ Project = $newProject })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        $this.AddCommand("new task", "Create a new task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new task command")
            }
            
            # Publish event to switch to tasks tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
            }
            
            # Publish command to create new task
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'NewTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit project", "Edit selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit task", "Edit selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete project", "Delete selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete task", "Delete selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("search", "Search in files", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Search command executed")
            }
            # TODO: Implement search
        }.GetNewClosure())
        
        $this.AddCommand("settings", "Open settings", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Settings command executed")
            }
            # Switch to settings tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 3 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("eventbus monitor", "Open EventBus monitor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: EventBus monitor command executed")
            }
            # Open EventBus monitor dialog
            $monitor = [EventBusMonitor]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($monitor)
            }
        }.GetNewClosure())
        
        $this.AddCommand("reload", "Reload configuration", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Reload command executed")
            }
            # TODO: Implement reload
        }.GetNewClosure())
        
        $this.AddCommand("theme dark", "Switch to dark theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Dark theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        
        $this.AddCommand("theme light", "Switch to light theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Light theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        $this.AddCommand("quit", "Exit application", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quit command executed")
            }
            if ($global:ScreenManager) {
                $screen = $global:ScreenManager.GetActiveScreen()
                if ($screen) { 
                    $screen.Active = $false 
                }
            }
        }.GetNewClosure())
    }
    
    [void] AddCommand([string]$name, [string]$description, [scriptblock]$action) {
        $this.AllCommands.Add(@{
            Name = $name
            Description = $description
            Action = $action
        })
    }
    
    [void] Show() {
        $this.IsVisible = $true
        $this.SearchText = ""
        $this.UpdateFilter()
        $this.Invalidate()
        
        # Focus on results
        $this.ResultsList.Focus()
    }
    
    [void] Hide() {
        $this.IsVisible = $false
        $this.Invalidate()
        
        # Return focus to parent's active tab
        if ($this.Parent -and $this.Parent.GetType().Name -eq "MainScreen") {
            $activeTab = $this.Parent.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                $activeTab.Content.Focus()
            }
        }
    }
    
    [void] UpdateFilter() {
        $this.FilteredCommands.Clear()
        
        if ([string]::IsNullOrEmpty($this.SearchText)) {
            $this.FilteredCommands.AddRange($this.AllCommands)
        } else {
            # Simple fuzzy search
            $searchLower = $this.SearchText.ToLower()
            foreach ($cmd in $this.AllCommands) {
                if ($cmd.Name.ToLower().Contains($searchLower) -or 
                    $cmd.Description.ToLower().Contains($searchLower)) {
                    $this.FilteredCommands.Add($cmd)
                }
            }
        }
        
        # Update list
        $this.ResultsList.SetItems($this.FilteredCommands.ToArray())
    }
    
    [void] OnBoundsChanged() {
        # Center the palette
        $centerX = [int](($this.Width - $this.PaletteWidth) / 2)
        $centerY = [int](($this.Height - $this.PaletteHeight) / 2)
        
        # Update own bounds to be centered
        $this.X = $centerX
        $this.Y = $centerY
        $this.Width = $this.PaletteWidth
        $this.Height = $this.PaletteHeight
        
        # Layout results list (leave room for search box and border)
        $this.ResultsList.SetBounds(
            $this.X + 2,
            $this.Y + 4,
            $this.Width - 4,
            $this.Height - 6
        )
        
        # Recalculate visible items
        $this.ResultsList.VisibleItems = [Math]::Min($this.MaxResults, $this.Height - 6)
        
        ([Container]$this).OnBoundsChanged()
    }
    
    [string] OnRender() {
        if (-not $this.IsVisible) { return "" }
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Draw background first
        $sb.Append(([Container]$this).OnRender())
        
        # Draw border
        $borderColor = $this.Theme.GetColor("border.focused")
        
        # Top border with title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * 2))
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append(" Command Palette ")
        $sb.Append($borderColor)
        $sb.Append([VT]::H() * ($this.Width - 19) + [VT]::TR())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        
        # Search box
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 2))
        $sb.Append($this.Theme.GetColor("foreground"))
        $sb.Append("Search: ")
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append($this.SearchText)
        $sb.Append("_")
        
        # Separator
        $sb.Append([VT]::MoveTo($this.X + 1, $this.Y + 3))
        $sb.Append($borderColor)
        $sb.Append([VT]::H() * ($this.Width - 2))
        
        # Help text
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + $this.Height - 2))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append("[Enter] Select  [Esc] Cancel")
        
        $sb.Append([VT]::Reset())
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsVisible) { return $false }
        
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($global:Logger) {
                    $global:Logger.Debug("CommandPalette: Escape pressed, hiding palette")
                }
                try {
                    $this.Hide()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("CommandPalette: Error hiding palette: $_")
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.ResultsList.GetSelectedItem()
                if ($selected) {
                    if ($global:Logger) {
                        $global:Logger.Debug("CommandPalette: Executing command '$($selected.Name)'")
                    }
                    $this.Hide()
                    if ($selected.Action) {
                        try {
                            # Execute in the context of the CommandPalette
                            $selected.Action.Invoke()
                        } catch {
                            if ($global:Logger) {
                                $global:Logger.Error("CommandPalette: Error executing command '$($selected.Name)': $_")
                            }
                        }
                    }
                    if ($this.OnCommandSelected) {
                        & $this.OnCommandSelected $selected
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.SearchText.Length -gt 0) {
                    $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                    $this.UpdateFilter()
                    $this.Invalidate()
                }
                return $true
            }
            default {
                # Let list handle navigation
                if ($this.ResultsList.HandleInput($key)) {
                    return $true
                }
                
                # Add character to search
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or $key.KeyChar -eq ' ') {
                    $this.SearchText += $key.KeyChar
                    $this.UpdateFilter()
                    $this.Invalidate()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Components/DataGrid.ps1
# DataGrid.ps1 - Fast data grid component for tabular display
# Simplified from AxiomPhoenix with focus on performance

class DataGrid : UIElement {
    [System.Collections.ArrayList]$Items
    [hashtable[]]$Columns = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_headerCache = @{}
    hidden [bool]$_headerCacheValid = $false
    
    DataGrid() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        $this._headerCacheValid = $false
        $this.Invalidate()
    }
    
    # Set the columns for the grid
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this._headerCacheValid = $false
        $this.Invalidate()
    }
    
    # Set data items
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = if ($this.Items.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    # Get selected item
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    # Select specific index
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    # Ensure selected item is visible
    hidden [void] EnsureVisible() {
        if ($this.Items.Count -eq 0) { return }
        
        $contentHeight = $this.Height - 2  # Account for borders
        if ($this.ShowHeader) { $contentHeight-- }
        
        # Scroll up if selected is above visible area
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        # Scroll down if selected is below visible area
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $contentHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Ensure scroll offset is valid
        $maxScroll = [Math]::Max(0, $this.Items.Count - $contentHeight)
        $this.ScrollOffset = [Math]::Max(0, [Math]::Min($this.ScrollOffset, $maxScroll))
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Calculate content area
        $contentX = $this.X + 1
        $contentY = $this.Y + 1
        $contentWidth = $this.Width - 2
        $contentHeight = $this.Height - 2
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $borderColor = if ($this.IsFocused) { 
                $this.Theme.GetColor("border.focused") 
            } else { 
                $this.Theme.GetColor("border") 
            }
            
            # Top border with title
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL())
            
            if ($this.Title) {
                $titleText = " $($this.Title) "
                $titleLen = $titleText.Length
                $borderLen = $this.Width - 2
                $leftPad = [int](($borderLen - $titleLen) / 2)
                
                if ($leftPad -gt 0) {
                    $sb.Append([VT]::H() * $leftPad)
                }
                $sb.Append($this.Theme.GetColor("accent"))
                $sb.Append($titleText)
                $sb.Append($borderColor)
                $remainingBorder = [Math]::Max(0, $borderLen - $leftPad - $titleLen)
                if ($remainingBorder -gt 0) {
                    $sb.Append([VT]::H() * $remainingBorder)
                }
            } else {
                $topBorderWidth = [Math]::Max(0, $this.Width - 2)
                if ($topBorderWidth -gt 0) {
                    $sb.Append([VT]::H() * $topBorderWidth)
                }
            }
            
            $sb.Append([VT]::TR())
            
            # Side borders
            for ($i = 1; $i -lt $this.Height - 1; $i++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i))
                $sb.Append([VT]::V())
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
            $sb.Append([VT]::BL())
            $bottomBorderWidth = [Math]::Max(0, $this.Width - 2)
            if ($bottomBorderWidth -gt 0) {
                $sb.Append([VT]::H() * $bottomBorderWidth)
            }
            $sb.Append([VT]::BR())
            $sb.Append([VT]::Reset())
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
            $contentHeight = $this.Height
        }
        
        # Clear content area
        $bgColor = $this.Theme.GetBgColor("background")
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $sb.Append([VT]::MoveTo($contentX, $contentY + $y))
            $sb.Append($bgColor)
            $sb.Append(" " * $contentWidth)
        }
        
        $currentY = $contentY
        
        # Render header if enabled
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            $sb.Append([VT]::MoveTo($contentX, $currentY))
            $sb.Append($this.Theme.GetBgColor("header.background"))
            $sb.Append($this.Theme.GetColor("header.foreground"))
            
            $x = 0
            foreach ($col in $this.Columns) {
                $header = if ($col.Header) { $col.Header } else { $col.Name }
                $width = if ($col.Width) { $col.Width } else { 10 }
                
                # Ensure we don't overflow
                if ($x + $width -gt $contentWidth) {
                    $width = $contentWidth - $x
                }
                
                if ($width -gt 0) {
                    $text = if ($header.Length -gt $width) {
                        $header.Substring(0, $width - 1) + "…"
                    } else {
                        $header.PadRight($width)
                    }
                    $sb.Append($text)
                    $x += $width
                }
                
                if ($x -ge $contentWidth) { break }
            }
            
            # Fill remaining header space
            if ($x -lt $contentWidth) {
                $remaining = [Math]::Max(0, $contentWidth - $x)
                if ($remaining -gt 0) {
                    $sb.Append(" " * $remaining)
                }
            }
            
            $sb.Append([VT]::Reset())
            $currentY++
            $contentHeight--
        }
        
        # Render data rows
        $visibleRows = [Math]::Min($contentHeight, $this.Items.Count - $this.ScrollOffset)
        
        for ($i = 0; $i -lt $visibleRows; $i++) {
            $itemIndex = $this.ScrollOffset + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isSelected = ($itemIndex -eq $this.SelectedIndex)
            
            $sb.Append([VT]::MoveTo($contentX, $currentY + $i))
            
            if ($isSelected) {
                $sb.Append($this.Theme.GetBgColor("selection.background"))
                $sb.Append($this.Theme.GetColor("selection.foreground"))
            } else {
                $sb.Append($this.Theme.GetColor("foreground"))
            }
            
            # Render columns
            $x = 0
            foreach ($col in $this.Columns) {
                $width = if ($col.Width) { $col.Width } else { 10 }
                
                # Ensure we don't overflow
                if ($x + $width -gt $contentWidth) {
                    $width = $contentWidth - $x
                }
                
                if ($width -gt 0) {
                    # Get value using property name or custom getter
                    $value = ""
                    if ($col.Getter) {
                        $value = & $col.Getter $item
                    } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                        $value = $item.($col.Name)
                    }
                    
                    # Apply formatter if provided
                    if ($col.Formatter) {
                        $value = & $col.Formatter $value
                    }
                    
                    # Convert to string and truncate if needed
                    $text = $value.ToString()
                    if ($text.Length -gt $width) {
                        $text = $text.Substring(0, $width - 1) + "…"
                    } else {
                        $text = $text.PadRight($width)
                    }
                    
                    $sb.Append($text)
                    $x += $width
                }
                
                if ($x -ge $contentWidth) { break }
            }
            
            # Fill remaining row space
            if ($x -lt $contentWidth) {
                $remaining = [Math]::Max(0, $contentWidth - $x)
                if ($remaining -gt 0) {
                    $sb.Append(" " * $remaining)
                }
            }
        }
        
        # Clear remaining rows
        for ($i = $visibleRows; $i -lt $contentHeight; $i++) {
            $sb.Append([VT]::MoveTo($contentX, $currentY + $i))
            $sb.Append($this.Theme.GetColor("background"))
            $sb.Append(" " * $contentWidth)
        }
        
        # Show scroll indicator
        if ($this.Items.Count -gt $contentHeight) {
            $scrollBarX = $this.X + $this.Width - 1
            $scrollBarHeight = $contentHeight
            $scrollThumbSize = [Math]::Max(1, [int]($scrollBarHeight * $contentHeight / $this.Items.Count))
            $scrollThumbPos = [int]($this.ScrollOffset * ($scrollBarHeight - $scrollThumbSize) / ($this.Items.Count - $contentHeight))
            
            $sb.Append($this.Theme.GetColor("scrollbar"))
            for ($i = 0; $i -lt $scrollBarHeight; $i++) {
                $sb.Append([VT]::MoveTo($scrollBarX, $currentY + $i))
                if ($i -ge $scrollThumbPos -and $i -lt ($scrollThumbPos + $scrollThumbSize)) {
                    $sb.Append("█")
                } else {
                    $sb.Append("│")
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsFocused -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 2
                if ($this.ShowHeader) { $pageSize-- }
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 2
                if ($this.ShowHeader) { $pageSize-- }
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.EnsureVisible()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this.Invalidate()
    }
}


####\Components/ListBox.ps1
# ListBox.ps1 - Fast list box component with selection and scrolling

class ListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [int]$VisibleItems = 10
    [bool]$ShowBorder = $true
    [bool]$ShowScrollbar = $true
    
    # Display properties
    [scriptblock]$ItemRenderer = { param($item) $item.ToString() }
    [string]$Title = ""
    
    # Callback for selection changes
    [scriptblock]$OnSelectionChanged = {}
    
    # Cached rendering
    hidden [string]$_cachedItems = ""
    hidden [bool]$_itemsCacheInvalid = $true
    hidden [ThemeManager]$Theme
    
    ListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] SetItems([array]$items) {
        $oldIndex = $this.SelectedIndex
        $this.Items.Clear()
        $this.Items.AddRange($items)
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
        
        # Trigger callback if we have items and the selection changed
        if ($this.Items.Count -gt 0 -and ($oldIndex -ne 0 -or $this.Items.Count -eq 1) -and $this.OnSelectionChanged) {
            & $this.OnSelectionChanged
        }
    }
    
    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible($index)
            $this._itemsCacheInvalid = $true
            $this.Invalidate()
            
            # Trigger callback if selection actually changed
            if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
    }
    
    [void] EnsureVisible([int]$index) {
        # Adjust scroll to keep selected item visible
        $visibleEnd = $this.ScrollOffset + $this.VisibleItems - 1
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        } elseif ($index -gt $visibleEnd) {
            $this.ScrollOffset = $index - $this.VisibleItems + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # Recalculate visible items based on height
        $contentHeight = $this.Height
        if ($this.ShowBorder) { $contentHeight -= 2 }
        if ($this.Title) { $contentHeight -= 1 }
        
        $this.VisibleItems = [Math]::Max(1, $contentHeight)
        $this._itemsCacheInvalid = $true
    }
    
    [string] OnRender() {
        if ($this._itemsCacheInvalid) {
            $this.RebuildItemsCache()
        }
        return $this._cachedItems
    }
    
    [void] RebuildItemsCache() {
        $sb = [System.Text.StringBuilder]::new()
        
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($sb)
            $contentX++
            $contentY++
            $contentWidth -= 2
        }
        
        # Draw title if present
        if ($this.Title) {
            $sb.Append([VT]::MoveTo($contentX, $contentY))
            $sb.Append($this.Theme.GetColor("accent"))
            $titleText = $this.Title
            if ($titleText.Length -gt $contentWidth) {
                $titleText = $titleText.Substring(0, $contentWidth - 3) + "..."
            }
            $sb.Append($titleText)
            $sb.Append($this.Theme.GetColor("foreground"))
            $contentY++
        }
        
        # Draw items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        $itemY = $contentY
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $text = & $this.ItemRenderer $item
            
            # Truncate if too long
            if ($text.Length -gt $contentWidth - 2) {
                $text = $text.Substring(0, $contentWidth - 5) + "..."
            }
            
            $sb.Append([VT]::MoveTo($contentX, $itemY))
            
            # Selection highlighting
            if ($i -eq $this.SelectedIndex) {
                if ($this.IsFocused) {
                    $sb.Append($this.Theme.GetBgColor("selection"))
                    $sb.Append($this.Theme.GetColor("menu.selected.foreground"))
                } else {
                    $sb.Append($this.Theme.GetColor("disabled"))
                }
                $sb.Append("> ")
            } else {
                $sb.Append("  ")
            }
            
            $sb.Append($text)
            
            # Clear to end of line if selected
            if ($i -eq $this.SelectedIndex) {
                $remainingSpace = $contentWidth - $text.Length - 2
                if ($remainingSpace -gt 0) {
                    $sb.Append(" " * $remainingSpace)
                }
                $sb.Append([VT]::Reset())
            }
            
            $itemY++
        }
        
        # Draw scrollbar if enabled and needed
        if ($this.ShowScrollbar -and $this.Items.Count -gt $this.VisibleItems) {
            $this.DrawScrollbar($sb)
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedItems = $sb.ToString()
        $this._itemsCacheInvalid = $false
    }
    
    [void] DrawBorder([System.Text.StringBuilder]$sb) {
        $borderColor = if ($this.IsFocused) { 
            $this.Theme.GetColor("border.focused") 
        } else { 
            $this.Theme.GetColor("border") 
        }
        
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
        
        # Side borders
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        $sb.Append([VT]::Reset())
    }
    
    [void] DrawScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        if ($this.ShowBorder) { $scrollbarX-- }
        
        $scrollbarY = $this.Y + 1
        if ($this.ShowBorder) { $scrollbarY++ }
        if ($this.Title) { $scrollbarY++ }
        
        $scrollbarHeight = $this.VisibleItems
        
        # Calculate thumb position and size
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $this.VisibleItems / $this.Items.Count))
        $thumbPos = [int]($scrollbarY + ($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $this.VisibleItems))
        
        # Draw scrollbar track and thumb
        for ($y = $scrollbarY; $y -lt $scrollbarY + $scrollbarHeight; $y++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $y))
            
            if ($y -ge $thumbPos -and $y -lt $thumbPos + $thumbSize) {
                $sb.Append($this.Theme.GetColor("accent"))
                $sb.Append("█")
            } else {
                $sb.Append($this.Theme.GetColor("border"))
                $sb.Append("│")
            }
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectIndex($this.SelectedIndex - 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectIndex($this.SelectedIndex + 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $newIndex = [Math]::Max(0, $this.SelectedIndex - $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $newIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectIndex(0)
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectIndex($this.Items.Count - 1)
                $handled = $true
            }
        }
        
        return $handled
    }
    
    # Focus handling
    [void] OnGotFocus() {
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
}


####\Components/SimpleButton.ps1
# SimpleButton.ps1 - Minimal button for testing

class SimpleButton : UIElement {
    [string]$Text = ""
    
    SimpleButton([string]$text) : base() {
        $this.Text = $text
        $this.IsFocusable = $true
        $this.Height = 3
    }
    
    [void] Initialize([ServiceContainer]$services) {
        # No theme, just basic
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Simple box with text
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append("┌")
        for ($i = 0; $i -lt $this.Width - 2; $i++) {
            $sb.Append("─")
        }
        $sb.Append("┐")
        
        # Middle line with text
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append("│")
        
        # Center the text
        $padding = $this.Width - 2 - $this.Text.Length
        $leftPad = [int]($padding / 2)
        $rightPad = $padding - $leftPad
        
        # Add left padding
        for ($i = 0; $i -lt $leftPad; $i++) {
            $sb.Append(" ")
        }
        
        # Add text
        $sb.Append($this.Text)
        
        # Add right padding
        for ($i = 0; $i -lt $rightPad; $i++) {
            $sb.Append(" ")
        }
        
        $sb.Append("│")
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 2))
        $sb.Append("└")
        for ($i = 0; $i -lt $this.Width - 2; $i++) {
            $sb.Append("─")
        }
        $sb.Append("┘")
        
        return $sb.ToString()
    }
}


####\Components/TabContainer.ps1
# TabContainer.ps1 - Fast tab-based screen switching
# Core component for PRAXIS multi-screen management

class TabContainer : Container {
    [System.Collections.Generic.List[TabItem]]$Tabs
    [int]$ActiveTabIndex = 0
    [int]$TabBarHeight = 2
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_tabCache = @{}
    hidden [string]$_cachedTabBar = ""
    hidden [bool]$_tabBarInvalid = $true
    
    TabContainer() : base() {
        $this.Tabs = [System.Collections.Generic.List[TabItem]]::new()
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Propagate to all tabs
        foreach ($tab in $this.Tabs) {
            if ($tab.Content -and $tab.Content -is [Screen]) {
                $tab.Content.OnThemeChanged()
            }
        }
    }
    
    # Add a new tab
    [void] AddTab([string]$title, [UIElement]$content) {
        $tab = [TabItem]::new()
        $tab.Title = $title
        $tab.Content = $content
        $tab.ShortcutKey = $this.Tabs.Count + 1  # 1-9 shortcuts
        
        # Initialize the content if it's a Screen
        if ($content -is [Screen] -and $global:ServiceContainer) {
            $content.Initialize($global:ServiceContainer)
            # Tab content shouldn't draw their own background
            $content.DrawBackground = $false
        }
        
        $this.Tabs.Add($tab)
        $this._tabBarInvalid = $true
        
        # Set as active if first tab
        if ($this.Tabs.Count -eq 1) {
            $this.ActivateTab(0)
        } else {
            # Position but don't add to children yet
            $this.PositionContent($content, $false)
        }
        
        $this.Invalidate()
    }
    
    # Switch to a specific tab
    [void] ActivateTab([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Tabs.Count) { return }
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.ActivateTab: Switching from tab $($this.ActiveTabIndex) to tab $index")
        }
        
        # Deactivate current
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $oldTab = $this.Tabs[$this.ActiveTabIndex]
            if ($oldTab.Content) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Removing old tab content: $($oldTab.Title)")
                }
                $this.RemoveChild($oldTab.Content)
                if ($oldTab.Content -is [Screen]) {
                    $oldTab.Content.OnDeactivated()
                }
            }
        }
        
        # Activate new
        $this.ActiveTabIndex = $index
        $newTab = $this.Tabs[$index]
        if ($newTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Adding new tab content: $($newTab.Title)")
                $global:Logger.Debug("TabContainer: Content type: $($newTab.Content.GetType().Name)")
            }
            $this.PositionContent($newTab.Content, $true)
            $this.AddChild($newTab.Content)
            if ($newTab.Content -is [Screen]) {
                # Ensure tab content doesn't draw its own background
                $newTab.Content.DrawBackground = $false
                $newTab.Content.OnActivated()
            }
            $newTab.Content.Focus()
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: New content bounds: X=$($newTab.Content.X) Y=$($newTab.Content.Y) W=$($newTab.Content.Width) H=$($newTab.Content.Height)")
            }
        }
        
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Force parent to redraw completely to clear any artifacts
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
        
        # Force a render request
        if ($global:ScreenManager) {
            $global:ScreenManager.RequestRender()
        }
    }
    
    # Position content below tab bar
    hidden [void] PositionContent([UIElement]$content, [bool]$isActive) {
        $content.SetBounds(
            $this.X,
            $this.Y + $this.TabBarHeight,
            $this.Width,
            $this.Height - $this.TabBarHeight
        )
    }
    
    # Layout management
    [void] OnBoundsChanged() {
        # Update tab bar cache
        $this._tabBarInvalid = $true
        
        # Update active content bounds
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $activeTab = $this.Tabs[$this.ActiveTabIndex]
            if ($activeTab.Content) {
                $this.PositionContent($activeTab.Content, $true)
            }
        }
    }
    
    # Render the tab container
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: tabBarInvalid=$($this._tabBarInvalid), Children.Count=$($this.Children.Count)")
        }
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Render tab bar
        if ($this._tabBarInvalid) {
            $this.RebuildTabBar()
        }
        $sb.Append($this._cachedTabBar)
        
        # Clear content area below tab bar
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
        $contentY = $this.Y + $this.TabBarHeight
        $contentHeight = $this.Height - $this.TabBarHeight
        $clearLine = " " * $this.Width
        
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $contentY + $y))
            if ($bgColor) { $sb.Append($bgColor) }
            $sb.Append($clearLine)
        }
        if ($bgColor) { $sb.Append([VT]::Reset()) }
        
        # Render active content (base class handles children)
        $baseRender = ([Container]$this).OnRender()
        $sb.Append($baseRender)
        
        if ($global:Logger -and $baseRender.Length -eq 0) {
            $global:Logger.Warning("TabContainer: Base render returned empty string")
        }
        
        return $sb.ToString()
    }
    
    # Build the tab bar
    hidden [void] RebuildTabBar() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Tab bar background
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this.Theme.GetBgColor("tab.background"))
        $sb.Append(" " * $this.Width)
        
        # Draw tabs
        $x = $this.X + 1
        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {
            $tab = $this.Tabs[$i]
            $title = $tab.Title
            
            # Add shortcut hint if applicable
            if ($tab.ShortcutKey -ge 1 -and $tab.ShortcutKey -le 9) {
                $title = "$($tab.ShortcutKey):$title"
            }
            
            # Calculate tab width
            $tabWidth = $title.Length + 4  # Padding
            
            # Don't draw if it would overflow
            if (($x + $tabWidth) -gt ($this.X + $this.Width - 1)) {
                break
            }
            
            $sb.Append([VT]::MoveTo($x, $this.Y))
            
            # Tab styling
            if ($i -eq $this.ActiveTabIndex) {
                # Active tab
                $sb.Append($this.Theme.GetBgColor("tab.active.background"))
                $sb.Append($this.Theme.GetColor("tab.active.foreground"))
                $sb.Append(" $title ")
                
                # Bottom accent line
                $sb.Append([VT]::MoveTo($x, $this.Y + 1))
                $sb.Append($this.Theme.GetColor("tab.active.accent"))
                $sb.Append("─" * ($tabWidth - 2))
            } else {
                # Inactive tab
                $sb.Append($this.Theme.GetBgColor("tab.background"))
                $sb.Append($this.Theme.GetColor("tab.foreground"))
                $sb.Append(" $title ")
            }
            
            $x += $tabWidth + 1
        }
        
        # Reset and draw separator line
        $sb.Append([VT]::Reset())
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append("─" * $this.Width)
        $sb.Append([VT]::Reset())
        
        $this._cachedTabBar = $sb.ToString()
        $this._tabBarInvalid = $false
    }
    
    # Handle keyboard input
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Modifiers=$($key.Modifiers)")
            $global:Logger.Debug("TabContainer: KeyChar type: $($key.KeyChar.GetType().Name) Value: '$($key.KeyChar)'")
            $global:Logger.Debug("TabContainer: KeyChar ASCII value: $([int]$key.KeyChar)")
        }
        
        # Check TabContainer shortcuts FIRST before passing to children
        
        # Number keys for quick tab switching
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer: About to check number keys. KeyChar='$($key.KeyChar)' ASCII=$([int]$key.KeyChar)")
            $global:Logger.Debug("TabContainer: Checking if $([int]$key.KeyChar) is between $([int]'1') (49) and $([int]'9') (57)")
        }
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Number key detected!")
            }
            $tabIndex = [int]$key.KeyChar - [int][char]'1'
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Tab index calculated: $tabIndex, Tabs.Count: $($this.Tabs.Count)")
            }
            if ($tabIndex -lt $this.Tabs.Count) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Switching to tab $($tabIndex + 1)")
                }
                $this.ActivateTab($tabIndex)
                return $true
            } else {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Tab index $tabIndex is out of range (Tabs.Count=$($this.Tabs.Count))")
                }
            }
        }
        
        # Ctrl+Tab / Ctrl+Shift+Tab for cycling
        if ($key.Key -eq [System.ConsoleKey]::Tab -and 
            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.PreviousTab()
            } else {
                $this.NextTab()
            }
            return $true
        }
        
        # Alt+Left/Right for navigation
        if ($key.Modifiers -band [System.ConsoleModifiers]::Alt) {
            if ($key.Key -eq [System.ConsoleKey]::LeftArrow) {
                $this.PreviousTab()
                return $true
            } elseif ($key.Key -eq [System.ConsoleKey]::RightArrow) {
                $this.NextTab()
                return $true
            }
        }
        
        # Now pass to active content
        return ([Container]$this).HandleInput($key)
    }
    
    # Navigation helpers
    [void] NextTab() {
        if ($this.Tabs.Count -gt 0) {
            $next = ($this.ActiveTabIndex + 1) % $this.Tabs.Count
            $this.ActivateTab($next)
        }
    }
    
    [void] PreviousTab() {
        if ($this.Tabs.Count -gt 0) {
            $prev = $this.ActiveTabIndex - 1
            if ($prev -lt 0) { $prev = $this.Tabs.Count - 1 }
            $this.ActivateTab($prev)
        }
    }
    
    # Get active tab
    [TabItem] GetActiveTab() {
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            return $this.Tabs[$this.ActiveTabIndex]
        }
        return $null
    }
}

# Tab item class
class TabItem {
    [string]$Title = "Tab"
    [UIElement]$Content = $null
    [int]$ShortcutKey = 0
}


####\Components/TextBox.ps1
# TextBox.ps1 - Fast text input component
# Adapted from AxiomPhoenix with string-based rendering

class TextBox : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [bool]$ShowBorder = $true
    [bool]$ShowCursor = $true
    [scriptblock]$OnChange = {}
    [scriptblock]$OnSubmit = {}
    
    hidden [int]$_scrollOffset = 0
    hidden [string]$_cachedRender = ""
    hidden [bool]$_needsRender = $true
    hidden [ThemeManager]$Theme
    
    TextBox() : base() {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3  # Border + content + border
    }
    
    [void] Initialize([ServiceContainer]$services) {
        if ($services) {
            $this.Theme = $services.GetService("ThemeManager")
            if ($this.Theme) {
                $this.Theme.Subscribe({ $this._needsRender = $true; $this.Invalidate() })
            }
        }
    }
    
    [string] OnRender() {
        if (-not $this._needsRender) {
            return $this._cachedRender
        }
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Colors based on focus state
        $borderColor = if ($this.Theme -and $this.IsFocused) {
            $this.Theme.GetColor("input.focused.border")
        } elseif ($this.Theme) {
            $this.Theme.GetColor("input.border")
        } else {
            ""
        }
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("input.background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("input.foreground") } else { "" }
        $placeholderColor = if ($this.Theme) { $this.Theme.GetColor("input.placeholder") } else { "" }
        
        # Content area
        $contentY = $this.Y + 1
        $contentStartX = $this.X + 1
        $contentWidth = $this.Width - 2
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            
            # Middle line with content
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append([VT]::V())
            
            # Clear content area
            $sb.Append($bgColor)
            $sb.Append(" " * $contentWidth)
            
            # Right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + 2))
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        } else {
            # Just clear the content area
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($bgColor)
            $sb.Append(" " * $this.Width)
            $contentY = $this.Y
            $contentStartX = $this.X
            $contentWidth = $this.Width
        }
        
        # Render text or placeholder
        $sb.Append([VT]::MoveTo($contentStartX, $contentY))
        
        if ($this.Text.Length -eq 0 -and -not [string]::IsNullOrEmpty($this.Placeholder)) {
            # Show placeholder
            $sb.Append($placeholderColor)
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth)
            } else {
                $this.Placeholder
            }
            $sb.Append($placeholderText)
        } else {
            # Calculate scroll offset to keep cursor in view
            if ($this.CursorPosition -lt $this._scrollOffset) {
                $this._scrollOffset = $this.CursorPosition
            } elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
            }
            
            # Draw visible portion of text
            $sb.Append($fgColor)
            if ($this.Text.Length -gt $this._scrollOffset) {
                $len = [Math]::Min($contentWidth, $this.Text.Length - $this._scrollOffset)
                $visibleText = $this.Text.Substring($this._scrollOffset, $len)
                $sb.Append($visibleText)
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this.ShowCursor) {
                $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                    $cursorX = $contentStartX + $cursorScreenPos
                    $sb.Append([VT]::MoveTo($cursorX, $contentY))
                    
                    # Reverse video for cursor
                    $charUnderCursor = if ($this.CursorPosition -lt $this.Text.Length) {
                        $this.Text[$this.CursorPosition]
                    } else {
                        ' '
                    }
                    
                    $sb.Append($bgColor)  # Swap colors for cursor
                    if ($this.Theme) {
                        $sb.Append($this.Theme.GetBgColor("input.foreground"))
                    }
                    $sb.Append($charUnderCursor)
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedRender = $sb.ToString()
        $this._needsRender = $false
        return $this._cachedRender
    }
    
    [void] OnGotFocus() {
        $this.ShowCursor = $true
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnGotFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [void] OnLostFocus() {
        $this.ShowCursor = $false
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnLostFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $true
        $oldText = $this.Text
        
        switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                }
            }
            ([System.ConsoleKey]::Home) {
                $this.CursorPosition = 0
            }
            ([System.ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.OnSubmit) {
                    & $this.OnSubmit $this.Text
                }
            }
            ([System.ConsoleKey]::Tab) {
                # Don't handle Tab - let parent handle focus navigation
                $handled = $false
            }
            ([System.ConsoleKey]::Escape) {
                # Don't handle Escape - let parent handle it
                $handled = $false
            }
            default {
                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
        if ($handled) {
            # Call OnChange if text was modified
            if ($oldText -ne $this.Text -and $this.OnChange) {
                & $this.OnChange $this.Text
            }
            $this._needsRender = $true
            $this.Invalidate()
        }
        
        return $handled
    }
    
    # Helper methods
    [void] SetText([string]$text) {
        if ($text.Length -le $this.MaxLength) {
            $this.Text = $text
            $this.CursorPosition = $text.Length
            $this._needsRender = $true
            $this.Invalidate()
        }
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this._scrollOffset = 0
        $this._needsRender = $true
        $this.Invalidate()
    }
}


####\Core/ScreenManager.ps1
# ScreenManager.ps1 - Manages screen lifecycle and rendering
# Optimized for minimal overhead

class ScreenManager {
    hidden [System.Collections.Generic.Stack[Screen]]$_screenStack
    hidden [Screen]$_activeScreen = $null
    hidden [bool]$_needsRender = $true
    hidden [System.ConsoleKeyInfo]$_lastKey
    hidden [ServiceContainer]$_services
    
    # Performance tracking
    hidden [System.Diagnostics.Stopwatch]$_renderTimer
    hidden [int]$_frameCount = 0
    hidden [double]$_lastFPS = 0
    
    ScreenManager([ServiceContainer]$services) {
        $this._screenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this._services = $services
        $this._renderTimer = [System.Diagnostics.Stopwatch]::new()
    }
    
    # Push a new screen
    [void] Push([Screen]$screen) {
        # Deactivate current
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
            $this._activeScreen.OnDeactivated()
        }
        
        # Initialize and activate new screen
        $screen.Initialize($this._services)
        $screen.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
        
        $this._screenStack.Push($screen)
        $this._activeScreen = $screen
        $this._activeScreen.Active = $true
        $this._activeScreen.OnActivated()
        
        $this._needsRender = $true
    }
    
    # Pop current screen
    [Screen] Pop() {
        if ($this._screenStack.Count -eq 0) { return $null }
        
        $popped = $this._screenStack.Pop()
        $popped.Active = $false
        $popped.OnDeactivated()
        
        # Activate previous screen if any
        if ($this._screenStack.Count -gt 0) {
            $this._activeScreen = $this._screenStack.Peek()
            $this._activeScreen.Active = $true
            $this._activeScreen.OnActivated()
        } else {
            $this._activeScreen = $null
        }
        
        $this._needsRender = $true
        return $popped
    }
    
    # Replace current screen
    [void] Replace([Screen]$screen) {
        if ($this._screenStack.Count -gt 0) {
            $this.Pop() | Out-Null
        }
        $this.Push($screen)
    }
    
    # Get active screen
    [Screen] GetActiveScreen() {
        return $this._activeScreen
    }
    
    # Main run loop
    [void] Run() {
        # Initial setup
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Run: Starting main loop")
            $global:Logger.Info("Active screen: $($this._activeScreen.GetType().Name)")
            $global:Logger.Info("Active screen.Active: $($this._activeScreen.Active)")
            $global:Logger.Flush()
        }
        
        try {
            while ($this._activeScreen -and $this._activeScreen.Active) {
                if ($global:Logger) {
                    $global:Logger.Debug("ScreenManager: In main loop iteration")
                }
                
                # Handle terminal resize
                if ([Console]::WindowWidth -ne $this._activeScreen.Width -or 
                    [Console]::WindowHeight -ne $this._activeScreen.Height) {
                    $this.HandleResize()
                }
                
                # Render if needed
                if ($this._needsRender -or $this._activeScreen._cacheInvalid) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ScreenManager: Rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                    $this.Render()
                } else {
                    # Log occasionally why we're not rendering
                    if ($this._frameCount % 100 -eq 0 -and $global:Logger) {
                        $global:Logger.Debug("ScreenManager: Not rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                }
                
                # Handle input
                try {
                    # Check if running in test mode
                    if ($env:PRAXIS_TEST_MODE) {
                        if ($global:Logger) {
                            $global:Logger.Debug("Running in test mode - skipping input")
                        }
                        Start-Sleep -Milliseconds 100
                        continue
                    }
                    
                    if ([Console]::KeyAvailable) {
                        $key = [Console]::ReadKey($true)
                        $this._lastKey = $key
                        
                        # Log key press for debugging
                        if ($global:Logger) {
                            $global:Logger.Debug("Key pressed: $($key.Key) Char: '$($key.KeyChar)' Modifiers: $($key.Modifiers)")
                        }
                        
                        # Let active screen handle it
                        $handled = $false
                        try {
                            $handled = $this._activeScreen.HandleInput($key)
                            if ($global:Logger) {
                                $global:Logger.Debug("Key handled by screen: $handled")
                            }
                        } catch {
                            if ($global:Logger) {
                                $global:Logger.LogException($_, "Error handling input")
                            }
                        }
                        
                        if ($handled) {
                            $this._needsRender = $true
                        }
                        
                        # Global hotkeys
                        if ($key.Key -eq [System.ConsoleKey]::Escape -and 
                            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
                            break  # Ctrl+Esc to exit
                        }
                    } else {
                        # Small sleep to prevent CPU spinning
                        Start-Sleep -Milliseconds 10
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.LogException($_, "Error in input handling")
                    }
                    
                    # In non-interactive mode, just sleep
                    Start-Sleep -Milliseconds 50
                    
                    # Check if we should exit (for testing)
                    if ($env:PRAXIS_TEST_MODE) {
                        break
                    }
                }
            }
        } finally {
            # Cleanup
            [Console]::CursorVisible = $true
            [Console]::Clear()
            [Console]::SetCursorPosition(0, 0)
        }
    }
    
    # Render current screen
    hidden [void] Render() {
        $this._renderTimer.Restart()
        
        # Get rendered content
        $content = $this._activeScreen.Render()
        
        # Write to console in one shot
        [Console]::SetCursorPosition(0, 0)
        [Console]::Write($content)
        
        $this._renderTimer.Stop()
        $this._frameCount++
        
        # Update FPS every second
        if ($this._frameCount % 60 -eq 0) {
            $this._lastFPS = 1000.0 / $this._renderTimer.ElapsedMilliseconds
        }
        
        $this._needsRender = $false
    }
    
    # Handle terminal resize
    hidden [void] HandleResize() {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        # Update all screens in stack
        foreach ($screen in $this._screenStack) {
            $screen.SetBounds(0, 0, $newWidth, $newHeight)
        }
        
        # Clear and force full redraw
        [Console]::Clear()
        $this._needsRender = $true
    }
    
    # Request render on next frame
    [void] RequestRender() {
        $this._needsRender = $true
    }
    
    # Get current FPS
    [double] GetFPS() {
        return $this._lastFPS
    }
}

# Global screen manager instance
$global:ScreenManager = $null


####\Core/ServiceContainer.ps1
# ServiceContainer.ps1 - Lightweight dependency injection
# Simplified from AxiomPhoenix for PRAXIS

class ServiceContainer {
    hidden [hashtable]$_services = @{}
    hidden [hashtable]$_factories = @{}
    
    # Register a service instance
    [void] Register([string]$name, [object]$instance) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $instance) {
            throw "Service instance cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._services[$name] = $instance
    }
    
    # Register a factory for lazy initialization
    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$singleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $factory) {
            throw "Factory cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._factories[$name] = @{
            Factory = $factory
            Singleton = $singleton
            Instance = $null
        }
    }
    
    # Get a service by name
    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        
        # Check eager instances first
        if ($this._services.ContainsKey($name)) {
            return $this._services[$name]
        }
        
        # Check factories
        if ($this._factories.ContainsKey($name)) {
            $factory = $this._factories[$name]
            
            # Return cached singleton if available
            if ($factory.Singleton -and $null -ne $factory.Instance) {
                return $factory.Instance
            }
            
            # Create new instance
            $instance = & $factory.Factory $this
            
            # Cache if singleton
            if ($factory.Singleton) {
                $factory.Instance = $instance
            }
            
            return $instance
        }
        
        throw "Service '$name' not found. Available: $($this.GetServiceNames() -join ', ')"
    }
    
    # Get all registered service names
    [string[]] GetServiceNames() {
        $names = @()
        $names += $this._services.Keys
        $names += $this._factories.Keys
        return $names | Sort-Object
    }
    
    # Cleanup all services
    [void] Cleanup() {
        # Dispose any IDisposable services
        $allInstances = @()
        $allInstances += $this._services.Values
        $allInstances += $this._factories.Values | Where-Object { $_.Instance } | ForEach-Object { $_.Instance }
        
        foreach ($instance in $allInstances) {
            if ($instance -is [System.IDisposable]) {
                try {
                    $instance.Dispose()
                } catch {
                    # Ignore disposal errors
                }
            }
        }
        
        $this._services.Clear()
        $this._factories.Clear()
    }
}

# Global service container instance
$global:ServiceContainer = [ServiceContainer]::new()


####\Core/VT100.ps1
# VT100/ANSI Core for BOLT-AXIOM with True Color Support

class VT {
    # Cursor movement (ANSI uses 1-based coordinates)
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    
    # Screen control
    static [string] Clear() { return "`e[H`e[2J" }  # Clear screen and home
    static [string] ClearLine() { return "`e[K" }
    static [string] Home() { return "`e[H" }      # Just home position
    static [string] ClearToEnd() { return "`e[J" }  # Clear from cursor to end
    
    # Basic styles
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Dim() { return "`e[2m" }
    
    # 24-bit True Color
    static [string] RGB([int]$r, [int]$g, [int]$b) { 
        return "`e[38;2;$r;$g;$($b)m" 
    }
    static [string] RGBBG([int]$r, [int]$g, [int]$b) { 
        return "`e[48;2;$r;$g;$($b)m" 
    }
    
    # Wireframe color palette (true color)
    static [string] Border() { return [VT]::RGB(0, 255, 255) }      # Cyan
    static [string] BorderDim() { return [VT]::RGB(0, 128, 128) }   # Dark cyan
    static [string] BorderActive() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Text() { return [VT]::RGB(192, 192, 192) }      # Light gray
    static [string] TextDim() { return [VT]::RGB(128, 128, 128) }   # Gray
    static [string] TextBright() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Accent() { return [VT]::RGB(0, 255, 0) }        # Green
    static [string] Warning() { return [VT]::RGB(255, 255, 0) }     # Yellow
    static [string] Error() { return [VT]::RGB(255, 0, 0) }         # Red
    static [string] Selected() { return [VT]::RGB(255, 255, 255) + [VT]::RGBBG(0, 64, 128) } # White on dark blue
    
    # Box drawing - single lines for speed
    static [string] TL() { return "┌" }     # Top left
    static [string] TR() { return "┐" }     # Top right
    static [string] BL() { return "└" }     # Bottom left
    static [string] BR() { return "┘" }     # Bottom right
    static [string] H() { return "─" }      # Horizontal
    static [string] V() { return "│" }      # Vertical
    static [string] Cross() { return "┼" }  # Cross
    static [string] T() { return "┬" }      # T down
    static [string] B() { return "┴" }      # T up
    static [string] L() { return "├" }      # T right
    static [string] R() { return "┤" }      # T left
    
    # Double lines for emphasis
    static [string] DTL() { return "╔" }
    static [string] DTR() { return "╗" }
    static [string] DBL() { return "╚" }
    static [string] DBR() { return "╝" }
    static [string] DH() { return "═" }
    static [string] DV() { return "║" }
}

# Layout measurement helpers
class Measure {
    static [int] TextWidth([string]$text) {
        # Remove ANSI sequences for accurate measurement
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        return $clean.Length
    }
    
    static [string] Truncate([string]$text, [int]$maxWidth) {
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        if ($clean.Length -le $maxWidth) { return $text }
        return $clean.Substring(0, $maxWidth - 3) + "..."
    }
    
    static [string] Pad([string]$text, [int]$width, [string]$align = "Left") {
        $textWidth = [Measure]::TextWidth($text)
        if ($textWidth -ge $width) { return [Measure]::Truncate($text, $width) }
        
        $padding = $width - $textWidth
        switch ($align) {
            "Left" { return $text + (" " * $padding) }
            "Right" { return (" " * $padding) + $text }
            "Center" { 
                $left = [int]($padding / 2)
                $right = $padding - $left
                return (" " * $left) + $text + (" " * $right)
            }
        }
        return $text
    }
}


####\Models/Project.ps1
# Project Model - Enhanced project definition based on PMC pattern

class Project {
    [string]$Id
    [string]$FullProjectName
    [string]$Nickname
    [string]$ID1
    [string]$ID2
    [DateTime]$DateAssigned
    [DateTime]$BFDate
    [DateTime]$DateDue
    [string]$Note
    [string]$CAAPath
    [string]$RequestPath
    [string]$T2020Path
    [decimal]$CumulativeHrs
    [DateTime]$ClosedDate
    [bool]$Deleted
    [DateTime]$CreatedAt
    
    Project([string]$fullName, [string]$nickname) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.FullProjectName = $fullName
        $this.Nickname = $nickname
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        $this.Deleted = $false
        $this.CreatedAt = [DateTime]::Now
    }
    
    # Legacy constructor for backward compatibility
    Project([string]$name) {
        $this.Id = [Guid]::NewGuid().ToString()
        $this.FullProjectName = $name
        $this.Nickname = $name
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        $this.Deleted = $false
        $this.CreatedAt = [DateTime]::Now
    }
}


####\Models/Task.ps1
# Task.ps1 - Task model

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

class Task {
    [string]$Id
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [string]$ProjectId = ""
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    [DateTime]$CreatedAt
    [DateTime]$UpdatedAt
    [bool]$Deleted = $false
    
    Task() {
        $this.Id = [guid]::NewGuid().ToString()
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[✓]" }
            ([TaskStatus]::Cancelled) { return "[✗]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "↓" }
            ([TaskPriority]::Medium) { return "→" }
            ([TaskPriority]::High) { return "↑" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
}


####\Screens/ConfirmationDialog.ps1
# ConfirmationDialog.ps1 - Generic confirmation dialog

class ConfirmationDialog : Screen {
    [string]$Message
    [string]$ConfirmText = "Yes"
    [string]$CancelText = "No"
    [Button]$ConfirmButton
    [Button]$CancelButton
    [scriptblock]$OnConfirm = {}
    [scriptblock]$OnCancel = {}
    
    ConfirmationDialog([string]$message) : base() {
        $this.Title = "Confirm"
        $this.Message = $message
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create buttons
        $this.ConfirmButton = [Button]::new($this.ConfirmText)
        # Capture dialog reference
        $dialog = $this
        $this.ConfirmButton.OnClick = {
            if ($dialog.OnConfirm) {
                & $dialog.OnConfirm
            }
        }.GetNewClosure()
        $this.ConfirmButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ConfirmButton)
        
        $this.CancelButton = [Button]::new($this.CancelText)
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.ConfirmButton) {
                & $this.ConfirmButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
        $this.BindKey('y', { & $this.ConfirmButton.OnClick })
        $this.BindKey('Y', { & $this.ConfirmButton.OnClick })
        $this.BindKey('n', { & $this.CancelButton.OnClick })
        $this.BindKey('N', { & $this.CancelButton.OnClick })
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on message
        $messageLines = $this.Message -split "`n"
        $maxLineLength = ($messageLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(40, $maxLineLength + 8)
        $dialogHeight = 10 + $messageLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 3
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.ConfirmButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on cancel button by default (safer)
        $this.CancelButton.Focus()
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            $warningColor = $this.Theme.GetColor("warning")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title with warning icon
            $title = " ⚠ Confirm "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($warningColor)
            $sb.Append($title)
            
            # Draw message
            $messageLines = $this.Message -split "`n"
            $messageY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $messageLines) {
                $lineX = $x + [int](($w - $line.Length) / 2)
                $sb.Append([VT]::MoveTo($lineX, $messageY))
                $sb.Append($line)
                $messageY++
            }
            
            # Draw hint
            $hint = "[Y/N] or use Tab to select"
            $hintX = $x + [int](($w - $hint.Length) / 2)
            $sb.Append([VT]::MoveTo($hintX, $y + $h - 2))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append($hint)
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        if ($this.ConfirmButton.IsFocused) {
            $this.CancelButton.Focus()
        } else {
            $this.ConfirmButton.Focus()
        }
    }
}


####\Screens/EditProjectDialog.ps1
# EditProjectDialog.ps1 - Dialog for editing existing projects

class EditProjectDialog : Screen {
    [Project]$Project
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$NoteBox
    [TextBox]$DueDateBox
    [Button]$SaveButton
    [Button]$CancelButton
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    EditProjectDialog([Project]$project) : base() {
        $this.Title = "Edit Project"
        $this.Project = $project
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create name textbox
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Text = $this.Project.FullProjectName
        $this.NameBox.Placeholder = "Enter project name..."
        $this.NameBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.NameBox)
        
        # Create nickname textbox
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Text = $this.Project.Nickname
        $this.NicknameBox.Placeholder = "Enter nickname..."
        $this.NicknameBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.NicknameBox)
        
        # Create note textbox
        $this.NoteBox = [TextBox]::new()
        $this.NoteBox.Text = $this.Project.Note
        $this.NoteBox.Placeholder = "Enter notes (optional)..."
        $this.NoteBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.NoteBox)
        
        # Create due date textbox
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Text = $this.Project.DateDue.ToString("yyyy-MM-dd")
        $this.DueDateBox.Placeholder = "YYYY-MM-DD"
        $this.DueDateBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DueDateBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        # Capture dialog reference
        $dialog = $this
        $this.SaveButton.OnClick = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse date
                $dueDate = $dialog.Project.DateDue
                $dateText = $dialog.DueDateBox.Text.Trim()
                if ($dateText) {
                    $parsedDate = [DateTime]::MinValue
                    if ([DateTime]::TryParse($dateText, [ref]$parsedDate)) {
                        $dueDate = $parsedDate
                    }
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave @{
                        FullProjectName = $dialog.NameBox.Text
                        Nickname = $dialog.NicknameBox.Text
                        Note = $dialog.NoteBox.Text
                        DateDue = $dueDate
                    }
                }
            }
        }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.SaveButton) {
                & $this.SaveButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on name box
        $this.NameBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 60
        $dialogHeight = 18
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.NameBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        $this.NicknameBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        $this.NoteBox.SetBounds($centerX + 2, $centerY + 10, $dialogWidth - 4, 3)
        $this.DueDateBox.SetBounds($centerX + 2, $centerY + 14, 20, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 14
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " Edit Project "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Name:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Nickname:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 9))
            $sb.Append("Notes:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 13))
            $sb.Append("Due Date:")
            
            # Draw project info
            $sb.Append([VT]::MoveTo($x + 25, $y + 13))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append("Assigned: " + $this.Project.DateAssigned.ToString("yyyy-MM-dd"))
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/EditTaskDialog.ps1
# EditTaskDialog.ps1 - Dialog for editing existing tasks

class EditTaskDialog : Screen {
    [Task]$Task
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$StatusList
    [ListBox]$PriorityList
    [TextBox]$ProgressBox
    [Button]$SaveButton
    [Button]$CancelButton
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    EditTaskDialog([Task]$task) : base() {
        $this.Title = "Edit Task"
        $this.Task = $task
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Text = $this.Task.Title
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Text = $this.Task.Description
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create status list
        $this.StatusList = [ListBox]::new()
        $this.StatusList.Title = "Status"
        $this.StatusList.ShowBorder = $true
        $this.StatusList.Initialize($global:ServiceContainer)
        $this.StatusList.SetItems(@(
            @{Name="Pending"; Value=[TaskStatus]::Pending},
            @{Name="In Progress"; Value=[TaskStatus]::InProgress},
            @{Name="Completed"; Value=[TaskStatus]::Completed},
            @{Name="Cancelled"; Value=[TaskStatus]::Cancelled}
        ))
        $this.StatusList.ItemRenderer = { param($item) $item.Name }
        # Select current status
        for ($i = 0; $i -lt $this.StatusList.Items.Count; $i++) {
            if ($this.StatusList.Items[$i].Value -eq $this.Task.Status) {
                $this.StatusList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.StatusList)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.Initialize($global:ServiceContainer)
        $this.PriorityList.SetItems(@(
            @{Name="Low"; Value=[TaskPriority]::Low},
            @{Name="Medium"; Value=[TaskPriority]::Medium},
            @{Name="High"; Value=[TaskPriority]::High}
        ))
        $this.PriorityList.ItemRenderer = { param($item) $item.Name }
        # Select current priority
        for ($i = 0; $i -lt $this.PriorityList.Items.Count; $i++) {
            if ($this.PriorityList.Items[$i].Value -eq $this.Task.Priority) {
                $this.PriorityList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.PriorityList)
        
        # Create progress textbox
        $this.ProgressBox = [TextBox]::new()
        $this.ProgressBox.Text = $this.Task.Progress.ToString()
        $this.ProgressBox.Placeholder = "0-100"
        $this.ProgressBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProgressBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        # Capture dialog reference
        $dialog = $this
        $this.SaveButton.OnClick = {
            if ($dialog.TitleBox.Text.Trim()) {
                $selectedStatus = $dialog.StatusList.GetSelectedItem()
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $progress = 0
                if ([int]::TryParse($dialog.ProgressBox.Text, [ref]$progress)) {
                    $progress = [Math]::Max(0, [Math]::Min(100, $progress))
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave @{
                        Title = $dialog.TitleBox.Text
                        Description = $dialog.DescriptionBox.Text
                        Status = if ($selectedStatus) { $selectedStatus.Value } else { $dialog.Task.Status }
                        Priority = if ($selectedPriority) { $selectedPriority.Value } else { $dialog.Task.Priority }
                        Progress = $progress
                    }
                }
            }
        }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.SaveButton) {
                & $this.SaveButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 65
        $dialogHeight = 22
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.TitleBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        $this.DescriptionBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        
        $this.StatusList.SetBounds($centerX + 2, $centerY + 10, 20, 6)
        $this.PriorityList.SetBounds($centerX + 24, $centerY + 10, 20, 5)
        $this.ProgressBox.SetBounds($centerX + 46, $centerY + 10, 16, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 17
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on title box
        $this.TitleBox.Focus()
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " Edit Task "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Title:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Description:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 9))
            $sb.Append("Status:")
            
            $sb.Append([VT]::MoveTo($x + 24, $y + 9))
            $sb.Append("Priority:")
            
            $sb.Append([VT]::MoveTo($x + 46, $y + 9))
            $sb.Append("Progress (%):")
            
            # Draw task info
            $sb.Append([VT]::MoveTo($x + 2, $y + 16))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append("Created: " + $this.Task.CreatedAt.ToString("yyyy-MM-dd HH:mm"))
            if ($this.Task.DueDate -ne [DateTime]::MinValue) {
                $sb.Append(" | Due: " + $this.Task.DueDate.ToString("yyyy-MM-dd"))
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/EventBusMonitor.ps1
# EventBusMonitor.ps1 - Dialog for monitoring EventBus activity

class EventBusMonitor : Screen {
    [TextBox]$InfoDisplay
    [Button]$RefreshButton
    [Button]$ToggleHistoryButton
    [Button]$ToggleDebugButton
    [Button]$ClearHistoryButton
    [Button]$CloseButton
    [EventBus]$EventBus
    hidden [System.Timers.Timer]$RefreshTimer
    
    EventBusMonitor() : base() {
        $this.Title = "EventBus Monitor"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create info display
        $this.InfoDisplay = [TextBox]::new()
        $this.InfoDisplay.ReadOnly = $true
        $this.InfoDisplay.ShowBorder = $true
        $this.InfoDisplay.Text = "Loading EventBus information..."
        $this.InfoDisplay.Initialize($global:ServiceContainer)
        $this.AddChild($this.InfoDisplay)
        
        # Create buttons
        $this.RefreshButton = [Button]::new("Refresh")
        $this.RefreshButton.OnClick = { $this.RefreshInfo() }
        $this.RefreshButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.RefreshButton)
        
        $this.ToggleHistoryButton = [Button]::new("Toggle History")
        $this.ToggleHistoryButton.OnClick = { $this.ToggleHistory() }
        $this.ToggleHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleHistoryButton)
        
        $this.ToggleDebugButton = [Button]::new("Toggle Debug")
        $this.ToggleDebugButton.OnClick = { $this.ToggleDebug() }
        $this.ToggleDebugButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleDebugButton)
        
        $this.ClearHistoryButton = [Button]::new("Clear History")
        $this.ClearHistoryButton.OnClick = { $this.ClearHistory() }
        $this.ClearHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ClearHistoryButton)
        
        $this.CloseButton = [Button]::new("Close")
        $this.CloseButton.IsDefault = $true
        $this.CloseButton.OnClick = { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        $this.CloseButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CloseButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        })
        $this.BindKey('r', { $this.RefreshInfo() })
        $this.BindKey('h', { $this.ToggleHistory() })
        $this.BindKey('d', { $this.ToggleDebug() })
        $this.BindKey('c', { $this.ClearHistory() })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        
        # Initial refresh
        $this.RefreshInfo()
        
        # Focus on close button
        $this.CloseButton.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout components
        $padding = 2
        $buttonHeight = 3
        $buttonWidth = 20
        $buttonSpacing = 2
        
        # Info display takes most of the space
        $this.InfoDisplay.SetBounds(
            $this.X + $padding,
            $this.Y + $padding,
            $this.Width - ($padding * 2),
            $this.Height - $buttonHeight - ($padding * 3)
        )
        
        # Buttons at the bottom
        $totalButtonWidth = ($buttonWidth * 5) + ($buttonSpacing * 4)
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - $padding
        
        $this.RefreshButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleHistoryButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleDebugButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 2, $buttonY, $buttonWidth, $buttonHeight)
        $this.ClearHistoryButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 3, $buttonY, $buttonWidth, $buttonHeight)
        $this.CloseButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 4, $buttonY, $buttonWidth, $buttonHeight)
    }
    
    [void] RefreshInfo() {
        if (-not $this.EventBus) { return }
        
        $report = $this.EventBus.GetDebugReport()
        
        # Add recent history if enabled
        if ($this.EventBus.EnableHistory) {
            $history = $this.EventBus.GetEventHistory()
            if ($history.Count -gt 0) {
                $report += "`n`nRecent Events:`n"
                $recent = $history | Select-Object -Last 10
                foreach ($event in $recent) {
                    $report += "  $($event.Timestamp.ToString('HH:mm:ss')) - $($event.EventName)`n"
                }
            }
        }
        
        # Add keyboard shortcuts
        $report += "`n`nKeyboard Shortcuts:`n"
        $report += "  [R] Refresh  [H] Toggle History  [D] Toggle Debug`n"
        $report += "  [C] Clear History  [Esc] Close"
        
        $this.InfoDisplay.Text = $report
        $this.InfoDisplay.Invalidate()
    }
    
    [void] ToggleHistory() {
        if ($this.EventBus) {
            $this.EventBus.EnableHistory = -not $this.EventBus.EnableHistory
            $this.RefreshInfo()
        }
    }
    
    [void] ToggleDebug() {
        if ($this.EventBus) {
            $this.EventBus.EnableDebugLogging = -not $this.EventBus.EnableDebugLogging
            $this.RefreshInfo()
        }
    }
    
    [void] ClearHistory() {
        if ($this.EventBus) {
            $this.EventBus.ClearHistory()
            $this.RefreshInfo()
        }
    }
    
    [void] FocusNext() {
        $focusableChildren = @($this.RefreshButton, $this.ToggleHistoryButton, 
                              $this.ToggleDebugButton, $this.ClearHistoryButton, 
                              $this.CloseButton)
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        # Move to next
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/MainScreen.ps1
# MainScreen.ps1 - Main screen with tab container

class MainScreen : Screen {
    [TabContainer]$TabContainer
    [CommandPalette]$CommandPalette
    [EventBus]$EventBus
    hidden [string]$TabChangedSubscription
    
    MainScreen() : base() {
        $this.Title = "PRAXIS"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to tab change events
        if ($this.EventBus) {
            $this.TabChangedSubscription = $this.EventBus.Subscribe([EventNames]::TabChanged, {
                param($sender, $eventData)
                if ($eventData.TabIndex -ne $null -and $this.TabContainer) {
                    $this.TabContainer.ActivateTab($eventData.TabIndex)
                    $this.RequestRender()
                }
            }.GetNewClosure())
        }
        
        # Create tab container
        $this.TabContainer = [TabContainer]::new()
        $this.TabContainer.Initialize($global:ServiceContainer)
        $this.AddChild($this.TabContainer)
        
        # Add real screens as tabs
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Adding tabs to TabContainer")
        }
        
        $projectsScreen = [ProjectsScreen]::new()
        $this.TabContainer.AddTab("Projects", $projectsScreen)
        
        $taskScreen = [TaskScreen]::new()
        $this.TabContainer.AddTab("Tasks", $taskScreen)
        
        $test3 = [TestScreen]::new()
        $test3.Message = "Dashboard (Coming Soon)"
        $this.TabContainer.AddTab("Dashboard", $test3)
        
        $settingsScreen = [SettingsScreen]::new()
        $this.TabContainer.AddTab("Settings", $settingsScreen)
        
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Added $($this.TabContainer.Tabs.Count) tabs")
        }
        
        # Create command palette (overlay)
        $this.CommandPalette = [CommandPalette]::new()
        $this.CommandPalette.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandPalette)
        
        # Global key bindings
        $this.BindKey('q', { $this.Active = $false })
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.CommandPalette.IsVisible) {
                $this.CommandPalette.Hide()
            } elseif ($this.TabContainer.GetActiveTab().Content.Active) {
                $this.Active = $false
            }
        })
        
        # Command palette shortcut
        $this.BindKey('/', { 
            $this.CommandPalette.Show()
            $this.RequestRender()
        })
        $this.BindKey(':', { 
            $this.CommandPalette.Show()
            $this.RequestRender()
        })
    }
    
    [void] OnBoundsChanged() {
        if ($this.TabContainer) {
            $this.TabContainer.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
        if ($this.CommandPalette) {
            # Command palette uses full screen for centering
            $this.CommandPalette.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure bounds are set
        if ($this.Width -eq 0 -or $this.Height -eq 0) {
            $this.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
        }
        
        # Focus on the active tab's content
        if ($this.TabContainer) {
            $activeTab = $this.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                $activeTab.Content.Focus()
            }
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Command palette gets input priority when visible
        if ($this.CommandPalette -and $this.CommandPalette.IsVisible) {
            $handled = $this.CommandPalette.HandleInput($key)
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette handled: $handled")
            }
            if ($handled) { return $true }
        }
        
        # Let TabContainer handle tab-specific shortcuts first
        if ($this.TabContainer) {
            $handled = $this.TabContainer.HandleInput($key)
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer handled: $handled")
            }
            if ($handled) { return $true }
        }
        
        # Otherwise use normal handling
        $handled = ([Screen]$this).HandleInput($key)
        if ($global:Logger) {
            $global:Logger.Debug("Screen base handled: $handled")
        }
        return $handled
    }
}


####\Screens/NewProjectDialog.ps1
# NewProjectDialog.ps1 - Dialog for creating new projects

class NewProjectDialog : Screen {
    [TextBox]$NameBox
    [TextBox]$DescriptionBox
    [Button]$CreateButton
    [Button]$CancelButton
    [scriptblock]$OnCreate = {}  # Legacy callback support
    [scriptblock]$OnCancel = {}  # Legacy callback support
    [EventBus]$EventBus
    
    NewProjectDialog() : base() {
        $this.Title = "New Project"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create name textbox
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Placeholder = "Enter project name..."
        $this.NameBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.NameBox)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Enter description..."
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create buttons
        $this.CreateButton = [Button]::new("Create")
        # Capture the dialog reference
        $dialog = $this
        $this.CreateButton.OnClick = {
            if ($dialog.NameBox.Text.Trim()) {
                $projectData = @{
                    Name = $dialog.NameBox.Text
                    Description = $dialog.DescriptionBox.Text
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create project via service
                    $projectService = $global:ServiceContainer.GetService("ProjectService")
                    if ($projectService) {
                        $nickname = $projectData.Name -replace '\s+', ''
                        $newProject = $projectService.AddProject($projectData.Name, $nickname)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::ProjectCreated, @{ 
                            Project = $newProject 
                        })
                    }
                    
                    # Close dialog
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewProjectDialog'
                        Result = 'Create'
                    })
                    
                    if ($global:ScreenManager) {
                        $global:ScreenManager.Pop()
                    }
                }
                # Fallback to callback if EventBus not available
                elseif ($dialog.OnCreate) {
                    & $dialog.OnCreate $projectData
                }
            }
        }.GetNewClosure()
        $this.CreateButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CreateButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            # Use EventBus if available
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewProjectDialog'
                    Result = 'Cancel'
                })
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            # Fallback to callback
            elseif ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.EventBus) {
                $this.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewProjectDialog'
                    Result = 'Cancel'
                })
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            elseif ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Publish dialog opened event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::DialogOpened, @{ 
                Dialog = 'NewProjectDialog' 
            })
        }
        
        # Focus on name box
        $this.NameBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 50
        $dialogHeight = 14
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.NameBox.Width = $dialogWidth - 4
        $this.NameBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        
        $this.DescriptionBox.Width = $dialogWidth - 4
        $this.DescriptionBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 10
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.CreateButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " New Project "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Name:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Description:")
        }
        
        # Render children (textboxes and buttons)
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/NewTaskDialog.ps1
# NewTaskDialog.ps1 - Dialog for creating new tasks

class NewTaskDialog : Screen {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$PriorityList
    [Button]$CreateButton
    [Button]$CancelButton
    [scriptblock]$OnCreate = {}  # Legacy callback support
    [scriptblock]$OnCancel = {}  # Legacy callback support
    [EventBus]$EventBus
    
    NewTaskDialog() : base() {
        $this.Title = "New Task"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.Initialize($global:ServiceContainer)
        $this.PriorityList.SetItems(@(
            @{Name="Low"; Value=[TaskPriority]::Low},
            @{Name="Medium"; Value=[TaskPriority]::Medium},
            @{Name="High"; Value=[TaskPriority]::High}
        ))
        $this.PriorityList.ItemRenderer = { param($item) $item.Name }
        $this.PriorityList.SelectIndex(1)  # Default to Medium
        $this.AddChild($this.PriorityList)
        
        # Create buttons
        $this.CreateButton = [Button]::new("Create")
        # Capture the dialog reference
        $dialog = $this
        $this.CreateButton.OnClick = {
            if ($dialog.TitleBox.Text.Trim()) {
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $taskData = @{
                    Title = $dialog.TitleBox.Text
                    Description = $dialog.DescriptionBox.Text
                    Priority = if ($selectedPriority) { $selectedPriority.Value } else { [TaskPriority]::Medium }
                    Status = [TaskStatus]::Pending
                    Progress = 0
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create task via service
                    $taskService = $global:ServiceContainer.GetService("TaskService")
                    if ($taskService) {
                        $newTask = $taskService.CreateTask($taskData)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::TaskCreated, @{ 
                            Task = $newTask 
                        })
                    }
                    
                    # Close dialog
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewTaskDialog'
                        Result = 'Create'
                    })
                    
                    if ($global:ScreenManager) {
                        $global:ScreenManager.Pop()
                    }
                }
                # Fallback to callback if EventBus not available
                elseif ($dialog.OnCreate) {
                    & $dialog.OnCreate $taskData
                }
            }
        }.GetNewClosure()
        $this.CreateButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CreateButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            # Use EventBus if available
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewTaskDialog'
                    Result = 'Cancel'
                })
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            # Fallback to callback
            elseif ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.EventBus) {
                $this.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewTaskDialog'
                    Result = 'Cancel'
                })
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            elseif ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Publish dialog opened event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::DialogOpened, @{ 
                Dialog = 'NewTaskDialog' 
            })
        }
        
        # Focus on title box
        $this.TitleBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 60
        $dialogHeight = 20
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.TitleBox.Width = $dialogWidth - 4
        $this.TitleBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        
        $this.DescriptionBox.Width = $dialogWidth - 4
        $this.DescriptionBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        
        $this.PriorityList.Height = 5
        $this.PriorityList.SetBounds($centerX + 2, $centerY + 10, 20, 5)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 16  # 10 + 5 (list) + 1 (spacing)
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.CreateButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " New Task "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Title:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Description:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 9))
            $sb.Append("Priority:")
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/NumberInputDialog.ps1
# NumberInputDialog.ps1 - Simple dialog for numeric input

class NumberInputDialog : Screen {
    [string]$Prompt
    [decimal]$DefaultValue
    [decimal]$MinValue
    [decimal]$MaxValue
    [bool]$AllowDecimals
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    NumberInputDialog([string]$prompt) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = 0
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    NumberInputDialog([string]$prompt, [decimal]$defaultValue) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue.ToString()
        $this.InputBox.Placeholder = if ($this.AllowDecimals) { "0.00" } else { "0" }
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            $value = [decimal]0
            if ([decimal]::TryParse($dialog.InputBox.Text, [ref]$value)) {
                # Validate range
                if ($value -lt $dialog.MinValue) {
                    $value = $dialog.MinValue
                } elseif ($value -gt $dialog.MaxValue) {
                    $value = $dialog.MaxValue
                }
                
                # Round if no decimals allowed
                if (-not $dialog.AllowDecimals) {
                    $value = [Math]::Round($value)
                }
                
                if ($dialog.OnSubmit) {
                    & $dialog.OnSubmit $value
                }
            }
            # If parse fails, don't submit
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box
        $this.InputBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 11 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
            
            # Draw constraints if any
            $constraintY = $y + 2 + $promptLines.Count + 4
            $sb.Append([VT]::MoveTo($x + 2, $constraintY))
            $sb.Append($this.Theme.GetColor("disabled"))
            $constraints = @()
            if ($this.MinValue -ne [decimal]::MinValue) {
                $constraints += "Min: $($this.MinValue)"
            }
            if ($this.MaxValue -ne [decimal]::MaxValue) {
                $constraints += "Max: $($this.MaxValue)"
            }
            if (-not $this.AllowDecimals) {
                $constraints += "Integers only"
            }
            if ($constraints.Count -gt 0) {
                $sb.Append($constraints -join " | ")
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ProjectsScreen.ps1
# ProjectsScreen.ps1 - Project management screen using fast components

class ProjectsScreen : Screen {
    [ListBox]$ProjectList
    [Button]$NewButton
    [Button]$EditButton
    [Button]$DeleteButton
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    ProjectsScreen() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Subscribe to project created events
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe([EventNames]::ProjectCreated, {
                param($sender, $eventData)
                $this.RefreshProjects()
                # Select the new project if provided
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $this.ProjectList.Items.Count; $i++) {
                        if ($this.ProjectList.Items[$i].Id -eq $eventData.Project.Id) {
                            $this.ProjectList.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe([EventNames]::CommandExecuted, {
                param($sender, $eventData)
                if ($eventData.Target -eq 'ProjectsScreen') {
                    switch ($eventData.Command) {
                        'EditProject' { $this.EditProject() }
                        'DeleteProject' { $this.DeleteProject() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe([EventNames]::ProjectUpdated, {
                param($sender, $eventData)
                $this.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe([EventNames]::ProjectDeleted, {
                param($sender, $eventData)
                $this.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create components
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = "Projects"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "[✓]" } else { "[ ]" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $dueStatus = if ($daysLeft -lt 0) { "OVERDUE" } elseif ($daysLeft -lt 7) { "DUE SOON" } else { "$daysLeft days" }
            return "$status $($project.Nickname) - $dueStatus"
        }
        $this.ProjectList.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectList)
        
        # Create buttons
        $this.NewButton = [Button]::new("New Project")
        $this.NewButton.IsDefault = $true
        $this.NewButton.OnClick = { $this.NewProject() }
        $this.NewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.NewButton)
        
        $this.EditButton = [Button]::new("Edit")
        $this.EditButton.OnClick = { $this.EditProject() }
        $this.EditButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.EditButton)
        
        $this.DeleteButton = [Button]::new("Delete")
        $this.DeleteButton.OnClick = { $this.DeleteProject() }
        $this.DeleteButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.DeleteButton)
        
        # Load projects
        $this.LoadProjects()
        
        # Key bindings
        $this.BindKey('n', { $this.NewProject() })
        $this.BindKey('e', { $this.EditProject() })
        $this.BindKey('d', { $this.DeleteProject() })
        $this.BindKey('r', { $this.LoadProjects() })
        $this.BindKey([System.ConsoleKey]::Enter, { $this.EditProject() })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey('q', { $this.Active = $false })
        
        # Focus on list
        $this.ProjectList.Focus()
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure list has focus when screen is activated
        if ($this.ProjectList) {
            $this.ProjectList.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Debug
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Layout: List takes most space, buttons at bottom
        $buttonAreaHeight = $this.ButtonHeight + 2
        $listHeight = $this.Height - $buttonAreaHeight
        
        # Project list
        $this.ProjectList.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $listHeight
        )
        
        # Buttons (horizontally arranged)
        $maxButtonWidth = 25  # Maximum button width
        $totalButtonWidth = ($maxButtonWidth * 3) + ($this.ButtonSpacing * 2)
        
        # Center buttons if screen is wide enough
        if ($this.Width -gt $totalButtonWidth) {
            $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $this.X
            $buttonWidth = [int](($this.Width - ($this.ButtonSpacing * 2)) / 3)
        }
        
        # Position buttons at bottom of screen bounds
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        
        $this.NewButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.EditButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.DeleteButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 2,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date
        $sorted = $activeProjects | Sort-Object DateDue
        
        $this.ProjectList.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        # Reload projects and update display
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        # Create new project dialog
        $dialog = [NewProjectDialog]::new()
        
        # EventBus will handle project creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                
                # Create nickname from name
                $nickname = $projectData.Name -replace '\s+', ''
                if ($nickname.Length -gt 10) {
                    $nickname = $nickname.Substring(0, 10)
                }
                
                $project = $screen.ProjectService.AddProject($projectData.Name, $nickname)
                $screen.LoadProjects()
                
                # Select the new project
                for ($i = 0; $i -lt $screen.ProjectList.Items.Count; $i++) {
                    if ($screen.ProjectList.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectList.SelectIndex($i)
                        break
                    }
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectList.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit project dialog
        $dialog = [EditProjectDialog]::new($selected)
        # Capture references
        $screen = $this
        $project = $selected
        $dialog.OnSave = {
            param($projectData)
            
            # Update the project
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            # Save through service
            $screen.ProjectService.UpdateProject($project)
            
            # Publish project updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                # Fallback if EventBus not available
                $screen.LoadProjects()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectList.GetSelectedItem()
        if ($selected) {
            # Show confirmation dialog
            $dialog = [ConfirmationDialog]::new(
                "Delete Project",
                "Are you sure you want to delete project '$($selected.Nickname)'?"
            )
            
            $screen = $this
            $projectId = $selected.Id
            $dialog.OnConfirm = {
                # Delete the project
                $screen.ProjectService.DeleteProject($projectId)
                
                # Publish project deleted event
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    # Fallback if EventBus not available
                    $screen.LoadProjects()
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] FocusNext() {
        $focused = $this.FindFocused()
        
        if ($focused -eq $this.ProjectList) {
            $this.NewButton.Focus()
        } elseif ($focused -eq $this.NewButton) {
            $this.EditButton.Focus()
        } elseif ($focused -eq $this.EditButton) {
            $this.DeleteButton.Focus()
        } else {
            $this.ProjectList.Focus()
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle registered keys first
        if (([Screen]$this).HandleInput($key)) {
            return $true
        }
        
        # Pass unhandled input to focused child
        return ([Container]$this).HandleInput($key)
    }
}


####\Screens/SettingsScreen.ps1
# SettingsScreen.ps1 - Settings management screen

class SettingsScreen : Screen {
    [ListBox]$CategoryList
    [DataGrid]$SettingsGrid
    [ConfigurationService]$ConfigService
    [hashtable[]]$CurrentSettings = @()
    [string]$CurrentCategory = ""
    [EventBus]$EventBus
    
    SettingsScreen() : base() {
        $this.Title = "Settings"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ConfigService = $global:ServiceContainer.GetService("ConfigurationService")
        if (-not $this.ConfigService) {
            $this.ConfigService = [ConfigurationService]::new()
            $global:ServiceContainer.Register("ConfigurationService", $this.ConfigService)
        }
        
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create category list
        $this.CategoryList = [ListBox]::new()
        $this.CategoryList.Title = "Categories"
        $this.CategoryList.ShowBorder = $true
        # Capture screen reference for callback
        $screen = $this
        $this.CategoryList.OnSelectionChanged = {
            $screen.LoadCategorySettings()
        }.GetNewClosure()
        $this.CategoryList.Initialize($global:ServiceContainer)
        $this.AddChild($this.CategoryList)
        
        # Create settings grid
        $this.SettingsGrid = [DataGrid]::new()
        $this.SettingsGrid.Title = "Settings"
        $this.SettingsGrid.ShowBorder = $true
        $this.SettingsGrid.Initialize($global:ServiceContainer)
        $this.SettingsGrid.SetColumns(@(
            @{Name="Setting"; Header="Setting"; Width=30},
            @{Name="Value"; Header="Value"; Width=20},
            @{Name="Type"; Header="Type"; Width=10}
        ))
        $this.AddChild($this.SettingsGrid)
        
        # Load categories
        $this.LoadCategories()
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::LeftArrow, { 
            if ($this.SettingsGrid.IsFocused) {
                $this.CategoryList.Focus()
            }
        })
        $this.BindKey([System.ConsoleKey]::RightArrow, { 
            if ($this.CategoryList.IsFocused) {
                $this.SettingsGrid.Focus()
            }
        })
        $this.BindKey([System.ConsoleKey]::Enter, { $this.EditSetting() })
        $this.BindKey('e', { $this.EditSetting() })
        $this.BindKey('r', { $this.ResetCategory() })
        $this.BindKey('R', { $this.ResetAll() })
        $this.BindKey('s', { $this.SaveSettings() })
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle the input
        return ([Screen]$this).HandleInput($key)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        $this.CategoryList.Focus()
        # Settings are loaded automatically when selection changes
    }
    
    [void] OnBoundsChanged() {
        # Split the width between category list and settings grid
        $categoryWidth = 25
        $gridWidth = [Math]::Max(10, $this.Width - $categoryWidth)
        
        # Set bounds for category list
        $this.CategoryList.SetBounds(
            $this.X,
            $this.Y,
            $categoryWidth,
            $this.Height
        )
        
        # Set bounds for settings grid
        $this.SettingsGrid.SetBounds(
            $this.X + $categoryWidth,
            $this.Y,
            $gridWidth,
            $this.Height
        )
    }
    
    [void] LoadCategories() {
        $config = $this.ConfigService.GetAll()
        $categories = @()
        
        foreach ($key in $config.Keys | Sort-Object) {
            if ($config[$key] -is [hashtable]) {
                $categories += @{
                    Name = $key
                    DisplayName = $this.FormatCategoryName($key)
                }
            }
        }
        
        $this.CategoryList.SetItems($categories)
        $this.CategoryList.ItemRenderer = { param($cat) $cat.DisplayName }
        
        if ($categories.Count -gt 0) {
            $this.CategoryList.SelectIndex(0)
            # LoadCategorySettings is now called automatically by OnSelectionChanged
        }
    }
    
    [void] LoadCategorySettings() {
        $selected = $this.CategoryList.GetSelectedItem()
        if (-not $selected) { return }
        
        $this.CurrentCategory = $selected.Name
        $categoryConfig = $this.ConfigService.Get($this.CurrentCategory)
        
        if ($categoryConfig -is [hashtable]) {
            $settings = @()
            
            foreach ($key in $categoryConfig.Keys | Sort-Object) {
                $value = $categoryConfig[$key]
                $type = $this.GetValueType($value)
                
                $settings += @{
                    Setting = $this.FormatSettingName($key)
                    Value = $this.FormatValue($value)
                    Type = $type
                    Key = $key
                    RawValue = $value
                }
            }
            
            $this.CurrentSettings = $settings
            $this.SettingsGrid.SetItems($settings)
            $this.SettingsGrid.Title = "Settings - $($selected.DisplayName)"
        }
    }
    
    [void] EditSetting() {
        if (-not $this.SettingsGrid.IsFocused) { return }
        
        $selected = $this.SettingsGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $path = "$($this.CurrentCategory).$($selected.Key)"
        $currentValue = $selected.RawValue
        
        # Create appropriate dialog based on type
        $dialog = $null
        
        switch ($selected.Type) {
            "Boolean" {
                # Simple toggle
                $newValue = -not $currentValue
                $this.ConfigService.Set($path, $newValue)
                
                # Publish config changed event
                if ($this.EventBus) {
                    $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                        Path = $path
                        OldValue = $currentValue
                        NewValue = $newValue
                        Category = $this.CurrentCategory
                    })
                }
                
                $this.LoadCategorySettings()
                return
            }
            "Number" {
                # TODO: Create NumberInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("Number editing not yet implemented")
                }
            }
            "String" {
                # TODO: Create TextInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("String editing not yet implemented")
                }
            }
        }
    }
    
    [void] ResetCategory() {
        if (-not $this.CurrentCategory) { return }
        
        $message = "Reset all settings in '$($this.CurrentCategory)' to defaults?"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.OnConfirm = {
            $this.ConfigService.ResetSection($this.CurrentCategory)
            $this.LoadCategorySettings()
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ResetAll() {
        $message = "Reset ALL settings to defaults?`n`nThis cannot be undone!"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.ConfirmText = "Reset All"
        $dialog.OnConfirm = {
            $this.ConfigService.Reset()
            $this.LoadCategories()
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] SaveSettings() {
        $this.ConfigService.Save()
        if ($global:Logger) {
            $global:Logger.Info("Settings saved")
        }
    }
    
    [void] FocusNext() {
        if ($this.CategoryList.IsFocused) {
            $this.SettingsGrid.Focus()
        } else {
            $this.CategoryList.Focus()
        }
        $this.Invalidate()
    }
    
    hidden [string] FormatCategoryName([string]$name) {
        # Convert PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        return $formatted.Trim()
    }
    
    hidden [string] FormatSettingName([string]$name) {
        # Convert camelCase/PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        $formatted = $formatted.Substring(0,1).ToUpper() + $formatted.Substring(1)
        return $formatted.Trim()
    }
    
    hidden [string] FormatValue($value) {
        if ($value -eq $null) { return "<null>" }
        if ($value -is [bool]) { return $(if ($value) { "Yes" } else { "No" }) }
        if ($value -is [hashtable]) { return "<nested>" }
        if ($value -is [array]) { return "<array[$($value.Count)]>" }
        return $value.ToString()
    }
    
    hidden [string] GetValueType($value) {
        if ($value -eq $null) { return "Null" }
        if ($value -is [bool]) { return "Boolean" }
        if ($value -is [int] -or $value -is [long] -or $value -is [double]) { return "Number" }
        if ($value -is [string]) { return "String" }
        if ($value -is [hashtable]) { return "Object" }
        if ($value -is [array]) { return "Array" }
        return "Unknown"
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Render base
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append("─" * $this.Width)
        
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append(" [Tab]Navigate [Enter/E]Edit [R]Reset Category [Shift+R]Reset All [S]Save")
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
}


####\Screens/TaskScreen.ps1
# TaskScreen.ps1 - Task management screen

class TaskScreen : Screen {
    [ListBox]$TaskList
    [TextBox]$FilterBox
    [TaskService]$TaskService
    [hashtable]$StatusColors
    [hashtable]$PriorityColors
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout settings
    hidden [int]$FilterHeight = 3
    hidden [int]$StatusBarHeight = 2
    
    TaskScreen() : base() {
        $this.Title = "Tasks"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        if (-not $this.TaskService) {
            $this.TaskService = [TaskService]::new()
            $global:ServiceContainer.Register("TaskService", $this.TaskService)
        }
        
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Subscribe to task created events
            $this.EventSubscriptions['TaskCreated'] = $this.EventBus.Subscribe([EventNames]::TaskCreated, {
                param($sender, $eventData)
                $this.LoadTasks()
                # Select the new task if provided
                if ($eventData.Task) {
                    for ($i = 0; $i -lt $this.TaskList.Items.Count; $i++) {
                        if ($this.TaskList.Items[$i].Id -eq $eventData.Task.Id) {
                            $this.TaskList.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe([EventNames]::CommandExecuted, {
                param($sender, $eventData)
                if ($eventData.Target -eq 'TaskScreen') {
                    switch ($eventData.Command) {
                        'NewTask' { $this.NewTask() }
                        'EditTask' { $this.EditTask() }
                        'DeleteTask' { $this.DeleteTask() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to task updated events
            $this.EventSubscriptions['TaskUpdated'] = $this.EventBus.Subscribe([EventNames]::TaskUpdated, {
                param($sender, $eventData)
                $this.LoadTasks()
            }.GetNewClosure())
            
            # Subscribe to task deleted events
            $this.EventSubscriptions['TaskDeleted'] = $this.EventBus.Subscribe([EventNames]::TaskDeleted, {
                param($sender, $eventData)
                $this.LoadTasks()
            }.GetNewClosure())
        }
        
        # Set up color mappings
        $this.StatusColors = @{
            [TaskStatus]::Pending = "foreground"
            [TaskStatus]::InProgress = "warning"
            [TaskStatus]::Completed = "success"
            [TaskStatus]::Cancelled = "disabled"
        }
        
        $this.PriorityColors = @{
            [TaskPriority]::Low = "success"
            [TaskPriority]::Medium = "warning"
            [TaskPriority]::High = "error"
        }
        
        # Create filter box
        $this.FilterBox = [TextBox]::new()
        $this.FilterBox.Placeholder = "Filter tasks... (type to search)"
        $this.FilterBox.ShowBorder = $true
        $taskScreen = $this
        $this.FilterBox.OnChange = {
            param($text)
            $taskScreen.ApplyFilter()
        }.GetNewClosure()
        $this.FilterBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.FilterBox)
        
        # Create task list
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = "Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.ItemRenderer = {
            param($task)
            $status = $task.GetStatusDisplay()
            $priority = $task.GetPriorityDisplay()
            
            # Build display string
            $display = "$status $priority $($task.Title)"
            
            # Add due date indicator if applicable
            if ($task.DueDate -ne [DateTime]::MinValue) {
                $days = $task.GetDaysUntilDue()
                if ($task.IsOverdue()) {
                    $display += " [OVERDUE]"
                } elseif ($days -le 3) {
                    $display += " [Due in $days days]"
                }
            }
            
            # Add progress if in progress
            if ($task.Status -eq [TaskStatus]::InProgress -and $task.Progress -gt 0) {
                $display += " ($($task.Progress)%)"
            }
            
            return $display
        }
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.AddChild($this.TaskList)
        
        # Load tasks
        $this.LoadTasks()
        
        # Key bindings
        $this.BindKey('n', { $this.NewTask() })
        $this.BindKey('e', { $this.EditTask() })
        $this.BindKey([System.ConsoleKey]::Enter, { $this.EditTask() })
        $this.BindKey('d', { $this.DeleteTask() })
        $this.BindKey([System.ConsoleKey]::Delete, { $this.DeleteTask() })
        $this.BindKey('r', { $this.LoadTasks() })
        $this.BindKey([System.ConsoleKey]::F5, { $this.LoadTasks() })
        $this.BindKey('s', { $this.CycleStatus() })
        $this.BindKey('p', { $this.CyclePriority() })
        $this.BindKey('f', { $this.FilterBox.Focus() })  # 'f' for filter
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Escape, {
            if ($this.FilterBox.IsFocused -and $this.FilterBox.Text) {
                $this.FilterBox.Clear()
                $this.ApplyFilter()
                $this.TaskList.Focus()
            }
        })
        
        # Focus on task list
        $this.TaskList.Focus()
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure task list has focus when screen is activated
        if ($this.TaskList) {
            # Ensure the TaskScreen itself is focused first
            $this.Focus()
            
            # Then focus the TaskList
            $this.TaskList.Focus()
            if ($global:Logger) {
                $global:Logger.Debug("TaskScreen.OnActivated: Focused TaskList")
                $focused = $this.FindFocused()
                $global:Logger.Debug("TaskScreen.OnActivated: Currently focused element: $($focused.GetType().Name)")
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Layout: Filter at top, tasks in middle, status at bottom
        $contentHeight = $this.Height - $this.FilterHeight - $this.StatusBarHeight
        
        # Filter box
        $this.FilterBox.SetBounds(
            $this.X,
            $this.Y,
            $this.Width,
            $this.FilterHeight
        )
        
        # Task list
        $this.TaskList.SetBounds(
            $this.X,
            $this.Y + $this.FilterHeight,
            $this.Width,
            $contentHeight
        )
    }
    
    [void] LoadTasks() {
        $tasks = $this.TaskService.GetAllTasks()
        
        # Filter out deleted tasks
        $activeTasks = $tasks | Where-Object { -not $_.Deleted }
        
        # Sort by priority (high first), then status, then due date
        $sorted = $activeTasks | Sort-Object -Property `
            @{Expression = {$_.Priority}; Descending = $true},
            @{Expression = {$_.Status}; Ascending = $true},
            @{Expression = {if ($_.DueDate -eq [DateTime]::MinValue) { [DateTime]::MaxValue } else { $_.DueDate }}; Ascending = $true}
        
        $this.TaskList.SetItems($sorted)
    }
    
    [void] ApplyFilter() {
        $filterText = $this.FilterBox.Text.ToLower()
        
        if ([string]::IsNullOrWhiteSpace($filterText)) {
            $this.LoadTasks()
            return
        }
        
        $tasks = $this.TaskService.GetAllTasks()
        $filtered = $tasks | Where-Object {
            -not $_.Deleted -and (
                $_.Title.ToLower().Contains($filterText) -or
                $_.Description.ToLower().Contains($filterText) -or
                $_.Tags -contains $filterText
            )
        }
        
        # Sort filtered results
        $sorted = $filtered | Sort-Object -Property `
            @{Expression = {$_.Priority}; Descending = $true},
            @{Expression = {$_.Status}; Ascending = $true},
            @{Expression = {if ($_.DueDate -eq [DateTime]::MinValue) { [DateTime]::MaxValue } else { $_.DueDate }}; Ascending = $true}
        
        $this.TaskList.SetItems($sorted)
    }
    
    [void] NewTask() {
        # Create new task dialog
        $dialog = [NewTaskDialog]::new()
        
        # EventBus will handle task creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($taskData)
                
                $task = $screen.TaskService.CreateTask($taskData)
                $screen.LoadTasks()
                
                # Select the new task
                for ($i = 0; $i -lt $screen.TaskList.Items.Count; $i++) {
                    if ($screen.TaskList.Items[$i].Id -eq $task.Id) {
                        $screen.TaskList.SelectIndex($i)
                        break
                    }
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditTask() {
        $selected = $this.TaskList.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit task dialog
        $dialog = [EditTaskDialog]::new($selected)
        # Capture references
        $screen = $this
        $task = $selected
        $dialog.OnSave = {
            param($taskData)
            
            # Update the task
            $task.Title = $taskData.Title
            $task.Description = $taskData.Description
            $task.Status = $taskData.Status
            $task.Priority = $taskData.Priority
            $task.Progress = $taskData.Progress
            $task.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.TaskService.UpdateTask($task)
            
            # Publish task updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskUpdated, @{ Task = $task })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteTask() {
        $selected = $this.TaskList.GetSelectedItem()
        if (-not $selected) { return }
        
        # Show confirmation dialog
        $message = "Are you sure you want to delete this task?`n`n$($selected.Title)"
        $dialog = [ConfirmationDialog]::new($message)
        # Capture references
        $screen = $this
        $taskId = $selected.Id
        $dialog.OnConfirm = {
            $screen.TaskService.DeleteTask($taskId)
            
            # Publish task deleted event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskDeleted, @{ TaskId = $taskId })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CycleStatus() {
        $selected = $this.TaskList.GetSelectedItem()
        if (-not $selected) { return }
        
        # Cycle through status values
        $newStatus = switch ($selected.Status) {
            ([TaskStatus]::Pending) { [TaskStatus]::InProgress }
            ([TaskStatus]::InProgress) { [TaskStatus]::Completed }
            ([TaskStatus]::Completed) { [TaskStatus]::Cancelled }
            ([TaskStatus]::Cancelled) { [TaskStatus]::Pending }
        }
        
        $this.TaskService.UpdateTaskStatus($selected.Id, $newStatus)
        
        # Publish task status changed event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TaskStatusChanged, @{ 
                TaskId = $selected.Id
                OldStatus = $selected.Status
                NewStatus = $newStatus
            })
        } else {
            # Fallback if EventBus not available
            $this.LoadTasks()
        }
    }
    
    [void] CyclePriority() {
        $selected = $this.TaskList.GetSelectedItem()
        if (-not $selected) { return }
        
        $this.TaskService.CyclePriority($selected.Id)
        $this.LoadTasks()
    }
    
    [void] FocusNext() {
        $focused = $this.FindFocused()
        
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.FocusNext: Currently focused: $($focused.GetType().Name)")
            $global:Logger.Debug("TaskScreen.FocusNext: FilterBox.IsFocused=$($this.FilterBox.IsFocused), TaskList.IsFocused=$($this.TaskList.IsFocused)")
        }
        
        if ($focused -eq $this.FilterBox) {
            # Focus TaskList (Focus() method will handle unfocusing FilterBox)
            $this.TaskList.Focus()
            if ($global:Logger) {
                $global:Logger.Debug("TaskScreen: Switched focus from FilterBox to TaskList")
            }
        } elseif ($focused -eq $this.TaskList) {
            # Focus FilterBox (Focus() method will handle unfocusing TaskList)
            $this.FilterBox.Focus()
            if ($global:Logger) {
                $global:Logger.Debug("TaskScreen: Switched focus from TaskList to FilterBox")
            }
        } else {
            # Neither has focus, focus the list first
            $this.TaskList.Focus()
            if ($global:Logger) {
                $global:Logger.Debug("TaskScreen: No child focused, focusing TaskList")
            }
        }
        
        # Verify focus was actually changed
        $newFocused = $this.FindFocused()
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.FocusNext: After switch, focused: $($newFocused.GetType().Name)")
            $global:Logger.Debug("TaskScreen.FocusNext: After switch - FilterBox.IsFocused=$($this.FilterBox.IsFocused), TaskList.IsFocused=$($this.TaskList.IsFocused)")
        }
        
        # Force re-render to show focus change
        $this.Invalidate()
        if ($global:ScreenManager) {
            $global:ScreenManager.RequestRender()
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Let base class handle key bindings first
        if (([Screen]$this).HandleInput($key)) {
            if ($global:Logger) {
                $global:Logger.Debug("TaskScreen: Input handled by Screen base class")
            }
            return $true
        }
        
        # Otherwise let Container handle focused child input
        return ([Container]$this).HandleInput($key)
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Render base (background and children)
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - $this.StatusBarHeight
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append("─" * $this.Width)
        
        # Status text
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY + 1))
        $sb.Append($this.Theme.GetColor("disabled"))
        
        # Show focus indicator
        $focused = $this.FindFocused()
        $focusInfo = if ($focused -eq $this.FilterBox) { "[FILTER]" } elseif ($focused -eq $this.TaskList) { "[LIST]" } else { "[NONE]" }
        
        $selected = $this.TaskList.GetSelectedItem()
        if ($selected) {
            # Show task details in status bar
            $sb.Append("$focusInfo Task: $($selected.Title) | Status: $($selected.Status) | Priority: $($selected.Priority)")
        } else {
            # Show help text
            $sb.Append("$focusInfo [N]ew [E]dit [D]elete [S]tatus [P]riority [/]Filter [Tab]Navigate")
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
}


####\Screens/TestScreen.ps1
# TestScreen.ps1 - Simple test screen to verify PRAXIS is working

class TestScreen : Screen {
    [string]$Message = "PRAXIS Test Screen"
    [int]$Counter = 0
    hidden [string]$_cachedContent = ""
    
    TestScreen() : base() {
        $this.Title = "Test"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnInitialize: $($this.Title)")
        }
        
        # Set up key bindings
        $this.BindKey([System.ConsoleKey]::Spacebar, { 
            $this.Counter++
            $this._cachedContent = ""  # Force re-render
            $this.RequestRender() 
        })
        
        $this.BindKey('q', { $this.Active = $false })
        $this.BindKey([System.ConsoleKey]::Escape, { $this.Active = $false })
        
        # Don't rebuild content here - wait until we have bounds
    }
    
    [void] OnThemeChanged() {
        ([Screen]$this).OnThemeChanged()
        $this._cachedContent = ""
        $this.RebuildContent()
    }
    
    [void] RebuildContent() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Calculate absolute positions
        $absoluteCenterY = $this.Y + [int]($this.Height / 2)
        $absoluteCenterX = $this.X + [int](($this.Width - $this.Message.Length) / 2)
        
        # Title
        $sb.Append([VT]::MoveTo($absoluteCenterX, $absoluteCenterY - 2))
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append($this.Message)
        
        # Counter
        $counterText = "Counter: $($this.Counter)"
        $counterX = $this.X + [int](($this.Width - $counterText.Length) / 2)
        $sb.Append([VT]::MoveTo($counterX, $absoluteCenterY))
        $sb.Append($this.Theme.GetColor("foreground"))
        $sb.Append($counterText)
        
        # Instructions
        $instructionText = "Press SPACE to increment, Q to quit"
        $instructionX = $this.X + [int](($this.Width - $instructionText.Length) / 2)
        $sb.Append([VT]::MoveTo($instructionX, $absoluteCenterY + 2))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append($instructionText)
        
        # FPS counter (bottom right)
        if ($global:ScreenManager) {
            $fps = [Math]::Round($global:ScreenManager.GetFPS(), 1)
            $fpsText = "FPS: $fps"
            $sb.Append([VT]::MoveTo($this.X + $this.Width - $fpsText.Length - 2, $this.Y + $this.Height - 2))
            $sb.Append($this.Theme.GetColor("success"))
            $sb.Append($fpsText)
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedContent = $sb.ToString()
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnRender: Bounds X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
        }
        
        # Check if we need to rebuild
        if ([string]::IsNullOrEmpty($this._cachedContent)) {
            $this.RebuildContent()
        }
        
        # Return base background + our content
        return ([Container]$this).OnRender() + $this._cachedContent
    }
}


####\Screens/TextInputDialog.ps1
# TextInputDialog.ps1 - Simple dialog for text input

class TextInputDialog : Screen {
    [string]$Prompt
    [string]$DefaultValue
    [string]$Placeholder
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    TextInputDialog([string]$prompt) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = ""
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    TextInputDialog([string]$prompt, [string]$defaultValue) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue
        $this.InputBox.Placeholder = $this.Placeholder
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            if ($dialog.OnSubmit) {
                & $dialog.OnSubmit $dialog.InputBox.Text
            }
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box and select all text
        $this.InputBox.Focus()
        # TODO: Add SelectAll method to TextBox
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 10 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Services/ConfigurationService.ps1
# ConfigurationService.ps1 - Configuration management with persistence

class ConfigurationService {
    hidden [string]$ConfigPath
    hidden [hashtable]$Config
    hidden [hashtable]$Defaults
    hidden [bool]$AutoSave = $true
    
    ConfigurationService() {
        $this.ConfigPath = Join-Path $global:PraxisRoot "_Config" "settings.json"
        $this.InitializeDefaults()
        $this.Load()
    }
    
    ConfigurationService([string]$configPath) {
        $this.ConfigPath = $configPath
        $this.InitializeDefaults()
        $this.Load()
    }
    
    hidden [void] InitializeDefaults() {
        $this.Defaults = @{
            Theme = "default"
            Editor = @{
                TabSize = 4
                WordWrap = $false
                ShowLineNumbers = $true
                HighlightCurrentLine = $true
            }
            UI = @{
                AnimationsEnabled = $true
                ShowScrollbars = $true
                CompactMode = $false
            }
            Projects = @{
                DefaultPath = Join-Path $global:PraxisRoot "_ProjectData"
                AutoSave = $true
                BackupEnabled = $true
                BackupCount = 5
            }
            Tasks = @{
                DefaultPriority = "Medium"
                ShowCompletedTasks = $true
                CompletedTaskRetention = 30  # days
            }
            Performance = @{
                EnableCaching = $true
                MaxCacheSize = 100  # MB
                RenderOptimization = $true
            }
            Logging = @{
                Level = "Info"
                MaxFileSize = 10  # MB
                MaxFiles = 5
            }
        }
    }
    
    [void] Load() {
        # Ensure config directory exists
        $configDir = Split-Path -Parent $this.ConfigPath
        if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir -Force | Out-Null
        }
        
        # Load config from file or use defaults
        if (Test-Path $this.ConfigPath) {
            try {
                $json = Get-Content -Path $this.ConfigPath -Raw
                $loaded = $json | ConvertFrom-Json -AsHashtable
                
                # Merge with defaults to ensure all keys exist
                $this.Config = $this.MergeHashtables($this.Defaults, $loaded)
                
                if ($global:Logger) {
                    $global:Logger.Info("Configuration loaded from: $($this.ConfigPath)")
                }
            } catch {
                Write-Warning "Failed to load configuration: $_"
                $this.Config = $this.Defaults.Clone()
            }
        } else {
            # No config file, use defaults and save
            $this.Config = $this.Defaults.Clone()
            $this.Save()
        }
    }
    
    [void] Save() {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $this.ConfigPath -Value $json -Encoding UTF8
            
            if ($global:Logger) {
                $global:Logger.Debug("Configuration saved to: $($this.ConfigPath)")
            }
        } catch {
            Write-Warning "Failed to save configuration: $_"
        }
    }
    
    # Deep merge hashtables, preserving structure
    hidden [hashtable] MergeHashtables([hashtable]$base, [hashtable]$overlay) {
        $result = $base.Clone()
        
        foreach ($key in $overlay.Keys) {
            if ($base.ContainsKey($key) -and $base[$key] -is [hashtable] -and $overlay[$key] -is [hashtable]) {
                # Recursively merge nested hashtables
                $result[$key] = $this.MergeHashtables($base[$key], $overlay[$key])
            } else {
                # Overlay value takes precedence
                $result[$key] = $overlay[$key]
            }
        }
        
        return $result
    }
    
    # Get configuration value with dot notation support
    [object] Get([string]$path) {
        return $this.Get($path, $null)
    }
    
    [object] Get([string]$path, $default) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $default
            }
        }
        
        return $current
    }
    
    # Set configuration value with dot notation support
    [void] Set([string]$path, $value) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            } elseif ($current[$part] -isnot [hashtable]) {
                # Path conflict - convert to hashtable
                $current[$part] = @{}
            }
            
            $current = $current[$part]
        }
        
        # Set the final value
        $lastPart = $parts[-1]
        $current[$lastPart] = $value
        
        # Auto-save if enabled
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Check if configuration key exists
    [bool] Has([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $false
            }
        }
        
        return $true
    }
    
    # Remove configuration key
    [void] Remove([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                # Path doesn't exist
                return
            }
        }
        
        # Remove the final key
        $lastPart = $parts[-1]
        if ($current -is [hashtable] -and $current.ContainsKey($lastPart)) {
            $current.Remove($lastPart)
            
            # Auto-save if enabled
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Reset to defaults
    [void] Reset() {
        $this.Config = $this.Defaults.Clone()
        $this.Save()
    }
    
    # Reset specific section to defaults
    [void] ResetSection([string]$section) {
        if ($this.Defaults.ContainsKey($section)) {
            $this.Config[$section] = $this.Defaults[$section].Clone()
            
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Get all configuration as hashtable
    [hashtable] GetAll() {
        return $this.Config.Clone()
    }
    
    # Import configuration from hashtable
    [void] Import([hashtable]$config) {
        $this.Config = $this.MergeHashtables($this.Defaults, $config)
        
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Export configuration to file
    [void] Export([string]$path) {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $path -Value $json -Encoding UTF8
        } catch {
            throw "Failed to export configuration: $_"
        }
    }
}


####\Services/EventBus.ps1
# EventBus Service for PRAXIS
# Based on AxiomPhoenix EventManager with adaptations for PRAXIS architecture
# Provides pub/sub event system for decoupled communication between components

class EventBus {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $false  # Disabled by default for performance
    [ServiceContainer]$ServiceContainer
    [bool]$EnableDebugLogging = $false  # Enable detailed event logging
    hidden [int]$TotalEventsPublished = 0
    hidden [int]$TotalHandlersCalled = 0
    
    EventBus() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.ServiceContainer = $container
        $logger = $container.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus initialized", "Info")
        }
    }
    
    # Subscribe to an event with a handler
    # Returns a subscription ID that can be used to unsubscribe
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("Handler cannot be null")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        $logger = $this.ServiceContainer.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus: Subscribed handler '$handlerId' to event '$eventName'", "Debug")
        }
        
        return $handlerId
    }
    
    # Subscribe with a weak reference to an object
    # Automatically unsubscribes if the object is garbage collected
    [string] SubscribeWeak([string]$eventName, [object]$target, [scriptblock]$handler) {
        $weakRef = [System.WeakReference]::new($target)
        $wrappedHandler = {
            param($sender, $eventData)
            $strongRef = $weakRef.Target
            if ($strongRef) {
                & $handler $sender $eventData
            } else {
                # Target has been garbage collected, unsubscribe
                $eventBus = $sender
                $eventBus.Unsubscribe($eventName, $args[0])
            }
        }.GetNewClosure()
        
        return $this.Subscribe($eventName, $wrappedHandler)
    }
    
    # Unsubscribe a specific handler
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
                
                $logger = $this.ServiceContainer.GetService('Logger')
                if ($logger) {
                    $logger.Log("EventBus: Unsubscribed handler '$handlerId' from event '$eventName'", "Debug")
                }
            }
        }
    }
    
    # Unsubscribe all handlers for an event
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Unsubscribed all $handlerCount handlers from event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event with optional data
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        # Add timestamp to event data
        $eventData['Timestamp'] = [DateTime]::Now
        $eventData['EventName'] = $eventName
        
        $this.TotalEventsPublished++
        
        # Debug logging
        if ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Publishing event '$eventName' with data: $($eventData | ConvertTo-Json -Compress)", "Debug")
            }
        }
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $this.AddToHistory($eventName, $eventData)
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            
            if ($this.EnableDebugLogging) {
                $debugLogger = $this.ServiceContainer.GetService('Logger')
                if ($debugLogger) {
                    $debugLogger.Log("EventBus: Found $($handlers.Count) handlers for event '$eventName'", "Debug")
                }
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    $this.TotalHandlersCalled++
                    
                    if ($this.EnableDebugLogging) {
                        $debugLogger = $this.ServiceContainer.GetService('Logger')
                        if ($debugLogger) {
                            $debugLogger.Log("EventBus: Calling handler '$($entry.Key)' for event '$eventName'", "Debug")
                        }
                    }
                    
                    # Call handler with EventBus as sender and eventData
                    & $handlerData.Handler $this $eventData
                }
                catch {
                    $logger = $this.ServiceContainer.GetService('Logger')
                    if ($logger) {
                        $logger.Log("EventBus: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)", "Error")
                    }
                }
            }
        }
        elseif ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: No handlers registered for event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event asynchronously (returns immediately)
    [void] PublishAsync([string]$eventName, [hashtable]$eventData = @{}) {
        $job = Start-Job -ScriptBlock {
            param($eventBus, $eventName, $eventData)
            $eventBus.Publish($eventName, $eventData)
        } -ArgumentList $this, $eventName, $eventData
        
        # Clean up job after completion
        Register-ObjectEvent -InputObject $job -EventName StateChanged -Action {
            if ($Event.SourceEventArgs.JobStateInfo.State -eq 'Completed') {
                Remove-Job -Job $Event.SourceEventArgs
                Unregister-Event -SourceIdentifier $Event.SourceIdentifier
            }
        } | Out-Null
    }
    
    # Add event to history
    hidden [void] AddToHistory([string]$eventName, [hashtable]$eventData) {
        # Sanitize event data to prevent circular references
        $sanitizedData = @{}
        foreach ($key in $eventData.Keys) {
            $value = $eventData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [double] -or 
                $value -is [bool] -or $value -is [datetime] -or $value -eq $null) {
                $sanitizedData[$key] = $value
            }
            elseif ($value.GetType().Name -eq 'UIElement' -or $value.GetType().BaseType.Name -eq 'UIElement') {
                # Handle UIElement without requiring the type to be loaded
                $name = if ($value.PSObject.Properties['Name']) { $value.Name } else { 'Unknown' }
                $sanitizedData[$key] = "[UIElement: $name]"
            }
            else {
                $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
            }
        }
        
        $historyEntry = @{
            EventName = $eventName
            EventData = $sanitizedData
            Timestamp = [DateTime]::Now
            HandlerCount = if ($this.EventHandlers.ContainsKey($eventName)) { 
                $this.EventHandlers[$eventName].Count 
            } else { 0 }
        }
        
        $this.EventHistory.Add($historyEntry)
        
        if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
            $this.EventHistory.RemoveAt(0)
        }
    }
    
    # Get event history
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory.Where({ $_.EventName -eq $eventName })
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    # Clear event history
    [void] ClearHistory() {
        $this.EventHistory.Clear()
    }
    
    # Get information about registered events
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
            TotalEventsPublished = $this.TotalEventsPublished
            TotalHandlersCalled = $this.TotalHandlersCalled
            EnableHistory = $this.EnableHistory
            EnableDebugLogging = $this.EnableDebugLogging
            HistorySize = $this.EventHistory.Count
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { 
                    @{
                        Id = $_
                        ExecutionCount = $handlers[$_].ExecutionCount
                        SubscribedAt = $handlers[$_].SubscribedAt
                    }
                }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
    
    # Get debug report
    [string] GetDebugReport() {
        $sb = [System.Text.StringBuilder]::new()
        $info = $this.GetEventInfo()
        
        $sb.AppendLine("EventBus Debug Report")
        $sb.AppendLine("====================")
        $sb.AppendLine("Total Events Published: $($info.TotalEventsPublished)")
        $sb.AppendLine("Total Handlers Called: $($info.TotalHandlersCalled)")
        $sb.AppendLine("Active Handlers: $($info.TotalHandlers)")
        $sb.AppendLine("History Enabled: $($info.EnableHistory)")
        $sb.AppendLine("Debug Logging: $($info.EnableDebugLogging)")
        $sb.AppendLine("History Size: $($info.HistorySize)/$($this.MaxHistorySize)")
        $sb.AppendLine("")
        $sb.AppendLine("Registered Events:")
        
        foreach ($eventName in $info.RegisteredEvents.Keys | Sort-Object) {
            $eventInfo = $info.RegisteredEvents[$eventName]
            $sb.AppendLine("  $eventName : $($eventInfo.HandlerCount) handler(s)")
            
            foreach ($handler in $eventInfo.Handlers) {
                $sb.AppendLine("    - $($handler.Id): $($handler.ExecutionCount) executions")
            }
        }
        
        return $sb.ToString()
    }
}

# Common Event Names (for consistency across the application)
class EventNames {
    # Project Events
    static [string]$ProjectCreated = 'project.created'
    static [string]$ProjectUpdated = 'project.updated'
    static [string]$ProjectDeleted = 'project.deleted'
    static [string]$ProjectSelected = 'project.selected'
    
    # Task Events
    static [string]$TaskCreated = 'task.created'
    static [string]$TaskUpdated = 'task.updated'
    static [string]$TaskDeleted = 'task.deleted'
    static [string]$TaskSelected = 'task.selected'
    static [string]$TaskStatusChanged = 'task.statusChanged'
    
    # Navigation Events
    static [string]$TabChanged = 'navigation.tabChanged'
    static [string]$ScreenChanged = 'navigation.screenChanged'
    static [string]$DialogOpened = 'navigation.dialogOpened'
    static [string]$DialogClosed = 'navigation.dialogClosed'
    
    # Application Events
    static [string]$AppInitialized = 'app.initialized'
    static [string]$AppShutdown = 'app.shutdown'
    static [string]$ThemeChanged = 'app.themeChanged'
    static [string]$ConfigChanged = 'app.configChanged'
    static [string]$RefreshRequested = 'app.refreshRequested'
    static [string]$DataChanged = 'app.dataChanged'
    
    # Command Events
    static [string]$CommandExecuted = 'command.executed'
    static [string]$CommandRegistered = 'command.registered'
    
    # UI Events
    static [string]$FocusChanged = 'ui.focusChanged'
    static [string]$SelectionChanged = 'ui.selectionChanged'
}

# Helper class for command registration
class CommandRegistration {
    static [void] RegisterCommand([string]$name, [string]$description, [scriptblock]$action) {
        $eventBus = $global:ServiceContainer.GetService('EventBus')
        if ($eventBus) {
            $eventBus.Publish([EventNames]::CommandRegistered, @{
                Name = $name
                Description = $description
                Action = $action
            })
        }
    }
}


####\Services/Logger.ps1
# Logger.ps1 - Fast logging service adapted from AxiomPhoenix
# Optimized for speed - no console output, minimal file I/O

class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 100  # Smaller queue for faster flushing
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false  # Never log to console in TUI
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    hidden [System.Text.StringBuilder]$_buffer
    hidden [int]$_unflushedCount = 0
    hidden [int]$_flushThreshold = 10  # Flush every N messages
    
    Logger() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { (Get-Location).Path }
        $logDir = Join-Path $praxisDir "_Logs"
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        $this.LogPath = Join-Path $logDir "praxis.log"
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        $this._buffer = [System.Text.StringBuilder]::new(4096)  # Pre-allocate buffer
        
        # Check for debug mode
        if ($global:PraxisDebug -or $env:PRAXIS_DEBUG) {
            $this.MinimumLevel = "Debug"
        }
        
        # Rotate log if too large (>10MB)
        try {
            if ((Test-Path $this.LogPath) -and (Get-Item $this.LogPath).Length -gt 10MB) {
                $backupPath = $this.LogPath + ".old"
                Move-Item $this.LogPath $backupPath -Force -ErrorAction SilentlyContinue
            }
        } catch {
            # Ignore rotation errors
        }
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Fast level check
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        # Format timestamp efficiently
        $timestamp = [DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
        $levelPadded = $level.ToUpper().PadRight(7)
        
        # Build log line
        $logLine = "$timestamp [$levelPadded] $message"
        
        # Add to buffer instead of queue for speed
        $this._buffer.AppendLine($logLine)
        $this._unflushedCount++
        
        # Auto-flush on threshold or error/fatal
        if ($this._unflushedCount -ge $this._flushThreshold -or 
            $level -eq "Error" -or $level -eq "Fatal") {
            $this.Flush()
        }
    }
    
    [void] LogException([Exception]$exception, [string]$context = "") {
        $message = if ($context) { "$context - " } else { "" }
        $message += "$($exception.GetType().Name): $($exception.Message)"
        $this.Log($message, "Error")
        
        # Log stack trace as debug
        if ($exception.StackTrace) {
            $this.Log("Stack: $($exception.StackTrace -replace "`n", " ")", "Debug")
        }
    }
    
    [void] Flush() {
        if ($this._buffer.Length -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            # Write buffer to file in one operation
            [System.IO.File]::AppendAllText($this.LogPath, $this._buffer.ToString())
            $this._buffer.Clear()
            $this._unflushedCount = 0
        }
        catch {
            # Ignore logging errors to prevent crashes
        }
    }
    
    # Quick logging methods
    [void] Debug([string]$message) { $this.Log($message, "Debug") }
    [void] Info([string]$message) { $this.Log($message, "Info") }
    [void] Warning([string]$message) { $this.Log($message, "Warning") }
    [void] Error([string]$message) { $this.Log($message, "Error") }
    
    [void] Cleanup() {
        $this.Flush()
    }
}

# Global Write-Log function for compatibility
function global:Write-Log {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    if ($global:Logger) {
        $global:Logger.Log($Message, $Level)
    }
}


####\Services/ProjectService.ps1
# ProjectService - Business logic for project management
# Lightweight service focusing on project-related operations

class ProjectService {
    hidden [System.Collections.ArrayList]$Projects = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile
    
    ProjectService() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PSScriptRoot }
        $this.DataFile = Join-Path $praxisDir "_ProjectData/projects.json"
        
        # Ensure directory exists
        $dataDir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        $this.LoadProjects()
    }
    
    [void] LoadProjects() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Projects.Clear()
                foreach ($projData in $data) {
                    # Handle both old and new format
                    if ($projData.PSObject.Properties['FullProjectName']) {
                        # New PMC format
                        $project = [Project]::new($projData.FullProjectName, $projData.Nickname)
                        $project.Id = $projData.Id
                        $project.ID1 = $projData.ID1 ?? ""
                        $project.ID2 = $projData.ID2 ?? ""
                        if ($projData.DateAssigned) { $project.DateAssigned = [DateTime]::Parse($projData.DateAssigned) }
                        if ($projData.BFDate) { $project.BFDate = [DateTime]::Parse($projData.BFDate) }
                        if ($projData.DateDue) { $project.DateDue = [DateTime]::Parse($projData.DateDue) }
                        $project.Note = $projData.Note ?? ""
                        $project.CAAPath = $projData.CAAPath ?? ""
                        $project.RequestPath = $projData.RequestPath ?? ""
                        $project.T2020Path = $projData.T2020Path ?? ""
                        $project.CumulativeHrs = $projData.CumulativeHrs ?? 0
                        if ($projData.ClosedDate -and $projData.ClosedDate -ne "0001-01-01T00:00:00") { 
                            $project.ClosedDate = [DateTime]::Parse($projData.ClosedDate) 
                        }
                        $project.Deleted = $projData.Deleted ?? $false
                    } else {
                        # Legacy format
                        $project = [Project]::new($projData.Name)
                        $project.Id = $projData.Id
                        if ($projData.Description) { $project.Note = $projData.Description }
                    }
                    $this.Projects.Add($project) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load projects: $_"
            }
        }
        
        # Ensure default project exists
        if (-not ($this.Projects | Where-Object { $_.Nickname -eq "Default" })) {
            $default = [Project]::new("Default")
            $default.Note = "Default project for uncategorized tasks"
            $this.Projects.Add($default) | Out-Null
            $this.SaveProjects()
        }
    }
    
    [void] SaveProjects() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($project in $this.Projects) {
            $data += @{
                Id = $project.Id
                FullProjectName = $project.FullProjectName
                Nickname = $project.Nickname
                ID1 = $project.ID1
                ID2 = $project.ID2
                DateAssigned = $project.DateAssigned.ToString("yyyy-MM-ddTHH:mm:ss")
                BFDate = $project.BFDate.ToString("yyyy-MM-ddTHH:mm:ss")
                DateDue = $project.DateDue.ToString("yyyy-MM-ddTHH:mm:ss")
                Note = $project.Note
                CAAPath = $project.CAAPath
                RequestPath = $project.RequestPath
                T2020Path = $project.T2020Path
                CumulativeHrs = $project.CumulativeHrs
                ClosedDate = $project.ClosedDate.ToString("yyyy-MM-ddTHH:mm:ss")
                Deleted = $project.Deleted
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Project[]] GetAllProjects() {
        return $this.Projects.ToArray()
    }
    
    [Project] GetProject([string]$id) {
        return $this.Projects | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Project] GetProjectByName([string]$name) {
        return $this.Projects | Where-Object { $_.Nickname -eq $name -or $_.FullProjectName -eq $name } | Select-Object -First 1
    }
    
    [Project] AddProject([string]$name) {
        # Check if already exists
        $existing = $this.GetProjectByName($name)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($name)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([Project]$project) {
        # Check if already exists by nickname
        $existing = $this.GetProjectByName($project.Nickname)
        if ($existing) {
            return $existing
        }
        
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [void] UpdateProject([Project]$project) {
        $this.SaveProjects()
    }
    
    [void] DeleteProject([string]$id) {
        $project = $this.GetProject($id)
        if ($project -and $project.Nickname -ne "Default") {
            $this.Projects.Remove($project)
            $this.SaveProjects()
        }
    }
    
    [hashtable[]] GetProjectsWithStats([object]$taskService) {
        $result = @()
        
        foreach ($project in $this.Projects) {
            $tasks = $taskService.GetTasksByProject($project.Nickname)
            $completed = ($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $total = $tasks.Count
            
            $result += @{
                Project = $project
                Name = $project.Nickname  # Use nickname for compatibility
                FullName = $project.FullProjectName
                TaskCount = $total
                CompletedCount = $completed
                Progress = if ($total -gt 0) { $completed / $total } else { 0 }
            }
        }
        
        return $result
    }
}


####\Services/TaskService.ps1
# TaskService.ps1 - Service for managing tasks

class TaskService {
    [System.Collections.Generic.List[Task]]$Tasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    TaskService() {
        $this.Tasks = [System.Collections.Generic.List[Task]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "tasks.json"
        
        # Load existing tasks
        $this.Load()
    }
    
    # CRUD Operations
    [Task] AddTask([string]$title, [string]$projectId) {
        $task = [Task]::new()
        $task.Title = $title
        $task.ProjectId = $projectId
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] CreateTask([hashtable]$properties) {
        $task = [Task]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($task.PSObject.Properties.Name -contains $key) {
                $task.$key = $properties[$key]
            }
        }
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] GetTask([string]$id) {
        return $this.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Task[]] GetAllTasks() {
        return $this.Tasks.ToArray()
    }
    
    [Task[]] GetTasksByProject([string]$projectId) {
        return $this.Tasks | Where-Object { $_.ProjectId -eq $projectId -and -not $_.Deleted }
    }
    
    [Task[]] GetActiveTasks() {
        return $this.Tasks | Where-Object { 
            -not $_.Deleted -and 
            $_.Status -ne [TaskStatus]::Completed -and 
            $_.Status -ne [TaskStatus]::Cancelled 
        }
    }
    
    [void] UpdateTask([Task]$task) {
        $task.UpdatedAt = Get-Date
        $this._isDirty = $true
        $this.Save()
    }
    
    [void] DeleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.Deleted = $true
            $task.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Status management
    [void] UpdateTaskStatus([string]$id, [TaskStatus]$status) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.Status = $status
            $task.UpdatedAt = Get-Date
            
            # Auto-update progress
            if ($status -eq [TaskStatus]::Completed) {
                $task.Progress = 100
            } elseif ($status -eq [TaskStatus]::Pending) {
                $task.Progress = 0
            }
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Priority management
    [void] CyclePriority([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            switch ($task.Priority) {
                ([TaskPriority]::Low) { $task.Priority = [TaskPriority]::Medium }
                ([TaskPriority]::Medium) { $task.Priority = [TaskPriority]::High }
                ([TaskPriority]::High) { $task.Priority = [TaskPriority]::Low }
            }
            $task.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Persistence
    [void] Save() {
        if (-not $this._isDirty) { return }
        
        try {
            $json = $this.Tasks | ConvertTo-Json -Depth 10
            $json | Set-Content -Path $this.DataPath -Encoding UTF8
            $this._isDirty = $false
            
            if ($global:Logger) {
                $global:Logger.Debug("TaskService: Saved $($this.Tasks.Count) tasks")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TaskService: Failed to save tasks: $_")
            }
        }
    }
    
    [void] Load() {
        if (Test-Path $this.DataPath) {
            try {
                $json = Get-Content -Path $this.DataPath -Raw
                $data = $json | ConvertFrom-Json
                
                $this.Tasks.Clear()
                foreach ($item in $data) {
                    $task = [Task]::new()
                    
                    # Map properties
                    $task.Id = $item.Id
                    $task.Title = $item.Title
                    $task.Description = $item.Description
                    $task.Status = [TaskStatus]$item.Status
                    $task.Priority = [TaskPriority]$item.Priority
                    $task.Progress = $item.Progress
                    $task.ProjectId = $item.ProjectId
                    $task.Tags = $item.Tags
                    $task.DueDate = if ($item.DueDate) { [DateTime]$item.DueDate } else { [DateTime]::MinValue }
                    $task.CreatedAt = [DateTime]$item.CreatedAt
                    $task.UpdatedAt = [DateTime]$item.UpdatedAt
                    $task.Deleted = $item.Deleted
                    
                    $this.Tasks.Add($task)
                }
                
                if ($global:Logger) {
                    $global:Logger.Debug("TaskService: Loaded $($this.Tasks.Count) tasks")
                }
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("TaskService: Failed to load tasks: $_")
                }
                # Start with empty list on error
                $this.Tasks.Clear()
            }
        } else {
            # Create sample tasks for testing
            $this.CreateSampleTasks()
        }
    }
    
    hidden [void] CreateSampleTasks() {
        # Create a few sample tasks
        $task1 = $this.AddTask("Implement user authentication", "")
        $task1.Description = "Add login/logout functionality with session management"
        $task1.Priority = [TaskPriority]::High
        $task1.Status = [TaskStatus]::InProgress
        $task1.Progress = 45
        
        $task2 = $this.AddTask("Write API documentation", "")
        $task2.Description = "Document all REST endpoints with examples"
        $task2.Priority = [TaskPriority]::Medium
        $task2.DueDate = (Get-Date).AddDays(7)
        
        $task3 = $this.AddTask("Fix navigation bug", "")
        $task3.Description = "Users report navigation not working after login"
        $task3.Priority = [TaskPriority]::High
        $task3.Status = [TaskStatus]::Completed
        $task3.Progress = 100
        
        $this.Save()
    }
}


####\Services/ThemeManager.ps1
# ThemeManager.ps1 - Fast theme management with pre-cached ANSI sequences
# All colors are pre-computed to avoid runtime lookups

class ThemeManager {
    hidden [hashtable]$_themes = @{}
    hidden [string]$_currentTheme = "default"
    hidden [hashtable]$_cache = @{}
    hidden [System.Collections.Generic.List[scriptblock]]$_listeners
    hidden [EventBus]$EventBus
    
    ThemeManager() {
        $this._listeners = [System.Collections.Generic.List[scriptblock]]::new()
        $this.InitializeDefaultTheme()
        
        # EventBus will be set later via SetEventBus
    }
    
    [void] InitializeDefaultTheme() {
        # Define default theme with RGB values
        $defaultTheme = @{
            # Base colors
            "background" = @(24, 24, 24)        # Dark background
            "foreground" = @(204, 204, 204)     # Light gray text
            "accent" = @(0, 150, 255)           # Blue accent
            "success" = @(0, 200, 83)           # Green
            "warning" = @(255, 195, 0)          # Yellow
            "error" = @(255, 85, 85)            # Red
            
            # UI elements
            "border" = @(68, 68, 68)           # Dark gray
            "border.focused" = @(0, 150, 255)   # Blue
            "selection" = @(60, 60, 60)         # Selection background
            "disabled" = @(128, 128, 128)       # Gray
            
            # Component specific
            "button.background" = @(48, 48, 48)
            "button.foreground" = @(204, 204, 204)
            "button.focused.background" = @(0, 150, 255)
            "button.focused.foreground" = @(255, 255, 255)
            
            "input.background" = @(32, 32, 32)
            "input.foreground" = @(204, 204, 204)
            "input.focused.border" = @(0, 150, 255)
            
            "menu.background" = @(32, 32, 32)
            "menu.foreground" = @(204, 204, 204)
            "menu.selected.background" = @(0, 150, 255)
            "menu.selected.foreground" = @(255, 255, 255)
            
            "tab.background" = @(48, 48, 48)
            "tab.foreground" = @(170, 170, 170)
            "tab.active.background" = @(24, 24, 24)
            "tab.active.foreground" = @(255, 255, 255)
            "tab.active.accent" = @(0, 150, 255)
        }
        
        $this.RegisterTheme("default", $defaultTheme)
        $this.SetTheme("default")
    }
    
    # Register a new theme
    [void] RegisterTheme([string]$name, [hashtable]$colors) {
        $this._themes[$name] = $colors
        
        # If this is the current theme, rebuild cache
        if ($name -eq $this._currentTheme) {
            $this.RebuildCache()
        }
    }
    
    # Switch to a different theme
    [void] SetTheme([string]$name) {
        if (-not $this._themes.ContainsKey($name)) {
            throw "Theme '$name' not found"
        }
        
        $oldTheme = $this._currentTheme
        $this._currentTheme = $name
        $this.RebuildCache()
        
        # Notify via EventBus if available
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::ThemeChanged, @{
                OldTheme = $oldTheme
                NewTheme = $name
                ThemeManager = $this
            })
        }
        
        # Also notify legacy listeners for backward compatibility
        $this.NotifyListeners()
    }
    
    # Get pre-computed ANSI color sequence
    [string] GetColor([string]$key) {
        if ($this._cache.ContainsKey($key)) {
            return $this._cache[$key]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$key] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get background color sequence
    [string] GetBgColor([string]$key) {
        $bgKey = "$key.bg"
        if ($this._cache.ContainsKey($bgKey)) {
            return $this._cache[$bgKey]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$bgKey] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get raw RGB values
    [int[]] GetRGB([string]$key) {
        $theme = $this._themes[$this._currentTheme]
        
        if ($theme.ContainsKey($key)) {
            return $theme[$key]
        }
        
        # Try parent keys (e.g., "button" for "button.focused.background")
        $parts = $key -split '\.'
        for ($i = $parts.Count - 1; $i -gt 0; $i--) {
            $parentKey = $parts[0..($i-1)] -join '.'
            if ($theme.ContainsKey($parentKey)) {
                return $theme[$parentKey]
            }
        }
        
        return $null
    }
    
    # Rebuild the entire cache
    hidden [void] RebuildCache() {
        $this._cache.Clear()
        $theme = $this._themes[$this._currentTheme]
        
        # Pre-compute all theme colors
        foreach ($key in $theme.Keys) {
            $rgb = $theme[$key]
            if ($rgb -is [array] -and $rgb.Count -eq 3) {
                # Foreground
                $this._cache[$key] = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
                # Background
                $this._cache["$key.bg"] = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            }
        }
        
        # Add common combinations
        $this._cache["reset"] = [VT]::Reset()
        $this._cache["clear"] = [VT]::Clear()
        $this._cache["clearline"] = [VT]::ClearLine()
    }
    
    # Subscribe to theme changes (legacy method - use EventBus instead)
    [void] Subscribe([scriptblock]$callback) {
        # If EventBus is available, use it instead
        if ($this.EventBus) {
            # Wrap the callback to match EventBus signature
            $this.EventBus.Subscribe([EventNames]::ThemeChanged, {
                param($sender, $eventData)
                & $callback
            })
        } else {
            # Fall back to legacy listeners
            $this._listeners.Add($callback)
        }
    }
    
    # Notify all listeners of theme change (legacy method)
    hidden [void] NotifyListeners() {
        # Only notify legacy listeners if EventBus is not available
        if (-not $this.EventBus) {
            foreach ($listener in $this._listeners) {
                try {
                    & $listener
                } catch {
                    # Ignore listener errors
                }
            }
        }
    }
    
    # Set EventBus after initialization (called by ServiceContainer)
    [void] SetEventBus([EventBus]$eventBus) {
        $this.EventBus = $eventBus
    }
    
    # Get list of available themes
    [string[]] GetThemeNames() {
        return $this._themes.Keys | Sort-Object
    }
    
    # Get current theme name
    [string] GetCurrentTheme() {
        return $this._currentTheme
    }
}


####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}



####\Start.ps1
#!/usr/bin/env pwsh
# PRAXIS - Performance-focused TUI Framework
# Entry point and bootstrapper

param(
    [switch]$Debug,
    [switch]$Performance,
    [string]$Theme = "default"
)

# Enable debug output if requested
if ($Debug) {
    $global:PraxisDebug = $true
}

# Ensure we're in the right directory
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Ensure data directory exists
$dataDir = Join-Path $script:PraxisRoot "_ProjectData"
if (-not (Test-Path $dataDir)) {
    New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
}

# Load order is critical for class inheritance
$loadOrder = @(
    # Core modules first
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    
    # Services (needed by base classes)
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    
    # Base classes
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    
    # Models
    "Models/Project.ps1"
    "Models/Task.ps1"
    
    # Services
    "Services/ProjectService.ps1"
    "Services/TaskService.ps1"
    "Services/ConfigurationService.ps1"
    
    # Components
    "Components/ListBox.ps1"
    "Components/TextBox.ps1"
    "Components/Button.ps1"
    "Components/DataGrid.ps1"
    "Components/TabContainer.ps1"
    
    # Core systems
    "Core/ScreenManager.ps1"
    
    # Dialogs (must be loaded before screens that use them)
    "Screens/TextInputDialog.ps1",
    "Screens/NumberInputDialog.ps1",
    "Screens/ConfirmationDialog.ps1",
    "Screens/NewProjectDialog.ps1",
    "Screens/EditProjectDialog.ps1",
    "Screens/NewTaskDialog.ps1",
    "Screens/EditTaskDialog.ps1",
    "Screens/EventBusMonitor.ps1",
    
    # Screens (after dialogs they depend on)
    "Screens/TestScreen.ps1",
    "Screens/ProjectsScreen.ps1",
    "Screens/TaskScreen.ps1",
    "Screens/SettingsScreen.ps1",
    
    # CommandPalette (after screens it references)
    "Components/CommandPalette.ps1"
    
    # Main screen
    "Screens/MainScreen.ps1"
)

# Load all modules
Write-Host "Loading PRAXIS framework..." -ForegroundColor Cyan
foreach ($file in $loadOrder) {
    $path = Join-Path $script:PraxisRoot $file
    if (Test-Path $path) {
        try {
            . $path
            if ($Debug) {
                Write-Host "  ✓ $file" -ForegroundColor Green
            }
        } catch {
            Write-Host "  ✗ $file - $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "  ✗ $file - File not found" -ForegroundColor Red
        exit 1
    }
}

# Initialize services
Write-Host "Initializing services..." -ForegroundColor Cyan

# Logger (first so other services can use it)
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
if ($Debug) {
    Write-Host "  Logger created at: $($logger.LogPath)" -ForegroundColor DarkGray
}

# Theme manager
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# EventBus (after Logger and ThemeManager, before other services)
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)
if ($Debug) {
    Write-Host "  EventBus initialized" -ForegroundColor DarkGray
}

# Connect ThemeManager to EventBus
$themeManager.SetEventBus($eventBus)

# Project service
$projectService = [ProjectService]::new()
$global:ServiceContainer.Register("ProjectService", $projectService)

# Task service
$taskService = [TaskService]::new()
$global:ServiceContainer.Register("TaskService", $taskService)

# Configuration service
$configService = [ConfigurationService]::new()
$global:ServiceContainer.Register("ConfigurationService", $configService)

# Screen manager
$screenManager = [ScreenManager]::new($global:ServiceContainer)
$global:ScreenManager = $screenManager
$global:ServiceContainer.Register("ScreenManager", $screenManager)

# Create main screen with tabs
Write-Host "Creating main interface..." -ForegroundColor Cyan

# Create and run main screen
if ($Debug) { Write-Host "  Creating MainScreen..." -ForegroundColor DarkGray }
$mainScreen = [MainScreen]::new()

if ($Debug) { Write-Host "  Pushing to ScreenManager..." -ForegroundColor DarkGray }
$screenManager.Push($mainScreen)

if ($Debug) { Write-Host "  Main screen initialized" -ForegroundColor DarkGray }

Write-Host "Starting PRAXIS..." -ForegroundColor Green
Write-Host "  • Press 1-3 to switch tabs" -ForegroundColor DarkGray
Write-Host "  • Press Ctrl+Tab to cycle tabs" -ForegroundColor DarkGray
Write-Host "  • Press / or : for command palette" -ForegroundColor DarkGray
Write-Host "  • Press Q or Escape to quit" -ForegroundColor DarkGray
Write-Host ""

# Run the application
try {
    $global:Logger.Info("Starting PRAXIS main loop")
    $screenManager.Run()
} catch {
    if ($global:Logger) {
        if ($_.Exception) {
            $global:Logger.LogException($_.Exception, "Fatal error in main loop")
        } else {
            $global:Logger.Error("Fatal error in main loop: $_")
        }
    }
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    if ($global:Logger) {
        Write-Host "`nCheck log file at: $($global:Logger.LogPath)" -ForegroundColor Yellow
    }
} finally {
    # Cleanup
    $global:Logger.Info("Shutting down PRAXIS")
    $global:Logger.Cleanup()
    $global:ServiceContainer.Cleanup()
    Write-Host "`nPRAXIS terminated." -ForegroundColor Cyan
}


####\test-all-features.ps1
#!/usr/bin/env pwsh
# Test script for all PRAXIS features

Write-Host "PRAXIS Feature Test Guide" -ForegroundColor Cyan
Write-Host "=========================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Tab Navigation:" -ForegroundColor Yellow
Write-Host "  - Press 1-4 to switch between tabs" -ForegroundColor White
Write-Host "  - Projects, Tasks, Dashboard, Settings" -ForegroundColor Gray
Write-Host ""
Write-Host "Task Management (Tab 2):" -ForegroundColor Yellow
Write-Host "  - n: Create new task" -ForegroundColor White
Write-Host "  - e/Enter: Edit selected task" -ForegroundColor White
Write-Host "  - d/Delete: Delete selected task" -ForegroundColor White
Write-Host "  - s: Cycle task status" -ForegroundColor White
Write-Host "  - p: Cycle task priority" -ForegroundColor White
Write-Host "  - /: Focus filter box" -ForegroundColor White
Write-Host "  - Tab: Switch between filter and list" -ForegroundColor White
Write-Host ""
Write-Host "Settings (Tab 4):" -ForegroundColor Yellow
Write-Host "  - Arrow keys to navigate categories" -ForegroundColor White
Write-Host "  - Tab to switch between category list and settings grid" -ForegroundColor White
Write-Host "  - Enter/e: Edit setting (booleans toggle)" -ForegroundColor White
Write-Host "  - r: Reset current category" -ForegroundColor White
Write-Host "  - R: Reset all settings" -ForegroundColor White
Write-Host ""
Write-Host "Global:" -ForegroundColor Yellow
Write-Host "  - /: Open command palette" -ForegroundColor White
Write-Host "  - q/Escape: Quit" -ForegroundColor White
Write-Host ""
Write-Host "Starting in 5 seconds..." -ForegroundColor Green
Start-Sleep -Seconds 5

# Run the main app
& "$PSScriptRoot/Start.ps1"


####\test-button-fixes.ps1
#!/usr/bin/env pwsh
# Test script to verify button fixes in dialogs

Write-Host "Button Fix Verification Script" -ForegroundColor Cyan
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "This script will verify that the button fixes have been applied correctly."
Write-Host ""

# Read the dialog files and check for the button fix patterns
$dialogFiles = @(
    "Screens/NewProjectDialog.ps1",
    "Screens/NewTaskDialog.ps1", 
    "Screens/EditTaskDialog.ps1",
    "Screens/ConfirmationDialog.ps1"
)

$fixesFound = 0
$totalChecks = $dialogFiles.Count * 3  # 3 checks per file

foreach ($file in $dialogFiles) {
    Write-Host "`nChecking $file..." -ForegroundColor Yellow
    $content = Get-Content $file -Raw
    
    # Check 1: OnBoundsChanged method exists
    if ($content -match "OnBoundsChanged\(\)") {
        Write-Host "  ✓ OnBoundsChanged method found" -ForegroundColor Green
        $fixesFound++
    } else {
        Write-Host "  ✗ OnBoundsChanged method NOT found" -ForegroundColor Red
    }
    
    # Check 2: Button positioning logic similar to ProjectsScreen
    if ($content -match "buttonHeight = 3" -and $content -match "buttonSpacing = 2" -and $content -match "maxButtonWidth") {
        Write-Host "  ✓ Button positioning logic found" -ForegroundColor Green
        $fixesFound++
    } else {
        Write-Host "  ✗ Button positioning logic NOT found" -ForegroundColor Red
    }
    
    # Check 3: Dark overlay rendering
    if ($content -match "Dark gray overlay" -or $content -match "RGBBG\(16, 16, 16\)") {
        Write-Host "  ✓ Dark overlay rendering found" -ForegroundColor Green
        $fixesFound++
    } else {
        Write-Host "  ✗ Dark overlay rendering NOT found" -ForegroundColor Red
    }
}

Write-Host "`n================================" -ForegroundColor Cyan
Write-Host "Results: $fixesFound/$totalChecks checks passed" -ForegroundColor $(if ($fixesFound -eq $totalChecks) { "Green" } else { "Yellow" })

if ($fixesFound -eq $totalChecks) {
    Write-Host "`nAll button fixes have been successfully applied!" -ForegroundColor Green
} else {
    Write-Host "`nSome fixes may be missing. Please review the files." -ForegroundColor Yellow
}

Write-Host "`nTo test the dialogs manually:" -ForegroundColor Cyan
Write-Host "1. Run: pwsh -File Start.ps1"
Write-Host "2. Press '2' to go to Tasks tab"
Write-Host "3. Press 'n' to open New Task dialog"
Write-Host "4. Check that buttons are properly centered and rendered"
Write-Host "5. Use Tab to navigate between buttons"


####\test-button.ps1
#!/usr/bin/env pwsh
# Test button rendering directly

# Load framework
. ./Core/VT100.ps1
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/ThemeManager.ps1
. ./Base/UIElement.ps1
. ./Components/Button.ps1

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# Create a button
$button = [Button]::new("Test Button")
$button.Initialize($global:ServiceContainer)
$button.SetBounds(5, 5, 20, 3)

# Clear screen
Write-Host ([VT]::Clear())

# Render the button
$output = $button.Render()
Write-Host $output -NoNewline

# Position cursor below button
Write-Host ([VT]::MoveTo(0, 10))

# Show what the button thinks it has
Write-Host "Button Text: '$($button.Text)'"
Write-Host "Button Bounds: X=$($button.X) Y=$($button.Y) W=$($button.Width) H=$($button.Height)"
Write-Host "Cache empty: $([string]::IsNullOrEmpty($button._cachedRender))"

# Wait for key
Write-Host "`nPress any key to exit..."
[Console]::ReadKey($true) | Out-Null


####\test-cross-screen-events.ps1
#!/usr/bin/env pwsh
# Test cross-screen event communication

Write-Host "Cross-Screen Event Communication Test" -ForegroundColor Cyan
Write-Host "=====================================" -ForegroundColor Cyan
Write-Host ""

# Load the framework
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load only essential files
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/EventBus.ps1

# Initialize services
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

Write-Host "Services initialized" -ForegroundColor Green
Write-Host ""

# Simulate screens subscribing to events
Write-Host "Setting up screen event subscriptions..." -ForegroundColor Yellow

# ProjectsScreen simulation
$projectsScreenEvents = @()
$projectsSub1 = $eventBus.Subscribe([EventNames]::RefreshRequested, {
    param($sender, $eventData)
    if (-not $eventData.Target -or $eventData.Target -eq 'ProjectsScreen') {
        $script:projectsScreenEvents += "Refresh requested"
        Write-Host "  [ProjectsScreen] Refreshing project list..." -ForegroundColor Green
    }
})

$projectsSub2 = $eventBus.Subscribe([EventNames]::ConfigChanged, {
    param($sender, $eventData)
    if ($eventData.Path -like "ui.projects.*") {
        $script:projectsScreenEvents += "Config changed: $($eventData.Path)"
        Write-Host "  [ProjectsScreen] Config changed: $($eventData.Path) = $($eventData.NewValue)" -ForegroundColor Yellow
    }
})

# TaskScreen simulation
$taskScreenEvents = @()
$tasksSub1 = $eventBus.Subscribe([EventNames]::RefreshRequested, {
    param($sender, $eventData)
    if (-not $eventData.Target -or $eventData.Target -eq 'TaskScreen') {
        $script:taskScreenEvents += "Refresh requested"
        Write-Host "  [TaskScreen] Refreshing task list..." -ForegroundColor Cyan
    }
})

$tasksSub2 = $eventBus.Subscribe([EventNames]::ProjectDeleted, {
    param($sender, $eventData)
    $script:taskScreenEvents += "Project deleted: $($eventData.ProjectId)"
    Write-Host "  [TaskScreen] Removing tasks for deleted project $($eventData.ProjectId)" -ForegroundColor Red
})

# MainScreen simulation
$mainScreenEvents = @()
$mainSub = $eventBus.Subscribe([EventNames]::DataChanged, {
    param($sender, $eventData)
    $script:mainScreenEvents += "Data changed: $($eventData.Type)"
    Write-Host "  [MainScreen] Data changed notification: $($eventData.Type)" -ForegroundColor Magenta
})

Write-Host "Subscriptions set up" -ForegroundColor Green
Write-Host ""

# Test scenarios
Write-Host "Test 1: Global Refresh Request" -ForegroundColor Cyan
Write-Host "------------------------------" -ForegroundColor DarkGray
$eventBus.Publish([EventNames]::RefreshRequested, @{})
Write-Host ""

Write-Host "Test 2: Targeted Refresh Request" -ForegroundColor Cyan
Write-Host "--------------------------------" -ForegroundColor DarkGray
$eventBus.Publish([EventNames]::RefreshRequested, @{ Target = 'TaskScreen' })
Write-Host ""

Write-Host "Test 3: Configuration Change" -ForegroundColor Cyan
Write-Host "----------------------------" -ForegroundColor DarkGray
$eventBus.Publish([EventNames]::ConfigChanged, @{
    Path = "ui.projects.showCompleted"
    OldValue = $true
    NewValue = $false
    Category = "ui.projects"
})
Write-Host ""

Write-Host "Test 4: Cascading Events (Project Deletion)" -ForegroundColor Cyan
Write-Host "-------------------------------------------" -ForegroundColor DarkGray
Write-Host "  Deleting project triggers:" -ForegroundColor White
$eventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = 123 })
$eventBus.Publish([EventNames]::DataChanged, @{ Type = "Projects"; Action = "Delete" })
Write-Host ""

Write-Host "Test 5: Dynamic Command Registration" -ForegroundColor Cyan
Write-Host "------------------------------------" -ForegroundColor DarkGray
$commandRegistered = $false
$cmdSub = $eventBus.Subscribe([EventNames]::CommandRegistered, {
    param($sender, $eventData)
    $script:commandRegistered = $true
    Write-Host "  [CommandPalette] New command registered: $($eventData.Name)" -ForegroundColor Green
})

# Simulate a screen registering a command
[CommandRegistration]::RegisterCommand(
    "refresh all",
    "Refresh all screens",
    {
        Write-Host "    Executing: Refresh all screens" -ForegroundColor Yellow
        $eventBus = $global:ServiceContainer.GetService('EventBus')
        $eventBus.Publish([EventNames]::RefreshRequested, @{})
    }
)
Write-Host ""

# Summary
Write-Host "Event Summary" -ForegroundColor Cyan
Write-Host "-------------" -ForegroundColor DarkGray
Write-Host "  ProjectsScreen received: $($projectsScreenEvents.Count) events" -ForegroundColor Gray
Write-Host "  TaskScreen received: $($taskScreenEvents.Count) events" -ForegroundColor Gray
Write-Host "  MainScreen received: $($mainScreenEvents.Count) events" -ForegroundColor Gray
Write-Host "  Command registered: $commandRegistered" -ForegroundColor Gray
Write-Host ""

# Show event bus statistics
$info = $eventBus.GetEventInfo()
Write-Host "EventBus Statistics" -ForegroundColor Cyan
Write-Host "-------------------" -ForegroundColor DarkGray
Write-Host "  Total handlers: $($info.TotalHandlers)" -ForegroundColor Yellow
Write-Host "  Active event types: $($info.RegisteredEvents.Count)" -ForegroundColor Yellow
Write-Host ""

Write-Host "Cross-screen communication test completed!" -ForegroundColor Green

# Cleanup
$logger.Cleanup()


####\test-dialogs.ps1
#!/usr/bin/env pwsh
# Test script for dialogs

Write-Host "Testing PRAXIS Task Dialogs..." -ForegroundColor Yellow
Write-Host "Instructions:" -ForegroundColor Cyan
Write-Host "  1. Press '2' to switch to Tasks tab" -ForegroundColor White
Write-Host "  2. Press 'n' to create a new task" -ForegroundColor White
Write-Host "  3. Press 'e' or Enter to edit a task" -ForegroundColor White
Write-Host "  4. Press 'd' or Delete to delete a task" -ForegroundColor White
Write-Host "  5. Use Tab to navigate within dialogs" -ForegroundColor White
Write-Host "  6. Press 'q' or Escape to quit" -ForegroundColor White
Write-Host ""
Write-Host "Starting in 3 seconds..." -ForegroundColor Green
Start-Sleep -Seconds 3

# Run the main app
& "$PSScriptRoot/Start.ps1"


####\test-eventbus-complete.ps1
#!/usr/bin/env pwsh
# Complete EventBus integration test

Write-Host "Complete EventBus Integration Test" -ForegroundColor Cyan
Write-Host "==================================" -ForegroundColor Cyan
Write-Host ""

# Load the framework
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load essential files
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/EventBus.ps1
. ./Services/ThemeManager.ps1

# Initialize services
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# Connect ThemeManager to EventBus
$themeManager.SetEventBus($eventBus)

# Enable debugging and history
$eventBus.EnableHistory = $true
$eventBus.EnableDebugLogging = $false  # Set to true to see detailed logs

Write-Host "Services initialized with EventBus" -ForegroundColor Green
Write-Host ""

# Test 1: ThemeManager integration
Write-Host "Test 1: ThemeManager EventBus Integration" -ForegroundColor Cyan
Write-Host "-----------------------------------------" -ForegroundColor DarkGray

$themeChanges = 0
$themeSub = $eventBus.Subscribe([EventNames]::ThemeChanged, {
    param($sender, $eventData)
    $script:themeChanges++
    Write-Host "  Theme changed from '$($eventData.OldTheme)' to '$($eventData.NewTheme)'" -ForegroundColor Yellow
})

# Register a test theme
$themeManager.RegisterTheme("test", @{
    "background" = @(0, 0, 0)
    "foreground" = @(255, 255, 255)
})

# Change theme (should trigger EventBus)
$themeManager.SetTheme("test")
$themeManager.SetTheme("default")

Write-Host "  Total theme changes detected: $themeChanges" -ForegroundColor Green
Write-Host ""

# Test 2: Dynamic command registration
Write-Host "Test 2: Dynamic Command Registration" -ForegroundColor Cyan
Write-Host "------------------------------------" -ForegroundColor DarkGray

$commandsRegistered = @()
$cmdRegSub = $eventBus.Subscribe([EventNames]::CommandRegistered, {
    param($sender, $eventData)
    $script:commandsRegistered += $eventData.Name
    Write-Host "  Command registered: $($eventData.Name) - $($eventData.Description)" -ForegroundColor Green
})

# Register some test commands
[CommandRegistration]::RegisterCommand("test command 1", "First test command", { Write-Host "Test 1" })
[CommandRegistration]::RegisterCommand("test command 2", "Second test command", { Write-Host "Test 2" })
[CommandRegistration]::RegisterCommand("debug eventbus", "Show EventBus debug info", {
    $eb = $global:ServiceContainer.GetService('EventBus')
    Write-Host $eb.GetDebugReport()
})

Write-Host "  Total commands registered: $($commandsRegistered.Count)" -ForegroundColor Yellow
Write-Host ""

# Test 3: Event statistics
Write-Host "Test 3: EventBus Statistics" -ForegroundColor Cyan
Write-Host "---------------------------" -ForegroundColor DarkGray

# Generate some events
$eventBus.Publish([EventNames]::RefreshRequested, @{})
$eventBus.Publish([EventNames]::DataChanged, @{ Type = "Test" })
$eventBus.Publish([EventNames]::ProjectCreated, @{ Project = @{ Name = "Test" } })

$info = $eventBus.GetEventInfo()
Write-Host "  Total events published: $($info.TotalEventsPublished)" -ForegroundColor Yellow
Write-Host "  Total handlers called: $($info.TotalHandlersCalled)" -ForegroundColor Yellow
Write-Host "  Active handlers: $($info.TotalHandlers)" -ForegroundColor Yellow
Write-Host "  History entries: $($info.HistorySize)" -ForegroundColor Yellow
Write-Host ""

# Test 4: Debug report
Write-Host "Test 4: EventBus Debug Report" -ForegroundColor Cyan
Write-Host "-----------------------------" -ForegroundColor DarkGray
Write-Host $eventBus.GetDebugReport() -ForegroundColor Gray
Write-Host ""

# Test 5: Event history
Write-Host "Test 5: Event History" -ForegroundColor Cyan
Write-Host "---------------------" -ForegroundColor DarkGray

$history = $eventBus.GetEventHistory()
Write-Host "  Last 5 events:" -ForegroundColor Yellow
foreach ($event in $history | Select-Object -Last 5) {
    Write-Host "    $($event.Timestamp.ToString('HH:mm:ss')) - $($event.EventName)" -ForegroundColor Gray
}
Write-Host ""

# Summary
Write-Host "Summary" -ForegroundColor Cyan
Write-Host "-------" -ForegroundColor DarkGray
Write-Host "✓ ThemeManager integrated with EventBus" -ForegroundColor Green
Write-Host "✓ Dynamic command registration working" -ForegroundColor Green
Write-Host "✓ Event statistics and monitoring functional" -ForegroundColor Green
Write-Host "✓ Debug reporting available" -ForegroundColor Green
Write-Host "✓ Event history tracking enabled" -ForegroundColor Green
Write-Host ""
Write-Host "EventBus integration is fully operational!" -ForegroundColor Green

# Cleanup
$logger.Cleanup()


####\test-eventbus-integration.ps1
#!/usr/bin/env pwsh
# Integration test for EventBus in PRAXIS

Write-Host "EventBus Integration Test" -ForegroundColor Cyan
Write-Host "=========================" -ForegroundColor Cyan
Write-Host ""

# Load the framework (without running the main loop)
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load all required files
$loadOrder = @(
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Services/Logger.ps1"
    "Services/ThemeManager.ps1"
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    "Models/Project.ps1"
    "Models/Task.ps1"
    "Services/EventBus.ps1"
    "Services/ProjectService.ps1"
    "Services/TaskService.ps1"
    "Services/ConfigurationService.ps1"
    "Components/ListBox.ps1"
    "Components/TextBox.ps1"
    "Components/Button.ps1"
    "Components/DataGrid.ps1"
    "Components/TabContainer.ps1"
    "Core/ScreenManager.ps1"
    "Screens/TextInputDialog.ps1"
    "Screens/NumberInputDialog.ps1"
    "Screens/ConfirmationDialog.ps1"
    "Screens/NewProjectDialog.ps1"
    "Screens/EditProjectDialog.ps1"
    "Screens/NewTaskDialog.ps1"
    "Screens/EditTaskDialog.ps1"
    "Screens/TestScreen.ps1"
    "Screens/ProjectsScreen.ps1"
    "Screens/TaskScreen.ps1"
    "Screens/SettingsScreen.ps1"
    "Components/CommandPalette.ps1"
    "Screens/MainScreen.ps1"
)

Write-Host "Loading framework components..." -ForegroundColor Yellow
foreach ($file in $loadOrder) {
    $path = Join-Path $script:PraxisRoot $file
    if (Test-Path $path) {
        . $path
    }
}

# Initialize services
Write-Host "Initializing services..." -ForegroundColor Yellow
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

$projectService = [ProjectService]::new()
$global:ServiceContainer.Register("ProjectService", $projectService)

$taskService = [TaskService]::new()
$global:ServiceContainer.Register("TaskService", $taskService)

$configService = [ConfigurationService]::new()
$global:ServiceContainer.Register("ConfigurationService", $configService)

$screenManager = [ScreenManager]::new($global:ServiceContainer)
$global:ScreenManager = $screenManager
$global:ServiceContainer.Register("ScreenManager", $screenManager)

Write-Host "Services initialized successfully!" -ForegroundColor Green
Write-Host ""

# Test 1: Tab change events
Write-Host "Test 1: Tab Change Events" -ForegroundColor Cyan
Write-Host "-------------------------" -ForegroundColor DarkGray

$tabChanges = @()
$tabSubscription = $eventBus.Subscribe([EventNames]::TabChanged, {
    param($sender, $eventData)
    $script:tabChanges += $eventData
    Write-Host "  Tab changed to index: $($eventData.TabIndex)" -ForegroundColor Green
})

# Simulate CommandPalette publishing tab change
$eventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
$eventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })

Write-Host "  Total tab changes: $($tabChanges.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 2: Project events
Write-Host "Test 2: Project Events" -ForegroundColor Cyan
Write-Host "----------------------" -ForegroundColor DarkGray

$projectEvents = @()
$projectCreatedSub = $eventBus.Subscribe([EventNames]::ProjectCreated, {
    param($sender, $eventData)
    $script:projectEvents += @{ Type = 'Created'; Data = $eventData }
    Write-Host "  Project created: $($eventData.Project.Name)" -ForegroundColor Green
})

$projectUpdatedSub = $eventBus.Subscribe([EventNames]::ProjectUpdated, {
    param($sender, $eventData)
    $script:projectEvents += @{ Type = 'Updated'; Data = $eventData }
    Write-Host "  Project updated: $($eventData.Project.Name)" -ForegroundColor Yellow
})

$projectDeletedSub = $eventBus.Subscribe([EventNames]::ProjectDeleted, {
    param($sender, $eventData)
    $script:projectEvents += @{ Type = 'Deleted'; Data = $eventData }
    Write-Host "  Project deleted: ID $($eventData.ProjectId)" -ForegroundColor Red
})

# Simulate project operations
$testProject = @{ Id = 1; Name = "Test Project"; Nickname = "TEST" }
$eventBus.Publish([EventNames]::ProjectCreated, @{ Project = $testProject })
$eventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $testProject })
$eventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = 1 })

Write-Host "  Total project events: $($projectEvents.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 3: Command execution events
Write-Host "Test 3: Command Execution Events" -ForegroundColor Cyan
Write-Host "--------------------------------" -ForegroundColor DarkGray

$commandsExecuted = @()
$commandSub = $eventBus.Subscribe([EventNames]::CommandExecuted, {
    param($sender, $eventData)
    $script:commandsExecuted += $eventData
    Write-Host "  Command: $($eventData.Command) on $($eventData.Target)" -ForegroundColor Magenta
})

# Simulate command execution
$eventBus.Publish([EventNames]::CommandExecuted, @{ Command = 'NewTask'; Target = 'TaskScreen' })
$eventBus.Publish([EventNames]::CommandExecuted, @{ Command = 'EditProject'; Target = 'ProjectsScreen' })

Write-Host "  Total commands executed: $($commandsExecuted.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 4: Event bus info
Write-Host "Test 4: EventBus Statistics" -ForegroundColor Cyan
Write-Host "---------------------------" -ForegroundColor DarkGray

$info = $eventBus.GetEventInfo()
Write-Host "  Total handlers: $($info.TotalHandlers)" -ForegroundColor Yellow
Write-Host "  Event types:" -ForegroundColor Yellow
foreach ($eventName in $info.RegisteredEvents.Keys | Sort-Object) {
    $handlers = $info.RegisteredEvents[$eventName]
    Write-Host "    - $eventName : $($handlers.HandlerCount) handler(s)" -ForegroundColor Gray
}

Write-Host ""
Write-Host "Integration test completed successfully!" -ForegroundColor Green
Write-Host ""

# Show a sample of how screens would interact
Write-Host "Example: How screens interact with EventBus" -ForegroundColor Cyan
Write-Host "-------------------------------------------" -ForegroundColor DarkGray
Write-Host "1. CommandPalette publishes: TabChanged + CommandExecuted" -ForegroundColor White
Write-Host "2. MainScreen subscribes to: TabChanged (switches tabs)" -ForegroundColor White
Write-Host "3. ProjectsScreen subscribes to: CommandExecuted, ProjectCreated/Updated/Deleted" -ForegroundColor White
Write-Host "4. TaskScreen subscribes to: CommandExecuted, TaskCreated/Updated/Deleted" -ForegroundColor White
Write-Host ""

# Cleanup
$eventBus.UnsubscribeAll([EventNames]::TabChanged)
$eventBus.UnsubscribeAll([EventNames]::ProjectCreated)
$eventBus.UnsubscribeAll([EventNames]::ProjectUpdated)
$eventBus.UnsubscribeAll([EventNames]::ProjectDeleted)
$eventBus.UnsubscribeAll([EventNames]::CommandExecuted)

$logger.Cleanup()

Write-Host "Cleanup completed." -ForegroundColor DarkGray


####\test-eventbus.ps1
#!/usr/bin/env pwsh
# Test script for EventBus functionality

param(
    [switch]$Verbose
)

# Load the framework
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load required files
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/EventBus.ps1

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

# Create and register EventBus
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

Write-Host "Testing EventBus functionality..." -ForegroundColor Cyan
Write-Host ""

# Test 1: Basic subscription and publishing
Write-Host "Test 1: Basic Event Publishing" -ForegroundColor Yellow
$receivedEvents = @()
$subscription1 = $eventBus.Subscribe("test.event", {
    param($sender, $eventData)
    $receivedEvents += $eventData
    Write-Host "  Received event: $($eventData.Message)" -ForegroundColor Green
})

$eventBus.Publish("test.event", @{ Message = "Hello from EventBus!" })
Write-Host "  Events received: $($receivedEvents.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 2: Multiple subscribers
Write-Host "Test 2: Multiple Subscribers" -ForegroundColor Yellow
$counter = 0
$subscription2 = $eventBus.Subscribe("test.event", {
    param($sender, $eventData)
    $script:counter++
    Write-Host "  Subscriber 2 received: $($eventData.Message)" -ForegroundColor Cyan
})

$eventBus.Publish("test.event", @{ Message = "Broadcasting to multiple subscribers" })
Write-Host "  Total handler executions: $($counter + $receivedEvents.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 3: Event filtering by name
Write-Host "Test 3: Event Filtering" -ForegroundColor Yellow
$projectEvents = @()
$projectSubscription = $eventBus.Subscribe([EventNames]::ProjectCreated, {
    param($sender, $eventData)
    $script:projectEvents += $eventData
    Write-Host "  Project created: $($eventData.Project.Name)" -ForegroundColor Green
})

$eventBus.Publish([EventNames]::ProjectCreated, @{ Project = @{ Name = "Test Project"; Id = 1 } })
$eventBus.Publish([EventNames]::TaskCreated, @{ Task = @{ Title = "Test Task"; Id = 1 } })
Write-Host "  Project events received: $($projectEvents.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 4: Unsubscribe
Write-Host "Test 4: Unsubscribe" -ForegroundColor Yellow
$eventBus.Unsubscribe("test.event", $subscription1)
$beforeCount = $receivedEvents.Count
$eventBus.Publish("test.event", @{ Message = "After unsubscribe" })
Write-Host "  Events before unsubscribe: $beforeCount" -ForegroundColor DarkGray
Write-Host "  Events after unsubscribe: $($receivedEvents.Count)" -ForegroundColor DarkGray
Write-Host ""

# Test 5: Command execution simulation
Write-Host "Test 5: Command Execution Pattern" -ForegroundColor Yellow
$commandExecuted = $false
$commandSubscription = $eventBus.Subscribe([EventNames]::CommandExecuted, {
    param($sender, $eventData)
    if ($eventData.Target -eq 'TestScreen' -and $eventData.Command -eq 'TestCommand') {
        $script:commandExecuted = $true
        Write-Host "  Command executed: $($eventData.Command) on $($eventData.Target)" -ForegroundColor Green
    }
})

$eventBus.Publish([EventNames]::CommandExecuted, @{ Target = 'TestScreen'; Command = 'TestCommand' })
Write-Host "  Command was executed: $commandExecuted" -ForegroundColor DarkGray
Write-Host ""

# Test 6: Event history
Write-Host "Test 6: Event History" -ForegroundColor Yellow
$eventBus.EnableHistory = $true
$eventBus.Publish("history.test", @{ Value = 42 })
$eventBus.Publish("history.test", @{ Value = 100 })
$history = $eventBus.GetEventHistory("history.test")
Write-Host "  History entries for 'history.test': $($history.Count)" -ForegroundColor DarkGray
foreach ($entry in $history) {
    Write-Host "    - Event at $($entry.Timestamp): Value = $($entry.EventData.Value)" -ForegroundColor Gray
}
Write-Host ""

# Test 7: Get event info
Write-Host "Test 7: Event Info" -ForegroundColor Yellow
$info = $eventBus.GetEventInfo()
Write-Host "  Total registered handlers: $($info.TotalHandlers)" -ForegroundColor DarkGray
Write-Host "  Registered events:" -ForegroundColor DarkGray
foreach ($eventName in $info.RegisteredEvents.Keys) {
    Write-Host "    - $eventName : $($info.RegisteredEvents[$eventName].HandlerCount) handlers" -ForegroundColor Gray
}

Write-Host ""
Write-Host "EventBus tests completed successfully!" -ForegroundColor Green

# Cleanup
$logger.Cleanup()


####\test-focus.ps1
#!/usr/bin/env pwsh
# Simple test to verify focus navigation in TaskScreen

Write-Host "Testing PRAXIS TaskScreen focus navigation..." -ForegroundColor Yellow
Write-Host "Instructions:" -ForegroundColor Cyan
Write-Host "  1. Press '2' to switch to Tasks tab" -ForegroundColor White
Write-Host "  2. Press Tab to switch between filter box and task list" -ForegroundColor White
Write-Host "  3. Watch for border color changes (blue = focused)" -ForegroundColor White
Write-Host "  4. Press 'q' or Escape to quit" -ForegroundColor White
Write-Host ""
Write-Host "Starting in 3 seconds..." -ForegroundColor Green
Start-Sleep -Seconds 3

# Run the main app
& "$PSScriptRoot/Start.ps1"


####\test-listbox-onselectionchanged.ps1
#!/usr/bin/env pwsh
# Test script to verify ListBox OnSelectionChanged functionality

Write-Host "ListBox OnSelectionChanged Test" -ForegroundColor Cyan
Write-Host "===============================" -ForegroundColor Cyan
Write-Host ""

# Check ListBox implementation
Write-Host "Checking ListBox.ps1..." -ForegroundColor Yellow
$content = Get-Content "Components/ListBox.ps1" -Raw

$checks = 0
$passed = 0

# Check 1: OnSelectionChanged property exists
$checks++
if ($content -match '\[scriptblock\]\$OnSelectionChanged = \{\}') {
    Write-Host "  ✓ OnSelectionChanged property defined" -ForegroundColor Green
    $passed++
} else {
    Write-Host "  ✗ OnSelectionChanged property NOT found" -ForegroundColor Red
}

# Check 2: SelectIndex calls OnSelectionChanged
$checks++
if ($content -match 'SelectIndex[\s\S]*OnSelectionChanged[\s\S]*& \$this\.OnSelectionChanged') {
    Write-Host "  ✓ SelectIndex triggers OnSelectionChanged" -ForegroundColor Green
    $passed++
} else {
    Write-Host "  ✗ SelectIndex does NOT trigger OnSelectionChanged" -ForegroundColor Red
}

# Check 3: SetItems calls OnSelectionChanged
$checks++
if ($content -match 'SetItems[\s\S]*OnSelectionChanged[\s\S]*& \$this\.OnSelectionChanged') {
    Write-Host "  ✓ SetItems triggers OnSelectionChanged" -ForegroundColor Green
    $passed++
} else {
    Write-Host "  ✗ SetItems does NOT trigger OnSelectionChanged" -ForegroundColor Red
}

# Check SettingsScreen implementation
Write-Host "`nChecking SettingsScreen.ps1..." -ForegroundColor Yellow
$content = Get-Content "Screens/SettingsScreen.ps1" -Raw

# Check 4: SettingsScreen uses OnSelectionChanged
$checks++
if ($content -match 'CategoryList\.OnSelectionChanged = \{') {
    Write-Host "  ✓ SettingsScreen sets OnSelectionChanged callback" -ForegroundColor Green
    $passed++
} else {
    Write-Host "  ✗ SettingsScreen does NOT set OnSelectionChanged" -ForegroundColor Red
}

# Check 5: HandleInput is simplified
$checks++
if ($content -match 'HandleInput[\s\S]*return \(\[Screen\]\$this\)\.HandleInput\(\$key\)' -and 
    $content -notmatch 'previousSelection') {
    Write-Host "  ✓ HandleInput is simplified (no manual tracking)" -ForegroundColor Green
    $passed++
} else {
    Write-Host "  ✗ HandleInput still has manual selection tracking" -ForegroundColor Red
}

Write-Host ""
Write-Host "Results: $passed/$checks checks passed" -ForegroundColor $(if ($passed -eq $checks) { "Green" } else { "Yellow" })

if ($passed -eq $checks) {
    Write-Host "`nOnSelectionChanged implementation successful!" -ForegroundColor Green
    Write-Host ""
    Write-Host "To test manually:" -ForegroundColor Cyan
    Write-Host "1. Run: pwsh -File Start.ps1"
    Write-Host "2. Press '4' to go to Settings tab"
    Write-Host "3. Use arrow keys to navigate categories"
    Write-Host "4. Settings should update automatically when selection changes"
} else {
    Write-Host "`nSome checks failed. Please review the implementation." -ForegroundColor Yellow
}


####\test-navigation.ps1
#!/usr/bin/env pwsh
# Test script to debug navigation issues in TaskScreen

# Set up logging
$global:Logger = @{
    Debug = { param($msg) Write-Host "[DEBUG] $msg" -ForegroundColor Cyan }
    Info = { param($msg) Write-Host "[INFO] $msg" -ForegroundColor Green }
    Error = { param($msg) Write-Host "[ERROR] $msg" -ForegroundColor Red }
}

# Load the praxis framework
. "$PSScriptRoot/Start.ps1" -NoStart

# Create a simple test app that goes directly to TaskScreen
try {
    # Initialize services
    $global:ServiceContainer = [ServiceContainer]::new()
    
    # Register theme manager
    $themeManager = [ThemeManager]::new()
    $global:ServiceContainer.Register("ThemeManager", $themeManager)
    
    # Register logger
    $logger = [Logger]::new("$PSScriptRoot/_Logs/test-navigation.log")
    $global:ServiceContainer.Register("Logger", $logger)
    $global:Logger = $logger
    
    # Create screen manager
    $global:ScreenManager = [ScreenManager]::new($global:ServiceContainer)
    
    # Create and push TaskScreen directly
    $taskScreen = [TaskScreen]::new()
    $taskScreen.Initialize($global:ServiceContainer)
    
    Write-Host "Starting navigation test. Press Tab to switch between filter and list." -ForegroundColor Yellow
    Write-Host "Press 'q' to quit." -ForegroundColor Yellow
    Start-Sleep -Seconds 2
    
    # Push the screen and run
    $global:ScreenManager.Push($taskScreen)
    $global:ScreenManager.Run()
    
} catch {
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor Red
} finally {
    # Clean up
    [Console]::CursorVisible = $true
    Clear-Host
}


####\test-new-task-fix.ps1
#!/usr/bin/env pwsh
# Test script to verify the new task dialog fix

Write-Host "New Task Dialog Fix Verification" -ForegroundColor Cyan
Write-Host "================================" -ForegroundColor Cyan
Write-Host ""

# Check that the TaskScreen has the proper variable capture
$content = Get-Content "Screens/TaskScreen.ps1" -Raw

$fixesFound = 0

# Check for $screen capture in NewTask
if ($content -match '\$screen = \$this[\s\S]*\$screen\.TaskService\.CreateTask') {
    Write-Host "✓ NewTask method properly captures \$screen reference" -ForegroundColor Green
    $fixesFound++
} else {
    Write-Host "✗ NewTask method does NOT properly capture \$screen reference" -ForegroundColor Red
}

# Check for $screen capture in EditTask
if ($content -match 'EditTask[\s\S]*\$screen = \$this[\s\S]*\$screen\.TaskService\.UpdateTask') {
    Write-Host "✓ EditTask method properly captures \$screen reference" -ForegroundColor Green
    $fixesFound++
} else {
    Write-Host "✗ EditTask method does NOT properly capture \$screen reference" -ForegroundColor Red
}

# Check for $screen capture in DeleteTask
if ($content -match 'DeleteTask[\s\S]*\$screen = \$this[\s\S]*\$screen\.TaskService\.DeleteTask') {
    Write-Host "✓ DeleteTask method properly captures \$screen reference" -ForegroundColor Green
    $fixesFound++
} else {
    Write-Host "✗ DeleteTask method does NOT properly capture \$screen reference" -ForegroundColor Red
}

Write-Host ""
Write-Host "Results: $fixesFound/3 fixes verified" -ForegroundColor $(if ($fixesFound -eq 3) { "Green" } else { "Yellow" })

if ($fixesFound -eq 3) {
    Write-Host ""
    Write-Host "All null reference fixes have been applied!" -ForegroundColor Green
    Write-Host ""
    Write-Host "To test the fix:" -ForegroundColor Cyan
    Write-Host "1. Run: pwsh -File Start.ps1"
    Write-Host "2. Press '2' to go to Tasks tab"
    Write-Host "3. Press 'n' to create a new task"
    Write-Host "4. Fill in the task details and press Tab to navigate to Create button"
    Write-Host "5. Press Enter to create the task"
    Write-Host ""
    Write-Host "The task should be created without any null reference errors." -ForegroundColor Green
} else {
    Write-Host ""
    Write-Host "Some fixes are missing. Please review the TaskScreen.ps1 file." -ForegroundColor Yellow
}


####\test-project-constructor-fix.ps1
#!/usr/bin/env pwsh
# Test script to verify the Project constructor fix

Write-Host "Project Constructor Fix Verification" -ForegroundColor Cyan
Write-Host "===================================" -ForegroundColor Cyan
Write-Host ""

$errors = 0

# Check CommandPalette doesn't use parameterless Project constructor
Write-Host "Checking CommandPalette.ps1..." -ForegroundColor Yellow
$content = Get-Content "Components/CommandPalette.ps1" -Raw
if ($content -match '\[Project\]::new\(\)') {
    Write-Host "  ✗ CommandPalette still uses parameterless Project constructor" -ForegroundColor Red
    $errors++
} else {
    Write-Host "  ✓ CommandPalette properly uses ProjectService.AddProject" -ForegroundColor Green
}

# Check ProjectsScreen uses dialog properly
Write-Host "`nChecking ProjectsScreen.ps1..." -ForegroundColor Yellow
$content = Get-Content "Screens/ProjectsScreen.ps1" -Raw
if ($content -match 'NewProject[\s\S]*NewProjectDialog') {
    Write-Host "  ✓ ProjectsScreen now uses NewProjectDialog" -ForegroundColor Green
} else {
    Write-Host "  ✗ ProjectsScreen doesn't use NewProjectDialog" -ForegroundColor Red
    $errors++
}

# Verify Project model has correct constructors
Write-Host "`nChecking Project.ps1..." -ForegroundColor Yellow
$content = Get-Content "Models/Project.ps1" -Raw
if ($content -match 'Project\(\[string\]\$fullName, \[string\]\$nickname\)' -and 
    $content -match 'Project\(\[string\]\$name\)') {
    Write-Host "  ✓ Project has correct constructors (with parameters)" -ForegroundColor Green
} else {
    Write-Host "  ✗ Project constructors may be missing" -ForegroundColor Red
    $errors++
}

Write-Host ""
if ($errors -eq 0) {
    Write-Host "All fixes verified successfully!" -ForegroundColor Green
    Write-Host ""
    Write-Host "To test the fix:" -ForegroundColor Cyan
    Write-Host "1. Run: pwsh -File Start.ps1"
    Write-Host "2. Press '1' to go to Projects tab"
    Write-Host "3. Press 'n' to create a new project"
    Write-Host "4. Fill in the project name and press Tab to navigate to Create button"
    Write-Host "5. Press Enter to create the project"
    Write-Host ""
    Write-Host "The project should be created without constructor errors." -ForegroundColor Green
} else {
    Write-Host "Found $errors issues. Please review the fixes." -ForegroundColor Red
}


