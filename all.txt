####\Base/BaseDialog.ps1
# BaseDialog.ps1 - Base class for modal dialogs to eliminate code duplication

class BaseDialog : Screen {
    # Dialog properties
    [int]$DialogWidth = 50
    [int]$DialogHeight = 14
    [int]$DialogPadding = 2
    [int]$ButtonHeight = 3
    [int]$ButtonSpacing = 2
    [int]$MaxButtonWidth = 12
    
    # Common buttons
    [Button]$PrimaryButton
    [Button]$SecondaryButton
    [string]$PrimaryButtonText = "OK"
    [string]$SecondaryButtonText = "Cancel"
    
    # Event handlers
    [scriptblock]$OnPrimary = {}
    [scriptblock]$OnSecondary = {}
    [scriptblock]$OnCreate = {}  # Legacy support
    [scriptblock]$OnCancel = {}  # Legacy support
    
    # Internal state
    hidden [hashtable]$_dialogBounds = @{}
    hidden [System.Collections.ArrayList]$_contentControls
    [EventBus]$EventBus
    
    BaseDialog([string]$title) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    BaseDialog([string]$title, [int]$width, [int]$height) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this.DialogWidth = $width
        $this.DialogHeight = $height
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create default buttons
        $this.CreateDefaultButtons()
        
        # Call derived class initialization
        $this.InitializeContent()
    }
    
    # Virtual method for derived classes to override
    [void] InitializeContent() {
        # Override in derived classes
    }
    
    [void] CreateDefaultButtons() {
        # Create primary button
        $this.PrimaryButton = [Button]::new($this.PrimaryButtonText)
        $this.PrimaryButton.IsDefault = $true
        $dialog = $this  # Capture reference
        $this.PrimaryButton.OnClick = {
            $dialog.HandlePrimaryAction()
        }.GetNewClosure()
        $this.PrimaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.PrimaryButton)
        
        # Create secondary button
        $this.SecondaryButton = [Button]::new($this.SecondaryButtonText)
        $this.SecondaryButton.OnClick = {
            $dialog.HandleSecondaryAction()
        }.GetNewClosure()
        $this.SecondaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SecondaryButton)
    }
    
    [void] AddContentControl([UIElement]$control, [int]$tabIndex = -1) {
        if ($tabIndex -gt 0) {
            $control.TabIndex = $tabIndex
        }
        $control.Initialize($global:ServiceContainer)
        $this.AddChild($control)
        $this._contentControls.Add($control) | Out-Null
    }
    
    [void] HandlePrimaryAction() {
        # Call custom handler first
        if ($this.OnPrimary -and $this.OnPrimary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnPrimary
        }
        
        # Legacy support
        if ($this.OnCreate -and $this.OnCreate.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCreate
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] HandleSecondaryAction() {
        # Call custom handler first
        if ($this.OnSecondary -and $this.OnSecondary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnSecondary
        }
        
        # Legacy support  
        if ($this.OnCancel -and $this.OnCancel.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCancel
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] CloseDialog() {
        if ($global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    # PARENT-DELEGATED INPUT MODEL (inherits from Screen)
    # Dialog shortcuts are handled via HandleScreenInput
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Dialog-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                if (-not $key.Modifiers) {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleSecondaryAction()
                return $true
            }
        }
        return $false
    }
    
    [void] OnActivated() {
        # Publish dialog opened event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::DialogOpened, @{ 
                Dialog = $this.GetType().Name
            })
        }
        
        # Focus first content control
        if ($this._contentControls.Count -gt 0) {
            $this._contentControls[0].Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog position (centered)
        $centerX = [int](($this.Width - $this.DialogWidth) / 2)
        $centerY = [int](($this.Height - $this.DialogHeight) / 2)
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $this.DialogWidth
            Height = $this.DialogHeight
        }
        
        # Position content controls
        $this.PositionContentControls($centerX, $centerY)
        
        # Position buttons
        $this.PositionButtons($centerX, $centerY)
    }
    
    # Virtual method for derived classes to override content positioning
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Default implementation - stack controls vertically
        $currentY = $dialogY + $this.DialogPadding
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $controlHeight = 3
        
        foreach ($control in $this._contentControls) {
            $control.SetBounds(
                $dialogX + $this.DialogPadding,
                $currentY,
                $controlWidth,
                $controlHeight
            )
            $currentY += $controlHeight + 1
        }
    }
    
    [void] PositionButtons([int]$dialogX, [int]$dialogY) {
        # Calculate button positioning
        $buttonY = $dialogY + $this.DialogHeight - $this.ButtonHeight - 1
        $totalButtonWidth = ($this.MaxButtonWidth * 2) + $this.ButtonSpacing
        
        # Center buttons if dialog is wide enough
        if ($this.DialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $dialogX + [int](($this.DialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $this.MaxButtonWidth
        } else {
            $buttonStartX = $dialogX + $this.DialogPadding
            $buttonWidth = [int](($this.DialogWidth - ($this.DialogPadding * 2) - $this.ButtonSpacing) / 2)
        }
        
        # Position primary button
        $this.PrimaryButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        # Position secondary button
        $this.SecondaryButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024  # Dialogs need moderate capacity
        
        # Render overlay background
        $this.RenderOverlay($sb)
        
        # Render dialog box
        if ($this._dialogBounds.Count -gt 0) {
            $this.RenderDialogBox($sb)
            $this.RenderTitle($sb)
        }
        
        # Render children (content controls and buttons)
        $sb.Append(([Container]$this).OnRender())
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [void] RenderOverlay([System.Text.StringBuilder]$sb) {
        # Dark overlay background
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
    }
    
    [void] RenderDialogBox([System.Text.StringBuilder]$sb) {
        $borderColor = $this.Theme.GetColor("dialog.border")
        $bgColor = $this.Theme.GetBgColor("dialog.background")
        
        $x = $this._dialogBounds.X
        $y = $this._dialogBounds.Y
        $w = $this._dialogBounds.Width
        $h = $this._dialogBounds.Height
        
        # Fill background
        for ($i = 0; $i -lt $h; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append($bgColor)
            $sb.Append(" " * $w)
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo($x, $y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
        
        for ($i = 1; $i -lt $h - 1; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo($x, $y + $h - 1))
        $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
    }
    
    [void] RenderTitle([System.Text.StringBuilder]$sb) {
        if (-not [string]::IsNullOrEmpty($this.Title)) {
            $titleColor = $this.Theme.GetColor("dialog.title")
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            
            # Calculate title position (centered)
            $titleText = " $($this.Title) "
            $titleX = $x + [int](($w - $titleText.Length) / 2)
            
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($titleText)
        }
    }
}


####\Base/BaseModel.ps1
# BaseModel.ps1 - Base class for all data models to standardize common properties

class BaseModel {
    [string]$Id
    [DateTime]$CreatedAt
    [DateTime]$UpdatedAt
    [bool]$Deleted = $false
    
    BaseModel() {
        $this.Id = [guid]::NewGuid().ToString()
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    BaseModel([string]$id) {
        $this.Id = $id
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    # Method to update the UpdatedAt timestamp when model is modified
    [void] MarkAsUpdated() {
        $this.UpdatedAt = Get-Date
    }
    
    # Method to soft delete the model
    [void] SoftDelete() {
        $this.Deleted = $true
        $this.MarkAsUpdated()
    }
    
    # Method to restore a soft deleted model
    [void] Restore() {
        $this.Deleted = $false
        $this.MarkAsUpdated()
    }
    
    # Helper method to check if model is active (not deleted)
    [bool] IsActive() {
        return -not $this.Deleted
    }
    
    # Helper method to get age of the model
    [TimeSpan] GetAge() {
        return (Get-Date) - $this.CreatedAt
    }
    
    # Helper method to get time since last update
    [TimeSpan] GetTimeSinceUpdate() {
        return (Get-Date) - $this.UpdatedAt
    }
}


####\Base/Container.ps1
# Container.ps1 - Base class for components that contain other components
# Optimized for fast string aggregation

class Container : UIElement {
    # Optional background
    [bool]$DrawBackground = $false
    hidden [string]$_cachedBackground = ""
    hidden [string]$_cachedBgColor = ""
    hidden [ThemeManager]$Theme
    
    Container() : base() {
    }
    
    # Efficient child rendering with string builder
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Draw background if enabled
        if ($this.DrawBackground -and $this._cachedBackground) {
            $sb.Append($this._cachedBackground)
        }
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        return $sb.ToString()
    }
    
    # Pre-compute background
    [void] SetBackgroundColor([string]$ansiColor) {
        $this._cachedBgColor = $ansiColor
        $this.InvalidateBackground()
    }
    
    [void] InvalidateBackground() {
        if (-not $this.DrawBackground -or $this.Width -le 0 -or $this.Height -le 0) { 
            $this._cachedBackground = ""
            return 
        }
        
        $sb = [System.Text.StringBuilder]::new()
        $line = " " * $this.Width
        
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            if ($this._cachedBgColor) {
                $sb.Append($this._cachedBgColor)
            }
            $sb.Append($line)
        }
        
        if ($this._cachedBgColor) {
            $sb.Append([VT]::Reset())
        }
        
        $this._cachedBackground = $sb.ToString()
    }
    
    [void] OnBoundsChanged() {
        # Recalculate background when size changes
        if ($this.DrawBackground) {
            $this.InvalidateBackground()
        }
        
        # Let derived classes handle child layout
        $this.LayoutChildren()
    }
    
    # Override in derived classes for custom layouts
    [void] LayoutChildren() {
        # Base implementation does nothing
        # Derived classes like HorizontalSplit, VerticalSplit, etc. will implement
    }
    
    # Find child at specific coordinates
    [UIElement] HitTest([int]$x, [int]$y) {
        # Check if point is within our bounds
        if ($x -lt $this.X -or $x -ge ($this.X + $this.Width) -or
            $y -lt $this.Y -or $y -ge ($this.Y + $this.Height)) {
            return $null
        }
        
        # Check children in reverse order (top to bottom)
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                $hit = if ($child -is [Container]) {
                    $child.HitTest($x, $y)
                } else {
                    # Non-containers do simple bounds check
                    if ($x -ge $child.X -and $x -lt ($child.X + $child.Width) -and
                        $y -ge $child.Y -and $y -lt ($child.Y + $child.Height)) {
                        $child
                    } else {
                        $null
                    }
                }
                
                if ($hit) { return $hit }
            }
        }
        
        # No child hit, return self
        return $this
    }
    
    # Route input to focused child
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Type=$($this.GetType().Name)")
        }
        
        # Simple rule: Let focused child handle first
        $focused = $this.FindFocusedChild()
        if ($focused) {
            if ($global:Logger) {
                $global:Logger.Debug("Container: Routing to focused child $($focused.GetType().Name)")
            }
            return $focused.HandleInput($key)
        }
        
        # No focused child
        return $false
    }
    
    # Find direct focused child (not deep search)
    [UIElement] FindFocusedChild() {
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.IsFocused) {
                if ($global:Logger) {
                    $global:Logger.Debug("Container.FindFocusedChild: Found focused child $($child.GetType().Name)")
                }
                return $child
            }
        }
        if ($global:Logger) {
            $global:Logger.Debug("Container.FindFocusedChild: No focused child found among $($this.Children.Count) children")
        }
        return $null
    }
    
    # Parent-delegated focus navigation
    [void] FocusNextChild([UIElement]$currentChild) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.FocusNextChild: Type=$($this.GetType().Name), CurrentChild=$($currentChild.GetType().Name)")
        }
        
        # For containers, we need to consider both focusable children AND containers
        $allChildren = $this.Children | Where-Object { $_.Visible }
        $currentIndex = -1
        
        # Find current child index
        for ($i = 0; $i -lt $allChildren.Count; $i++) {
            if ($allChildren[$i] -eq $currentChild) {
                $currentIndex = $i
                break
            }
        }
        
        if ($currentIndex -eq -1) {
            # Current child not found, shouldn't happen
            return
        }
        
        # Look for next child that either is focusable or contains focusable elements
        for ($i = $currentIndex + 1; $i -lt $allChildren.Count; $i++) {
            $child = $allChildren[$i]
            if ($child.IsFocusable) {
                $child.Focus()
                return
            } elseif ($child -is [Container]) {
                # Try to focus first element in this container
                $child.FocusFirstInTree()
                if ($this.GetRoot().FindFocused()) {
                    return  # Focus was set
                }
            }
        }
        
        # No next child found, bubble up or wrap
        if ($this.Parent) {
            $this.Parent.FocusNextChild($this)
        } else {
            # We're at root, wrap to beginning
            $this.FocusFirstInTree()
        }
    }
    
    [void] FocusPreviousChild([UIElement]$currentChild) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.FocusPreviousChild: Type=$($this.GetType().Name), CurrentChild=$($currentChild.GetType().Name)")
        }
        
        # For containers, we need to consider both focusable children AND containers
        $allChildren = $this.Children | Where-Object { $_.Visible }
        $currentIndex = -1
        
        # Find current child index
        for ($i = 0; $i -lt $allChildren.Count; $i++) {
            if ($allChildren[$i] -eq $currentChild) {
                $currentIndex = $i
                break
            }
        }
        
        if ($currentIndex -eq -1) {
            # Current child not found, shouldn't happen
            return
        }
        
        # Look for previous child that either is focusable or contains focusable elements
        for ($i = $currentIndex - 1; $i -ge 0; $i--) {
            $child = $allChildren[$i]
            if ($child.IsFocusable) {
                $child.Focus()
                return
            } elseif ($child -is [Container]) {
                # Try to focus last element in this container
                $child.FocusLastInTree()
                if ($this.GetRoot().FindFocused()) {
                    return  # Focus was set
                }
            }
        }
        
        # No previous child found, bubble up or wrap
        if ($this.Parent) {
            $this.Parent.FocusPreviousChild($this)
        } else {
            # We're at root, wrap to end
            $this.FocusLastInTree()
        }
    }
    
    # Focus first focusable child
    [void] FocusFirst() {
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
        }
    }
    
    # Focus first focusable element in the entire tree
    [void] FocusFirstInTree() {
        # First check if any direct children are focusable
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
            return
        }
        
        # Otherwise check children's children
        foreach ($child in $this.Children) {
            if ($child -is [Container] -and $child.Visible) {
                $child.FocusFirstInTree()
                # If focus was set, we're done
                $root = $this.GetRoot()
                if ($root.FindFocused()) {
                    return
                }
            }
        }
    }
    
    # Focus last focusable element in the entire tree
    [void] FocusLastInTree() {
        # Check children in reverse order
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                if ($child -is [Container]) {
                    # Recurse into container
                    $child.FocusLastInTree()
                    # If focus was set, we're done
                    $root = $this.GetRoot()
                    if ($root.FindFocused()) {
                        return
                    }
                } elseif ($child.IsFocusable) {
                    $child.Focus()
                    return
                }
            }
        }
    }
}


####\Base/Screen.ps1
# Screen.ps1 - Base class for all screens
# Simplified from ALCAR with focus on speed

class Screen : Container {
    [string]$Title = "Screen"
    [bool]$Active = $true
    hidden [hashtable]$_keyBindings = @{}
    hidden [ThemeManager]$Theme
    
    # Protected service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    Screen() : base() {
        $this.IsFocusable = $false  # Screens are containers, not focusable elements
        $this.DrawBackground = $true
    }
    
    # Initialize with services
    [void] Initialize([ServiceContainer]$services) {
        # Call base initialization
        ([UIElement]$this).Initialize($services)
        
        # Screen-specific initialization
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    # Helper method for service access with error handling
    [object] GetService([string]$serviceName) {
        if (-not $this.ServiceContainer) {
            if ($global:Logger) {
                $global:Logger.Warning("Screen.GetService: ServiceContainer not available, falling back to global access for $serviceName")
            }
            return $global:ServiceContainer.GetService($serviceName)
        }
        return $this.ServiceContainer.GetService($serviceName)
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Theme change handler
    [void] OnThemeChanged() {
        $this.SetBackgroundColor($this.Theme.GetColor("background"))
        $this.Invalidate()
    }
    
    # Override this method in derived screens to handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        return $false  # Base implementation - no screen-specific handling
    }
    
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($global:Logger) {
            $global:Logger.Debug("Screen.HandleInput: Key=$($keyInfo.Key) Type=$($this.GetType().Name)")
        }
        
        # 1. Let focused child handle first (components get priority)
        $handled = ([Container]$this).HandleInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen base handled: $handled")
        }
        if ($handled) {
            return $true
        }
        
        # 2. Screen shortcuts as fallback only
        $screenHandled = $this.HandleScreenInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen shortcuts handled: $screenHandled")
        }
        return $screenHandled
    }
    
    # Lifecycle methods - simple and fast
    [void] OnActivated() {
        # Force a render when screen is activated
        $this.Invalidate()
    }
    
    [void] OnDeactivated() {
        # Override in derived classes if needed
    }
    
    # Removed old FocusNext/FocusPrevious - now handled by parent delegation
    
    # Delegate to Container's FocusFirst
    [void] FocusFirst() {
        ([Container]$this).FocusFirst()
    }

    # Request a re-render
    [void] RequestRender() {
        $this.Invalidate()
        # The ScreenManager will handle the actual rendering
    }
}


####\Base/UIElement.ps1
# UIElement.ps1 - Fast base class for all UI components
# Inspired by AxiomPhoenix architecture but optimized for string-based rendering

class UIElement {
    # Position and dimensions
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 0
    [int]$Height = 0
    
    # Visibility and focus
    [bool]$Visible = $true
    [bool]$IsFocusable = $false
    [bool]$IsFocused = $false
    [int]$TabIndex = 0
    
    # Hierarchy
    [UIElement]$Parent = $null
    [System.Collections.Generic.List[UIElement]]$Children
    
    # Service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    # Caching for maximum speed
    hidden [string]$_renderCache = ""
    hidden [bool]$_cacheInvalid = $true
    
    # Pre-computed values
    hidden [string]$_cachedPosition = ""
    hidden [string]$_cachedClear = ""
    
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Fast render - returns cached string if valid
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        if ($this._cacheInvalid) {
            # Rebuild cache only when needed
            $this._renderCache = $this.OnRender()
            $this._cacheInvalid = $false
        }
        
        return $this._renderCache
    }
    
    # Override in derived classes
    [string] OnRender() {
        return ""
    }
    
    # Mark this element (and parents) as needing re-render
    [void] Invalidate() {
        if ($this._cacheInvalid) { return }  # Already invalid
        
        $this._cacheInvalid = $true
        $this.InvalidatePosition()  # Position might have changed too
        
        # Propagate up the tree
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
        
        # Render request is handled by propagation to root
    }
    
    # Pre-compute position strings
    [void] InvalidatePosition() {
        # Pre-compute ANSI sequences for this element's position
        $this._cachedPosition = [VT]::MoveTo($this.X, $this.Y)
        
        # Pre-compute clear sequence for this element's area
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $clearLine = " " * $this.Width
            $clearSeq = [System.Text.StringBuilder]::new()
            for ($i = 0; $i -lt $this.Height; $i++) {
                $clearSeq.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $clearSeq.Append($clearLine)
            }
            $this._cachedClear = $clearSeq.ToString()
        } else {
            $this._cachedClear = ""
        }
    }
    
    # Layout management
    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($this.X -eq $x -and $this.Y -eq $y -and 
            $this.Width -eq $width -and $this.Height -eq $height) {
            return  # No change
        }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        
        $this.InvalidatePosition()
        $this.Invalidate()
        $this.OnBoundsChanged()
    }
    
    # Override for custom layout logic
    [void] OnBoundsChanged() {
        # Base implementation does nothing
    }
    
    # Child management - now invalidates focus cache
    [void] AddChild([UIElement]$child) {
        $child.Parent = $this
        $this.Children.Add($child)
        
        # No focus cache invalidation needed - using simple direct focus
        
        $this.Invalidate()
    }
    
    [void] RemoveChild([UIElement]$child) {
        $child.Parent = $null
        $this.Children.Remove($child)
        
        # No focus cache invalidation needed - using simple direct focus
        
        $this.Invalidate()
    }
    
    # Simple focus management - works with PowerShell patterns
    [void] Focus() {
        if (-not $this.IsFocusable -or -not $this.Visible) { 
            if ($global:Logger) {
                $global:Logger.Debug("UIElement.Focus: Cannot focus $($this.GetType().Name) - IsFocusable=$($this.IsFocusable), Visible=$($this.Visible)")
            }
            return 
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("UIElement.Focus: Focusing $($this.GetType().Name)")
        }
        
        # Find root and clear any existing focus
        $root = $this
        while ($root.Parent) { $root = $root.Parent }
        $current = $this.FindFocusedElement($root)
        if ($current -and $current -ne $this) {
            $current.IsFocused = $false
            $current.OnLostFocus()
            $current.Invalidate()
        }
        
        # Focus this element
        $this.IsFocused = $true
        $this.OnGotFocus()
        $this.Invalidate()
    }
    
    # Find focused element in tree
    [UIElement] FindFocusedElement([UIElement]$element) {
        if ($element.IsFocused) { return $element }
        foreach ($child in $element.Children) {
            $found = $this.FindFocusedElement($child)
            if ($found) { return $found }
        }
        return $null
    }
    
    [UIElement] GetRoot() {
        $current = $this
        while ($current.Parent) {
            $current = $current.Parent
        }
        return $current
    }
    
    [UIElement] FindFocused() {
        if ($this.IsFocused) { return $this }
        
        foreach ($child in $this.Children) {
            $focused = $child.FindFocused()
            if ($focused) { return $focused }
        }
        
        return $null
    }
    
    # Override for focus behavior
    [void] OnGotFocus() {}
    [void] OnLostFocus() {}
    
    # Initialize with service container
    [void] Initialize([ServiceContainer]$services) {
        $this.ServiceContainer = $services
        $this.OnInitialize()
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Base implementation does nothing
        return $false
    }
}


####\Components/Button.ps1
# Button.ps1 - Fast button component with theming

class Button : UIElement {
    [string]$Text = "Button"
    [scriptblock]$OnClick = {}
    [bool]$IsDefault = $false
    
    # Cached rendering
    hidden [string]$_cachedRender = ""
    hidden [ThemeManager]$Theme
    
    Button() : base() {
        $this.IsFocusable = $true
        $this.Height = 3  # Default button height
    }
    
    Button([string]$text) : base() {
        $this.Text = $text
        $this.IsFocusable = $true
        $this.Height = 3
        if ($global:Logger) {
            $global:Logger.Debug("Button created with text: '$text'")
        }
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
        $this.Invalidate()  # Force initial render
    }
    
    [void] OnThemeChanged() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        # Debug logging
        if ($global:Logger) {
            $global:Logger.Debug("Button.RebuildCache: Text='$($this.Text)' Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        $sb = Get-PooledStringBuilder 512  # Button rendering typically needs small capacity
        
        # Determine colors based on state
        $bgColor = ""
        $fgColor = ""
        $borderColor = ""
        
        if ($this.IsFocused) {
            $bgColor = $this.Theme.GetBgColor("button.focused.background")
            $fgColor = $this.Theme.GetColor("button.focused.foreground")
            $borderColor = $this.Theme.GetColor("border.focused")
        } else {
            $bgColor = $this.Theme.GetBgColor("button.background")
            $fgColor = $this.Theme.GetColor("button.foreground")
            $borderColor = $this.Theme.GetColor("border")
        }
        
        # Calculate text position (centered)
        $textX = $this.X + [Math]::Max(1, [int](($this.Width - $this.Text.Length) / 2))
        $textY = $this.Y + 1  # For height=3, text should be on the middle line
        
        if ($global:Logger -and $this.Text -eq "New Project") {
            $global:Logger.Debug("Button text position: textX=$textX, textY=$textY for button at ($($this.X),$($this.Y)) with height $($this.Height)")
        }
        
        # Draw button box
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $borderWidth = [Math]::Max(0, $this.Width - 2)
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::TL() + ([VT]::H() * $borderWidth) + [VT]::TR())
        } else {
            $sb.Append([VT]::TL() + [VT]::TR())
        }
        
        # Middle lines
        for ($y = $this.Y + 1; $y -lt $this.Y + $this.Height - 1; $y++) {
            if ($global:Logger -and $this.Text -eq "New Project") {
                $global:Logger.Debug("Button middle line: y=$y, textY=$textY, Text='$($this.Text)'")
            }
            
            $sb.Append([VT]::MoveTo($this.X, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Fill line with background, but handle text line specially
            if ($y -eq $textY -and $this.Text) {
                # Draw background up to text
                $sb.Append($bgColor)
                $textStartOffset = [Math]::Max(0, ($this.Width - $this.Text.Length) / 2) - 1
                if ($textStartOffset -gt 0) {
                    $sb.Append(" " * [int]$textStartOffset)
                }
                
                # Draw text
                $sb.Append($fgColor)
                $sb.Append($this.Text)
                
                # Fill rest of line
                $sb.Append($bgColor)
                $remainingSpace = $this.Width - 2 - [int]$textStartOffset - $this.Text.Length
                if ($remainingSpace -gt 0) {
                    $sb.Append(" " * $remainingSpace)
                }
            } else {
                # Non-text lines - just fill with background
                $sb.Append($bgColor)
                $paddingWidth = [Math]::Max(0, $this.Width - 2)
                if ($paddingWidth -gt 0) {
                    $sb.Append(" " * $paddingWidth)
                }
            }
            
            # Draw right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            $sb.Append([VT]::Reset())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::BL() + ([VT]::H() * $borderWidth) + [VT]::BR())
        } else {
            $sb.Append([VT]::BL() + [VT]::BR())
        }
        
        # Add default indicator if needed
        if ($this.IsDefault) {
            $sb.Append([VT]::MoveTo($this.X + 1, $this.Y))
            $sb.Append($this.Theme.GetColor("accent"))
            $sb.Append("*")
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -eq [System.ConsoleKey]::Enter -or 
                $key.Key -eq [System.ConsoleKey]::Spacebar) {
                $this.Click()
                return $true
            }
            return $false
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    [void] Click() {
        try {
            if ($this.OnClick) {
                & $this.OnClick
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.Click: Error executing OnClick handler - $($_.Exception.Message)")
            }
        }
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/CommandPalette.ps1
# CommandPalette.ps1 - Fast command palette overlay

class CommandPalette : Container {
    [string]$SearchText = ""
    [ListBox]$ResultsList
    [System.Collections.ArrayList]$AllCommands
    [System.Collections.ArrayList]$FilteredCommands
    [scriptblock]$OnCommandSelected = {}
    [bool]$IsVisible = $false
    [EventBus]$EventBus
    [ThemeManager]$Theme
    
    # Layout
    hidden [int]$PaletteWidth = 60
    hidden [int]$PaletteHeight = 20
    hidden [int]$MaxResults = 15
    
    CommandPalette() : base() {
        $this.AllCommands = [System.Collections.ArrayList]::new()
        $this.FilteredCommands = [System.Collections.ArrayList]::new()
        $this.DrawBackground = $true
        
        # Create results list
        $this.ResultsList = [ListBox]::new()
        $this.ResultsList.ShowBorder = $false
        $this.ResultsList.ShowScrollbar = $true
        $this.ResultsList.ItemRenderer = {
            param($cmd)
            $name = $cmd.Name.PadRight(20)
            $desc = if ($cmd.Description.Length -gt 35) {
                $cmd.Description.Substring(0, 32) + "..."
            } else {
                $cmd.Description
            }
            return "$name $desc"
        }
        $this.AddChild($this.ResultsList)
    }
    
    [void] Initialize([ServiceContainer]$services) {
        # Call base initialization
        ([Container]$this).Initialize($services)
        
        # Get services
        $this.EventBus = $services.GetService('EventBus')
        $this.Theme = $services.GetService('ThemeManager')
        
        # Subscribe to command registration events
        if ($this.EventBus) {
            $this.EventBus.Subscribe([EventNames]::CommandRegistered, {
                param($sender, $eventData)
                if ($eventData.Name -and $eventData.Description -and $eventData.Action) {
                    $this.AddCommand($eventData.Name, $eventData.Description, $eventData.Action)
                }
            }.GetNewClosure())
        }
        
        # Initialize child components
        if ($this.ResultsList) {
            $this.ResultsList.Initialize($services)
        }
        
        # Set palette background if theme is available
        if ($this.Theme) {
            $this.SetBackgroundColor($this.Theme.GetBgColor("menu.background"))
        }
        
        # Load default commands
        $this.LoadDefaultCommands()
    }
    
    [void] LoadDefaultCommands() {
        # Store reference to this palette for use in scriptblocks
        $palette = $this
        
        # Add some default commands
        $this.AddCommand("new project", "Create a new project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new project command")
            }
            
            # Publish event to switch to projects tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
            }
            
            # Create and show the dialog
            $dialog = [NewProjectDialog]::new()
            $dialog.OnCreate = {
                param($project)
                if ($global:Logger) {
                    $global:Logger.Info("Creating project: $($project.Name)")
                }
                # Add project via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    # Create proper Project object using single-parameter constructor
                    $newProject = $projectService.AddProject($project.Name)
                    
                    # Publish project created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::ProjectCreated, @{ Project = $newProject })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        $this.AddCommand("new task", "Create a new task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new task command")
            }
            
            # Publish event to switch to tasks tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
            }
            
            # Create and show the dialog directly (same pattern as new project)
            $dialog = [NewTaskDialog]::new()
            $dialog.OnCreate = {
                param($task)
                if ($global:Logger) {
                    $global:Logger.Info("Creating task: $($task.Title)")
                }
                # Create task via service
                $taskService = $global:ServiceContainer.GetService("TaskService")
                if ($taskService) {
                    $newTask = $taskService.CreateTask($task)
                    
                    # Publish task created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TaskCreated, @{ Task = $newTask })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit project", "Edit selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit task", "Edit selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete project", "Delete selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete task", "Delete selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("search", "Search in files", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Search command executed")
            }
            # TODO: Implement search
        }.GetNewClosure())
        
        $this.AddCommand("files", "Open file browser", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Files command executed")
            }
            # Switch to files tab (tab index 3 - Projects, Tasks, Dashboard, Files)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 3 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("text editor", "Open text editor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Text editor command executed")
            }
            # Switch to editor tab (tab index 4 - Projects, Tasks, Dashboard, Files, Editor)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("editor", "Open text editor tab", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Editor tab command executed")
            }
            # Switch to editor tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("settings", "Open settings", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Settings command executed")
            }
            # Switch to settings tab (tab index 5 - Projects, Tasks, Dashboard, Files, Editor, Settings)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 5 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("eventbus monitor", "Open EventBus monitor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: EventBus monitor command executed")
            }
            # Open EventBus monitor dialog
            $monitor = [EventBusMonitor]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($monitor)
            }
        }.GetNewClosure())
        
        $this.AddCommand("reload", "Reload configuration", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Reload command executed")
            }
            # TODO: Implement reload
        }.GetNewClosure())
        
        $this.AddCommand("theme dark", "Switch to dark theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Dark theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        
        $this.AddCommand("theme light", "Switch to light theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Light theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        $this.AddCommand("quit", "Exit application", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quit command executed")
            }
            if ($global:ScreenManager) {
                $screen = $global:ScreenManager.GetActiveScreen()
                if ($screen) { 
                    $screen.Active = $false 
                }
            }
        }.GetNewClosure())
    }
    
    [void] AddCommand([string]$name, [string]$description, [scriptblock]$action) {
        $this.AllCommands.Add(@{
            Name = $name
            Description = $description
            Action = $action
        })
    }
    
    [void] Show() {
        $this.IsVisible = $true
        $this.SearchText = ""
        $this.UpdateFilter()
        $this.Invalidate()
        
        # Focus on results
        $this.ResultsList.Focus()
    }
    
    [void] Hide() {
        $this.IsVisible = $false
        $this.Invalidate()
        
        # Return focus to parent's active tab
        if ($this.Parent -and $this.Parent.GetType().Name -eq "MainScreen") {
            $activeTab = $this.Parent.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                $activeTab.Content.Focus()
            }
        }
    }
    
    [void] UpdateFilter() {
        $this.FilteredCommands.Clear()
        
        if ([string]::IsNullOrEmpty($this.SearchText)) {
            $this.FilteredCommands.AddRange($this.AllCommands)
        } else {
            # Simple fuzzy search
            $searchLower = $this.SearchText.ToLower()
            foreach ($cmd in $this.AllCommands) {
                if ($cmd.Name.ToLower().Contains($searchLower) -or 
                    $cmd.Description.ToLower().Contains($searchLower)) {
                    $this.FilteredCommands.Add($cmd)
                }
            }
        }
        
        # Update list
        $this.ResultsList.SetItems($this.FilteredCommands.ToArray())
    }
    
    [void] OnBoundsChanged() {
        # Center the palette
        $centerX = [int](($this.Width - $this.PaletteWidth) / 2)
        $centerY = [int](($this.Height - $this.PaletteHeight) / 2)
        
        # Update own bounds to be centered
        $this.X = $centerX
        $this.Y = $centerY
        $this.Width = $this.PaletteWidth
        $this.Height = $this.PaletteHeight
        
        # Layout results list (leave room for search box and border)
        $this.ResultsList.SetBounds(
            $this.X + 2,
            $this.Y + 4,
            $this.Width - 4,
            $this.Height - 6
        )
        
        # Recalculate visible items
        $this.ResultsList.VisibleItems = [Math]::Min($this.MaxResults, $this.Height - 6)
        
        ([Container]$this).OnBoundsChanged()
    }
    
    [string] OnRender() {
        if (-not $this.IsVisible) { return "" }
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Draw background first
        $sb.Append(([Container]$this).OnRender())
        
        # Draw border
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("border.focused") } else { "" }
        
        # Top border with title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * 2))
        $accentColor = if ($this.Theme) { $this.Theme.GetColor("accent") } else { "" }
        $sb.Append($accentColor)
        $sb.Append(" Command Palette ")
        $sb.Append($borderColor)
        $sb.Append([VT]::H() * ($this.Width - 19) + [VT]::TR())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        
        # Search box
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 2))
        $foregroundColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
        $sb.Append($foregroundColor)
        $sb.Append("Search: ")
        $sb.Append($accentColor)
        $sb.Append($this.SearchText)
        $sb.Append("_")
        
        # Separator
        $sb.Append([VT]::MoveTo($this.X + 1, $this.Y + 3))
        $sb.Append($borderColor)
        $sb.Append([VT]::H() * ($this.Width - 2))
        
        # Help text
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + $this.Height - 2))
        $disabledColor = if ($this.Theme) { $this.Theme.GetColor("disabled") } else { "" }
        $sb.Append($disabledColor)
        $sb.Append("[Enter] Select  [Esc] Cancel")
        
        $sb.Append([VT]::Reset())
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsVisible) { return $false }
        
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($global:Logger) {
                    $global:Logger.Debug("CommandPalette: Escape pressed, hiding palette")
                }
                try {
                    $this.Hide()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("CommandPalette: Error hiding palette: $_")
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.ResultsList.GetSelectedItem()
                if ($selected) {
                    if ($global:Logger) {
                        $global:Logger.Debug("CommandPalette: Executing command '$($selected.Name)'")
                    }
                    $this.Hide()
                    if ($selected.Action) {
                        try {
                            # Execute in the context of the CommandPalette
                            $selected.Action.Invoke()
                        } catch {
                            if ($global:Logger) {
                                $global:Logger.Error("CommandPalette: Error executing command '$($selected.Name)': $_")
                            }
                        }
                    }
                    if ($this.OnCommandSelected) {
                        & $this.OnCommandSelected $selected
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.SearchText.Length -gt 0) {
                    $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                    $this.UpdateFilter()
                    $this.Invalidate()
                }
                return $true
            }
            default {
                # Let list handle navigation
                if ($this.ResultsList.HandleInput($key)) {
                    return $true
                }
                
                # Add character to search
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or $key.KeyChar -eq ' ') {
                    $this.SearchText += $key.KeyChar
                    $this.UpdateFilter()
                    $this.Invalidate()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Components/DataGrid.ps1
# DataGrid.ps1 - Fast data grid component for tabular display with full grid lines
# Optimized for performance with caching and pooled string builders

class DataGrid : UIElement {
    [System.Collections.ArrayList]$Items
    [hashtable[]]$Columns = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$ShowGridLines = $true  # New property for grid lines
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_columnWidths = @{}
    hidden [string]$_cachedHeader = ""
    hidden [string]$_cachedSeparator = ""
    hidden [bool]$_layoutCacheValid = $false
    hidden [int]$_lastWidth = 0
    
    DataGrid() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        $this._layoutCacheValid = $false
        $this.Invalidate()
    }
    
    # Set the columns for the grid
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this._layoutCacheValid = $false
        $this.Invalidate()
    }
    
    # Set data items
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = if ($this.Items.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    # Get selected item
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    # Select specific index
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    # Calculate column widths with auto-sizing
    hidden [void] CalculateColumnWidths([int]$availableWidth) {
        if ($this._layoutCacheValid -and $this._lastWidth -eq $availableWidth) {
            return
        }
        
        $this._columnWidths.Clear()
        $totalFixed = 0
        $flexCount = 0
        
        # First pass: calculate fixed widths and count flex columns
        foreach ($col in $this.Columns) {
            if ($col.Width -and $col.Width -gt 0) {
                $this._columnWidths[$col.Name] = $col.Width
                $totalFixed += $col.Width
            } else {
                $flexCount++
            }
        }
        
        # Add space for separators if grid lines are shown
        if ($this.ShowGridLines -and $this.Columns.Count -gt 1) {
            $totalFixed += ($this.Columns.Count - 1)  # Vertical separators
        }
        
        # Second pass: distribute remaining width to flex columns
        if ($flexCount -gt 0 -and $availableWidth -gt $totalFixed) {
            $flexWidth = [Math]::Floor(($availableWidth - $totalFixed) / $flexCount)
            foreach ($col in $this.Columns) {
                if (-not $col.Width -or $col.Width -eq 0) {
                    $this._columnWidths[$col.Name] = [Math]::Max(5, $flexWidth)  # Min width of 5
                }
            }
        }
        
        $this._lastWidth = $availableWidth
        $this._layoutCacheValid = $true
    }
    
    # Build cached header string
    hidden [void] BuildCachedHeader([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedHeader) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $header = if ($col.Header) { $col.Header } else { $col.Name }
                $text = if ($header.Length -gt $width) {
                    $header.Substring(0, $width - 1) + ""
                } else {
                    $header.PadRight($width)
                }
                $sb.Append($text)
                $x += $width
                
                # Add separator after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append(" " * ($contentWidth - $x))
        }
        
        $this._cachedHeader = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Build cached separator line
    hidden [void] BuildCachedSeparator([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedSeparator) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $sb.Append("" * $width)
                $x += $width
                
                # Add intersection after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append("" * ($contentWidth - $x))
        }
        
        $this._cachedSeparator = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Ensure selected item is visible
    hidden [void] EnsureVisible() {
        if ($this.Items.Count -eq 0) { return }
        
        $contentHeight = $this.Height - 2  # Account for borders
        if ($this.ShowHeader) { 
            $contentHeight -= 2  # Header + separator line
        }
        
        # Account for row separators
        if ($this.ShowGridLines) {
            $contentHeight = [Math]::Floor($contentHeight / 2)  # Each row takes 2 lines with separator
        }
        
        # Scroll up if selected is above visible area
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        # Scroll down if selected is below visible area
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $contentHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Ensure scroll offset is valid
        $maxScroll = [Math]::Max(0, $this.Items.Count - $contentHeight)
        $this.ScrollOffset = [Math]::Max(0, [Math]::Min($this.ScrollOffset, $maxScroll))
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096  # Larger size for grid with separators
        
        # Calculate content area
        $contentX = $this.X + 1
        $contentY = $this.Y + 1
        $contentWidth = $this.Width - 2
        $contentHeight = $this.Height - 2
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $borderColor = if ($this.IsFocused) { 
                $this.Theme.GetColor("border.focused") 
            } else { 
                $this.Theme.GetColor("border") 
            }
            
            # Top border with title
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL())
            
            if ($this.Title) {
                $titleText = " $($this.Title) "
                $titleLen = $titleText.Length
                $borderLen = $this.Width - 2
                $leftPad = [int](($borderLen - $titleLen) / 2)
                
                if ($leftPad -gt 0) {
                    $sb.Append([VT]::H() * $leftPad)
                }
                $sb.Append($this.Theme.GetColor("accent"))
                $sb.Append($titleText)
                $sb.Append($borderColor)
                $remainingBorder = [Math]::Max(0, $borderLen - $leftPad - $titleLen)
                if ($remainingBorder -gt 0) {
                    $sb.Append([VT]::H() * $remainingBorder)
                }
            } else {
                $topBorderWidth = [Math]::Max(0, $this.Width - 2)
                if ($topBorderWidth -gt 0) {
                    $sb.Append([VT]::H() * $topBorderWidth)
                }
            }
            
            $sb.Append([VT]::TR())
            
            # Side borders
            for ($i = 1; $i -lt $this.Height - 1; $i++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i))
                $sb.Append([VT]::V())
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
            $sb.Append([VT]::BL())
            $bottomBorderWidth = [Math]::Max(0, $this.Width - 2)
            if ($bottomBorderWidth -gt 0) {
                $sb.Append([VT]::H() * $bottomBorderWidth)
            }
            $sb.Append([VT]::BR())
            $sb.Append([VT]::Reset())
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
            $contentHeight = $this.Height
        }
        
        # Calculate column widths
        $this.CalculateColumnWidths($contentWidth)
        
        # Clear content area
        $bgColor = $this.Theme.GetBgColor("background")
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $sb.Append([VT]::MoveTo($contentX, $contentY + $y))
            $sb.Append($bgColor)
            $sb.Append(" " * $contentWidth)
        }
        
        $currentY = $contentY
        $dataStartY = $currentY
        
        # Render header if enabled
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            # Build cached header
            $this.BuildCachedHeader($contentWidth)
            
            # Render header
            $sb.Append([VT]::MoveTo($contentX, $currentY))
            $sb.Append($this.Theme.GetBgColor("header.background"))
            $sb.Append($this.Theme.GetColor("header.foreground"))
            $sb.Append($this._cachedHeader)
            $sb.Append([VT]::Reset())
            $currentY++
            
            # Render header separator line
            if ($this.ShowGridLines) {
                $this.BuildCachedSeparator($contentWidth)
                $sb.Append([VT]::MoveTo($contentX, $currentY))
                $sb.Append($this.Theme.GetColor("border"))
                $sb.Append($this._cachedSeparator)
                $sb.Append([VT]::Reset())
                $currentY++
            }
            
            $dataStartY = $currentY
            $contentHeight = $this.Height - 2 - ($currentY - $contentY)
        }
        
        # Calculate visible rows (accounting for separators)
        $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
        $maxVisibleRows = [Math]::Floor($contentHeight / $rowHeight)
        $visibleRows = [Math]::Min($maxVisibleRows, $this.Items.Count - $this.ScrollOffset)
        
        # Render data rows
        for ($i = 0; $i -lt $visibleRows; $i++) {
            $itemIndex = $this.ScrollOffset + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isSelected = ($itemIndex -eq $this.SelectedIndex)
            $rowY = $currentY + ($i * $rowHeight)
            
            # Render data row
            $sb.Append([VT]::MoveTo($contentX, $rowY))
            
            if ($isSelected) {
                $sb.Append($this.Theme.GetBgColor("selection"))
                $sb.Append($this.Theme.GetColor("foreground"))
            } else {
                $sb.Append($this.Theme.GetBgColor("background"))
                $sb.Append($this.Theme.GetColor("foreground"))
            }
            
            # Render columns
            $x = 0
            for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                $col = $this.Columns[$j]
                $width = $this._columnWidths[$col.Name]
                
                if ($x + $width -gt $contentWidth) {
                    $width = $contentWidth - $x
                }
                
                if ($width -gt 0) {
                    # Get value using property name or custom getter
                    $value = ""
                    if ($col.Getter) {
                        $value = & $col.Getter $item
                    } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                        $value = $item.($col.Name)
                    }
                    
                    # Apply formatter if provided
                    if ($col.Formatter) {
                        $value = & $col.Formatter $value
                    }
                    
                    # Convert to string and truncate if needed
                    $text = $value.ToString()
                    if ($text.Length -gt $width) {
                        $text = $text.Substring(0, $width - 1) + ""
                    } else {
                        $text = $text.PadRight($width)
                    }
                    
                    $sb.Append($text)
                    $x += $width
                    
                    # Add vertical separator after column (except last)
                    if ($this.ShowGridLines -and $j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                        if ($isSelected) {
                            # Keep selection colors for separator
                            $sb.Append("")
                        } else {
                            $sb.Append($this.Theme.GetColor("border"))
                            $sb.Append("")
                            $sb.Append($this.Theme.GetColor("foreground"))
                        }
                        $x++
                    }
                }
                
                if ($x -ge $contentWidth) { break }
            }
            
            # Fill remaining row space
            if ($x -lt $contentWidth) {
                $sb.Append(" " * ($contentWidth - $x))
            }
            
            # Render row separator (except after last visible row)
            if ($this.ShowGridLines -and $i -lt $visibleRows - 1) {
                $sb.Append([VT]::MoveTo($contentX, $rowY + 1))
                $sb.Append($this.Theme.GetColor("border"))
                
                $x = 0
                for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                    $col = $this.Columns[$j]
                    $width = $this._columnWidths[$col.Name]
                    
                    if ($x + $width -gt $contentWidth) {
                        $width = $contentWidth - $x
                    }
                    
                    if ($width -gt 0) {
                        $sb.Append("" * $width)
                        $x += $width
                        
                        # Add intersection
                        if ($j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                            $sb.Append("")
                            $x++
                        }
                    }
                    
                    if ($x -ge $contentWidth) { break }
                }
                
                # Fill remaining separator
                if ($x -lt $contentWidth) {
                    $sb.Append("" * ($contentWidth - $x))
                }
                $sb.Append([VT]::Reset())
            }
        }
        
        # Show scroll indicator
        if ($this.Items.Count -gt $maxVisibleRows) {
            $scrollBarX = $this.X + $this.Width - 1
            $scrollBarHeight = $contentHeight
            $scrollThumbSize = [Math]::Max(1, [int]($scrollBarHeight * $maxVisibleRows / $this.Items.Count))
            $scrollThumbPos = [int]($this.ScrollOffset * ($scrollBarHeight - $scrollThumbSize) / ($this.Items.Count - $maxVisibleRows))
            
            $sb.Append($this.Theme.GetColor("scrollbar"))
            for ($i = 0; $i -lt $scrollBarHeight; $i++) {
                $sb.Append([VT]::MoveTo($scrollBarX, $dataStartY + $i))
                if ($i -ge $scrollThumbPos -and $i -lt ($scrollThumbPos + $scrollThumbSize)) {
                    $sb.Append("")
                } else {
                    $sb.Append("")
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsFocused -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.EnsureVisible()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        # Invalidate layout cache when bounds change
        if ($this.Width -ne $this._lastWidth) {
            $this._layoutCacheValid = $false
        }
        ([UIElement]$this).OnBoundsChanged()
    }
}


####\Components/DockPanel.ps1
# DockPanel.ps1 - Dock-based layout container
# Allows children to be docked to Top, Bottom, Left, Right, or Fill remaining space

enum DockPosition {
    Top
    Bottom
    Left
    Right
    Fill
}

class DockPanel : Container {
    [bool]$LastChildFill = $true
    [int]$DockSpacing = 0
    
    # Layout caching for performance
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastChildCount = 0
    
    # Available content area after docking
    hidden [int]$_contentX = 0
    hidden [int]$_contentY = 0  
    hidden [int]$_contentWidth = 0
    hidden [int]$_contentHeight = 0
    
    DockPanel() : base() {
        # DockPanel manages its own layout
    }
    
    [void] SetChildDock([UIElement]$child, [DockPosition]$position) {
        # Add custom property to track dock position
        $child | Add-Member -MemberType NoteProperty -Name "DockPosition" -Value $position -Force
        $this.InvalidateLayout()
    }
    
    [void] SetChildHeight([UIElement]$child, [int]$height) {
        # Add custom property to track fixed height
        $child | Add-Member -MemberType NoteProperty -Name "FixedHeight" -Value $height -Force
        $child.Height = $height
        $this.InvalidateLayout()
    }
    
    [void] SetChildWidth([UIElement]$child, [int]$width) {
        # Add custom property to track fixed width
        $child | Add-Member -MemberType NoteProperty -Name "FixedWidth" -Value $width -Force
        $child.Width = $width
        $this.InvalidateLayout()
    }
    
    [DockPosition] GetChildDock([UIElement]$child) {
        if ($child.PSObject.Properties["DockPosition"]) {
            return $child.DockPosition
        }
        return [DockPosition]::Fill
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        ([Container]$this).OnBoundsChanged()
    }
    
    [void] AddChild([UIElement]$child) {
        ([Container]$this).AddChild($child)
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        ([Container]$this).RemoveChild($child)
        $this.InvalidateLayout()
    }
    
    [void] UpdateLayout() {
        # Check if layout needs updating
        if (-not $this._layoutInvalid -and 
            $this.Width -eq $this._lastWidth -and 
            $this.Height -eq $this._lastHeight -and 
            $this.Children.Count -eq $this._lastChildCount) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Recalculating layout for $($this.Children.Count) children")
        }
        
        # Initialize available area (full container minus any padding)
        $availableX = $this.X
        $availableY = $this.Y
        $availableWidth = $this.Width
        $availableHeight = $this.Height
        
        # Group children by dock position
        $topChildren = @()
        $bottomChildren = @()
        $leftChildren = @()
        $rightChildren = @()
        $fillChild = $null
        
        foreach ($child in $this.Children) {
            if (-not $child.Visible) { continue }
            
            $dock = $this.GetChildDock($child)
            switch ($dock) {
                ([DockPosition]::Top) { $topChildren += $child }
                ([DockPosition]::Bottom) { $bottomChildren += $child }
                ([DockPosition]::Left) { $leftChildren += $child }
                ([DockPosition]::Right) { $rightChildren += $child }
                ([DockPosition]::Fill) { $fillChild = $child }
            }
        }
        
        # Process docked children in order: Top, Bottom, Left, Right
        
        # Top docked children
        foreach ($child in $topChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $child.SetBounds($availableX, $availableY, $availableWidth, $childHeight)
            $availableY += $childHeight + $this.DockSpacing
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Bottom docked children
        foreach ($child in $bottomChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $childY = $availableY + $availableHeight - $childHeight
            $child.SetBounds($availableX, $childY, $availableWidth, $childHeight)
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Left docked children  
        foreach ($child in $leftChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $child.SetBounds($availableX, $availableY, $childWidth, $availableHeight)
            $availableX += $childWidth + $this.DockSpacing
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Right docked children
        foreach ($child in $rightChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $childX = $availableX + $availableWidth - $childWidth
            $child.SetBounds($childX, $availableY, $childWidth, $availableHeight)
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Fill remaining space with fill child (if LastChildFill is enabled and we have one)
        if ($this.LastChildFill -and $fillChild) {
            # Ensure minimum size
            $fillWidth = [Math]::Max(0, $availableWidth)
            $fillHeight = [Math]::Max(0, $availableHeight)
            $fillChild.SetBounds($availableX, $availableY, $fillWidth, $fillHeight)
        }
        
        # Cache current state
        $this._contentX = $availableX
        $this._contentY = $availableY
        $this._contentWidth = $availableWidth
        $this._contentHeight = $availableHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Layout complete. Content area: ($availableX,$availableY) ${availableWidth}x$availableHeight")
        }
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering - render all visible children
        $sb = [System.Text.StringBuilder]::new()
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child first
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [hashtable] GetContentArea() {
        $this.UpdateLayout()
        return @{
            X = $this._contentX
            Y = $this._contentY
            Width = $this._contentWidth
            Height = $this._contentHeight
        }
    }
    
    # Convenience methods for setting dock positions
    [void] DockTop([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Top) }
    [void] DockBottom([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Bottom) }
    [void] DockLeft([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Left) }
    [void] DockRight([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Right) }
    [void] DockFill([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Fill) }
}


####\Components/FastFileTree.ps1
# FastFileTree.ps1 - High-performance file system browser based on ALCAR patterns
# Fast string-based rendering with directory caching and lazy loading

class FileSystemNode {
    [string]$Name
    [string]$FullPath
    [bool]$IsDirectory
    [long]$Size
    [datetime]$LastModified
    [bool]$IsExpanded = $false
    [System.Collections.ArrayList]$Children
    [FileSystemNode]$Parent
    [int]$Level = 0
    [bool]$IsLoaded = $false
    [bool]$HasChildren = $false
    
    FileSystemNode([string]$fullPath) {
        $this.FullPath = $fullPath
        $this.Name = Split-Path $fullPath -Leaf
        $this.Children = [System.Collections.ArrayList]::new()
        
        if (Test-Path $fullPath) {
            $item = Get-Item $fullPath -ErrorAction SilentlyContinue
            if ($item) {
                $this.IsDirectory = $item.PSIsContainer
                $this.Size = if (-not $this.IsDirectory -and $item.Length) { $item.Length } else { 0 }
                $this.LastModified = $item.LastWriteTime
                
                # Check if directory has children without loading them
                if ($this.IsDirectory) {
                    try {
                        $hasItems = Get-ChildItem $fullPath -Force -ErrorAction Stop | Select-Object -First 1
                        $this.HasChildren = $hasItems -ne $null
                    } catch {
                        $this.HasChildren = $false
                    }
                }
            }
        }
    }
    
    [void] LoadChildren() {
        if ($this.IsLoaded -or -not $this.IsDirectory) {
            return
        }
        
        try {
            $items = Get-ChildItem $this.FullPath -Force -ErrorAction Stop | Sort-Object @{Expression={$_.PSIsContainer}; Descending=$true}, Name
            
            $this.Children.Clear()
            foreach ($item in $items) {
                $child = [FileSystemNode]::new($item.FullName)
                $child.Parent = $this
                $child.Level = $this.Level + 1
                $this.Children.Add($child) | Out-Null
            }
            
            $this.IsLoaded = $true
            $this.HasChildren = $this.Children.Count -gt 0
            
        } catch {
            # Access denied or other error - mark as loaded but empty
            $this.IsLoaded = $true
            $this.HasChildren = $false
        }
    }
    
    [string] GetIcon() {
        if ($this.IsDirectory) {
            if ($this.IsExpanded) { 
                return "" 
            } else { 
                return "" 
            }
        }
        
        # File type icons based on extension
        $ext = [System.IO.Path]::GetExtension($this.Name).ToLower()
        switch ($ext) {
            ".ps1" { return "" }
            ".txt" { return "" }
            ".log" { return "" }
            ".json" { return "" }
            ".xml" { return "" }
            ".md" { return "" }
            ".zip" { return "" }
            ".exe" { return "" }
            ".dll" { return "" }
            ".png" { return "" }
            ".jpg" { return "" }
            ".gif" { return "" }
            default { return "" }
        }
        return ""  # Fallback
    }
    
    [string] GetSizeString() {
        if ($this.IsDirectory) {
            return ""
        }
        
        if ($this.Size -lt 1KB) {
            return "$($this.Size) B"
        } elseif ($this.Size -lt 1MB) {
            return "$([math]::Round($this.Size / 1KB, 1)) KB"
        } elseif ($this.Size -lt 1GB) {
            return "$([math]::Round($this.Size / 1MB, 1)) MB"
        } else {
            return "$([math]::Round($this.Size / 1GB, 2)) GB"
        }
    }
}

class FastFileTree : UIElement {
    [string]$RootPath = ""
    [FileSystemNode]$RootNode
    [System.Collections.ArrayList]$_flatView
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = "File Browser"
    [bool]$ShowSize = $true
    [bool]$ShowModified = $false
    [string]$Filter = "*"
    
    # Events
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnFileSelected = {}
    [scriptblock]$OnDirectoryChanged = {}
    
    # Visual settings
    [int]$IndentSize = 2
    [string]$ExpandedIcon = ""
    [string]$CollapsedIcon = ""
    
    hidden [ThemeManager]$Theme
    hidden [int]$_lastSelectedIndex = -1
    hidden [System.Collections.Generic.HashSet[string]]$_expandedPaths
    
    FastFileTree() : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        
        # Default to current directory
        $this.RootPath = $PWD.Path
    }
    
    FastFileTree([string]$rootPath) : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        $this.RootPath = $rootPath
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        $this.LoadDirectory($this.RootPath)
    }
    
    [void] OnThemeChanged() {
        $this.Invalidate()
    }
    
    
    # Public API
    [void] LoadDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        try {
            $this.RootPath = Resolve-Path $path
            $this.RootNode = [FileSystemNode]::new($this.RootPath)
            $this.RootNode.IsExpanded = $true
            $this.RootNode.LoadChildren()
            
            # Auto-expand remembered paths
            $this.RestoreExpandedState()
            
            $this.RebuildFlatView()
            $this.SelectedIndex = 0
            $this.ScrollOffset = 0
            $this.Invalidate()
            
            # Fire directory changed event
            if ($this.OnDirectoryChanged) {
                & $this.OnDirectoryChanged $this.RootPath
            }
            
        } catch {
            # Handle errors - could show in status or log
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Error("FastFileTree: Failed to load directory '$path': $($_.Exception.Message)")
            }
        }
    }
    
    [void] NavigateUp() {
        $parentPath = Split-Path $this.RootPath -Parent
        if ($parentPath -and (Test-Path $parentPath)) {
            $this.LoadDirectory($parentPath)
        }
    }
    
    [void] NavigateToSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory) {
            $this.LoadDirectory($selected.FullPath)
        }
    }
    
    [FileSystemNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] ExpandSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and -not $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] CollapseSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] ToggleExpanded([FileSystemNode]$node) {
        if (-not $node.IsDirectory) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        
        if ($node.IsExpanded) {
            $node.LoadChildren()
            $this._expandedPaths.Add($node.FullPath) | Out-Null
        } else {
            $this._expandedPaths.Remove($node.FullPath) | Out-Null
        }
        
        $this.RebuildFlatView()
        
        # Try to keep selection on the same node
        $this.SetSelectedNode($node)
        $this.Invalidate()
    }
    
    [void] SetSelectedNode([FileSystemNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].FullPath -eq $node.FullPath) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex) {
                if ($this.OnSelectionChanged) {
                    & $this.OnSelectionChanged
                }
            }
            
            $this.Invalidate()
        }
    }
    
    [void] RefreshCurrent() {
        # Save current selection
        $selectedPath = $null
        $selected = $this.GetSelectedNode()
        if ($selected) {
            $selectedPath = $selected.FullPath
        }
        
        # Reload directory
        $this.LoadDirectory($this.RootPath)
        
        # Restore selection if possible
        if ($selectedPath) {
            for ($i = 0; $i -lt $this._flatView.Count; $i++) {
                if ($this._flatView[$i].FullPath -eq $selectedPath) {
                    $this.SelectIndex($i)
                    break
                }
            }
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        if ($this.RootNode) {
            $this.AddNodeToFlatView($this.RootNode)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([FileSystemNode]$node) {
        # Apply filter for non-directories
        if (-not $node.IsDirectory -and $this.Filter -ne "*") {
            if (-not ($node.Name -like $this.Filter)) {
                return
            }
        }
        
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] RestoreExpandedState() {
        if ($this.RootNode) {
            $this.RestoreExpandedStateRecursive($this.RootNode)
        }
    }
    
    [void] RestoreExpandedStateRecursive([FileSystemNode]$node) {
        if ($this._expandedPaths.Contains($node.FullPath)) {
            $node.IsExpanded = $true
            $node.LoadChildren()
        }
        
        foreach ($child in $node.Children) {
            $this.RestoreExpandedStateRecursive($child)
        }
    }
    
    [void] EnsureVisible() {
        # Calculate visible lines based on current dimensions
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        $borderReduction = $effectiveShowBorder ? 2 : 0
        $titleReduction = ($this.Title -and $this.Height -gt $borderReduction) ? 1 : 0
        $visibleLines = [Math]::Max(0, $this.Height - $borderReduction - $titleReduction)
        
        if ($visibleLines -gt 0) {
            if ($this.SelectedIndex -lt $this.ScrollOffset) {
                $this.ScrollOffset = $this.SelectedIndex
            } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
                $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
            }
            
            $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
        }
    }
    
    # Rendering
    [string] OnRender() {
        return $this.BuildRenderString()
    }
    
    [string] BuildRenderString() {
        # Validate dimensions before rendering
        if ($this.Width -le 0 -or $this.Height -le 0) {
            return ""
        }
        
        # Disable border if dimensions are too small
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        
        # Use StringBuilder pool if available, otherwise create new
        $sb = $null
        if (Get-Command -Name 'Get-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            $sb = Get-PooledStringBuilder 4096  # File trees can be quite large
        } else {
            $sb = [System.Text.StringBuilder]::new(4096)
        }
        
        # Colors
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("border") } else { "" }
        $titleColor = if ($this.Theme) { $this.Theme.GetColor("title") } else { "" }
        $selectedBg = if ($this.Theme) { $this.Theme.GetBgColor("selection") } else { "" }
        $normalColor = if ($this.Theme) { $this.Theme.GetColor("normal") } else { "" }
        $directoryColor = if ($this.Theme) { $this.Theme.GetColor("directory") } else { $normalColor }
        $fileColor = if ($this.Theme) { $this.Theme.GetColor("file") } else { $normalColor }
        $focusBorder = if ($this.Theme) { $this.Theme.GetColor("border.focused") } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area with proper bounds checking
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($effectiveShowBorder ? 2 : 0)
        
        # Ensure content width is never negative
        if ($contentWidth -lt 0) {
            $contentWidth = 0
        }
        
        if ($effectiveShowBorder) {
            # Top border - safe to render since we validated Width >= 3
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title -and $contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                if ($titleText.Length -gt $contentWidth) {
                    $titleText = "..." + $titleText.Substring($titleText.Length - $contentWidth + 3)
                }
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title -and $this.Width -gt 0) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render file/directory entries
        $visibleLines = $contentHeight - ($effectiveShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
            
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                }
                
                # Build display line
                $line = ""
                
                # Indentation
                $line += " " * ($node.Level * $this.IndentSize)
                
                # Expand/collapse icon for directories
                if ($node.IsDirectory -and $node.HasChildren) {
                    $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
                } else {
                    $line += "  "  # Space for alignment
                }
                
                # File/directory icon
                $line += $node.GetIcon() + " "
                
                # Name
                $line += $node.Name
                
                # Size (for files, if enabled)
                if ($this.ShowSize -and -not $node.IsDirectory) {
                    $sizeStr = $node.GetSizeString()
                    if ($sizeStr) {
                        $line += " ($sizeStr)"
                    }
                }
                
                # Pad and truncate to fit
                $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
                
                # Apply appropriate color and render line
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                if ($i -eq $this.SelectedIndex) {
                    # Selected item - use selection colors
                    $sb.Append($selectedBg)
                    $foregroundColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
                    $sb.Append($foregroundColor)
                } else {
                    # Normal item - directory or file color with normal background
                    $normalBg = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
                    $sb.Append($normalBg)
                    $color = if ($node.IsDirectory) { $directoryColor } else { $fileColor }
                    $sb.Append($color)
                }
                $sb.Append($line)
            }
            
            # Side borders
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append(" ".PadRight($contentWidth))
            }
            
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($effectiveShowBorder) {
            # Bottom border - safe to render since we validated Width >= 3
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        if (Get-Command -Name 'Return-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            Return-PooledStringBuilder $sb  # Return to pool for reuse
        }
        return $result
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.GetSelectedNode()
                if ($selected) {
                    if ($selected.IsDirectory) {
                        if ($selected.HasChildren) {
                            $this.ToggleExpanded($selected)
                        } else {
                            $this.LoadDirectory($selected.FullPath)
                        }
                    } else {
                        # Fire file selected event
                        if ($this.OnFileSelected) {
                            & $this.OnFileSelected $selected
                        }
                    }
                }
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                $selected = $this.GetSelectedNode()
                if ($selected -and $selected.IsDirectory -and $selected.HasChildren) {
                    $this.ToggleExpanded($selected)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Backspace) {
                $this.NavigateUp()
                $handled = $true
            }
            ([System.ConsoleKey]::F5) {
                $this.RefreshCurrent()
                $handled = $true
            }
        }
        
        # Handle character keys for quick navigation
        if (-not $handled -and $key.KeyChar -ge 'A' -and $key.KeyChar -le 'z') {
            $this.QuickNavigate($key.KeyChar)
            $handled = $true
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] QuickNavigate([char]$char) {
        $startIndex = ($this.SelectedIndex + 1) % $this._flatView.Count
        
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            $index = ($startIndex + $i) % $this._flatView.Count
            $node = $this._flatView[$index]
            
            if ($node.Name.Length -gt 0 -and [char]::ToLower($node.Name[0]) -eq [char]::ToLower($char)) {
                $this.SelectIndex($index)
                break
            }
        }
    }
    
    [void] OnGotFocus() {
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this.Invalidate()
    }
}


####\Components/GridPanel.ps1
# GridPanel.ps1 - Fast grid layout component for PRAXIS

class GridPanel : Container {
    [int]$Columns = 2
    [int]$Rows = 0  # Auto-calculated if 0
    [int]$CellSpacing = 1
    [int]$MinCellWidth = 5
    [int]$MinCellHeight = 2
    [bool]$ShowBorder = $false
    [bool]$AutoSize = $true  # Auto-calculate rows based on children
    
    # Cached layout calculations
    hidden [int]$_cachedCellWidth = 0
    hidden [int]$_cachedCellHeight = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastColumns = 0
    hidden [int]$_lastChildCount = 0
    
    GridPanel() : base() {
        $this.DrawBackground = $false
    }
    
    GridPanel([int]$columns) : base() {
        $this.Columns = [Math]::Max(1, $columns)
        $this.DrawBackground = $false
    }
    
    [void] SetGridSize([int]$columns, [int]$rows) {
        $this.Columns = [Math]::Max(1, $columns)
        $this.Rows = [Math]::Max(0, $rows)
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] AddChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).AddChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).RemoveChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastHeight -eq $this.Height -and
            $this._lastColumns -eq $this.Columns -and
            $this._lastChildCount -eq $this.Children.Count) {
            return  # Layout is still valid
        }
        
        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) {
            $this._layoutInvalid = $false
            return
        }
        
        # Calculate grid dimensions
        $cols = $this.Columns
        $actualRows = if ($this.AutoSize) {
            [Math]::Ceiling($visibleChildren.Count / $cols)
        } else {
            [Math]::Max(1, $this.Rows)
        }
        
        # Calculate cell dimensions
        $totalSpacingWidth = ($cols - 1) * $this.CellSpacing
        $totalSpacingHeight = ($actualRows - 1) * $this.CellSpacing
        
        $cellWidth = [Math]::Max($this.MinCellWidth, 
            [int](($this.Width - $totalSpacingWidth) / $cols))
        $cellHeight = [Math]::Max($this.MinCellHeight, 
            [int](($this.Height - $totalSpacingHeight) / $actualRows))
        
        # Position children in grid
        for ($i = 0; $i -lt $visibleChildren.Count; $i++) {
            $child = $visibleChildren[$i]
            $col = $i % $cols
            $row = [int]($i / $cols)
            
            # Calculate position
            $childX = $this.X + ($col * ($cellWidth + $this.CellSpacing))
            $childY = $this.Y + ($row * ($cellHeight + $this.CellSpacing))
            
            # Set child bounds
            $child.SetBounds($childX, $childY, $cellWidth, $cellHeight)
        }
        
        # Cache the layout
        $this._cachedCellWidth = $cellWidth
        $this._cachedCellHeight = $cellHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastColumns = $this.Columns
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = [System.Text.StringBuilder]::new()
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        # Optional: render grid borders
        if ($this.ShowBorder -and $this._cachedCellWidth -gt 0) {
            $borderColor = $this.Theme.GetColor("border")
            $sb.Append($borderColor)
            
            # Draw grid lines (simplified - just basic grid)
            $cols = $this.Columns
            $actualRows = if ($this.AutoSize) {
                [Math]::Ceiling($this.Children.Count / $cols)
            } else {
                $this.Rows
            }
            
            # Vertical lines
            for ($col = 1; $col -lt $cols; $col++) {
                $lineX = $this.X + ($col * ($this._cachedCellWidth + $this.CellSpacing)) - 1
                for ($y = 0; $y -lt $this.Height; $y++) {
                    $sb.Append([VT]::MoveTo($lineX, $this.Y + $y))
                    $sb.Append("")
                }
            }
            
            # Horizontal lines
            for ($row = 1; $row -lt $actualRows; $row++) {
                $lineY = $this.Y + ($row * ($this._cachedCellHeight + $this.CellSpacing)) - 1
                $sb.Append([VT]::MoveTo($this.X, $lineY))
                $sb.Append("" * $this.Width)
            }
            
            $sb.Append([VT]::Reset())
        }
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [int] GetCellWidth() { return $this._cachedCellWidth }
    [int] GetCellHeight() { return $this._cachedCellHeight }
    
    # Get child at grid position
    [UIElement] GetChildAt([int]$col, [int]$row) {
        $index = ($row * $this.Columns) + $col
        if ($index -ge 0 -and $index -lt $this.Children.Count) {
            return $this.Children[$index]
        }
        return $null
    }
    
    # Focus management with grid navigation
    [void] FocusCell([int]$col, [int]$row) {
        $child = $this.GetChildAt($col, $row)
        if ($child -and $child.IsFocusable) {
            $child.Focus()
        }
    }
}


####\Components/HorizontalSplit.ps1
# HorizontalSplit.ps1 - Fast horizontal layout component for PRAXIS

class HorizontalSplit : Container {
    [UIElement]$LeftPane
    [UIElement]$RightPane
    [int]$SplitRatio = 50  # Percentage for left pane (0-100)
    [int]$MinPaneWidth = 5
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedLeftWidth = 0
    hidden [int]$_cachedRightWidth = 0
    hidden [int]$_cachedRightX = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastSplitRatio = 0
    
    HorizontalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] SetLeftPane([UIElement]$pane) {
        if ($this.LeftPane) {
            $this.RemoveChild($this.LeftPane)
        }
        $this.LeftPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetRightPane([UIElement]$pane) {
        if ($this.RightPane) {
            $this.RemoveChild($this.RightPane)
        }
        $this.RightPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalWidth = $this.Width
        $leftWidth = [int](($totalWidth * $this.SplitRatio) / 100)
        $leftWidth = [Math]::Max($this.MinPaneWidth, [Math]::Min($leftWidth, $totalWidth - $this.MinPaneWidth))
        $rightWidth = $totalWidth - $leftWidth
        $rightX = $this.X + $leftWidth
        
        # Update left pane
        if ($this.LeftPane) {
            $this.LeftPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        }
        
        # Update right pane
        if ($this.RightPane) {
            $this.RightPane.SetBounds($rightX, $this.Y, $rightWidth, $this.Height)
        }
        
        # Cache the layout
        $this._cachedLeftWidth = $leftWidth
        $this._cachedRightWidth = $rightWidth
        $this._cachedRightX = $rightX
        $this._lastWidth = $this.Width
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = [System.Text.StringBuilder]::new()
        
        # Render children
        if ($this.LeftPane -and $this.LeftPane.Visible) {
            $sb.Append($this.LeftPane.Render())
        }
        
        if ($this.RightPane -and $this.RightPane.Visible) {
            $sb.Append($this.RightPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedLeftWidth -gt 0) {
            $borderColor = $this.Theme.GetColor("border")
            for ($y = 0; $y -lt $this.Height; $y++) {
                $sb.Append([VT]::MoveTo($this._cachedRightX - 1, $this.Y + $y))
                $sb.Append($borderColor)
                $sb.Append("")
            }
            $sb.Append([VT]::Reset())
        }
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.LeftPane -and $this.LeftPane.IsFocused) {
            if ($this.LeftPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.RightPane -and $this.RightPane.IsFocused) {
            if ($this.RightPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetLeftFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetRightFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetLeftPane() { return $this.LeftPane }
    [UIElement] GetRightPane() { return $this.RightPane }
    
    # Focus management
    [void] FocusLeftPane() {
        if ($this.LeftPane -and $this.LeftPane.IsFocusable) {
            $this.LeftPane.Focus()
        }
    }
    
    [void] FocusRightPane() {
        if ($this.RightPane -and $this.RightPane.IsFocusable) {
            $this.RightPane.Focus()
        }
    }
}


####\Components/ListBox.ps1
# ListBox.ps1 - Fast list box component with selection and scrolling

class ListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [int]$VisibleItems = 10
    [bool]$ShowBorder = $true
    [bool]$ShowScrollbar = $true
    
    # Display properties
    [scriptblock]$ItemRenderer = { param($item) $item.ToString() }
    [string]$Title = ""
    
    # Callback for selection changes
    [scriptblock]$OnSelectionChanged = {}
    
    # Cached rendering
    hidden [string]$_cachedItems = ""
    hidden [bool]$_itemsCacheInvalid = $true
    hidden [ThemeManager]$Theme
    
    ListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] SetItems([array]$items) {
        $oldIndex = $this.SelectedIndex
        $this.Items.Clear()
        $this.Items.AddRange($items)
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
        
        # Trigger callback if we have items and the selection changed
        if ($this.Items.Count -gt 0 -and ($oldIndex -ne 0 -or $this.Items.Count -eq 1) -and $this.OnSelectionChanged) {
            try {
                & $this.OnSelectionChanged
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("ListBox.SetItems: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                }
            }
        }
    }
    
    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible($index)
            $this._itemsCacheInvalid = $true
            $this.Invalidate()
            
            # Trigger callback if selection actually changed
            if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
                try {
                    & $this.OnSelectionChanged
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ListBox.SelectIndex: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                    }
                }
            }
        }
    }
    
    [void] EnsureVisible([int]$index) {
        # Adjust scroll to keep selected item visible
        $visibleEnd = $this.ScrollOffset + $this.VisibleItems - 1
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        } elseif ($index -gt $visibleEnd) {
            $this.ScrollOffset = $index - $this.VisibleItems + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # Recalculate visible items based on height
        $contentHeight = $this.Height
        if ($this.ShowBorder) { $contentHeight -= 2 }
        if ($this.Title) { $contentHeight -= 1 }
        
        $this.VisibleItems = [Math]::Max(1, $contentHeight)
        $this._itemsCacheInvalid = $true
    }
    
    [string] OnRender() {
        if ($this._itemsCacheInvalid) {
            $this.RebuildItemsCache()
        }
        return $this._cachedItems
    }
    
    [void] RebuildItemsCache() {
        $sb = Get-PooledStringBuilder 2048  # ListBox can have many items
        
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($sb)
            $contentX++
            $contentY++
            $contentWidth -= 2
        }
        
        # Draw title if present
        if ($this.Title) {
            $sb.Append([VT]::MoveTo($contentX, $contentY))
            $sb.Append($this.Theme.GetColor("accent"))
            $titleText = $this.Title
            if ($titleText.Length -gt $contentWidth) {
                $titleText = $titleText.Substring(0, $contentWidth - 3) + "..."
            }
            $sb.Append($titleText)
            $sb.Append($this.Theme.GetColor("foreground"))
            $contentY++
        }
        
        # Draw items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        $itemY = $contentY
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $text = & $this.ItemRenderer $item
            
            # Truncate if too long
            if ($text.Length -gt $contentWidth - 2) {
                $text = $text.Substring(0, $contentWidth - 5) + "..."
            }
            
            $sb.Append([VT]::MoveTo($contentX, $itemY))
            
            # Selection highlighting
            if ($i -eq $this.SelectedIndex) {
                if ($this.IsFocused) {
                    $sb.Append($this.Theme.GetBgColor("selection"))
                    $sb.Append($this.Theme.GetColor("menu.selected.foreground"))
                } else {
                    $sb.Append($this.Theme.GetColor("disabled"))
                }
                $sb.Append("> ")
            } else {
                $sb.Append("  ")
            }
            
            $sb.Append($text)
            
            # Clear to end of line if selected
            if ($i -eq $this.SelectedIndex) {
                $remainingSpace = $contentWidth - $text.Length - 2
                if ($remainingSpace -gt 0) {
                    $sb.Append(" " * $remainingSpace)
                }
                $sb.Append([VT]::Reset())
            }
            
            $itemY++
        }
        
        # Draw scrollbar if enabled and needed
        if ($this.ShowScrollbar -and $this.Items.Count -gt $this.VisibleItems) {
            $this.DrawScrollbar($sb)
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedItems = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._itemsCacheInvalid = $false
    }
    
    [void] DrawBorder([System.Text.StringBuilder]$sb) {
        $borderColor = if ($this.IsFocused) { 
            $this.Theme.GetColor("border.focused") 
        } else { 
            $this.Theme.GetColor("border") 
        }
        
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
        
        # Side borders
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        $sb.Append([VT]::Reset())
    }
    
    [void] DrawScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        if ($this.ShowBorder) { $scrollbarX-- }
        
        $scrollbarY = $this.Y + 1
        if ($this.ShowBorder) { $scrollbarY++ }
        if ($this.Title) { $scrollbarY++ }
        
        $scrollbarHeight = $this.VisibleItems
        
        # Calculate thumb position and size
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $this.VisibleItems / $this.Items.Count))
        $thumbPos = [int]($scrollbarY + ($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $this.VisibleItems))
        
        # Draw scrollbar track and thumb
        for ($y = $scrollbarY; $y -lt $scrollbarY + $scrollbarHeight; $y++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $y))
            
            if ($y -ge $thumbPos -and $y -lt $thumbPos + $thumbSize) {
                $sb.Append($this.Theme.GetColor("accent"))
                $sb.Append("")
            } else {
                $sb.Append($this.Theme.GetColor("border"))
                $sb.Append("")
            }
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $false
            
            switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectIndex($this.SelectedIndex - 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectIndex($this.SelectedIndex + 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $newIndex = [Math]::Max(0, $this.SelectedIndex - $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $newIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectIndex(0)
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectIndex($this.Items.Count - 1)
                $handled = $true
            }
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ListBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Focus handling
    [void] OnGotFocus() {
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
}


####\Components/MultiSelectListBox.ps1
# MultiSelectListBox.ps1 - ListBox with multiple selection support
# Supports checkboxes, range selection, and bulk operations

class MultiSelectListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    
    # Multi-selection settings
    [System.Collections.Generic.HashSet[int]]$SelectedIndices
    [bool]$ShowCheckboxes = $true
    [bool]$AllowRangeSelection = $true
    [bool]$AllowToggleAll = $true
    
    # Visual indicators
    [char]$CheckedIcon = [char]0x2611    # 
    [char]$UncheckedIcon = [char]0x2610  # 
    [char]$PartialIcon = [char]0x2612    # 
    
    # Selection state tracking
    hidden [int]$_lastSelectedIndex = -1  # For range selection
    hidden [bool]$_allSelected = $false
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    
    MultiSelectListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        $this.SelectedIndices.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._lastSelectedIndex = -1
        $this._allSelected = $false
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $indexToRemove = -1
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if ($this.Items[$i] -eq $item) {
                $indexToRemove = $i
                break
            }
        }
        
        if ($indexToRemove -ge 0) {
            $this.RemoveItemAt($indexToRemove)
        }
    }
    
    [void] RemoveItemAt([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.Items.RemoveAt($index)
            
            # Update selected indices
            $newSelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
            foreach ($selectedIndex in $this.SelectedIndices) {
                if ($selectedIndex -lt $index) {
                    $newSelectedIndices.Add($selectedIndex) | Out-Null
                } elseif ($selectedIndex -gt $index) {
                    $newSelectedIndices.Add($selectedIndex - 1) | Out-Null
                }
                # Skip the removed index
            }
            $this.SelectedIndices = $newSelectedIndices
            
            # Update current selection
            if ($this.SelectedIndex -eq $index) {
                $this.SelectedIndex = [Math]::Min($index, $this.Items.Count - 1)
            } elseif ($this.SelectedIndex -gt $index) {
                $this.SelectedIndex--
            }
            
            $this.EnsureSelectionValid()
            $this.UpdateAllSelectedState()
            $this.Invalidate()
        }
    }
    
    # Selection management
    [bool] IsSelected([int]$index) {
        return $this.SelectedIndices.Contains($index)
    }
    
    [void] SetSelected([int]$index, [bool]$selected) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($selected) {
                $this.SelectedIndices.Add($index) | Out-Null
            } else {
                $this.SelectedIndices.Remove($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] ToggleSelected([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($this.IsSelected($index)) {
                $this.SelectedIndices.Remove($index) | Out-Null
            } else {
                $this.SelectedIndices.Add($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] SelectRange([int]$startIndex, [int]$endIndex) {
        if (-not $this.AllowRangeSelection) {
            return
        }
        
        $start = [Math]::Min($startIndex, $endIndex)
        $end = [Math]::Max($startIndex, $endIndex)
        
        for ($i = $start; $i -le $end -and $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [void] SelectAll() {
        $this.SelectedIndices.Clear()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        $this._allSelected = $true
        $this.FireSelectionChanged()
    }
    
    [void] SelectNone() {
        $this.SelectedIndices.Clear()
        $this._allSelected = $false
        $this.FireSelectionChanged()
    }
    
    [void] InvertSelection() {
        $newSelected = [System.Collections.Generic.HashSet[int]]::new()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if (-not $this.IsSelected($i)) {
                $newSelected.Add($i) | Out-Null
            }
        }
        $this.SelectedIndices = $newSelected
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [System.Collections.ArrayList] GetSelectedItems() {
        $selectedItems = [System.Collections.ArrayList]::new()
        foreach ($index in $this.SelectedIndices) {
            if ($index -ge 0 -and $index -lt $this.Items.Count) {
                $selectedItems.Add($this.Items[$index]) | Out-Null
            }
        }
        return $selectedItems
    }
    
    [System.Collections.Generic.List[int]] GetSelectedIndicesList() {
        $result = [System.Collections.Generic.List[int]]::new()
        $sortedIndices = $this.SelectedIndices | Sort-Object
        foreach ($index in $sortedIndices) {
            $result.Add($index)
        }
        return $result
    }
    
    [int] GetSelectedCount() {
        return $this.SelectedIndices.Count
    }
    
    # Navigation
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            $this.Invalidate()
        }
    }
    
    # Internal methods
    [void] UpdateAllSelectedState() {
        $this._allSelected = ($this.SelectedIndices.Count -eq $this.Items.Count -and $this.Items.Count -gt 0)
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this.Items.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [void] FireSelectionChanged() {
        if ($this.OnSelectionChanged) {
            & $this.OnSelectionChanged
        }
        $this.Invalidate()
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Colors
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("border") } else { "" }
        $titleColor = if ($this.Theme) { $this.Theme.GetColor("title") } else { "" }
        $selectedBg = if ($this.Theme) { $this.Theme.GetBgColor("selected") } else { "" }
        $normalColor = if ($this.Theme) { $this.Theme.GetColor("normal") } else { "" }
        $checkboxColor = if ($this.Theme) { $this.Theme.GetColor("checkbox") } else { $normalColor }
        $selectedCheckboxColor = if ($this.Theme) { $this.Theme.GetColor("checkbox.selected") } else { "`e[38;2;0;255;0m" }
        $focusBorder = if ($this.Theme) { $this.Theme.GetColor("border.focused") } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title with selection info
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this.Items.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $y = $contentY + ($i - $startIndex)
            $isCurrentSelection = ($i -eq $this.SelectedIndex)
            $isSelected = $this.IsSelected($i)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for current item
            if ($isCurrentSelection) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Checkbox
            if ($this.ShowCheckboxes) {
                $checkboxIcon = if ($isSelected) { $this.CheckedIcon } else { $this.UncheckedIcon }
                $checkboxColorToUse = if ($isSelected) { $selectedCheckboxColor } else { $checkboxColor }
                
                $line += "$checkboxIcon "
            }
            
            # Item content
            $itemText = if ($this.ItemRenderer) {
                & $this.ItemRenderer $item
            } else {
                if ($item -eq $null) {
                    "<null>"
                } else {
                    $item.ToString()
                }
            }
            
            $line += $itemText
            
            # Adjust content width for checkbox
            $availableWidth = if ($this.ShowCheckboxes) { $contentWidth - 2 } else { $contentWidth }
            
            # Truncate if too long
            if ($line.Length -gt $availableWidth) {
                $line = $line.Substring(0, $availableWidth - 3) + "..."
            }
            
            # Pad to full width
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            # Side borders
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append(" ".PadRight($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldSelectedIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    
                    # Shift+Up for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    
                    # Shift+Down for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                # Toggle selection of current item
                $this.ToggleSelected($this.SelectedIndex)
                $this._lastSelectedIndex = $this.SelectedIndex
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                # Toggle selection and move down
                $this.ToggleSelected($this.SelectedIndex)
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
                $this._lastSelectedIndex = $this.SelectedIndex - 1
                $handled = $true
            }
        }
        
        # Keyboard shortcuts
        if (($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            switch ($key.Key) {
                ([System.ConsoleKey]::A) {
                    if ($this.AllowToggleAll) {
                        if ($this._allSelected) {
                            $this.SelectNone()
                        } else {
                            $this.SelectAll()
                        }
                    }
                    $handled = $true
                }
                ([System.ConsoleKey]::I) {
                    $this.InvertSelection()
                    $handled = $true
                }
                ([System.ConsoleKey]::D) {
                    $this.SelectNone()
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Update last selected index for range operations
            if (-not ($key.Modifiers -band [System.ConsoleModifiers]::Shift)) {
                $this._lastSelectedIndex = $this.SelectedIndex
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/ProgressBar.ps1
# ProgressBar.ps1 - Progress visualization component based on AxiomPhoenix patterns
# Fast string-based rendering with percentage and status text display

class ProgressBar : UIElement {
    [int]$Value = 0                    # Current progress (0-100)
    [int]$Maximum = 100               # Maximum value (default 100 for percentages)
    [string]$StatusText = ""          # Optional status text
    [bool]$ShowPercentage = $true     # Show percentage text
    [bool]$ShowBorder = $true         # Show border around progress bar
    [string]$Title = ""               # Optional title
    
    # Visual customization
    [char]$FilledChar = [char]0x2588  #  (full block)
    [char]$EmptyChar = [char]0x2591   #  (light shade)
    [string]$ProgressColor = ""       # Color for filled portion
    [string]$CompleteColor = ""       # Color when 100% complete
    [string]$TextColor = ""           # Color for percentage text
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_lastValue = -1      # For change detection
    hidden [string]$_lastStatusText = ""
    
    ProgressBar() : base() {
        $this.Height = 5  # Default height (border + bar + percentage + status + border)
        $this.Width = 40  # Default width
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Set theme colors
        if ($this.Theme) {
            if ([string]::IsNullOrEmpty($this.ProgressColor)) {
                $this.ProgressColor = $this.Theme.GetColor("progress.active")
            }
            if ([string]::IsNullOrEmpty($this.CompleteColor)) {
                $this.CompleteColor = $this.Theme.GetColor("progress.complete")
            }
            if ([string]::IsNullOrEmpty($this.TextColor)) {
                $this.TextColor = $this.Theme.GetColor("progress.text")
            }
        }
        
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [void] SetProgress([int]$value) {
        $this.SetProgress($value, $this.StatusText)
    }
    
    [void] SetProgress([int]$value, [string]$statusText) {
        # Clamp value to valid range
        $this.Value = [Math]::Max(0, [Math]::Min($this.Maximum, $value))
        $this.StatusText = $statusText
        
        # Only invalidate if something actually changed
        if ($this.Value -ne $this._lastValue -or $this.StatusText -ne $this._lastStatusText) {
            $this._lastValue = $this.Value
            $this._lastStatusText = $this.StatusText
            $this.Invalidate()
        }
    }
    
    [int] GetPercentage() {
        if ($this.Maximum -eq 0) {
            return 0
        }
        return [int](($this.Value * 100) / $this.Maximum)
    }
    
    [bool] IsComplete() {
        return $this.Value -ge $this.Maximum
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Colors
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("border") } else { "" }
        $titleColor = if ($this.Theme) { $this.Theme.GetColor("title") } else { "" }
        $normalColor = if ($this.Theme) { $this.Theme.GetColor("normal") } else { "" }
        
        # Determine progress color based on completion
        $currentProgressColor = if ($this.IsComplete()) { 
            if ([string]::IsNullOrEmpty($this.CompleteColor)) { $this.ProgressColor } else { $this.CompleteColor }
        } else { 
            $this.ProgressColor 
        }
        
        # Calculate dimensions
        $contentY = $this.Y
        $contentHeight = $this.Height
        $barWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($barWidth).Substring(0, $barWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Calculate bar dimensions
        $percentage = $this.GetPercentage()
        $filledWidth = if ($barWidth -gt 0) { [Math]::Floor($barWidth * $percentage / 100) } else { 0 }
        $emptyWidth = $barWidth - $filledWidth
        
        # Render progress bar
        $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
        
        # Filled portion
        if ($filledWidth -gt 0) {
            $sb.Append($currentProgressColor)
            $sb.Append([string]$this.FilledChar * $filledWidth)
        }
        
        # Empty portion  
        if ($emptyWidth -gt 0) {
            $sb.Append($normalColor)
            $sb.Append([string]$this.EmptyChar * $emptyWidth)
        }
        
        $contentY++
        $contentHeight--
        
        # Percentage text (centered)
        if ($this.ShowPercentage) {
            $percentText = "$percentage%"
            $textX = $this.X + ($this.Width - $percentText.Length) / 2
            $sb.Append([VT]::MoveTo([int]$textX, $contentY))
            $sb.Append($this.TextColor)
            $sb.Append($percentText)
            $contentY++
            $contentHeight--
        }
        
        # Status text (left-aligned, truncated if needed)
        if ($this.StatusText -and $contentHeight -gt ($this.ShowBorder ? 1 : 0)) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($normalColor)
            
            $statusWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
            if ($this.StatusText.Length -gt $statusWidth) {
                $truncated = $this.StatusText.Substring(0, $statusWidth - 3) + "..."
                $sb.Append($truncated)
            } else {
                $paddedStatus = $this.StatusText.PadRight($statusWidth).Substring(0, $statusWidth)
                $sb.Append($paddedStatus)
            }
            $contentY++
            $contentHeight--
        }
        
        # Side borders for remaining height
        if ($this.ShowBorder) {
            while ($contentHeight -gt 1) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $contentY++
                $contentHeight--
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
    }
    
    # Animation helper method (for future use)
    [void] AnimateTo([int]$targetValue, [int]$durationMs = 1000) {
        # Basic animation - could be enhanced with timer/events
        $startValue = $this.Value
        $steps = [Math]::Max(1, $durationMs / 50)  # 50ms per step
        $increment = ($targetValue - $startValue) / $steps
        
        for ($i = 0; $i -lt $steps; $i++) {
            $currentValue = $startValue + ($increment * ($i + 1))
            $this.SetProgress([int]$currentValue)
            Start-Sleep -Milliseconds 50
        }
        
        # Ensure we reach the exact target
        $this.SetProgress($targetValue)
    }
    
    # No input handling needed for progress bar
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}


####\Components/RangerFileTree.ps1
# RangerFileTree.ps1 - Ranger-style 3-pane file browser
# Left: Parent directory, Center: Current directory, Right: Preview/child

class RangerFileTree : Container {
    [string]$CurrentPath
    [FileSystemNode]$ParentNode
    [FileSystemNode]$CurrentNode
    [FileSystemNode]$PreviewNode
    
    # Three panes
    [FastFileTree]$ParentPane
    [FastFileTree]$CurrentPane
    [FastFileTree]$PreviewPane
    
    # Layout
    [double]$LeftPaneWidth = 0.25
    [double]$CenterPaneWidth = 0.35
    [double]$RightPaneWidth = 0.40
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    hidden [ThemeManager]$Theme
    
    RangerFileTree() : base() {
        $this.CurrentPath = (Get-Location).Path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    RangerFileTree([string]$path) : base() {
        $this.CurrentPath = $path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    [void] CreatePanes() {
        # Create parent pane
        $this.ParentPane = [FastFileTree]::new()
        $this.ParentPane.ShowBorder = $true
        $this.ParentPane.Title = "Parent"
        $this.ParentPane.ShowSize = $false
        $this.AddChild($this.ParentPane)
        
        # Create current pane
        $this.CurrentPane = [FastFileTree]::new()
        $this.CurrentPane.ShowBorder = $true
        $this.CurrentPane.Title = "Current"
        $this.CurrentPane.ShowSize = $true
        $this.AddChild($this.CurrentPane)
        
        # Create preview pane
        $this.PreviewPane = [FastFileTree]::new()
        $this.PreviewPane.ShowBorder = $true
        $this.PreviewPane.Title = "Preview"
        $this.PreviewPane.ShowSize = $true
        $this.AddChild($this.PreviewPane)
        
        # Set up event handlers
        $ranger = $this
        $this.CurrentPane.OnSelectionChanged = {
            $ranger.UpdatePreviewPane()
        }.GetNewClosure()
        
        $this.CurrentPane.OnFileSelected = {
            param($node)
            if ($node.IsDirectory) {
                $ranger.NavigateToDirectory($node.FullPath)
            } else {
                if ($ranger.OnFileSelected) {
                    & $ranger.OnFileSelected $node
                }
            }
        }.GetNewClosure()
    }
    
    [void] OnInitialize() {
        # Initialize theme
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Initialize child panes
        $this.ParentPane.ServiceContainer = $this.ServiceContainer
        $this.ParentPane.OnInitialize()
        
        $this.CurrentPane.ServiceContainer = $this.ServiceContainer
        $this.CurrentPane.OnInitialize()
        
        $this.PreviewPane.ServiceContainer = $this.ServiceContainer
        $this.PreviewPane.OnInitialize()
        
        # Load initial directory
        $this.NavigateToDirectory($this.CurrentPath)
    }
    
    [void] NavigateToDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        $this.CurrentPath = Resolve-Path $path
        
        # Update parent pane
        $parentPath = Split-Path $this.CurrentPath -Parent
        if ($parentPath) {
            $this.ParentPane.LoadDirectory($parentPath)
            # Select current directory in parent
            $currentName = Split-Path $this.CurrentPath -Leaf
            for ($i = 0; $i -lt $this.ParentPane._flatView.Count; $i++) {
                if ($this.ParentPane._flatView[$i].Name -eq $currentName) {
                    $this.ParentPane.SelectIndex($i)
                    break
                }
            }
        } else {
            # At root, show drives or root
            $this.ParentPane.Title = "Drives"
            $this.ParentPane._flatView.Clear()
            $this.ParentPane.Invalidate()
        }
        
        # Update current pane
        $this.CurrentPane.LoadDirectory($this.CurrentPath)
        $this.CurrentPane.Title = Split-Path $this.CurrentPath -Leaf
        if ($this.CurrentPane._flatView.Count -gt 0) {
            $this.CurrentPane.SelectIndex(0)
        }
        
        # Update preview pane
        $this.UpdatePreviewPane()
    }
    
    [void] UpdatePreviewPane() {
        $selected = $this.CurrentPane.GetSelectedNode()
        if (-not $selected) {
            $this.PreviewPane.Title = "Preview"
            $this.PreviewPane._flatView.Clear()
            $this.PreviewPane.Invalidate()
            return
        }
        
        if ($selected.IsDirectory) {
            # Show directory contents
            $this.PreviewPane.LoadDirectory($selected.FullPath)
            $this.PreviewPane.Title = $selected.Name
        } else {
            # Show file preview
            $this.PreviewPane.Title = "File: $($selected.Name)"
            $this.PreviewPane._flatView.Clear()
            
            # Could add file preview logic here (first N lines, file info, etc.)
            # For now, just show file info
            $info = [FileSystemNode]::new($selected.FullPath)
            $info.Name = "Size: $($selected.GetSizeString())"
            $this.PreviewPane._flatView.Add($info) | Out-Null
            
            $info2 = [FileSystemNode]::new($selected.FullPath)
            $info2.Name = "Modified: $($selected.LastModified.ToString('yyyy-MM-dd HH:mm'))"
            $this.PreviewPane._flatView.Add($info2) | Out-Null
            
            $this.PreviewPane.Invalidate()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate pane widths
        $totalWidth = $this.Width
        $leftWidth = [int]($totalWidth * $this.LeftPaneWidth)
        $centerWidth = [int]($totalWidth * $this.CenterPaneWidth)
        $rightWidth = $totalWidth - $leftWidth - $centerWidth
        
        # Position panes
        $this.ParentPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        $this.CurrentPane.SetBounds($this.X + $leftWidth, $this.Y, $centerWidth, $this.Height)
        $this.PreviewPane.SetBounds($this.X + $leftWidth + $centerWidth, $this.Y, $rightWidth, $this.Height)
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Handle navigation keys
        switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                # Navigate to parent directory
                $parentPath = Split-Path $this.CurrentPath -Parent
                if ($parentPath) {
                    $this.NavigateToDirectory($parentPath)
                }
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                # Navigate into selected directory
                $selected = $this.CurrentPane.GetSelectedNode()
                if ($selected -and $selected.IsDirectory) {
                    $this.NavigateToDirectory($selected.FullPath)
                }
                return $true
            }
            ([System.ConsoleKey]::H) {
                if (-not $key.Modifiers) {
                    # Toggle hidden files
                    # TODO: Implement hidden file toggle
                    return $true
                }
            }
        }
        
        # Let current pane handle other input
        return $this.CurrentPane.HandleInput($key)
    }
    
    [void] OnGotFocus() {
        ([UIElement]$this).OnGotFocus()
        # Focus the current pane
        if ($this.CurrentPane) {
            $this.CurrentPane.Focus()
        }
    }
    
    [void] Focus() {
        ([UIElement]$this).Focus()
        # Also focus the current pane
        if ($this.CurrentPane) {
            $this.CurrentPane.Focus()
        }
    }
}


####\Components/SearchableListBox.ps1
# SearchableListBox.ps1 - ListBox with built-in search/filter functionality
# High-performance search with real-time filtering

class SearchableListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [System.Collections.ArrayList]$_filteredItems
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [string]$SearchQuery = ""
    [bool]$ShowSearchBox = $true
    [bool]$CaseSensitive = $false
    [bool]$UseRegex = $false
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    
    # Search configuration
    [int]$MinSearchLength = 0  # Start filtering immediately
    [bool]$SearchInDescription = $false
    [scriptblock]$SearchFilter = $null  # Custom filter function
    
    # Visual settings
    [string]$SearchPrompt = "Search: "
    [string]$NoResultsText = "No items found"
    [char]$SearchIcon = [char]0x1F50D  # 
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_searchBoxHeight = 3
    hidden [bool]$_searchMode = $false
    hidden [int]$_lastFilteredCount = -1
    hidden [System.Collections.Generic.HashSet[string]]$_highlightCache
    
    SearchableListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this._filteredItems = [System.Collections.ArrayList]::new()
        $this._highlightCache = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.ApplyFilter()
    }
    
    [void] OnThemeChanged() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.ApplyFilter()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.ApplyFilter()
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $this.Items.Remove($item) | Out-Null
        $this.ApplyFilter()
        $this.EnsureSelectionValid()
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._filteredItems.Count) {
            return $this._filteredItems[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._filteredItems.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] SetSearchQuery([string]$query) {
        if ($this.SearchQuery -ne $query) {
            $this.SearchQuery = $query
            $this.ApplyFilter()
            $this.SelectedIndex = 0  # Reset to top when search changes
            $this.ScrollOffset = 0
            $this.Invalidate()
        }
    }
    
    [void] ClearSearch() {
        $this.SetSearchQuery("")
    }
    
    [void] EnterSearchMode() {
        $this._searchMode = $true
        $this.Invalidate()
    }
    
    [void] ExitSearchMode() {
        $this._searchMode = $false
        $this.Invalidate()
    }
    
    [void] ToggleSearchMode() {
        $this._searchMode = -not $this._searchMode
        $this.Invalidate()
    }
    
    # Internal methods
    [void] ApplyFilter() {
        $this._filteredItems.Clear()
        $this._highlightCache.Clear()
        
        # If no search query, show all items
        if ([string]::IsNullOrEmpty($this.SearchQuery) -or $this.SearchQuery.Length -lt $this.MinSearchLength) {
            foreach ($item in $this.Items) {
                $this._filteredItems.Add($item) | Out-Null
            }
        } else {
            # Apply filtering
            foreach ($item in $this.Items) {
                if ($this.MatchesSearch($item, $this.SearchQuery)) {
                    $this._filteredItems.Add($item) | Out-Null
                }
            }
        }
        
        $this._lastFilteredCount = $this._filteredItems.Count
        $this.EnsureSelectionValid()
    }
    
    [bool] MatchesSearch($item, [string]$query) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $query.ToLower()
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                # Invalid regex, fall back to simple contains
                return $searchText -like "*$query*"
            }
        } else {
            # Simple contains search
            return $searchText -like "*$query*"
        }
    }
    
    [string] GetSearchableText($item) {
        if ($item -eq $null) {
            return ""
        }
        
        # If item has a specific string representation method
        if ($item.PSObject.Methods['ToString'] -and $item.ToString() -ne $item.GetType().FullName) {
            return $item.ToString()
        }
        
        # If it's a hashtable or PSObject, try common text properties
        if ($item -is [hashtable]) {
            $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
            foreach ($prop in $textProps) {
                if ($item.ContainsKey($prop) -and $item[$prop]) {
                    return $item[$prop].ToString()
                }
            }
            # Fall back to all values if SearchInDescription is enabled
            if ($this.SearchInDescription) {
                return ($item.Values -join ' ')
            }
        }
        
        # Try common properties for objects
        $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
        foreach ($prop in $textProps) {
            $value = $item.PSObject.Properties[$prop]
            if ($value -and $value.Value) {
                return $value.Value.ToString()
            }
        }
        
        # Fall back to string conversion
        return $item.ToString()
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this._filteredItems.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this._filteredItems.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $contentHeight = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        if ($this.ShowSearchBox) {
            $contentHeight -= $this._searchBoxHeight
        }
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $contentHeight) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Colors
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("border") } else { "" }
        $titleColor = if ($this.Theme) { $this.Theme.GetColor("title") } else { "" }
        $selectedBg = if ($this.Theme) { $this.Theme.GetBgColor("selected") } else { "" }
        $normalColor = if ($this.Theme) { $this.Theme.GetColor("normal") } else { "" }
        $searchColor = if ($this.Theme) { $this.Theme.GetColor("search") } else { $normalColor }
        $highlightColor = if ($this.Theme) { $this.Theme.GetColor("highlight") } else { "`e[38;2;255;255;0m" }
        $focusBorder = if ($this.Theme) { $this.Theme.GetColor("border.focused") } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Search box
        if ($this.ShowSearchBox) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($searchColor)
            
            $searchText = "$($this.SearchIcon) $($this.SearchPrompt)$($this.SearchQuery)"
            if ($this._searchMode) {
                $searchText += "|"  # Cursor indicator
            }
            
            $searchLine = $searchText.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($searchLine)
            $contentY++
            $contentHeight--
            
            # Search box separator
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::H() * $contentWidth)
            $contentY++
            $contentHeight--
            
            # Side borders for search area
            if ($this.ShowBorder) {
                for ($y = $contentY - 2; $y -lt $contentY; $y++) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._filteredItems.Count)
        
        if ($this._filteredItems.Count -eq 0) {
            # No results message
            $noResultsY = $contentY + ($visibleLines / 2)
            $sb.Append([VT]::MoveTo($this.X + ($this.Width / 2 - $this.NoResultsText.Length / 2), [int]$noResultsY))
            $sb.Append($normalColor)
            $sb.Append($this.NoResultsText)
        } else {
            # Render items
            for ($i = $startIndex; $i -lt $endIndex; $i++) {
                $item = $this._filteredItems[$i]
                $y = $contentY + ($i - $startIndex)
                
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                }
                
                # Get display text
                $displayText = if ($this.ItemRenderer) {
                    & $this.ItemRenderer $item
                } else {
                    $this.GetSearchableText($item)
                }
                
                # Highlight search terms
                if (-not [string]::IsNullOrEmpty($this.SearchQuery) -and $displayText) {
                    $displayText = $this.HighlightSearchTerms($displayText, $highlightColor, $normalColor)
                }
                
                # Pad and truncate to fit
                if ($displayText.Length -gt $contentWidth) {
                    $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
                }
                $displayLine = $displayText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($displayLine)
                
                # Side borders
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append(" ".PadRight($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
    }
    
    [string] HighlightSearchTerms([string]$text, [string]$highlightColor, [string]$normalColor) {
        if ([string]::IsNullOrEmpty($this.SearchQuery)) {
            return $text
        }
        
        # Simple highlighting - replace matches with colored versions
        try {
            $query = $this.SearchQuery
            if (-not $this.CaseSensitive) {
                # Case-insensitive replacement
                return [regex]::Replace($text, [regex]::Escape($query), "$highlightColor`$0$normalColor", [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
            } else {
                return $text.Replace($query, "$highlightColor$query$normalColor")
            }
        } catch {
            # If highlighting fails, return original text
            return $text
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        # Search mode input
        if ($this._searchMode) {
            switch ($key.Key) {
                ([System.ConsoleKey]::Escape) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Backspace) {
                    if ($this.SearchQuery.Length -gt 0) {
                        $this.SetSearchQuery($this.SearchQuery.Substring(0, $this.SearchQuery.Length - 1))
                    }
                    $handled = $true
                }
                default {
                    if ($key.KeyChar -ge 32 -and $key.KeyChar -lt 127) {  # Printable characters
                        $this.SetSearchQuery($this.SearchQuery + $key.KeyChar)
                        $handled = $true
                    }
                }
            }
        } else {
            # Normal navigation mode
            switch ($key.Key) {
                ([System.ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this._filteredItems.Count - 1) {
                        $this.SelectedIndex++
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::PageUp) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::PageDown) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Min($this._filteredItems.Count - 1, $this.SelectedIndex + $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::Home) {
                    $this.SelectedIndex = 0
                    $handled = $true
                }
                ([System.ConsoleKey]::End) {
                    $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
                    $handled = $true
                }
                ([System.ConsoleKey]::F3) {
                    $this.ToggleSearchMode()
                    $handled = $true
                }
            }
            
            # Character-based search activation
            if (-not $handled -and $key.KeyChar -ge 32 -and $key.KeyChar -lt 127) {
                $this.SetSearchQuery([string]$key.KeyChar)
                $this.EnterSearchMode()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._searchMode = $false  # Exit search mode when losing focus
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/TabContainer.ps1
# TabContainer.ps1 - Fast tab-based screen switching
# Core component for PRAXIS multi-screen management

class TabContainer : Container {
    [System.Collections.Generic.List[TabItem]]$Tabs
    [int]$ActiveTabIndex = 0
    [int]$TabBarHeight = 2
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_tabCache = @{}
    hidden [string]$_cachedTabBar = ""
    hidden [bool]$_tabBarInvalid = $true
    
    TabContainer() : base() {
        $this.Tabs = [System.Collections.Generic.List[TabItem]]::new()
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Propagate to all tabs
        foreach ($tab in $this.Tabs) {
            if ($tab.Content -and $tab.Content -is [Screen]) {
                $tab.Content.OnThemeChanged()
            }
        }
    }
    
    # Add a new tab
    [void] AddTab([string]$title, [UIElement]$content) {
        $tab = [TabItem]::new()
        $tab.Title = $title
        $tab.Content = $content
        $tab.ShortcutKey = $this.Tabs.Count + 1  # 1-9 shortcuts
        
        # Initialize the content if it's a Screen
        if ($content -is [Screen] -and $global:ServiceContainer) {
            $content.Initialize($global:ServiceContainer)
            # Tab content shouldn't draw their own background
            $content.DrawBackground = $false
        }
        
        $this.Tabs.Add($tab)
        $this._tabBarInvalid = $true
        
        # Set as active if first tab
        if ($this.Tabs.Count -eq 1) {
            # Force activation of first tab by temporarily setting ActiveTabIndex to -1
            $oldIndex = $this.ActiveTabIndex
            $this.ActiveTabIndex = -1
            $this.ActivateTab(0)
            # If ActivateTab failed, restore the index
            if ($this.ActiveTabIndex -eq -1) {
                $this.ActiveTabIndex = $oldIndex
            }
        } else {
            # Position but don't add to children yet
            $this.PositionContent($content, $false)
        }
        
        $this.Invalidate()
    }
    
    # Switch to a specific tab
    [void] ActivateTab([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Tabs.Count) { return }
        
        # Don't switch if already on this tab
        if ($index -eq $this.ActiveTabIndex) { return }
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.ActivateTab: Switching from tab $($this.ActiveTabIndex) to tab $index")
        }
        
        # Store old content reference
        $oldContent = $null
        
        # Deactivate current
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $oldTab = $this.Tabs[$this.ActiveTabIndex]
            if ($oldTab.Content) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Removing old tab content: $($oldTab.Title)")
                }
                $oldContent = $oldTab.Content
                $this.RemoveChild($oldTab.Content)
            }
        }
        
        # Activate new
        $this.ActiveTabIndex = $index
        $newTab = $this.Tabs[$index]
        if ($newTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Adding new tab content: $($newTab.Title)")
                $global:Logger.Debug("TabContainer: Content type: $($newTab.Content.GetType().Name)")
            }
            $this.PositionContent($newTab.Content, $true)
            $this.AddChild($newTab.Content)
            if ($newTab.Content -is [Screen]) {
                # Ensure tab content doesn't draw its own background
                $newTab.Content.DrawBackground = $false
                $newTab.Content.OnActivated()
            }
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: New content bounds: X=$($newTab.Content.X) Y=$($newTab.Content.Y) W=$($newTab.Content.Width) H=$($newTab.Content.Height)")
            }
        }
        
        # Now safely deactivate old content after UI tree is updated
        if ($oldContent -and $oldContent -is [Screen]) {
            $oldContent.OnDeactivated()
        }
        
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Force parent to redraw completely to clear any artifacts
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
        
        # Force a render request
        if ($global:ScreenManager) {
            $global:ScreenManager.RequestRender()
        }
    }
    
    # Position content below tab bar
    hidden [void] PositionContent([UIElement]$content, [bool]$isActive) {
        $content.SetBounds(
            $this.X,
            $this.Y + $this.TabBarHeight,
            $this.Width,
            $this.Height - $this.TabBarHeight
        )
    }
    
    # Layout management
    [void] OnBoundsChanged() {
        # Update tab bar cache
        $this._tabBarInvalid = $true
        
        # Update active content bounds
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $activeTab = $this.Tabs[$this.ActiveTabIndex]
            if ($activeTab.Content) {
                $this.PositionContent($activeTab.Content, $true)
            }
        }
    }
    
    # Render the tab container
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: tabBarInvalid=$($this._tabBarInvalid), Children.Count=$($this.Children.Count)")
        }
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Render tab bar
        if ($this._tabBarInvalid) {
            $this.RebuildTabBar()
        }
        $sb.Append($this._cachedTabBar)
        
        # Don't clear content area - let the screen handle its own background
        # This was overwriting buttons that are rendered by child screens
        
        # Render active content (base class handles children)
        $baseRender = ([Container]$this).OnRender()
        $sb.Append($baseRender)
        
        if ($global:Logger -and $baseRender.Length -eq 0) {
            $global:Logger.Warning("TabContainer: Base render returned empty string")
        }
        
        return $sb.ToString()
    }
    
    # Build the tab bar
    hidden [void] RebuildTabBar() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Tab bar background
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this.Theme.GetBgColor("tab.background"))
        $sb.Append(" " * $this.Width)
        
        # Draw tabs
        $x = $this.X + 1
        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {
            $tab = $this.Tabs[$i]
            $title = $tab.Title
            
            # Add shortcut hint if applicable
            if ($tab.ShortcutKey -ge 1 -and $tab.ShortcutKey -le 9) {
                $title = "$($tab.ShortcutKey):$title"
            }
            
            # Calculate tab width
            $tabWidth = $title.Length + 4  # Padding
            
            # Don't draw if it would overflow
            if (($x + $tabWidth) -gt ($this.X + $this.Width - 1)) {
                break
            }
            
            $sb.Append([VT]::MoveTo($x, $this.Y))
            
            # Tab styling
            if ($i -eq $this.ActiveTabIndex) {
                # Active tab
                $sb.Append($this.Theme.GetBgColor("tab.active.background"))
                $sb.Append($this.Theme.GetColor("tab.active.foreground"))
                $sb.Append(" $title ")
                
                # Bottom accent line
                $sb.Append([VT]::MoveTo($x, $this.Y + 1))
                $sb.Append($this.Theme.GetColor("tab.active.accent"))
                $sb.Append("" * ($tabWidth - 2))
            } else {
                # Inactive tab
                $sb.Append($this.Theme.GetBgColor("tab.background"))
                $sb.Append($this.Theme.GetColor("tab.foreground"))
                $sb.Append(" $title ")
            }
            
            $x += $tabWidth + 1
        }
        
        # Reset and draw separator line
        $sb.Append([VT]::Reset())
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append("" * $this.Width)
        $sb.Append([VT]::Reset())
        
        $this._cachedTabBar = $sb.ToString()
        $this._tabBarInvalid = $false
    }
    
    # Handle keyboard input
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Modifiers=$($key.Modifiers)")
        }
        
        # Check TabContainer shortcuts FIRST before passing to children
        
        # Number keys for quick tab switching
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            $tabIndex = [int]$key.KeyChar - [int][char]'1'
            if ($tabIndex -lt $this.Tabs.Count) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Switching to tab $($tabIndex + 1)")
                }
                $this.ActivateTab($tabIndex)
                return $true
            }
        }
        
        # Ctrl+Tab / Ctrl+Shift+Tab for cycling
        if ($key.Key -eq [System.ConsoleKey]::Tab -and 
            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.PreviousTab()
            } else {
                $this.NextTab()
            }
            return $true
        }
        
        # Alt+Left/Right for navigation
        if ($key.Modifiers -band [System.ConsoleModifiers]::Alt) {
            if ($key.Key -eq [System.ConsoleKey]::LeftArrow) {
                $this.PreviousTab()
                return $true
            } elseif ($key.Key -eq [System.ConsoleKey]::RightArrow) {
                $this.NextTab()
                return $true
            }
        }
        
        # Route to active tab's content if tab switching didn't handle it
        $activeTab = $this.GetActiveTab()
        if ($activeTab -and $activeTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Routing input to active tab content: $($activeTab.Content.GetType().Name)")
            }
            if ($activeTab.Content.HandleInput($key)) {
                return $true
            }
        }
        
        # No one handled it
        return $false
    }
    
    # Navigation helpers
    [void] NextTab() {
        if ($this.Tabs.Count -gt 0) {
            $next = ($this.ActiveTabIndex + 1) % $this.Tabs.Count
            $this.ActivateTab($next)
        }
    }
    
    [void] PreviousTab() {
        if ($this.Tabs.Count -gt 0) {
            $prev = $this.ActiveTabIndex - 1
            if ($prev -lt 0) { $prev = $this.Tabs.Count - 1 }
            $this.ActivateTab($prev)
        }
    }
    
    # Get active tab
    [TabItem] GetActiveTab() {
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            return $this.Tabs[$this.ActiveTabIndex]
        }
        return $null
    }
}

# Tab item class
class TabItem {
    [string]$Title = "Tab"
    [UIElement]$Content = $null
    [int]$ShortcutKey = 0
}


####\Components/TextBox.ps1
# TextBox.ps1 - Fast text input component
# Adapted from AxiomPhoenix with string-based rendering

class TextBox : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [bool]$ShowBorder = $true
    [bool]$ShowCursor = $true
    [scriptblock]$OnChange = {}
    [scriptblock]$OnSubmit = {}
    
    hidden [int]$_scrollOffset = 0
    hidden [string]$_cachedRender = ""
    hidden [bool]$_needsRender = $true
    hidden [ThemeManager]$Theme
    
    TextBox() : base() {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3  # Border + content + border
    }
    
    [void] Initialize([ServiceContainer]$services) {
        if ($services) {
            $this.Theme = $services.GetService("ThemeManager")
            if ($this.Theme) {
                $this.Theme.Subscribe({ $this._needsRender = $true; $this.Invalidate() })
            }
        }
    }
    
    [string] OnRender() {
        if (-not $this._needsRender) {
            return $this._cachedRender
        }
        
        $sb = Get-PooledStringBuilder 512  # TextBox typically needs moderate capacity
        
        # Colors based on focus state
        $borderColor = if ($this.Theme -and $this.IsFocused) {
            $this.Theme.GetColor("input.focused.border")
        } elseif ($this.Theme) {
            $this.Theme.GetColor("input.border")
        } else {
            ""
        }
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("input.background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("input.foreground") } else { "" }
        $placeholderColor = if ($this.Theme) { $this.Theme.GetColor("input.placeholder") } else { "" }
        
        # Content area
        $contentY = $this.Y + 1
        $contentStartX = $this.X + 1
        $contentWidth = $this.Width - 2
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            
            # Middle line with content
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append([VT]::V())
            
            # Clear content area
            $sb.Append($bgColor)
            $sb.Append(" " * $contentWidth)
            
            # Right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + 2))
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        } else {
            # Just clear the content area
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($bgColor)
            $sb.Append(" " * $this.Width)
            $contentY = $this.Y
            $contentStartX = $this.X
            $contentWidth = $this.Width
        }
        
        # Render text or placeholder
        $sb.Append([VT]::MoveTo($contentStartX, $contentY))
        
        if ($this.Text.Length -eq 0 -and -not [string]::IsNullOrEmpty($this.Placeholder)) {
            # Show placeholder
            $sb.Append($placeholderColor)
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth)
            } else {
                $this.Placeholder
            }
            $sb.Append($placeholderText)
        } else {
            # Calculate scroll offset to keep cursor in view
            if ($this.CursorPosition -lt $this._scrollOffset) {
                $this._scrollOffset = $this.CursorPosition
            } elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
            }
            
            # Draw visible portion of text
            $sb.Append($fgColor)
            if ($this.Text.Length -gt $this._scrollOffset) {
                $len = [Math]::Min($contentWidth, $this.Text.Length - $this._scrollOffset)
                $visibleText = $this.Text.Substring($this._scrollOffset, $len)
                $sb.Append($visibleText)
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this.ShowCursor) {
                $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                    $cursorX = $contentStartX + $cursorScreenPos
                    $sb.Append([VT]::MoveTo($cursorX, $contentY))
                    
                    # Reverse video for cursor
                    $charUnderCursor = if ($this.CursorPosition -lt $this.Text.Length) {
                        $this.Text[$this.CursorPosition]
                    } else {
                        ' '
                    }
                    
                    $sb.Append($bgColor)  # Swap colors for cursor
                    if ($this.Theme) {
                        $sb.Append($this.Theme.GetBgColor("input.foreground"))
                    }
                    $sb.Append($charUnderCursor)
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._needsRender = $false
        return $this._cachedRender
    }
    
    [void] OnGotFocus() {
        $this.ShowCursor = $true
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnGotFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [void] OnLostFocus() {
        $this.ShowCursor = $false
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnLostFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $oldText = $this.Text
            
            switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                }
            }
            ([System.ConsoleKey]::Home) {
                $this.CursorPosition = 0
            }
            ([System.ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            ([System.ConsoleKey]::Enter) {
                try {
                    if ($this.OnSubmit) {
                        & $this.OnSubmit $this.Text
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("TextBox.HandleInput: Error executing OnSubmit handler - $($_.Exception.Message)")
                    }
                }
            }
            ([System.ConsoleKey]::Tab) {
                # Don't handle Tab - let parent handle focus navigation
                $handled = $false
            }
            ([System.ConsoleKey]::Escape) {
                # Don't handle Escape - let parent handle it
                $handled = $false
            }
            default {
                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
            if ($handled) {
                # Call OnChange if text was modified
                if ($oldText -ne $this.Text -and $this.OnChange) {
                    try {
                        & $this.OnChange $this.Text
                    } catch {
                        if ($global:Logger) {
                            $global:Logger.Error("TextBox.HandleInput: Error executing OnChange handler - $($_.Exception.Message)")
                        }
                    }
                }
                $this._needsRender = $true
                $this.Invalidate()
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TextBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Helper methods
    [void] SetText([string]$text) {
        if ($text.Length -le $this.MaxLength) {
            $this.Text = $text
            $this.CursorPosition = $text.Length
            $this._needsRender = $true
            $this.Invalidate()
        }
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this._scrollOffset = 0
        $this._needsRender = $true
        $this.Invalidate()
    }
}


####\Components/TreeView.ps1
# TreeView.ps1 - Hierarchical tree view component based on ALCAR patterns
# Fast string-based rendering with expand/collapse functionality

class TreeNode {
    [string]$Id
    [object]$Data
    [TreeNode]$Parent
    [System.Collections.ArrayList]$Children
    [bool]$IsExpanded = $true
    [int]$Level = 0
    [string]$DisplayText
    
    TreeNode() {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
    }
    
    TreeNode([string]$displayText) {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
        $this.DisplayText = $displayText
    }
    
    TreeNode([string]$displayText, [object]$data) {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
        $this.DisplayText = $displayText
        $this.Data = $data
    }
    
    [void] AddChild([TreeNode]$child) {
        $child.Parent = $this
        $this.Children.Add($child) | Out-Null
        $this.UpdateLevels()
    }
    
    [void] RemoveChild([TreeNode]$child) {
        $this.Children.Remove($child)
        $child.Parent = $null
    }
    
    [void] UpdateLevels() {
        # Recursively update all child levels
        foreach ($child in $this.Children) {
            $child.Level = $this.Level + 1
            $child.UpdateLevels()
        }
    }
    
    [bool] HasChildren() {
        return $this.Children.Count -gt 0
    }
}

class TreeView : UIElement {
    [System.Collections.ArrayList]$Nodes
    [System.Collections.ArrayList]$_flatView  # Flattened display view
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnNodeExpanded = {}
    [scriptblock]$OnNodeCollapsed = {}
    
    # Visual settings
    [string]$ExpandedIcon = ""
    [string]$CollapsedIcon = ""
    [string]$LeafIcon = ""
    [int]$IndentSize = 2
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    
    TreeView() : base() {
        $this.Nodes = [System.Collections.ArrayList]::new()
        $this._flatView = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.RebuildFlatView()
    }
    
    [void] OnThemeChanged() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [TreeNode] AddRootNode([string]$displayText) {
        $node = [TreeNode]::new($displayText)
        $node.Level = 0
        $this.Nodes.Add($node) | Out-Null
        $this.RebuildFlatView()
        return $node
    }
    
    [TreeNode] AddRootNode([string]$displayText, [object]$data) {
        $node = [TreeNode]::new($displayText, $data)
        $node.Level = 0
        $this.Nodes.Add($node) | Out-Null
        $this.RebuildFlatView()
        return $node
    }
    
    [void] Clear() {
        $this.Nodes.Clear()
        $this._flatView.Clear()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [TreeNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SetSelectedNode([TreeNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].Id -eq $node.Id) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] ToggleExpanded([TreeNode]$node) {
        if (-not $node.HasChildren()) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        $this.RebuildFlatView()
        
        # Fire events
        if ($node.IsExpanded -and $this.OnNodeExpanded) {
            & $this.OnNodeExpanded $node
        } elseif (-not $node.IsExpanded -and $this.OnNodeCollapsed) {
            & $this.OnNodeCollapsed $node
        }
        
        # Maintain selection on the same node
        $this.SetSelectedNode($node)
    }
    
    [void] ExpandAll() {
        $this.SetAllExpanded($true)
    }
    
    [void] CollapseAll() {
        $this.SetAllExpanded($false)
    }
    
    [void] SetAllExpanded([bool]$expanded) {
        foreach ($node in $this.Nodes) {
            $this.SetNodeExpanded($node, $expanded)
        }
        $this.RebuildFlatView()
        $this.Invalidate()
    }
    
    [void] SetNodeExpanded([TreeNode]$node, [bool]$expanded) {
        if ($node.HasChildren()) {
            $node.IsExpanded = $expanded
        }
        foreach ($child in $node.Children) {
            $this.SetNodeExpanded($child, $expanded)
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        foreach ($node in $this.Nodes) {
            $this.AddNodeToFlatView($node)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([TreeNode]$node) {
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Colors
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("border") } else { "" }
        $titleColor = if ($this.Theme) { $this.Theme.GetColor("title") } else { "" }
        $selectedBg = if ($this.Theme) { $this.Theme.GetBgColor("selected") } else { "" }
        $normalColor = if ($this.Theme) { $this.Theme.GetColor("normal") } else { "" }
        $focusBorder = if ($this.Theme) { $this.Theme.GetColor("border.focused") } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($this.Width - 2)) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render tree nodes
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for selected item
            if ($i -eq $this.SelectedIndex) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Indentation
            $line += " " * ($node.Level * $this.IndentSize)
            
            # Tree icon
            if ($node.HasChildren()) {
                $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
            } else {
                $line += $this.LeafIcon + " "
            }
            
            # Node text
            $line += $node.DisplayText
            
            # Pad and truncate to fit
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            if ($this.ShowBorder) {
                # Side borders
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append(" ".PadRight($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + ([VT]::H() * ($this.Width - 2)) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3  # Approximate visible lines
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3  # Approximate visible lines
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $node = $this.GetSelectedNode()
                if ($node -and $node.HasChildren()) {
                    $this.ToggleExpanded($node)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Spacebar) {
                $node = $this.GetSelectedNode()
                if ($node -and $node.HasChildren()) {
                    $this.ToggleExpanded($node)
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/VerticalSplit.ps1
# VerticalSplit.ps1 - Fast vertical layout component for PRAXIS

class VerticalSplit : Container {
    [UIElement]$TopPane
    [UIElement]$BottomPane
    [int]$SplitRatio = 50  # Percentage for top pane (0-100)
    [int]$MinPaneHeight = 3
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedTopHeight = 0
    hidden [int]$_cachedBottomHeight = 0
    hidden [int]$_cachedBottomY = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastSplitRatio = 0
    
    VerticalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] SetTopPane([UIElement]$pane) {
        if ($this.TopPane) {
            $this.RemoveChild($this.TopPane)
        }
        $this.TopPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetBottomPane([UIElement]$pane) {
        if ($this.BottomPane) {
            $this.RemoveChild($this.BottomPane)
        }
        $this.BottomPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastHeight -eq $this.Height -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalHeight = $this.Height
        $topHeight = [int](($totalHeight * $this.SplitRatio) / 100)
        $topHeight = [Math]::Max($this.MinPaneHeight, [Math]::Min($topHeight, $totalHeight - $this.MinPaneHeight))
        $bottomHeight = $totalHeight - $topHeight
        $bottomY = $this.Y + $topHeight
        
        # Update top pane
        if ($this.TopPane) {
            $this.TopPane.SetBounds($this.X, $this.Y, $this.Width, $topHeight)
        }
        
        # Update bottom pane
        if ($this.BottomPane) {
            $this.BottomPane.SetBounds($this.X, $bottomY, $this.Width, $bottomHeight)
        }
        
        # Cache the layout
        $this._cachedTopHeight = $topHeight
        $this._cachedBottomHeight = $bottomHeight
        $this._cachedBottomY = $bottomY
        $this._lastHeight = $this.Height
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = [System.Text.StringBuilder]::new()
        
        # Render children
        if ($this.TopPane -and $this.TopPane.Visible) {
            $sb.Append($this.TopPane.Render())
        }
        
        if ($this.BottomPane -and $this.BottomPane.Visible) {
            $sb.Append($this.BottomPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedTopHeight -gt 0) {
            $borderColor = $this.Theme.GetColor("border")
            $sb.Append([VT]::MoveTo($this.X, $this._cachedBottomY - 1))
            $sb.Append($borderColor)
            $sb.Append("" * $this.Width)
            $sb.Append([VT]::Reset())
        }
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.TopPane -and $this.TopPane.IsFocused) {
            if ($this.TopPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.BottomPane -and $this.BottomPane.IsFocused) {
            if ($this.BottomPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetTopFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetBottomFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetTopPane() { return $this.TopPane }
    [UIElement] GetBottomPane() { return $this.BottomPane }
    
    # Focus management
    [void] FocusTopPane() {
        if ($this.TopPane -and $this.TopPane.IsFocusable) {
            $this.TopPane.Focus()
        }
    }
    
    [void] FocusBottomPane() {
        if ($this.BottomPane -and $this.BottomPane.IsFocusable) {
            $this.BottomPane.Focus()
        }
    }
}


####\Core/ScreenManager.ps1
# ScreenManager.ps1 - Manages screen lifecycle and rendering
# Optimized for minimal overhead

class ScreenManager {
    hidden [System.Collections.Generic.Stack[Screen]]$_screenStack
    hidden [Screen]$_activeScreen = $null
    hidden [bool]$_needsRender = $true
    hidden [System.ConsoleKeyInfo]$_lastKey
    hidden [ServiceContainer]$_services
    hidden [ShortcutManager]$_shortcutManager
    hidden [bool]$_exitRequested = $false
    
    # Performance tracking
    hidden [System.Diagnostics.Stopwatch]$_renderTimer
    hidden [int]$_frameCount = 0
    hidden [double]$_lastFPS = 0
    
    ScreenManager([ServiceContainer]$services) {
        $this._screenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this._services = $services
        $this._renderTimer = [System.Diagnostics.Stopwatch]::new()
        
        # Get ShortcutManager if available
        $this._shortcutManager = $services.GetService('ShortcutManager')
    }
    
    # Push a new screen
    [void] Push([Screen]$screen) {
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Push: Pushing screen $($screen.GetType().Name)")
        }
        
        # Deactivate current
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
            $this._activeScreen.OnDeactivated()
        }
        
        try {
            # Initialize and activate new screen
            $screen.Initialize($this._services)
            $screen.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
            
            $this._screenStack.Push($screen)
            $this._activeScreen = $screen
            $this._activeScreen.Active = $true
            $this._activeScreen.OnActivated()
            
            $this._needsRender = $true
            
            if ($global:Logger) {
                $global:Logger.Info("ScreenManager.Push: Successfully pushed $($screen.GetType().Name), Active=$($this._activeScreen.Active)")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ScreenManager.Push: Error pushing screen - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
            throw
        }
    }
    
    # Pop current screen
    [Screen] Pop() {
        if ($this._screenStack.Count -eq 0) { return $null }
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Pop: Stack count before pop = $($this._screenStack.Count)")
        }
        
        $popped = $this._screenStack.Pop()
        if ($popped) {
            $popped.Active = $false
            $popped.OnDeactivated()
        }
        
        # Activate previous screen if any
        if ($this._screenStack.Count -gt 0) {
            $this._activeScreen = $this._screenStack.Peek()
            if ($this._activeScreen) {
                if ($global:Logger) {
                    $global:Logger.Debug("ScreenManager.Pop: Activating previous screen: $($this._activeScreen.GetType().Name)")
                }
                try {
                    $this._activeScreen.Active = $true
                    $this._activeScreen.OnActivated()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ScreenManager.Pop: Error activating previous screen - $_")
                        $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
                    }
                }
            } else {
                if ($global:Logger) {
                    $global:Logger.Error("ScreenManager.Pop: Previous screen is null!")
                }
            }
        } else {
            $this._activeScreen = $null
        }
        
        $this._needsRender = $true
        return $popped
    }
    
    # Replace current screen
    [void] Replace([Screen]$screen) {
        if ($this._screenStack.Count -gt 0) {
            $this.Pop() | Out-Null
        }
        $this.Push($screen)
    }
    
    # Get active screen
    [Screen] GetActiveScreen() {
        return $this._activeScreen
    }
    
    # Main run loop
    [void] Run() {
        # Initial setup
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Run: Starting main loop")
            if ($this._activeScreen) {
                $global:Logger.Info("Active screen: $($this._activeScreen.GetType().Name)")
                $global:Logger.Info("Active screen.Active: $($this._activeScreen.Active)")
            } else {
                $global:Logger.Info("Active screen: null")
            }
            $global:Logger.Flush()
        }
        
        try {
            while ($this._activeScreen -and $this._activeScreen.Active -and -not $this._exitRequested) {
                if ($global:Logger) {
                    $global:Logger.Debug("ScreenManager: In main loop iteration")
                }
                
                # Handle terminal resize
                if ([Console]::WindowWidth -ne $this._activeScreen.Width -or 
                    [Console]::WindowHeight -ne $this._activeScreen.Height) {
                    $this.HandleResize()
                }
                
                # Render if needed
                if ($this._needsRender -or $this._activeScreen._cacheInvalid) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ScreenManager: Rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                    $this.Render()
                } else {
                    # Log occasionally why we're not rendering
                    if ($this._frameCount % 100 -eq 0 -and $global:Logger) {
                        $global:Logger.Debug("ScreenManager: Not rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                }
                
                # Handle input
                try {
                    # Check if running in test mode
                    if ($env:PRAXIS_TEST_MODE) {
                        if ($global:Logger) {
                            $global:Logger.Debug("Running in test mode - skipping input")
                        }
                        Start-Sleep -Milliseconds 100
                        continue
                    }
                    
                    if ([Console]::KeyAvailable) {
                        $key = [Console]::ReadKey($true)
                        $this._lastKey = $key
                        $handled = $false
                        
                        # Log key press for debugging
                        if ($global:Logger) {
                            $global:Logger.Debug("Key pressed: $($key.Key) Char: '$($key.KeyChar)' Modifiers: $($key.Modifiers)")
                        }
                        
                        # PARENT-DELEGATED INPUT MODEL - Simple routing only
                        $handled = $false
                        
                        # 1. Check ShortcutManager for global shortcuts first
                        if ($this._shortcutManager) {
                            # Get the actual active screen (e.g., ProjectsScreen within MainScreen's TabContainer)
                            $currentScreenType = ""
                            if ($this._activeScreen) {
                                if ($this._activeScreen.GetType().Name -eq "MainScreen" -and $this._activeScreen.TabContainer) {
                                    $activeTab = $this._activeScreen.TabContainer.GetActiveTab()
                                    if ($activeTab -and $activeTab.Content) {
                                        $currentScreenType = $activeTab.Content.GetType().Name
                                    }
                                } else {
                                    $currentScreenType = $this._activeScreen.GetType().Name
                                }
                            }
                            
                            $currentContext = if ($this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) { "CommandPalette" } else { "" }
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($key.Key) Char='$($key.KeyChar)' ScreenType=$currentScreenType Context=$currentContext")
                            }
                            
                            $handled = $this._shortcutManager.HandleKeyPress($key, $currentScreenType, $currentContext)
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager handled=$handled")
                            }
                        }
                        
                        # 2. Command Palette override (when visible) - only if not handled by shortcuts
                        if (-not $handled -and $this._activeScreen -and $this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) {
                            $handled = $this._activeScreen.CommandPalette.HandleInput($key)
                            if ($global:Logger) {
                                $global:Logger.Debug("Key routed to CommandPalette")
                            }
                        }
                        # 3. Fallback to hardcoded shortcuts if ShortcutManager not available
                        elseif (-not $this._shortcutManager) {
                            if ($key.KeyChar -eq '/' -or $key.KeyChar -eq ':') {
                                # Show command palette
                                if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
                                    $this._activeScreen.CommandPalette.Show()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Command palette opened")
                                    }
                                }
                            } 
                            elseif ($key.Key -eq [System.ConsoleKey]::Tab) {
                                # Handle Tab navigation via parent delegation
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                            elseif ($key.Modifiers -band [System.ConsoleModifiers]::Control) {
                                # Ctrl+Q for quit
                                if ($key.Key -eq [System.ConsoleKey]::Q) {
                                    $this.RequestExit()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Quit application")
                                    }
                                }
                            }
                            # Ctrl+Arrows for focus navigation
                            elseif ($key.Key -eq [System.ConsoleKey]::RightArrow -or $key.Key -eq [System.ConsoleKey]::LeftArrow) {
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                        }
                        
                        # 4. Tab navigation (if not handled above)
                        if (-not $handled -and $key.Key -eq [System.ConsoleKey]::Tab -and $this._activeScreen) {
                            $handled = $this.HandleTabNavigation($key)
                        }
                        
                        # 5. If not handled by global shortcuts, let screen handle it
                        if (-not $handled -and $this._activeScreen) {
                            try {
                                $handled = $this._activeScreen.HandleInput($key)
                                if ($handled -and $global:Logger) {
                                    $global:Logger.Debug("Key handled by screen: $($this._activeScreen.GetType().Name)")
                                }
                            } catch {
                                if ($global:Logger) {
                                    $global:Logger.LogException($_.Exception, "Error in screen input handling")
                                }
                            }
                        }
                        
                        if ($handled) {
                            $this._needsRender = $true
                        }
                        
                        # Emergency exit (Ctrl+Esc)
                        if ($key.Key -eq [System.ConsoleKey]::Escape -and 
                            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
                            break  # Ctrl+Esc to exit
                        }
                    } else {
                        # Small sleep to prevent CPU spinning
                        Start-Sleep -Milliseconds 10
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.LogException($_.Exception, "Error in input handling")
                    }
                    
                    # In non-interactive mode, just sleep
                    Start-Sleep -Milliseconds 50
                    
                    # Check if we should exit (for testing)
                    if ($env:PRAXIS_TEST_MODE) {
                        break
                    }
                }
            }
        } finally {
            # Cleanup
            [Console]::CursorVisible = $true
            [Console]::Clear()
            [Console]::SetCursorPosition(0, 0)
        }
    }
    
    # Render current screen
    hidden [void] Render() {
        $this._renderTimer.Restart()
        
        # Get rendered content
        $content = $this._activeScreen.Render()
        
        # Write to console in one shot
        [Console]::SetCursorPosition(0, 0)
        [Console]::Write($content)
        
        $this._renderTimer.Stop()
        $this._frameCount++
        
        # Update FPS every second
        if ($this._frameCount % 60 -eq 0) {
            $this._lastFPS = 1000.0 / $this._renderTimer.ElapsedMilliseconds
        }
        
        $this._needsRender = $false
    }
    
    # Handle terminal resize
    hidden [void] HandleResize() {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        # Update all screens in stack
        foreach ($screen in $this._screenStack) {
            $screen.SetBounds(0, 0, $newWidth, $newHeight)
        }
        
        # Clear and force full redraw
        [Console]::Clear()
        $this._needsRender = $true
    }
    
    # Request render on next frame
    [void] RequestRender() {
        $this._needsRender = $true
    }
    
    # Parent-delegated Tab navigation
    [bool] HandleTabNavigation([System.ConsoleKeyInfo]$key) {
        # Find the deepest focused element
        $focused = $this.FindDeepestFocusedElement($this._activeScreen)
        if ($global:Logger) {
            $global:Logger.Debug("HandleTabNavigation: Focused element = " + $(if ($focused) { $focused.GetType().Name } else { "null" }))
        }
        
        if (-not $focused) {
            # No focus, try to focus first focusable element
            if ($global:Logger) {
                $global:Logger.Debug("HandleTabNavigation: No focused element, focusing first")
            }
            $this._activeScreen.FocusFirst()
            return $true
        }
        
        # Ask the parent to handle navigation
        if ($focused.Parent) {
            $isReverse = ($key.Modifiers -band [System.ConsoleModifiers]::Shift) -or 
                         ($key.Key -eq [System.ConsoleKey]::LeftArrow)
            
            if ($global:Logger) {
                $global:Logger.Debug("HandleTabNavigation: Parent = $($focused.Parent.GetType().Name), Reverse = $isReverse")
            }
            
            if ($isReverse) {
                $focused.Parent.FocusPreviousChild($focused)
            } else {
                $focused.Parent.FocusNextChild($focused)
            }
            
            if ($global:Logger) {
                $direction = if ($isReverse) { "reverse" } else { "forward" }
                $global:Logger.Debug("Tab navigation: $direction via parent delegation")
            }
            return $true
        }
        
        return $false
    }
    
    # Find the deepest focused element in the tree
    [UIElement] FindDeepestFocusedElement([UIElement]$root) {
        if (-not $root) { return $null }
        
        if ($root.IsFocused) {
            # Check if any child is focused (go deeper)
            foreach ($child in $root.Children) {
                $deeper = $this.FindDeepestFocusedElement($child)
                if ($deeper) { return $deeper }
            }
            return $root
        }
        
        # Not focused, check children
        foreach ($child in $root.Children) {
            $found = $this.FindDeepestFocusedElement($child)
            if ($found) { return $found }
        }
        
        return $null
    }
    
    # Get current FPS
    [double] GetFPS() {
        return $this._lastFPS
    }
    
    # Request application exit
    [void] RequestExit() {
        $this._exitRequested = $true
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
        }
    }
    
    # Show command palette
    [void] ShowCommandPalette() {
        if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
            $this._activeScreen.CommandPalette.Show()
        }
    }
}

# Global screen manager instance
$global:ScreenManager = $null


####\Core/ServiceContainer.ps1
# ServiceContainer.ps1 - Lightweight dependency injection
# Simplified from AxiomPhoenix for PRAXIS

class ServiceContainer {
    hidden [hashtable]$_services = @{}
    hidden [hashtable]$_factories = @{}
    
    # Register a service instance
    [void] Register([string]$name, [object]$instance) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $instance) {
            throw "Service instance cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._services[$name] = $instance
    }
    
    # Register a factory for lazy initialization
    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$singleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $factory) {
            throw "Factory cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._factories[$name] = @{
            Factory = $factory
            Singleton = $singleton
            Instance = $null
        }
    }
    
    # Get a service by name
    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        
        # Check eager instances first
        if ($this._services.ContainsKey($name)) {
            return $this._services[$name]
        }
        
        # Check factories
        if ($this._factories.ContainsKey($name)) {
            $factory = $this._factories[$name]
            
            # Return cached singleton if available
            if ($factory.Singleton -and $null -ne $factory.Instance) {
                return $factory.Instance
            }
            
            # Create new instance
            $instance = & $factory.Factory $this
            
            # Cache if singleton
            if ($factory.Singleton) {
                $factory.Instance = $instance
            }
            
            return $instance
        }
        
        throw "Service '$name' not found. Available: $($this.GetServiceNames() -join ', ')"
    }
    
    # Get all registered service names
    [string[]] GetServiceNames() {
        $names = @()
        $names += $this._services.Keys
        $names += $this._factories.Keys
        return $names | Sort-Object
    }
    
    # Cleanup all services
    [void] Cleanup() {
        # Dispose any IDisposable services
        $allInstances = @()
        $allInstances += $this._services.Values
        $allInstances += $this._factories.Values | Where-Object { $_.Instance } | ForEach-Object { $_.Instance }
        
        foreach ($instance in $allInstances) {
            if ($instance -is [System.IDisposable]) {
                try {
                    $instance.Dispose()
                } catch {
                    # Ignore disposal errors
                }
            }
        }
        
        $this._services.Clear()
        $this._factories.Clear()
    }
}

# Global service container instance
$global:ServiceContainer = [ServiceContainer]::new()


####\Core/StringBuilderPool.ps1
# StringBuilderPool.ps1 - Pool for reusing StringBuilder instances to reduce memory allocations

class StringBuilderPool {
    static [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]$Pool = [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]::new()
    static [int]$MaxPoolSize = 50
    static [int]$MaxCapacity = 16384  # 16KB max capacity before discarding
    static [int]$CreatedCount = 0
    static [int]$ReusedCount = 0
    
    # Get a StringBuilder from the pool or create new one
    static [System.Text.StringBuilder] Get() {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()  # Clear but keep capacity
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new()
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Get a StringBuilder with initial capacity
    static [System.Text.StringBuilder] Get([int]$initialCapacity) {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()
            if ($sb.Capacity -lt $initialCapacity) {
                $sb.Capacity = $initialCapacity
            }
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new($initialCapacity)
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Return StringBuilder to pool for reuse
    static [void] Return([System.Text.StringBuilder]$sb) {
        if (-not $sb) { return }
        
        # Don't pool if too large (prevents memory bloat)
        if ($sb.Capacity -gt [StringBuilderPool]::MaxCapacity) {
            return
        }
        
        # Don't pool if we're at max capacity
        if ([StringBuilderPool]::Pool.Count -ge [StringBuilderPool]::MaxPoolSize) {
            return
        }
        
        $sb.Clear()
        [StringBuilderPool]::Pool.Enqueue($sb)
    }
    
    # Get pool statistics for debugging
    static [hashtable] GetStats() {
        return @{
            PoolSize = [StringBuilderPool]::Pool.Count
            MaxPoolSize = [StringBuilderPool]::MaxPoolSize
            Created = [StringBuilderPool]::CreatedCount
            Reused = [StringBuilderPool]::ReusedCount
            ReuseRate = if ([StringBuilderPool]::CreatedCount -eq 0) { 0 } else { 
                [Math]::Round(([StringBuilderPool]::ReusedCount / ([StringBuilderPool]::CreatedCount + [StringBuilderPool]::ReusedCount)) * 100, 2)
            }
        }
    }
    
    # Clear the pool (useful for testing or cleanup)
    static [void] Clear() {
        while ([StringBuilderPool]::Pool.TryDequeue([ref]$null)) {
            # Empty the queue
        }
    }
}

# Global helper functions for easier access
function Get-PooledStringBuilder {
    param([int]$initialCapacity = 256)
    
    if ($initialCapacity -gt 0) {
        return [StringBuilderPool]::Get($initialCapacity)
    } else {
        return [StringBuilderPool]::Get()
    }
}

function Return-PooledStringBuilder {
    param([System.Text.StringBuilder]$StringBuilder)
    [StringBuilderPool]::Return($StringBuilder)
}

function Get-StringBuilderPoolStats {
    return [StringBuilderPool]::GetStats()
}


####\Core/VT100.ps1
# VT100/ANSI Core for BOLT-AXIOM with True Color Support

class VT {
    # Cursor movement (ANSI uses 1-based coordinates)
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    
    # Screen control
    static [string] Clear() { return "`e[H`e[2J" }  # Clear screen and home
    static [string] ClearLine() { return "`e[K" }
    static [string] Home() { return "`e[H" }      # Just home position
    static [string] ClearToEnd() { return "`e[J" }  # Clear from cursor to end
    
    # Basic styles
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Dim() { return "`e[2m" }
    
    # 24-bit True Color
    static [string] RGB([int]$r, [int]$g, [int]$b) { 
        return "`e[38;2;$r;$g;$($b)m" 
    }
    static [string] RGBBG([int]$r, [int]$g, [int]$b) { 
        return "`e[48;2;$r;$g;$($b)m" 
    }
    
    # Wireframe color palette (true color)
    static [string] Border() { return [VT]::RGB(0, 255, 255) }      # Cyan
    static [string] BorderDim() { return [VT]::RGB(0, 128, 128) }   # Dark cyan
    static [string] BorderActive() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Text() { return [VT]::RGB(192, 192, 192) }      # Light gray
    static [string] TextDim() { return [VT]::RGB(128, 128, 128) }   # Gray
    static [string] TextBright() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Accent() { return [VT]::RGB(0, 255, 0) }        # Green
    static [string] Warning() { return [VT]::RGB(255, 255, 0) }     # Yellow
    static [string] Error() { return [VT]::RGB(255, 0, 0) }         # Red
    static [string] Selected() { return [VT]::RGB(255, 255, 255) + [VT]::RGBBG(0, 64, 128) } # White on dark blue
    
    # Box drawing - single lines for speed
    static [string] TL() { return "" }     # Top left
    static [string] TR() { return "" }     # Top right
    static [string] BL() { return "" }     # Bottom left
    static [string] BR() { return "" }     # Bottom right
    static [string] H() { return "" }      # Horizontal
    static [string] V() { return "" }      # Vertical
    static [string] Cross() { return "" }  # Cross
    static [string] T() { return "" }      # T down
    static [string] B() { return "" }      # T up
    static [string] L() { return "" }      # T right
    static [string] R() { return "" }      # T left
    
    # Double lines for emphasis
    static [string] DTL() { return "" }
    static [string] DTR() { return "" }
    static [string] DBL() { return "" }
    static [string] DBR() { return "" }
    static [string] DH() { return "" }
    static [string] DV() { return "" }
}

# Layout measurement helpers
class Measure {
    static [int] TextWidth([string]$text) {
        # Remove ANSI sequences for accurate measurement
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        return $clean.Length
    }
    
    static [string] Truncate([string]$text, [int]$maxWidth) {
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        if ($clean.Length -le $maxWidth) { return $text }
        return $clean.Substring(0, $maxWidth - 3) + "..."
    }
    
    static [string] Pad([string]$text, [int]$width, [string]$align = "Left") {
        $textWidth = [Measure]::TextWidth($text)
        if ($textWidth -ge $width) { return [Measure]::Truncate($text, $width) }
        
        $padding = $width - $textWidth
        switch ($align) {
            "Left" { return $text + (" " * $padding) }
            "Right" { return (" " * $padding) + $text }
            "Center" { 
                $left = [int]($padding / 2)
                $right = $padding - $left
                return (" " * $left) + $text + (" " * $right)
            }
        }
        return $text
    }
}


####\Models/Project.ps1
# Project Model - Enhanced project definition based on PMC pattern

class Project : BaseModel {
    [string]$FullProjectName
    [string]$Nickname
    [string]$ID1
    [string]$ID2
    [DateTime]$DateAssigned
    [DateTime]$BFDate
    [DateTime]$DateDue
    [string]$Note
    [string]$CAAPath
    [string]$RequestPath
    [string]$T2020Path
    [decimal]$CumulativeHrs
    [DateTime]$ClosedDate
    
    # Audit Information
    [string]$AuditType
    [string]$AuditProgram
    [string]$AuditCase
    [DateTime]$AuditStartDate
    [DateTime]$AuditPeriodFrom
    [DateTime]$AuditPeriodTo
    
    # Additional Audit Periods
    [DateTime]$AuditPeriod1Start
    [DateTime]$AuditPeriod1End
    [DateTime]$AuditPeriod2Start
    [DateTime]$AuditPeriod2End
    [DateTime]$AuditPeriod3Start
    [DateTime]$AuditPeriod3End
    [DateTime]$AuditPeriod4Start
    [DateTime]$AuditPeriod4End
    [DateTime]$AuditPeriod5Start
    [DateTime]$AuditPeriod5End
    
    # Client Information
    [string]$ClientID  # TPNum
    [string]$Address
    [string]$City
    [string]$Province
    [string]$PostalCode
    [string]$Country
    [string]$ShipToAddress
    
    # Auditor Information
    [string]$AuditorName
    [string]$AuditorPhone
    [string]$AuditorTL
    [string]$AuditorTLPhone
    
    # Contact Information
    [string]$Contact1Name
    [string]$Contact1Phone
    [string]$Contact1Ext
    [string]$Contact1Address
    [string]$Contact1Title
    [string]$Contact2Name
    [string]$Contact2Phone
    [string]$Contact2Ext
    [string]$Contact2Address
    [string]$Contact2Title
    
    # System Information
    [string]$AccountingSoftware1
    [string]$AccountingSoftware1Other
    [string]$AccountingSoftware1Type
    [string]$AccountingSoftware2
    [string]$AccountingSoftware2Other
    [string]$AccountingSoftware2Type
    
    # Other Information
    [DateTime]$RequestDate
    [string]$FXInfo
    [string]$Comments
    
    # Status tracking (not from Excel)
    [string]$Status = "Active"
    
    # Default constructor
    Project() : base() {
        $this.FullProjectName = ""
        $this.Nickname = ""
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Project([string]$fullName, [string]$nickname) : base() {
        $this.FullProjectName = $fullName
        $this.Nickname = $nickname
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Legacy constructor for backward compatibility
    Project([string]$name) : base() {
        $this.FullProjectName = $name
        $this.Nickname = $name
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
}


####\Models/Subtask.ps1
# Subtask.ps1 - Subtask model extending the Task system

class Subtask : BaseModel {
    [string]$ParentTaskId  # Links to parent Task.Id
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [int]$SortOrder = 0  # For ordering subtasks within parent
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    # Estimated and actual time tracking
    [int]$EstimatedMinutes = 0
    [int]$ActualMinutes = 0
    
    Subtask() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Subtask([string]$parentTaskId) : base() {
        $this.ParentTaskId = $parentTaskId
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[]" }
            ([TaskStatus]::Cancelled) { return "[]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "" }
            ([TaskPriority]::Medium) { return "" }
            ([TaskPriority]::High) { return "" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
    
    [string] GetDurationDisplay() {
        if ($this.EstimatedMinutes -eq 0) {
            return ""
        }
        
        $estimated = $this.FormatMinutes($this.EstimatedMinutes)
        if ($this.ActualMinutes -gt 0) {
            $actual = $this.FormatMinutes($this.ActualMinutes)
            return "$actual / $estimated"
        } else {
            return "~$estimated"
        }
    }
    
    [string] FormatMinutes([int]$minutes) {
        if ($minutes -lt 60) {
            return "$($minutes)m"
        } elseif ($minutes -lt 480) {  # Less than 8 hours
            $hours = [Math]::Floor($minutes / 60)
            $mins = $minutes % 60
            if ($mins -eq 0) {
                return "$($hours)h"
            } else {
                return "$($hours)h$($mins)m"
            }
        } else {
            $hours = [Math]::Round($minutes / 60.0, 1)
            return "$($hours)h"
        }
    }
    
    [bool] IsCompleted() {
        return $this.Status -eq [TaskStatus]::Completed
    }
    
    [bool] IsInProgress() {
        return $this.Status -eq [TaskStatus]::InProgress
    }
    
    [bool] IsPending() {
        return $this.Status -eq [TaskStatus]::Pending
    }
}


####\Models/Task.ps1
# Task.ps1 - Task model

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

class Task : BaseModel {
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [string]$ProjectId = ""
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    Task() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[]" }
            ([TaskStatus]::Cancelled) { return "[]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "" }
            ([TaskPriority]::Medium) { return "" }
            ([TaskPriority]::High) { return "" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
}


####\Models/TimeCode.ps1
# TimeCode Model - Non-project time codes (vacation, admin, etc.)

class TimeCode : BaseModel {
    [string]$ID2               # 3-5 character code (e.g., "VAC", "SICK", "ADMIN")
    [string]$Description       # Optional description for display
    [bool]$IsActive           # Whether this code is currently in use
    [int]$DisplayOrder        # For sorting common codes to top
    
    TimeCode() : base() {
        $this.IsActive = $true
        $this.DisplayOrder = 999  # Default to bottom
    }
    
    TimeCode([string]$id2) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = ""
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    TimeCode([string]$id2, [string]$description) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = $description
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    [string] GetDisplayName() {
        if ($this.Description) {
            return "$($this.ID2) - $($this.Description)"
        }
        return $this.ID2
    }
    
    # Static method to get common time codes
    static [TimeCode[]] GetCommonCodes() {
        return @(
            [TimeCode]::new("VAC", "Vacation"),
            [TimeCode]::new("SICK", "Sick Leave"),
            [TimeCode]::new("STAT", "Statutory Holiday"),
            [TimeCode]::new("ADMIN", "Administration"),
            [TimeCode]::new("TRAIN", "Training"),
            [TimeCode]::new("MTG", "Meetings"),
            [TimeCode]::new("PD", "Professional Development")
        )
    }
}


####\Models/TimeEntry.ps1
# TimeEntry Model - Universal time tracking for projects and non-project codes

class TimeEntry : BaseModel {
    [string]$WeekEndingFriday  # Friday date in yyyyMMdd format
    [string]$Name              # Project name or empty for non-project
    [string]$ID1               # Project ID1 or empty for non-project
    [string]$ID2               # Project ID2 or non-project code (3-5 chars)
    [decimal]$Monday
    [decimal]$Tuesday
    [decimal]$Wednesday
    [decimal]$Thursday
    [decimal]$Friday
    [decimal]$Total            # Calculated total for the week
    [string]$FiscalYear       # Format: "2024-2025" (Apr 1 2024 - Mar 31 2025)
    
    TimeEntry() : base() {
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    TimeEntry([string]$weekEndingFriday, [string]$id2) : base() {
        $this.WeekEndingFriday = $weekEndingFriday
        $this.ID2 = $id2
        $this.Name = ""
        $this.ID1 = ""
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    [void] CalculateTotal() {
        $this.Total = $this.Monday + $this.Tuesday + $this.Wednesday + $this.Thursday + $this.Friday
    }
    
    [void] CalculateFiscalYear() {
        if (-not $this.WeekEndingFriday) {
            $fridayDate = [DateTime]::Now
            while ($fridayDate.DayOfWeek -ne [DayOfWeek]::Friday) {
                $fridayDate = $fridayDate.AddDays(1)
            }
            $this.WeekEndingFriday = $fridayDate.ToString("yyyyMMdd")
        }
        
        $date = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        
        # Fiscal year runs April 1 - March 31
        if ($date.Month -ge 4) {
            # April through December - fiscal year starts this calendar year
            $fiscalStart = $date.Year
        } else {
            # January through March - fiscal year started last calendar year
            $fiscalStart = $date.Year - 1
        }
        
        $this.FiscalYear = "$fiscalStart-$($fiscalStart + 1)"
    }
    
    [bool] IsProjectEntry() {
        # Non-project entries have 3-5 character ID2 codes
        return $this.ID2.Length -gt 5
    }
    
    [DateTime] GetWeekStartMonday() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return $fridayDate.AddDays(-4)  # Monday is 4 days before Friday
    }
    
    [string] GetWeekDisplayString() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return "Week ending " + $fridayDate.ToString("MM/dd/yyyy")
    }
}


####\Screens/ConfirmationDialog.ps1
# ConfirmationDialog.ps1 - Generic confirmation dialog using BaseDialog

class ConfirmationDialog : BaseDialog {
    [string]$Message
    [string]$ConfirmText = "Yes"
    [string]$CancelText = "No"
    
    ConfirmationDialog([string]$message) : base("Confirm") {
        $this.Message = $message
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    [void] InitializeContent() {
        # Base dialog handles button creation, we just need to update button texts if needed
        if ($this.PrimaryButton -and $this.ConfirmText -ne "Yes") {
            $this.PrimaryButton.Text = $this.ConfirmText
        }
        
        if ($this.SecondaryButton -and $this.CancelText -ne "No") {
            $this.SecondaryButton.Text = $this.CancelText
        }
        
        # No additional content controls needed for simple confirmation
        # The message is rendered directly in the dialog
    }
    
    [void] OnActivated() {
        ([BaseDialog]$this).OnActivated()
        # Override to focus on cancel button by default (safer)
        if ($this.SecondaryButton) {
            $this.SecondaryButton.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on message
        $messageLines = $this.Message -split "`n"
        $maxLineLength = ($messageLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $this.DialogWidth = [Math]::Max(40, $maxLineLength + 8)
        $this.DialogHeight = 10 + $messageLines.Count
        
        # Let base class handle the rest
        ([BaseDialog]$this).OnBoundsChanged()
    }
    
    # Override HandleScreenInput to add Y/N shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Y/N shortcuts specific to confirmation dialog
        switch ($key.Key) {
            ([System.ConsoleKey]::Y) {
                if ($key.KeyChar -eq 'Y' -or $key.KeyChar -eq 'y') {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::N) {
                if ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n') {
                    $this.HandleSecondaryAction()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render the base dialog (overlay, box, title, buttons)
        $baseRender = ([BaseDialog]$this).OnRender()
        $sb.Append($baseRender)
        
        # Add our custom content - the message and hint
        if ($this._dialogBounds -and $this._dialogBounds.Count -gt 0) {
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Draw warning icon in title
            $title = "  Confirm "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($this.Theme.GetColor("warning"))
            $sb.Append($title)
            
            # Draw message
            $messageLines = $this.Message -split "`n"
            $messageY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $messageLines) {
                $lineX = $x + [int](($w - $line.Length) / 2)
                $sb.Append([VT]::MoveTo($lineX, $messageY))
                $sb.Append($line)
                $messageY++
            }
            
            # Draw hint
            $hint = "[Y/N] or use Tab to select"
            $hintX = $x + [int](($w - $hint.Length) / 2)
            $sb.Append([VT]::MoveTo($hintX, $y + $h - 2))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append($hint)
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/DashboardScreen.ps1
# DashboardScreen.ps1 - Ultra-complex dashboard to stress-test layout system
# Layout: Main HorizontalSplit -> Left: Project overview, Right: VerticalSplit -> Top: Task metrics, Bottom: GridPanel with action buttons

class DashboardScreen : Screen {
    # Main layout structure
    [HorizontalSplit]$MainLayout
    [VerticalSplit]$RightLayout
    [GridPanel]$ActionGrid
    [HorizontalSplit]$TopRightLayout
    [VerticalSplit]$MetricsLayout
    
    # Left pane components (Project Overview)
    [ListBox]$ProjectList
    [ListBox]$RecentActivity
    [VerticalSplit]$LeftLayout
    
    # Top-right pane components (Task Metrics & Charts)
    [ListBox]$TaskList
    [ListBox]$PriorityBreakdown
    [ListBox]$StatusChart
    [GridPanel]$MetricBoxes
    
    # Bottom-right pane (Action buttons)
    [Button]$NewProjectBtn
    [Button]$NewTaskBtn
    [Button]$ExportBtn
    [Button]$SettingsBtn
    [Button]$RefreshBtn
    [Button]$HelpBtn
    [Button]$ReportsBtn
    [Button]$ArchiveBtn
    
    # Services
    [ProjectService]$ProjectService
    [TaskService]$TaskService
    [EventBus]$EventBus
    
    # Data for complex displays
    hidden [array]$_projectStats
    hidden [array]$_taskMetrics
    hidden [array]$_recentActivities
    hidden [bool]$_isLoading = $false
    hidden [hashtable]$_loadingProgress = @{
        Projects = 0
        Tasks = 0
        Activity = 0
        Metrics = 0
    }
    
    DashboardScreen() : base() {
        $this.Title = "PRAXIS Dashboard"
    }
    
    [void] OnInitialize() {
        Write-Host "Initializing ultra-complex dashboard..."
        
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to data loading events for background updates
        $this.SetupEventHandlers()
        
        # Create the incredibly complex nested layout structure
        $this.BuildMasterLayout()
        $this.BuildLeftPane()
        $this.BuildRightPane()
        
        # Show initial loading state
        $this.ShowLoadingState()
        
        # Start background data loading (non-blocking)
        $this.StartBackgroundDataLoad()
        
        Write-Host "Dashboard initialized with maximum complexity!"
    }
    
    [void] BuildMasterLayout() {
        Write-Host "Building master layout structure..."
        
        # Main horizontal split: 40% left (projects), 60% right (tasks & actions)
        $this.MainLayout = [HorizontalSplit]::new()
        $this.MainLayout.SetSplitRatio(40)
        $this.MainLayout.ShowBorder = $false
        $this.MainLayout.Initialize($global:ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Left side: Vertical split for project list + recent activity
        $this.LeftLayout = [VerticalSplit]::new()
        $this.LeftLayout.SetSplitRatio(65)  # 65% project list, 35% recent activity
        $this.LeftLayout.ShowBorder = $false
        $this.LeftLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetLeftPane($this.LeftLayout)
        
        # Right side: Vertical split for task metrics + action buttons
        $this.RightLayout = [VerticalSplit]::new()
        $this.RightLayout.SetSplitRatio(75)  # 75% metrics, 25% buttons
        $this.RightLayout.ShowBorder = $false
        $this.RightLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetRightPane($this.RightLayout)
    }
    
    [void] BuildLeftPane() {
        Write-Host "Building left pane with project overview..."
        
        # Top-left: Project List with statistics
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = " Project Overview"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { " OVERDUE" } elseif ($daysLeft -lt 7) { "  DUE SOON" } elseif ($daysLeft -lt 30) { " $daysLeft days" } else { " $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        $this.ProjectList.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetTopPane($this.ProjectList)
        
        # Bottom-left: Recent Activity Feed
        $this.RecentActivity = [ListBox]::new()
        $this.RecentActivity.Title = " Recent Activity"
        $this.RecentActivity.ShowBorder = $true
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "" }
                "TaskCompleted" { "" }
                "TaskCreated" { "" }
                "ProjectUpdated" { "" }
                default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
        $this.RecentActivity.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetBottomPane($this.RecentActivity)
    }
    
    [void] BuildRightPane() {
        Write-Host "Building right pane with metrics and controls..."
        
        # Top-right: Another horizontal split for task metrics
        $this.TopRightLayout = [HorizontalSplit]::new()
        $this.TopRightLayout.SetSplitRatio(50)  # Equal split for metrics
        $this.TopRightLayout.ShowBorder = $false
        $this.TopRightLayout.Initialize($global:ServiceContainer)
        
        # Nested vertical split in the left side of top-right
        $this.MetricsLayout = [VerticalSplit]::new()
        $this.MetricsLayout.SetSplitRatio(50)
        $this.MetricsLayout.ShowBorder = $false
        $this.MetricsLayout.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetLeftPane($this.MetricsLayout)
        
        # Task List (top of metrics)
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = " Active Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }
                "Medium" { "" }
                "Low" { "" }
                default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }
                "Done" { "" }
                "Blocked" { "" }
                default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetTopPane($this.TaskList)
        
        # Priority Breakdown (bottom of metrics)
        $this.PriorityBreakdown = [ListBox]::new()
        $this.PriorityBreakdown.Title = " Priority Distribution"
        $this.PriorityBreakdown.ShowBorder = $true
        $this.PriorityBreakdown.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetBottomPane($this.PriorityBreakdown)
        
        # Status Chart (right side of top-right)
        $this.StatusChart = [ListBox]::new()
        $this.StatusChart.Title = " Status Overview"
        $this.StatusChart.ShowBorder = $true
        $this.StatusChart.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetRightPane($this.StatusChart)
        
        # Set the complex top layout
        $this.RightLayout.SetTopPane($this.TopRightLayout)
        
        # Bottom-right: Action button grid (4x2 = 8 buttons)
        $this.ActionGrid = [GridPanel]::new(4)  # 4 columns
        $this.ActionGrid.ShowBorder = $true
        $this.ActionGrid.CellSpacing = 1
        $this.ActionGrid.Initialize($global:ServiceContainer)
        
        # Create all the action buttons with cool icons and actions
        $this.CreateActionButtons()
        
        $this.RightLayout.SetBottomPane($this.ActionGrid)
    }
    
    [void] CreateActionButtons() {
        Write-Host "Creating interactive action buttons..."
        
        # Capture $this reference for use in button handlers
        $dashboardRef = $this
        
        # Button 1: New Project
        $this.NewProjectBtn = [Button]::new(" New Project")
        $this.NewProjectBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Project button clicked")
            }
            # Create new project dialog
            $dialog = [NewProjectDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewProjectBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewProjectBtn)
        
        # Button 2: New Task
        $this.NewTaskBtn = [Button]::new(" New Task")
        $this.NewTaskBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Task button clicked")
            }
            # Create new task dialog
            $dialog = [NewTaskDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewTaskBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewTaskBtn)
        
        # Button 3: Export Data
        $this.ExportBtn = [Button]::new(" Export")
        $this.ExportBtn.OnClick = { 
            Write-Host "Dashboard: Exporting data..."
            # TODO: Implement export functionality
        }.GetNewClosure()
        $this.ExportBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ExportBtn)
        
        # Button 4: Settings
        $this.SettingsBtn = [Button]::new("  Settings")
        $this.SettingsBtn.OnClick = { 
            Write-Host "Dashboard: Opening settings..."
            # TODO: Switch to settings screen
        }.GetNewClosure()
        $this.SettingsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.SettingsBtn)
        
        # Button 5: Refresh Data
        $this.RefreshBtn = [Button]::new(" Refresh")
        $this.RefreshBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Refresh button clicked - reloading all data")
            }
            $dashboardRef.ShowLoadingState()
            $dashboardRef.StartBackgroundDataLoad()
        }.GetNewClosure()
        $this.RefreshBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.RefreshBtn)
        
        # Button 6: Help
        $this.HelpBtn = [Button]::new(" Help")
        $helpBtnRef = $this.HelpBtn
        $this.HelpBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Help button clicked")
            }
            # Change button text to show it was clicked
            $helpBtnRef.Text = " Clicked!"
            $helpBtnRef.Invalidate()
            # TODO: Show help dialog
        }.GetNewClosure()
        $this.HelpBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.HelpBtn)
        
        # Button 7: Reports
        $this.ReportsBtn = [Button]::new(" Reports")
        $this.ReportsBtn.OnClick = { 
            Write-Host "Dashboard: Generating reports..."
            # TODO: Generate analytics reports
        }.GetNewClosure()
        $this.ReportsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ReportsBtn)
        
        # Button 8: Archive
        $this.ArchiveBtn = [Button]::new(" Archive")
        $this.ArchiveBtn.OnClick = { 
            Write-Host "Dashboard: Managing archives..."
            # TODO: Archive management
        }.GetNewClosure()
        $this.ArchiveBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ArchiveBtn)
    }
    
    [void] LoadAllData() {
        Write-Host "Loading complex dashboard data..."
        
        # Load project data with statistics
        $projects = @()
        if ($this.ProjectService) {
            $allProjects = $this.ProjectService.GetAllProjects()
            $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
        }
        
        # Add some demo projects if empty
        if ($projects.Count -eq 0) {
            $projects = @(
                @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
            )
        }
        
        $this.ProjectList.SetItems($projects)
        
        # Load task data with complex metrics
        $tasks = @()
        if ($this.TaskService) {
            $allTasks = $this.TaskService.GetAllTasks()
            $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
        }
        
        # Add demo tasks if empty
        if ($tasks.Count -eq 0) {
            $tasks = @(
                @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
            )
        }
        
        $this.TaskList.SetItems($tasks)
        
        # Generate priority breakdown with visual charts
        $priorityStats = @(
            " High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
            " Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
            " Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
            ""
            "Progress Overview:"
            " 60% Complete"
            "Active: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count) tasks"
            "Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count) tasks"
        )
        $this.PriorityBreakdown.SetItems($priorityStats)
        
        # Create status chart with ASCII visualization
        $completedTasks = if ($this.TaskService) { 
            @($this.TaskService.GetAllTasks() | Where-Object { $_.Status -eq "Done" }).Count
        } else { 8 }
        
        $totalTasks = $completedTasks + $tasks.Count
        $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
        
        $statusData = @(
            " Project Health Dashboard"
            ""
            "Completion Rate: $completionRate%"
            "[$('' * [int]($completionRate/10))$('' * (10 - [int]($completionRate/10)))]"
            ""
            " Completed: $completedTasks"
            " In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
            " Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
            " Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            ""
            " Productivity Score: $(Get-Random -Minimum 75 -Maximum 98)%"
        )
        $this.StatusChart.SetItems($statusData)
        
        # Create realistic recent activity feed
        $this.LoadRecentActivity()
        
        Write-Host "Dashboard data loaded successfully!"
    }
    
    [void] LoadRecentActivity() {
        $activities = @(
            @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
            @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
            @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
            @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
            @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            @{ Type = "TaskCreated"; Message = "Created performance task"; Time = "1 day ago" }
            @{ Type = "ProjectCreated"; Message = "Initialized Testing Framework"; Time = "2 days ago" }
        )
        
        $this.RecentActivity.SetItems($activities)
    }
    
    [void] SetupEventHandlers() {
        # Subscribe to background data loading completion events
        $dashboardRef = $this
        
        $this.EventBus.Subscribe('dashboard.data.projects.loaded', {
            param($sender, $data)
            if ($data.Projects) {
                $dashboardRef.ProjectList.SetItems($data.Projects)
                $dashboardRef._loadingProgress.Projects = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.tasks.loaded', {
            param($sender, $data)
            if ($data.Tasks) {
                $dashboardRef.TaskList.SetItems($data.Tasks)
                $dashboardRef._loadingProgress.Tasks = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.activity.loaded', {
            param($sender, $data)
            if ($data.Activities) {
                $dashboardRef.RecentActivity.SetItems($data.Activities)
                $dashboardRef._loadingProgress.Activity = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.metrics.loaded', {
            param($sender, $data)
            if ($data.PriorityStats) {
                $dashboardRef.PriorityBreakdown.SetItems($data.PriorityStats)
            }
            if ($data.StatusData) {
                $dashboardRef.StatusChart.SetItems($data.StatusData)
            }
            $dashboardRef._loadingProgress.Metrics = 100
            $dashboardRef.UpdateLoadingStatus()
        }.GetNewClosure())
    }
    
    [void] ShowLoadingState() {
        # Display loading indicators in each component
        $loadingProjects = @(
            " Loading project data...",
            "   Please wait..."
        )
        $this.ProjectList.SetItems($loadingProjects)
        
        $loadingTasks = @(
            " Loading task list...",
            "   Fetching from database..."
        )
        $this.TaskList.SetItems($loadingTasks)
        
        $loadingActivity = @(
            " Loading recent activity...",
            "   Analyzing events..."
        )
        $this.RecentActivity.SetItems($loadingActivity)
        
        $loadingMetrics = @(
            " Calculating metrics...",
            "   Processing data..."
        )
        $this.PriorityBreakdown.SetItems($loadingMetrics)
        $this.StatusChart.SetItems($loadingMetrics)
    }
    
    [void] StartBackgroundDataLoad() {
        if ($this._isLoading) {
            Write-Host "Data loading already in progress"
            return
        }
        
        $this._isLoading = $true
        $this._loadingProgress = @{
            Projects = 0
            Tasks = 0
            Activity = 0
            Metrics = 0
        }
        
        # Use PowerShell jobs for true background loading
        $projService = $this.ProjectService
        $taskSvc = $this.TaskService
        $evtBus = $this.EventBus
        
        # Load projects in background
        $projectJob = Start-Job -ScriptBlock {
            param($service, $evtBus)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 800
            
            $projects = @()
            if ($service) {
                $allProjects = $service.GetAllProjects()
                $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
            }
            
            if ($projects.Count -eq 0) {
                $projects = @(
                    @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                    @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                    @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                    @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
                )
            }
            
            # Process projects
            foreach ($project in $projects) {
                $project.ClosedDate = if ($project.ClosedDate) { $project.ClosedDate } else { [DateTime]::MinValue }
                $project.DateDue = if ($project.DateDue) { $project.DateDue } else { [DateTime]::Now.AddDays(30) }
            }
            
            return $projects
        } -ArgumentList $projService, $evtBus
        
        # Load tasks in background
        $taskJob = Start-Job -ScriptBlock {
            param($service)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 1200
            
            $tasks = @()
            if ($service) {
                $allTasks = $service.GetAllTasks()
                $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
            }
            
            if ($tasks.Count -eq 0) {
                $tasks = @(
                    @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                    @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                    @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                    @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
                )
            }
            
            return $tasks
        } -ArgumentList $taskSvc
        
        # Monitor jobs and publish events when complete
        $monitorJob = Start-Job -ScriptBlock {
            param($projectJob, $taskJob, $evtBus)
            
            # Wait for project job
            $projects = Receive-Job -Job $projectJob -Wait
            $evtBus.Publish('dashboard.data.projects.loaded', @{ Projects = $projects })
            
            # Wait for task job
            $tasks = Receive-Job -Job $taskJob -Wait
            $evtBus.Publish('dashboard.data.tasks.loaded', @{ Tasks = $tasks })
            
            # Generate metrics based on loaded data
            Start-Sleep -Milliseconds 500
            
            $priorityStats = @(
                " High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
                " Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
                " Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
                ""
                "Progress Overview:"
                " 60% Complete"
            )
            
            $completedTasks = @($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $totalTasks = $tasks.Count + $completedTasks
            $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
            
            $statusData = @(
                " Project Health Dashboard"
                ""
                "Completion Rate: $completionRate%"
                "[$('' * [int]($completionRate/10))$('' * (10 - [int]($completionRate/10)))]"
                ""
                " Completed: $completedTasks"
                " In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
                " Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
                " Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            )
            
            $evtBus.Publish('dashboard.data.metrics.loaded', @{ 
                PriorityStats = $priorityStats
                StatusData = $statusData 
            })
            
            # Load activity data
            Start-Sleep -Milliseconds 300
            $activities = @(
                @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
                @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
                @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
                @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
                @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            )
            
            $evtBus.Publish('dashboard.data.activity.loaded', @{ Activities = $activities })
            
            # Clean up jobs
            Remove-Job -Job $projectJob -Force
            Remove-Job -Job $taskJob -Force
            
        } -ArgumentList $projectJob, $taskJob, $evtBus
        
        # Set up item renderers that will be used when data loads
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { " OVERDUE" } elseif ($daysLeft -lt 7) { "  DUE SOON" } elseif ($daysLeft -lt 30) { " $daysLeft days" } else { " $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }
                "Medium" { "" }
                "Low" { "" }
                default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }
                "Done" { "" }
                "Blocked" { "" }
                default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "" }
                "TaskCompleted" { "" }
                "TaskCreated" { "" }
                "ProjectUpdated" { "" }
                default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
    }
    
    [void] UpdateLoadingStatus() {
        # Check if all data has loaded
        $totalProgress = ($this._loadingProgress.Projects + $this._loadingProgress.Tasks + 
                         $this._loadingProgress.Activity + $this._loadingProgress.Metrics) / 4
        
        if ($totalProgress -eq 100) {
            $this._isLoading = $false
            Write-Host "Dashboard data fully loaded!"
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Set initial focus to ProjectList
        if ($this.ProjectList) {
            $this.ProjectList.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Update the main layout to fill the entire screen
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Handle dashboard-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::F5) {
                $this.ShowLoadingState()
                $this.StartBackgroundDataLoad()
                Write-Host "Dashboard refresh started!"
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.ShowLoadingState()
                    $this.StartBackgroundDataLoad()
                    Write-Host "Dashboard data reload started!"
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        return $false
    }
    
}


####\Screens/EditProjectDialog.ps1
# EditProjectDialog.ps1 - Dialog for editing existing projects

class EditProjectDialog : BaseDialog {
    [Project]$Project
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$ID1Box
    [TextBox]$ID2Box
    [TextBox]$NoteBox
    [TextBox]$CAAPathBox
    [TextBox]$RequestPathBox
    [TextBox]$T2020PathBox
    [TextBox]$DueDateBox
    
    EditProjectDialog([Project]$project) : base("Edit Project") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 22
    }
    
    [void] InitializeContent() {
        # Create all project input fields with current values
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Text = $this.Project.FullProjectName
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Text = $this.Project.Nickname
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [TextBox]::new()
        $this.ID1Box.Text = $this.Project.ID1
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [TextBox]::new()
        $this.ID2Box.Text = $this.Project.ID2
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NoteBox = [TextBox]::new()
        $this.NoteBox.Text = $this.Project.Note
        $this.NoteBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NoteBox, 5)
        
        $this.CAAPathBox = [TextBox]::new()
        $this.CAAPathBox.Text = $this.Project.CAAPath
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [TextBox]::new()
        $this.RequestPathBox.Text = $this.Project.RequestPath
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [TextBox]::new()
        $this.T2020PathBox.Text = $this.Project.T2020Path
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Text = $this.Project.DateDue.ToString("MM/dd/yyyy")
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action (Save)
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = $dialog.Project.DateDue
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Keep original date if parsing fails
                    }
                }
                
                # Update project properties
                $dialog.Project.FullProjectName = $dialog.NameBox.Text
                $dialog.Project.Nickname = $dialog.NicknameBox.Text
                $dialog.Project.ID1 = $dialog.ID1Box.Text
                $dialog.Project.ID2 = $dialog.ID2Box.Text
                $dialog.Project.Note = $dialog.NoteBox.Text
                $dialog.Project.CAAPath = $dialog.CAAPathBox.Text
                $dialog.Project.RequestPath = $dialog.RequestPathBox.Text
                $dialog.Project.T2020Path = $dialog.T2020PathBox.Text
                $dialog.Project.DateDue = $dueDate
                $dialog.Project.UpdatedAt = [DateTime]::Now
                
                # Save via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    $projectService.SaveProject($dialog.Project)
                }
                
                # Publish event if EventBus available
                if ($dialog.EventBus) {
                    $dialog.EventBus.Publish([EventNames]::ProjectUpdated, @{ 
                        Project = $dialog.Project 
                    })
                    
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'EditProjectDialog'
                        Action = 'Save'
                        Data = $dialog.Project
                    })
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action (Cancel)
        $this.OnSecondary = {
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'EditProjectDialog'
                    Action = 'Cancel'
                })
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields (same as NewProjectDialog)
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 2)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 2)
        $currentY += 2
        
        $this.NoteBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
    }
}


####\Screens/EditTaskDialog.ps1
# EditTaskDialog.ps1 - Dialog for editing existing tasks

class EditTaskDialog : Screen {
    [Task]$Task
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$StatusList
    [ListBox]$PriorityList
    [TextBox]$ProgressBox
    [Button]$SaveButton
    [Button]$CancelButton
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    EditTaskDialog([Task]$task) : base() {
        $this.Title = "Edit Task"
        $this.Task = $task
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Text = $this.Task.Title
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Text = $this.Task.Description
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create status list
        $this.StatusList = [ListBox]::new()
        $this.StatusList.Title = "Status"
        $this.StatusList.ShowBorder = $true
        $this.StatusList.Initialize($global:ServiceContainer)
        $this.StatusList.SetItems(@(
            @{Name="Pending"; Value=[TaskStatus]::Pending},
            @{Name="In Progress"; Value=[TaskStatus]::InProgress},
            @{Name="Completed"; Value=[TaskStatus]::Completed},
            @{Name="Cancelled"; Value=[TaskStatus]::Cancelled}
        ))
        $this.StatusList.ItemRenderer = { param($item) $item.Name }
        # Select current status
        for ($i = 0; $i -lt $this.StatusList.Items.Count; $i++) {
            if ($this.StatusList.Items[$i].Value -eq $this.Task.Status) {
                $this.StatusList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.StatusList)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.Initialize($global:ServiceContainer)
        $this.PriorityList.SetItems(@(
            @{Name="Low"; Value=[TaskPriority]::Low},
            @{Name="Medium"; Value=[TaskPriority]::Medium},
            @{Name="High"; Value=[TaskPriority]::High}
        ))
        $this.PriorityList.ItemRenderer = { param($item) $item.Name }
        # Select current priority
        for ($i = 0; $i -lt $this.PriorityList.Items.Count; $i++) {
            if ($this.PriorityList.Items[$i].Value -eq $this.Task.Priority) {
                $this.PriorityList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.PriorityList)
        
        # Create progress textbox
        $this.ProgressBox = [TextBox]::new()
        $this.ProgressBox.Text = $this.Task.Progress.ToString()
        $this.ProgressBox.Placeholder = "0-100"
        $this.ProgressBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProgressBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        # Capture dialog reference
        $dialog = $this
        $this.SaveButton.OnClick = {
            if ($dialog.TitleBox.Text.Trim()) {
                $selectedStatus = $dialog.StatusList.GetSelectedItem()
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $progress = 0
                if ([int]::TryParse($dialog.ProgressBox.Text, [ref]$progress)) {
                    $progress = [Math]::Max(0, [Math]::Min(100, $progress))
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave @{
                        Title = $dialog.TitleBox.Text
                        Description = $dialog.DescriptionBox.Text
                        Status = if ($selectedStatus) { $selectedStatus.Value } else { $dialog.Task.Status }
                        Priority = if ($selectedPriority) { $selectedPriority.Value } else { $dialog.Task.Priority }
                        Progress = $progress
                    }
                }
            }
        }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($this.OnCancel) {
                    & $this.OnCancel
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $focused = $this.FindFocused()
                if ($focused -eq $this.SaveButton) {
                    & $this.SaveButton.OnClick
                } elseif ($focused -eq $this.CancelButton) {
                    & $this.CancelButton.OnClick
                }
                return $true
            }
        }
        
        # Let base class handle other keys (like Tab navigation)
        return ([Screen]$this).HandleInput($key)
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 65
        $dialogHeight = 22
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.TitleBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        $this.DescriptionBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        
        $this.StatusList.SetBounds($centerX + 2, $centerY + 10, 20, 6)
        $this.PriorityList.SetBounds($centerX + 24, $centerY + 10, 20, 5)
        $this.ProgressBox.SetBounds($centerX + 46, $centerY + 10, 16, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 17
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on title box
        $this.TitleBox.Focus()
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " Edit Task "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Title:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Description:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 9))
            $sb.Append("Status:")
            
            $sb.Append([VT]::MoveTo($x + 24, $y + 9))
            $sb.Append("Priority:")
            
            $sb.Append([VT]::MoveTo($x + 46, $y + 9))
            $sb.Append("Progress (%):")
            
            # Draw task info
            $sb.Append([VT]::MoveTo($x + 2, $y + 16))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append("Created: " + $this.Task.CreatedAt.ToString("yyyy-MM-dd HH:mm"))
            if ($this.Task.DueDate -ne [DateTime]::MinValue) {
                $sb.Append(" | Due: " + $this.Task.DueDate.ToString("yyyy-MM-dd"))
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/EventBusMonitor.ps1
# EventBusMonitor.ps1 - Dialog for monitoring EventBus activity

class EventBusMonitor : Screen {
    [TextBox]$InfoDisplay
    [Button]$RefreshButton
    [Button]$ToggleHistoryButton
    [Button]$ToggleDebugButton
    [Button]$ClearHistoryButton
    [Button]$CloseButton
    [EventBus]$EventBus
    hidden [System.Timers.Timer]$RefreshTimer
    
    EventBusMonitor() : base() {
        $this.Title = "EventBus Monitor"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create info display
        $this.InfoDisplay = [TextBox]::new()
        $this.InfoDisplay.ReadOnly = $true
        $this.InfoDisplay.ShowBorder = $true
        $this.InfoDisplay.Text = "Loading EventBus information..."
        $this.InfoDisplay.Initialize($global:ServiceContainer)
        $this.AddChild($this.InfoDisplay)
        
        # Create buttons
        $this.RefreshButton = [Button]::new("Refresh")
        $this.RefreshButton.OnClick = { $this.RefreshInfo() }
        $this.RefreshButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.RefreshButton)
        
        $this.ToggleHistoryButton = [Button]::new("Toggle History")
        $this.ToggleHistoryButton.OnClick = { $this.ToggleHistory() }
        $this.ToggleHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleHistoryButton)
        
        $this.ToggleDebugButton = [Button]::new("Toggle Debug")
        $this.ToggleDebugButton.OnClick = { $this.ToggleDebug() }
        $this.ToggleDebugButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleDebugButton)
        
        $this.ClearHistoryButton = [Button]::new("Clear History")
        $this.ClearHistoryButton.OnClick = { $this.ClearHistory() }
        $this.ClearHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ClearHistoryButton)
        
        $this.CloseButton = [Button]::new("Close")
        $this.CloseButton.IsDefault = $true
        $this.CloseButton.OnClick = { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        $this.CloseButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CloseButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        })
        $this.BindKey('r', { $this.RefreshInfo() })
        $this.BindKey('h', { $this.ToggleHistory() })
        $this.BindKey('d', { $this.ToggleDebug() })
        $this.BindKey('c', { $this.ClearHistory() })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        
        # Initial refresh
        $this.RefreshInfo()
        
        # Focus on close button
        $this.CloseButton.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout components
        $padding = 2
        $buttonHeight = 3
        $buttonWidth = 20
        $buttonSpacing = 2
        
        # Info display takes most of the space
        $this.InfoDisplay.SetBounds(
            $this.X + $padding,
            $this.Y + $padding,
            $this.Width - ($padding * 2),
            $this.Height - $buttonHeight - ($padding * 3)
        )
        
        # Buttons at the bottom
        $totalButtonWidth = ($buttonWidth * 5) + ($buttonSpacing * 4)
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - $padding
        
        $this.RefreshButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleHistoryButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleDebugButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 2, $buttonY, $buttonWidth, $buttonHeight)
        $this.ClearHistoryButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 3, $buttonY, $buttonWidth, $buttonHeight)
        $this.CloseButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 4, $buttonY, $buttonWidth, $buttonHeight)
    }
    
    [void] RefreshInfo() {
        if (-not $this.EventBus) { return }
        
        $report = $this.EventBus.GetDebugReport()
        
        # Add recent history if enabled
        if ($this.EventBus.EnableHistory) {
            $history = $this.EventBus.GetEventHistory()
            if ($history.Count -gt 0) {
                $report += "`n`nRecent Events:`n"
                $recent = $history | Select-Object -Last 10
                foreach ($event in $recent) {
                    $report += "  $($event.Timestamp.ToString('HH:mm:ss')) - $($event.EventName)`n"
                }
            }
        }
        
        # Add keyboard shortcuts
        $report += "`n`nKeyboard Shortcuts:`n"
        $report += "  [R] Refresh  [H] Toggle History  [D] Toggle Debug`n"
        $report += "  [C] Clear History  [Esc] Close"
        
        $this.InfoDisplay.Text = $report
        $this.InfoDisplay.Invalidate()
    }
    
    [void] ToggleHistory() {
        if ($this.EventBus) {
            $this.EventBus.EnableHistory = -not $this.EventBus.EnableHistory
            $this.RefreshInfo()
        }
    }
    
    [void] ToggleDebug() {
        if ($this.EventBus) {
            $this.EventBus.EnableDebugLogging = -not $this.EventBus.EnableDebugLogging
            $this.RefreshInfo()
        }
    }
    
    [void] ClearHistory() {
        if ($this.EventBus) {
            $this.EventBus.ClearHistory()
            $this.RefreshInfo()
        }
    }
    
    [void] FocusNext() {
        $focusableChildren = @($this.RefreshButton, $this.ToggleHistoryButton, 
                              $this.ToggleDebugButton, $this.ClearHistoryButton, 
                              $this.CloseButton)
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        # Move to next
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ExcelImportScreen.ps1
# ExcelImportScreen.ps1 - Excel import screen using PRAXIS patterns

class ExcelImportScreen : Screen {
    [FastFileTree]$FileTree
    [ListBox]$PreviewList
    [Button]$ImportButton
    [Button]$BackButton
    [ProgressBar]$ImportProgress
    [string]$SelectedFile
    [hashtable]$ImportedData
    [string]$StatusMessage = "Select an Excel file to import (SVI-CAS worksheet)"
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$StatusBarHeight = 1
    hidden [int]$ProgressHeight = 3
    
    ExcelImportScreen() : base() {
        $this.Title = "Excel Import"
    }
    
    [void] OnInitialize() {
        # Create file tree for Excel file selection
        $this.FileTree = [FastFileTree]::new()
        $this.FileTree.ShowBorder = $true
        $this.FileTree.Title = "Select Excel File"
        $this.FileTree.FileExtensions = @('.xlsx', '.xlsm', '.xls')
        $this.FileTree.ShowSize = $true
        $this.AddChild($this.FileTree)
        
        # Start with current directory
        $this.FileTree.LoadDirectory((Get-Location).Path)
        
        # Create preview list
        $this.PreviewList = [ListBox]::new()
        $this.PreviewList.Title = "Import Preview"
        $this.PreviewList.ShowBorder = $true
        $this.AddChild($this.PreviewList)
        
        # Create progress bar (initially hidden)
        $this.ImportProgress = [ProgressBar]::new()
        $this.ImportProgress.IsVisible = $false
        $this.AddChild($this.ImportProgress)
        
        # Create buttons
        $screen = $this  # Capture reference for closures
        
        $this.ImportButton = [Button]::new("Import")
        $this.ImportButton.IsEnabled = $false
        $this.ImportButton.OnClick = { $screen.StartImport() }.GetNewClosure()
        $this.AddChild($this.ImportButton)
        
        $this.BackButton = [Button]::new("Back")
        $this.BackButton.OnClick = { 
            $screen.ServiceContainer.GetService('ScreenManager').PopScreen() 
        }.GetNewClosure()
        $this.AddChild($this.BackButton)
        
        # Set up file selection handler
        $this.FileTree.OnFileSelected = {
            param($filePath)
            if ($filePath -match '\.xls[xm]?$') {
                $screen.SelectedFile = $filePath
                $screen.StatusMessage = "Selected: $(Split-Path $filePath -Leaf)"
                $screen.ImportButton.IsEnabled = $true
                $screen.PreviewFile()
                $screen.Invalidate()
            }
        }.GetNewClosure()
        
        # Key bindings
        $this.AddKeyBinding([ConsoleKey]::Escape, { 
            $this.ServiceContainer.GetService('ScreenManager').PopScreen() 
        })
        $this.AddKeyBinding([ConsoleKey]::I, { 
            if ($this.ImportButton.IsEnabled) { $this.StartImport() } 
        })
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.FileTree) { return }
        
        # Calculate layout
        $fileTreeHeight = [Math]::Floor(($this.Height - $this.StatusBarHeight - $this.ButtonHeight - 2) * 0.5)
        $previewHeight = $this.Height - $fileTreeHeight - $this.StatusBarHeight - $this.ButtonHeight - 2
        
        # Position file tree at top
        $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $fileTreeHeight)
        
        # Position preview list below file tree
        $previewY = $this.Y + $fileTreeHeight + 1
        $this.PreviewList.SetBounds($this.X, $previewY, $this.Width, $previewHeight)
        
        # Position progress bar over preview area when visible
        if ($this.ImportProgress.IsVisible) {
            $progressY = $previewY + [Math]::Floor($previewHeight / 2) - 1
            $this.ImportProgress.SetBounds($this.X + 4, $progressY, $this.Width - 8, $this.ProgressHeight)
        }
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - $this.StatusBarHeight
        $buttonWidth = 12
        $this.ImportButton.SetBounds($this.X + $this.Width - ($buttonWidth * 2) - 4, $buttonY, $buttonWidth, 3)
        $this.BackButton.SetBounds($this.X + $this.Width - $buttonWidth - 2, $buttonY, $buttonWidth, 3)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus on file tree
        if ($this.FileTree) {
            $this.FileTree.Focus()
        }
    }
    
    [void] PreviewFile() {
        if (-not $this.SelectedFile) { return }
        
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("File: $(Split-Path $this.SelectedFile -Leaf)")
        $this.PreviewList.AddItem("Path: $($this.SelectedFile)")
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("This will import data from the 'SVI-CAS' worksheet")
        $this.PreviewList.AddItem("Press 'Import' to continue...")
    }
    
    [void] StartImport() {
        if (-not $this.SelectedFile) { return }
        
        $this.ImportButton.IsEnabled = $false
        $this.ImportProgress.IsVisible = $true
        $this.ImportProgress.Value = 0
        $this.StatusMessage = "Importing from Excel..."
        $this.OnBoundsChanged()  # Reposition progress bar
        $this.Invalidate()
        
        try {
            # Get Excel import service
            $excelService = $this.ServiceContainer.GetService('ExcelImportService')
            if (-not $excelService) {
                throw "Excel import service not available"
            }
            
            # Import data
            $this.ImportProgress.Value = 20
            $this.StatusMessage = "Reading Excel file..."
            $this.Invalidate()
            
            $this.ImportedData = $excelService.ImportFromExcel($this.SelectedFile)
            
            $this.ImportProgress.Value = 50
            $this.StatusMessage = "Processing data..."
            $this.Invalidate()
            
            # Display preview
            $this.ShowImportPreview()
            
            $this.ImportProgress.Value = 80
            $this.StatusMessage = "Creating project..."
            $this.Invalidate()
            
            # Create project from imported data
            $project = $excelService.CreateProjectFromImport($this.ImportedData)
            
            # Save project
            $projectService = $this.ServiceContainer.GetService('ProjectService')
            $projectService.CreateProject($project)
            
            $this.ImportProgress.Value = 100
            $this.StatusMessage = "Import completed successfully! Project ID2: $($project.ID2)"
            $this.Invalidate()
            
            # Show success and return to projects screen after delay
            Start-Sleep -Seconds 2
            $screenManager = $this.ServiceContainer.GetService('ScreenManager')
            $screenManager.PopScreen()
            
            # Fire event to refresh projects list
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Publish([EventNames]::ProjectCreated, $this, @{ Project = $project })
            }
        }
        catch {
            $this.StatusMessage = "Import failed: $_"
            $this.ImportProgress.IsVisible = $false
            $this.ImportButton.IsEnabled = $true
            $this.OnBoundsChanged()  # Reset layout
            $this.Invalidate()
        }
    }
    
    [void] ShowImportPreview() {
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("=== IMPORTED DATA PREVIEW ===")
        $this.PreviewList.AddItem("")
        
        # Core project info
        if ($this.ImportedData.CASCase) {
            $this.PreviewList.AddItem("ID2 (CAS Case#): $($this.ImportedData.CASCase)")
        }
        if ($this.ImportedData.TPName) {
            $this.PreviewList.AddItem("TP Name: $($this.ImportedData.TPName)")
        }
        if ($this.ImportedData.TPNum) {
            $this.PreviewList.AddItem("TP Number: $($this.ImportedData.TPNum)")
        }
        if ($this.ImportedData.AuditType) {
            $this.PreviewList.AddItem("Audit Type: $($this.ImportedData.AuditType)")
        }
        
        # Address
        if ($this.ImportedData.Address -or $this.ImportedData.City) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("ADDRESS:")
            if ($this.ImportedData.Address) {
                $this.PreviewList.AddItem("  $($this.ImportedData.Address)")
            }
            if ($this.ImportedData.City -or $this.ImportedData.Province) {
                $this.PreviewList.AddItem("  $($this.ImportedData.City), $($this.ImportedData.Province) $($this.ImportedData.PostalCode)")
            }
        }
        
        # Auditor info
        if ($this.ImportedData.AuditorName) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("AUDITOR:")
            $this.PreviewList.AddItem("  $($this.ImportedData.AuditorName) - $($this.ImportedData.AuditorPhone)")
            if ($this.ImportedData.AuditorTL) {
                $this.PreviewList.AddItem("  Team Lead: $($this.ImportedData.AuditorTL)")
            }
        }
        
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("Press 'Import' to create project...")
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Render base screen first
        $null = $sb.Append(([Screen]$this).OnRender())
        
        # Render status bar at bottom
        $statusY = $this.Y + $this.Height - 1
        $null = $sb.Append($this.VT.MoveTo($this.X, $statusY))
        $null = $sb.Append($this.ThemeManager.GetCached('StatusBar'))
        $null = $sb.Append(' ' * $this.Width)  # Clear line
        $null = $sb.Append($this.VT.MoveTo($this.X + 2, $statusY))
        $null = $sb.Append($this.StatusMessage)
        $null = $sb.Append($this.VT.Reset)
        
        return $sb.ToString()
    }
}


####\Screens/FileBrowserScreen.ps1
# FileBrowserScreen - File browser using FastFileTree component
# Proper PRAXIS architecture implementation

class FileBrowserScreen : Screen {
    [RangerFileTree]$FileTree
    [scriptblock]$FileSelectedCallback = $null  # Callback for file selection
    
    FileBrowserScreen() : base() {
        $this.Title = "File Browser"
    }
    
    [void] OnInitialize() {
        # Create and configure the ranger-style file tree
        $this.FileTree = [RangerFileTree]::new()
        $this.FileTree.CurrentPath = (Get-Location).Path
        
        # Initialize the FileTree with the service container
        $this.FileTree.Initialize($this.ServiceContainer)
        
        # Set up event handlers
        $screen = $this  # Capture reference for closures
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($screen.FileSelectedCallback) {
                & $screen.FileSelectedCallback $node.FullPath
            } else {
                # Default behavior: open text editor for files
                $screen.OpenFileInEditor($node.FullPath)
            }
        }.GetNewClosure()
        
        # Add the file tree as a child component
        $this.AddChild($this.FileTree)
    }
    
    [void] OnBoundsChanged() {
        # Set the file tree to fill the entire screen
        if ($this.FileTree) {
            $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] OpenFileInEditor([string]$filePath) {
        if (-not $filePath -or -not (Test-Path $filePath)) {
            return
        }
        
        $item = Get-Item $filePath -ErrorAction SilentlyContinue
        if ($item -and -not $item.PSIsContainer) {
            # It's a file, open in text editor
            try {
                $editorType = [type]"TextEditorScreen"
                if ($editorType) {
                    $editor = $editorType::new($filePath)
                    
                    # Get screen manager and push the editor
                    $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Push($editor)
                }
            } catch {
                # TextEditorScreen not available
                if ($global:Logger) {
                    $global:Logger.Info("TextEditor not available for file: $filePath")
                }
            }
        }
    }
    
    # Override OnActivated to ensure FileTree gets focus
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        if ($this.FileTree) {
            $this.FileTree.Focus()
        }
    }
}


####\Screens/FilePickerDialog.ps1
# FilePickerDialog.ps1 - File selection dialog using FastFileTree
# Modal dialog for selecting files or directories

class FilePickerDialog : Screen {
    [FastFileTree]$FileTree
    [Button]$SelectButton
    [Button]$CancelButton
    [TextBox]$PathBox
    
    # Configuration
    [string]$InitialPath = ""
    [string]$Filter = "*"
    [bool]$AllowDirectories = $false
    [bool]$AllowFiles = $true
    [bool]$MustExist = $true
    [string]$DialogTitle = "Select File"
    
    # Results
    [string]$SelectedPath = ""
    [bool]$DialogResult = $false
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    # Layout
    hidden [int]$_treeHeight = 20
    hidden [int]$_dialogWidth = 80
    hidden [int]$_dialogHeight = 25
    
    FilePickerDialog() : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $PWD.Path
    }
    
    FilePickerDialog([string]$initialPath) : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $initialPath
    }
    
    [void] OnInitialize() {
        # Calculate dialog position (centered)
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        # Path input box at top
        $this.PathBox = [TextBox]::new()
        $this.PathBox.Placeholder = "Enter path or navigate below"
        $this.PathBox.Text = $this.InitialPath
        $this.PathBox.SetBounds([int]$centerX + 2, [int]$centerY + 2, $this._dialogWidth - 4, 3)
        $this.PathBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.PathBox)
        
        # File tree in the middle
        $this.FileTree = [FastFileTree]::new($this.InitialPath)
        $this.FileTree.Title = $this.DialogTitle
        $this.FileTree.Filter = $this.Filter
        $this.FileTree.ShowBorder = $true
        $this.FileTree.SetBounds([int]$centerX + 2, [int]$centerY + 6, $this._dialogWidth - 4, $this._treeHeight)
        $this.FileTree.Initialize($global:ServiceContainer)
        
        # Set up events
        $dialogRef = $this
        $this.FileTree.OnSelectionChanged = {
            $selected = $dialogRef.FileTree.GetSelectedNode()
            if ($selected) {
                $dialogRef.PathBox.Text = $selected.FullPath
                $dialogRef.UpdateButtonStates()
            }
        }.GetNewClosure()
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($dialogRef.IsValidSelection($node)) {
                $dialogRef.SelectedPath = $node.FullPath
                $dialogRef.DialogResult = $true
                $dialogRef.Active = $false
            }
        }.GetNewClosure()
        
        $this.AddChild($this.FileTree)
        
        # Buttons at bottom
        $buttonY = [int]$centerY + 6 + $this._treeHeight + 1
        $buttonWidth = 15
        $buttonSpacing = 2
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = [int]$centerX + (($this._dialogWidth - $totalButtonWidth) / 2)
        
        $this.SelectButton = [Button]::new("Select")
        $this.SelectButton.IsDefault = $true
        $this.SelectButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, 3)
        $this.SelectButton.OnClick = {
            $dialogRef.SelectFile()
        }.GetNewClosure()
        $this.SelectButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SelectButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, 3)
        $this.CancelButton.OnClick = {
            $dialogRef.SelectedPath = ""
            $dialogRef.DialogResult = $false
            $dialogRef.Active = $false
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.FileTree.Focus()
        
        # Update button states
        $this.UpdateButtonStates()
    }
    
    [void] UpdateButtonStates() {
        $selected = $this.FileTree.GetSelectedNode()
        $isValid = $this.IsValidSelection($selected)
        
        # Enable/disable select button based on selection
        # Note: Button doesn't have Enabled property in current implementation
        # This is a placeholder for when we add that functionality
        
        # Update button text to reflect what will happen
        if ($selected) {
            if ($selected.IsDirectory) {
                $this.SelectButton.Text = if ($this.AllowDirectories) { "Select Folder" } else { "Enter" }
            } else {
                $this.SelectButton.Text = "Select File"
            }
        } else {
            $this.SelectButton.Text = "Select"
        }
        $this.SelectButton.Invalidate()
    }
    
    [bool] IsValidSelection([FileSystemNode]$node) {
        if ($node -eq $null) {
            return $false
        }
        
        # Check if selection type is allowed
        if ($node.IsDirectory -and -not $this.AllowDirectories) {
            return $false
        }
        
        if (-not $node.IsDirectory -and -not $this.AllowFiles) {
            return $false
        }
        
        # Check if file exists (if required)
        if ($this.MustExist -and -not (Test-Path $node.FullPath)) {
            return $false
        }
        
        return $true
    }
    
    [void] SelectFile() {
        $selected = $this.FileTree.GetSelectedNode()
        
        if ($selected -and $this.IsValidSelection($selected)) {
            $this.SelectedPath = $selected.FullPath
            $this.DialogResult = $true
            
            # Fire event
            if ($this.OnFileSelected) {
                & $this.OnFileSelected $selected.FullPath
            }
            
            $this.Active = $false
        } elseif ($selected -and $selected.IsDirectory -and -not $this.AllowDirectories) {
            # Navigate into directory instead of selecting it
            $this.FileTree.NavigateToSelected()
            $this.PathBox.Text = $this.FileTree.RootPath
        } else {
            # Try to use path from text box
            $pathFromBox = $this.PathBox.Text.Trim()
            if ($pathFromBox -and (Test-Path $pathFromBox)) {
                $this.SelectedPath = $pathFromBox
                $this.DialogResult = $true
                
                if ($this.OnFileSelected) {
                    & $this.OnFileSelected $pathFromBox
                }
                
                $this.Active = $false
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Dialog is positioned manually in OnInitialize
        # This could be enhanced to support resizing
    }
    
    [string] OnRender() {
        # Draw dark overlay background
        $sb = [System.Text.StringBuilder]::new()
        
        # Semi-transparent background overlay
        $overlayColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.overlay") } else { "`e[48;2;0;0;0m" }
        
        for ($y = 0; $y -lt [Console]::WindowHeight; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayColor)
            $sb.Append(" " * [Console]::WindowWidth)
        }
        
        # Dialog border
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("dialog.border") } else { "`e[38;2;100;100;100m" }
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.background") } else { "`e[48;2;40;40;40m" }
        
        # Draw dialog background
        for ($y = 0; $y -lt $this._dialogHeight; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($bgColor)
            $sb.Append(" " * $this._dialogWidth)
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::TR())
        
        for ($y = 1; $y -lt $this._dialogHeight - 1; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            $sb.Append([VT]::MoveTo([int]$centerX + $this._dialogWidth - 1, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $this._dialogHeight - 1))
        $sb.Append($borderColor)
        $sb.Append([VT]::BL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::BR())
        
        # Title
        if ($this.DialogTitle) {
            $sb.Append([VT]::MoveTo([int]$centerX + 2, [int]$centerY))
            $titleColor = if ($this.Theme) { $this.Theme.GetColor("dialog.title") } else { "`e[38;2;255;255;255m" }
            $sb.Append($titleColor)
            $sb.Append(" $($this.DialogTitle) ")
        }
        
        $sb.Append([VT]::Reset())
        
        # Render children on top
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        return $sb.ToString()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                $this.SelectedPath = ""
                $this.DialogResult = $false
                $this.Active = $false
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.PathBox.IsFocused) {
                    # Try to navigate to path in text box
                    $path = $this.PathBox.Text.Trim()
                    if ($path -and (Test-Path $path)) {
                        if (Test-Path $path -PathType Container) {
                            $this.FileTree.LoadDirectory($path)
                            $this.FileTree.Focus()
                        } else {
                            # It's a file, select it
                            $this.SelectedPath = $path
                            $this.DialogResult = $true
                            $this.Active = $false
                        }
                    }
                    return $true
                }
                # Let other controls handle Enter
                break
            }
            ([System.ConsoleKey]::Tab) {
                # Cycle focus between controls
                if ($this.PathBox.IsFocused) {
                    $this.FileTree.Focus()
                } elseif ($this.FileTree.IsFocused) {
                    $this.SelectButton.Focus()
                } elseif ($this.SelectButton.IsFocused) {
                    $this.CancelButton.Focus()
                } else {
                    $this.PathBox.Focus()
                }
                return $true
            }
        }
        
        # Let base Screen handle other input
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/MainScreen.ps1
# MainScreen.ps1 - Main screen with tab container

class MainScreen : Screen {
    [TabContainer]$TabContainer
    [CommandPalette]$CommandPalette
    [EventBus]$EventBus
    hidden [string]$TabChangedSubscription
    
    MainScreen() : base() {
        $this.Title = "PRAXIS"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to tab change events
        if ($this.EventBus) {
            $this.TabChangedSubscription = $this.EventBus.Subscribe([EventNames]::TabChanged, {
                param($sender, $eventData)
                if ($eventData.TabIndex -ne $null -and $this.TabContainer) {
                    $this.TabContainer.ActivateTab($eventData.TabIndex)
                    $this.RequestRender()
                }
            }.GetNewClosure())
        }
        
        # Create tab container
        $this.TabContainer = [TabContainer]::new()
        $this.TabContainer.Initialize($global:ServiceContainer)
        $this.AddChild($this.TabContainer)
        
        # Add real screens as tabs
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Adding tabs to TabContainer")
        }
        
        $projectsScreen = [ProjectsScreen]::new()
        $this.TabContainer.AddTab("Projects", $projectsScreen)
        
        $taskScreen = [TaskScreen]::new()
        $this.TabContainer.AddTab("Tasks", $taskScreen)
        
        $fileBrowserScreen = [FileBrowserScreen]::new()
        $this.TabContainer.AddTab("Files", $fileBrowserScreen)
        
        $textEditorScreen = [TextEditorScreen]::new()
        $this.TabContainer.AddTab("Editor", $textEditorScreen)
        
        $settingsScreen = [SettingsScreen]::new()
        $this.TabContainer.AddTab("Settings", $settingsScreen)
        
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Added $($this.TabContainer.Tabs.Count) tabs")
        }
        
        # Create command palette (overlay)
        $this.CommandPalette = [CommandPalette]::new()
        $this.CommandPalette.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandPalette)
        
        # Key bindings now handled by GetShortcutBindings() method
    }
    
    
    [void] OnBoundsChanged() {
        if ($this.TabContainer) {
            $this.TabContainer.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
        if ($this.CommandPalette) {
            # Command palette uses full screen for centering
            $this.CommandPalette.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure bounds are set
        if ($this.Width -eq 0 -or $this.Height -eq 0) {
            $this.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
        }
        
        # Activate the active tab's content screen
        if ($this.TabContainer) {
            $activeTab = $this.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                # Screens are not focusable - call OnActivated instead
                if ($activeTab.Content -is [Screen]) {
                    $activeTab.Content.OnActivated()
                } else {
                    $activeTab.Content.Focus()
                }
            }
        }
    }
    
    # Override to handle global shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Global shortcuts
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Q) {
                if (-not $keyInfo.Modifiers) {
                    $this.Active = $false  # Exit the main loop
                    return $true
                }
            }
            # Remove Escape handling - let child screens handle it
        }
        
        # Let TabContainer handle tab switching shortcuts (numbers, Ctrl+Tab, etc)
        # This is safe because TabContainer is not focusable, so it won't be in the normal input chain
        if ($this.TabContainer) {
            return $this.TabContainer.HandleInput($keyInfo)
        }
        
        return $false
    }
}


####\Screens/NewProjectDialog.ps1
# NewProjectDialog.ps1 - Dialog for creating new projects (refactored to use BaseDialog)

class NewProjectDialog : BaseDialog {
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$ID1Box
    [TextBox]$ID2Box
    [TextBox]$NotesBox
    [TextBox]$CAAPathBox
    [TextBox]$RequestPathBox
    [TextBox]$T2020PathBox
    [TextBox]$DueDateBox
    
    NewProjectDialog() : base("New Project") {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 22
    }
    
    [void] InitializeContent() {
        # Create all project input fields
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [TextBox]::new()
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [TextBox]::new()
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NotesBox = [TextBox]::new()
        $this.NotesBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NotesBox, 5)
        
        $this.CAAPathBox = [TextBox]::new()
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [TextBox]::new()
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [TextBox]::new()
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.DueDateBox.Text = ([DateTime]::Now.AddDays(42)).ToString("MM/dd/yyyy")
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = [DateTime]::Now.AddDays(42)
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Use default if parsing fails
                        $dueDate = [DateTime]::Now.AddDays(42)
                    }
                }
                
                $projectData = @{
                    FullProjectName = $dialog.NameBox.Text
                    Nickname = if ($dialog.NicknameBox.Text.Trim()) { $dialog.NicknameBox.Text } else { $dialog.NameBox.Text }
                    ID1 = $dialog.ID1Box.Text
                    ID2 = $dialog.ID2Box.Text
                    Note = $dialog.NotesBox.Text
                    CAAPath = $dialog.CAAPathBox.Text
                    RequestPath = $dialog.RequestPathBox.Text
                    T2020Path = $dialog.T2020PathBox.Text
                    DateDue = $dueDate
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create project via service
                    $projectService = $global:ServiceContainer.GetService("ProjectService")
                    if ($projectService) {
                        # Create project with full data
                        $newProject = $projectService.AddProject($projectData.FullProjectName, $projectData.Nickname)
                        
                        # Update additional properties
                        $newProject.ID1 = $projectData.ID1
                        $newProject.ID2 = $projectData.ID2
                        $newProject.Note = $projectData.Note
                        $newProject.CAAPath = $projectData.CAAPath
                        $newProject.RequestPath = $projectData.RequestPath
                        $newProject.T2020Path = $projectData.T2020Path
                        $newProject.DateDue = $projectData.DateDue
                        
                        # Save the updated project
                        $projectService.SaveProject($newProject)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::ProjectCreated, @{ 
                            Project = $newProject 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewProjectDialog'
                        Action = 'Create'
                        Data = $projectData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $projectData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewProjectDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 2)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 2)
        $currentY += 2
        
        $this.NotesBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
    }
}


####\Screens/NewTaskDialog.ps1
# NewTaskDialog.ps1 - Dialog for creating new tasks (refactored to use BaseDialog)

class NewTaskDialog : BaseDialog {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$PriorityList
    
    NewTaskDialog() : base("New Task", 50, 18) {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.AddContentControl($this.TitleBox, 1)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.AddContentControl($this.DescriptionBox, 2)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.SetItems(@("Low", "Medium", "High"))
        $this.PriorityList.SelectIndex(1)  # Default to Medium
        $this.AddContentControl($this.PriorityList, 3)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.TitleBox.Text.Trim()) {
                # Get selected priority
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $priority = switch ($selectedPriority) {
                    "Low" { [TaskPriority]::Low }
                    "High" { [TaskPriority]::High }
                    default { [TaskPriority]::Medium }
                }
                
                $taskData = @{
                    Title = $dialog.TitleBox.Text.Trim()
                    Description = $dialog.DescriptionBox.Text.Trim()
                    Priority = $priority
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create task via service
                    $taskService = $global:ServiceContainer.GetService("TaskService")
                    if ($taskService) {
                        $newTask = $taskService.CreateTask($taskData)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::TaskCreated, @{ 
                            Task = $newTask 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewTaskDialog'
                        Action = 'Create'
                        Data = $taskData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $taskData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewTaskDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for task dialog controls
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        
        # Title box
        $this.TitleBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 2, 
            $controlWidth, 
            3
        )
        
        # Description box
        $this.DescriptionBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 6, 
            $controlWidth, 
            3
        )
        
        # Priority list
        $this.PriorityList.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 10, 
            $controlWidth, 
            5
        )
    }
}


####\Screens/NumberInputDialog.ps1
# NumberInputDialog.ps1 - Simple dialog for numeric input

class NumberInputDialog : Screen {
    [string]$Prompt
    [decimal]$DefaultValue
    [decimal]$MinValue
    [decimal]$MaxValue
    [bool]$AllowDecimals
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    NumberInputDialog([string]$prompt) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = 0
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    NumberInputDialog([string]$prompt, [decimal]$defaultValue) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue.ToString()
        $this.InputBox.Placeholder = if ($this.AllowDecimals) { "0.00" } else { "0" }
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            $value = [decimal]0
            if ([decimal]::TryParse($dialog.InputBox.Text, [ref]$value)) {
                # Validate range
                if ($value -lt $dialog.MinValue) {
                    $value = $dialog.MinValue
                } elseif ($value -gt $dialog.MaxValue) {
                    $value = $dialog.MaxValue
                }
                
                # Round if no decimals allowed
                if (-not $dialog.AllowDecimals) {
                    $value = [Math]::Round($value)
                }
                
                if ($dialog.OnSubmit) {
                    & $dialog.OnSubmit $value
                }
            }
            # If parse fails, don't submit
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box
        $this.InputBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 11 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
            
            # Draw constraints if any
            $constraintY = $y + 2 + $promptLines.Count + 4
            $sb.Append([VT]::MoveTo($x + 2, $constraintY))
            $sb.Append($this.Theme.GetColor("disabled"))
            $constraints = @()
            if ($this.MinValue -ne [decimal]::MinValue) {
                $constraints += "Min: $($this.MinValue)"
            }
            if ($this.MaxValue -ne [decimal]::MaxValue) {
                $constraints += "Max: $($this.MaxValue)"
            }
            if (-not $this.AllowDecimals) {
                $constraints += "Integers only"
            }
            if ($constraints.Count -gt 0) {
                $sb.Append($constraints -join " | ")
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ProjectDetailScreen.ps1
# ProjectDetailScreen - Detailed project view with time tracking information
# Redesigned to follow PRAXIS architecture standards using DockPanel and components

class ProjectDetailScreen : Screen {
    [Project]$Project = $null
    [System.Collections.ArrayList]$TimeEntries
    
    # PRAXIS Architecture Components
    [DockPanel]$MainLayout
    [ListBox]$ProjectInfoPanel
    [DataGrid]$WeeklySummaryGrid  
    [DataGrid]$TimeEntriesGrid
    
    # Services
    [ThemeManager]$ThemeManager
    [EventBus]$EventBus
    
    ProjectDetailScreen() : base() {
        $this.Title = "Project Details"
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    ProjectDetailScreen([Project]$project) : base() {
        $this.Title = "Project Details - $($project.Nickname)"
        $this.Project = $project
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services through proper dependency injection
        $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Load time entries if we have a project
        if ($this.Project) {
            $this.LoadTimeEntries()
        }
        
        # Create main DockPanel layout
        $this.MainLayout = [DockPanel]::new()
        $this.MainLayout.Initialize($this.ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Create project info panel (top section)
        $this.CreateProjectInfoPanel()
        
        # Create weekly summary grid (middle section)
        $this.CreateWeeklySummaryGrid()
        
        # Create time entries grid (fill remaining space)
        $this.CreateTimeEntriesGrid()
        
        # Update title
        if ($this.Project) {
            $this.Title = "Project Details - $($this.Project.Nickname)"
        }
        
        # Populate data
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
    }
    
    [void] CreateProjectInfoPanel() {
        $this.ProjectInfoPanel = [ListBox]::new()
        $this.ProjectInfoPanel.Initialize($this.ServiceContainer)
        $this.ProjectInfoPanel.ShowBorder = $true
        $this.ProjectInfoPanel.Title = "Project Information"
        $this.ProjectInfoPanel.IsFocusable = $false  # Read-only display
        
        # Dock to top with a specific height
        $this.MainLayout.SetChildDock($this.ProjectInfoPanel, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.ProjectInfoPanel, 35)  # Allow plenty of space for all fields
        $this.MainLayout.AddChild($this.ProjectInfoPanel)
    }
    
    [void] CreateWeeklySummaryGrid() {
        $this.WeeklySummaryGrid = [DataGrid]::new()
        $this.WeeklySummaryGrid.Initialize($this.ServiceContainer)
        $this.WeeklySummaryGrid.ShowHeader = $true
        $this.WeeklySummaryGrid.ShowBorder = $true
        $this.WeeklySummaryGrid.Title = "Weekly Hours Summary"
        $this.WeeklySummaryGrid.IsFocusable = $false  # Read-only display
        
        # Set up columns for weekly summary
        $columns = @(
            @{ Name = "WeekOf"; Header = "Week of"; Width = 12; Getter = { param($item) $item.WeekOf } }
            @{ Name = "Monday"; Header = "Mon"; Width = 7; Getter = { param($item) $item.Monday.ToString("F1") } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 7; Getter = { param($item) $item.Tuesday.ToString("F1") } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 7; Getter = { param($item) $item.Wednesday.ToString("F1") } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 7; Getter = { param($item) $item.Thursday.ToString("F1") } }
            @{ Name = "Friday"; Header = "Fri"; Width = 7; Getter = { param($item) $item.Friday.ToString("F1") } }
            @{ Name = "Total"; Header = "Total"; Width = 8; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.WeeklySummaryGrid.SetColumns($columns)
        
        # Dock to top (after project info) with a specific height
        $this.MainLayout.SetChildDock($this.WeeklySummaryGrid, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.WeeklySummaryGrid, 8)  # Weekly summary doesn't need much space
        $this.MainLayout.AddChild($this.WeeklySummaryGrid)
    }
    
    [void] CreateTimeEntriesGrid() {
        $this.TimeEntriesGrid = [DataGrid]::new()
        $this.TimeEntriesGrid.Initialize($this.ServiceContainer)
        $this.TimeEntriesGrid.ShowHeader = $true
        $this.TimeEntriesGrid.ShowBorder = $true
        $this.TimeEntriesGrid.Title = "Time Entries - [A]dd [E]dit [D]elete [R]efresh"
        $this.TimeEntriesGrid.IsFocusable = $true  # Interactive
        
        # Set up columns for time entries
        $screen = $this  # Capture reference for closure
        $columns = @(
            @{ Name = "Date"; Header = "Date"; Width = 12; Getter = { param($item) $screen.FormatDate($item.Date) }.GetNewClosure() }
            @{ Name = "Hours"; Header = "Hours"; Width = 8; Getter = { param($item) [double]::Parse($item.Total).ToString("F2") } }
            @{ Name = "Description"; Header = "Description"; Width = 40; Getter = { param($item) if ($item.Description) { $item.Description } else { "No description" } } }
        )
        $this.TimeEntriesGrid.SetColumns($columns)
        
        # Set up selection changed handler
        $screen = $this  # Capture reference for closure
        $this.TimeEntriesGrid.OnSelectionChanged = {
            # Handle selection changes if needed
        }.GetNewClosure()
        
        # Fill remaining space
        $this.MainLayout.SetChildDock($this.TimeEntriesGrid, [DockPosition]::Fill)
        $this.MainLayout.AddChild($this.TimeEntriesGrid)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus the time entries grid which is the main interactive component
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # DockPanel handles layout automatically
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] LoadTimeEntries() {
        # This would load time entries from the tracker system
        # For now, creating sample data based on the tracker.txt structure
        $this.TimeEntries.Clear()
        
        # Sample time entries (in production, this would load from actual data)
        $sampleEntries = @(
            @{
                Date = "20241201"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = "8.00"
                TueHours = ""
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "8.00"
                Description = "Initial project setup and requirements gathering"
            },
            @{
                Date = "20241202"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = "6.50"
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "6.50"
                Description = "Development work on core features"
            },
            @{
                Date = "20241203"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = ""
                WedHours = "7.25"
                ThuHours = ""
                FriHours = ""
                Total = "7.25"
                Description = "Testing and bug fixes"
            }
        )
        
        foreach ($entry in $sampleEntries) {
            $this.TimeEntries.Add([PSCustomObject]$entry) | Out-Null
        }
    }
    
    [void] PopulateProjectInfo() {
        if (-not $this.Project -or -not $this.ProjectInfoPanel) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: Project type = $($this.Project.GetType().Name)")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: AuditType = '$($this.Project.AuditType)'")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: ClientID = '$($this.Project.ClientID)'")
        }
        
        $infoItems = [System.Collections.ArrayList]::new()
        
        # === BASIC PROJECT INFORMATION ===
        $infoItems.Add("=== PROJECT IDENTIFICATION ===") | Out-Null
        $infoItems.Add("Nickname: $($this.Project.Nickname)") | Out-Null
        $infoItems.Add("Full Name: $($this.Project.FullProjectName)") | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen: Showing $($infoItems.Count) items so far")
        }
        
        # IDs
        if ($this.Project.ID1) {
            $infoItems.Add("Client Code (ID1): $($this.Project.ID1)") | Out-Null
        }
        if ($this.Project.ID2) {
            $infoItems.Add("CAS Case# (ID2): $($this.Project.ID2)") | Out-Null
        }
        if ($this.Project.ClientID) {
            $infoItems.Add("Client ID: $($this.Project.ClientID)") | Out-Null
        }
        
        # === AUDIT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDIT INFORMATION ===") | Out-Null
        if ($this.Project.AuditType) {
            $infoItems.Add("Audit Type: $($this.Project.AuditType)") | Out-Null
        }
        if ($this.Project.AuditProgram) {
            $infoItems.Add("Audit Program: $($this.Project.AuditProgram)") | Out-Null
        }
        if ($this.Project.AuditCase) {
            $infoItems.Add("Audit Case: $($this.Project.AuditCase)") | Out-Null
        }
        
        # Audit Dates
        if ($this.Project.AuditStartDate -and $this.Project.AuditStartDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Start Date: $($this.FormatDate($this.Project.AuditStartDate))") | Out-Null
        }
        if ($this.Project.AuditPeriodFrom -and $this.Project.AuditPeriodFrom -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period From: $($this.FormatDate($this.Project.AuditPeriodFrom))") | Out-Null
        }
        if ($this.Project.AuditPeriodTo -and $this.Project.AuditPeriodTo -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period To: $($this.FormatDate($this.Project.AuditPeriodTo))") | Out-Null
        }
        
        # Additional Audit Periods
        $hasAuditPeriods = $false
        for ($i = 1; $i -le 5; $i++) {
            $startProp = "AuditPeriod${i}Start"
            $endProp = "AuditPeriod${i}End"
            if ($this.Project.$startProp -ne [DateTime]::MinValue -or $this.Project.$endProp -ne [DateTime]::MinValue) {
                if (-not $hasAuditPeriods) {
                    $infoItems.Add("Additional Audit Periods:") | Out-Null
                    $hasAuditPeriods = $true
                }
                $start = if ($this.Project.$startProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$startProp) } else { "N/A" }
                $end = if ($this.Project.$endProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$endProp) } else { "N/A" }
                $infoItems.Add("  Period ${i}: $start to $end") | Out-Null
            }
        }
        
        # === PROJECT DATES ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== PROJECT DATES ===") | Out-Null
        if ($this.Project.RequestDate -and $this.Project.RequestDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Data Requested: $($this.FormatDate($this.Project.RequestDate))") | Out-Null
        }
        if ($this.Project.DateAssigned) {
            $infoItems.Add("Date Assigned: $($this.FormatDate($this.Project.DateAssigned))") | Out-Null
        }
        if ($this.Project.BFDate -and $this.Project.BFDate -ne [DateTime]::MinValue) {
            $infoItems.Add("BF Date: $($this.FormatDate($this.Project.BFDate))") | Out-Null
        }
        if ($this.Project.DateDue) {
            $infoItems.Add("Due Date: $($this.FormatDate($this.Project.DateDue))") | Out-Null
        }
        if ($this.Project.ClosedDate -and $this.Project.ClosedDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Completed: $($this.FormatDate($this.Project.ClosedDate))") | Out-Null
        }
        
        # === CLIENT LOCATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CLIENT LOCATION ===") | Out-Null
        if ($this.Project.Address) {
            $infoItems.Add("Address: $($this.Project.Address)") | Out-Null
        }
        if ($this.Project.City -or $this.Project.Province -or $this.Project.PostalCode) {
            $location = @()
            if ($this.Project.City) { $location += $this.Project.City }
            if ($this.Project.Province) { $location += $this.Project.Province }
            if ($this.Project.PostalCode) { $location += $this.Project.PostalCode }
            $infoItems.Add("City/Prov/Postal: $($location -join ', ')") | Out-Null
        }
        if ($this.Project.Country) {
            $infoItems.Add("Country: $($this.Project.Country)") | Out-Null
        }
        if ($this.Project.ShipToAddress) {
            $infoItems.Add("Ship To Address: $($this.Project.ShipToAddress)") | Out-Null
        }
        
        # === AUDITOR INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDITOR INFORMATION ===") | Out-Null
        if ($this.Project.AuditorName) {
            $infoItems.Add("Auditor: $($this.Project.AuditorName)") | Out-Null
        }
        if ($this.Project.AuditorPhone) {
            $infoItems.Add("Auditor Phone: $($this.Project.AuditorPhone)") | Out-Null
        }
        if ($this.Project.AuditorTL) {
            $infoItems.Add("Team Lead: $($this.Project.AuditorTL)") | Out-Null
        }
        if ($this.Project.AuditorTLPhone) {
            $infoItems.Add("Team Lead Phone: $($this.Project.AuditorTLPhone)") | Out-Null
        }
        
        # === CONTACT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CONTACT INFORMATION ===") | Out-Null
        # Contact 1
        if ($this.Project.Contact1Name) {
            $infoItems.Add("Contact 1:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact1Name)") | Out-Null
            if ($this.Project.Contact1Title) { $infoItems.Add("  Title: $($this.Project.Contact1Title)") | Out-Null }
            if ($this.Project.Contact1Phone) { 
                $phone = $this.Project.Contact1Phone
                if ($this.Project.Contact1Ext) { $phone += " x$($this.Project.Contact1Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact1Address) { $infoItems.Add("  Address: $($this.Project.Contact1Address)") | Out-Null }
        }
        # Contact 2
        if ($this.Project.Contact2Name) {
            $infoItems.Add("Contact 2:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact2Name)") | Out-Null
            if ($this.Project.Contact2Title) { $infoItems.Add("  Title: $($this.Project.Contact2Title)") | Out-Null }
            if ($this.Project.Contact2Phone) { 
                $phone = $this.Project.Contact2Phone
                if ($this.Project.Contact2Ext) { $phone += " x$($this.Project.Contact2Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact2Address) { $infoItems.Add("  Address: $($this.Project.Contact2Address)") | Out-Null }
        }
        
        # === SYSTEM INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== SYSTEM INFORMATION ===") | Out-Null
        if ($this.Project.AccountingSoftware1) {
            $sw1 = $this.Project.AccountingSoftware1
            if ($this.Project.AccountingSoftware1Other) { $sw1 += " ($($this.Project.AccountingSoftware1Other))" }
            if ($this.Project.AccountingSoftware1Type) { $sw1 += " - $($this.Project.AccountingSoftware1Type)" }
            $infoItems.Add("Accounting Software 1: $sw1") | Out-Null
        }
        if ($this.Project.AccountingSoftware2) {
            $sw2 = $this.Project.AccountingSoftware2
            if ($this.Project.AccountingSoftware2Other) { $sw2 += " ($($this.Project.AccountingSoftware2Other))" }
            if ($this.Project.AccountingSoftware2Type) { $sw2 += " - $($this.Project.AccountingSoftware2Type)" }
            $infoItems.Add("Accounting Software 2: $sw2") | Out-Null
        }
        
        # === STATUS AND TOTALS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== STATUS AND HOURS ===") | Out-Null
        $status = if ($this.Project.Status) { $this.Project.Status } else { "Active" }
        $infoItems.Add("Status: $status") | Out-Null
        
        # Show cumulative hours from Excel import
        if ($this.Project.CumulativeHrs -gt 0) {
            $infoItems.Add("Cumulative Hours (from import): $($this.Project.CumulativeHrs.ToString('F2'))") | Out-Null
        }
        
        $totalHours = $this.CalculateTotalHours()
        $infoItems.Add("Total Hours (tracked): $($totalHours.ToString('F2'))") | Out-Null
        
        # === FILE PATHS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== FILE PATHS ===") | Out-Null
        if ($this.Project.CAAPath) {
            $infoItems.Add("CAA Path: $($this.Project.CAAPath)") | Out-Null
        }
        if ($this.Project.RequestPath) {
            $infoItems.Add("Request Path: $($this.Project.RequestPath)") | Out-Null
        }
        if ($this.Project.T2020Path) {
            $infoItems.Add("T2020 Path: $($this.Project.T2020Path)") | Out-Null
        }
        
        # === ADDITIONAL INFORMATION ===
        if ($this.Project.FXInfo -or $this.Project.Comments -or $this.Project.Note) {
            $infoItems.Add("") | Out-Null
            $infoItems.Add("=== ADDITIONAL INFORMATION ===") | Out-Null
            
            if ($this.Project.FXInfo) {
                $infoItems.Add("FX Info: $($this.Project.FXInfo)") | Out-Null
            }
            if ($this.Project.Comments) {
                $infoItems.Add("Comments: $($this.Project.Comments)") | Out-Null
            }
            if ($this.Project.Note) {
                $infoItems.Add("Notes: $($this.Project.Note)") | Out-Null
            }
        }
        
        $this.ProjectInfoPanel.SetItems($infoItems)
    }
    
    [void] PopulateWeeklySummary() {
        if (-not $this.WeeklySummaryGrid) {
            return
        }
        
        $weeklyData = $this.CalculateWeeklySummary()
        $this.WeeklySummaryGrid.SetItems($weeklyData)
    }
    
    [void] PopulateTimeEntries() {
        if (-not $this.TimeEntriesGrid) {
            return
        }
        
        # Sort entries by date (most recent first)
        $sortedEntries = $this.TimeEntries | Sort-Object { [DateTime]::ParseExact($_.Date, "yyyyMMdd", $null) } -Descending
        $this.TimeEntriesGrid.SetItems($sortedEntries)
    }
    
    [string] FormatDate([string]$dateStr) {
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Not set"
        }
        
        try {
            if ($dateStr.Length -eq 8) {
                # YYYYMMDD format
                $date = [DateTime]::ParseExact($dateStr, "yyyyMMdd", $null)
                return $date.ToString("MM/dd/yyyy")
            } else {
                # Try parsing as DateTime
                $date = [DateTime]::Parse($dateStr)
                return $date.ToString("MM/dd/yyyy")
            }
        } catch {
            return $dateStr
        }
    }
    
    [string] FormatDate([DateTime]$date) {
        if ($date -eq [DateTime]::MinValue) {
            return "Not set"
        }
        return $date.ToString("MM/dd/yyyy")
    }
    
    [double] CalculateTotalHours() {
        $total = 0.0
        foreach ($entry in $this.TimeEntries) {
            try {
                $hours = [double]::Parse($entry.Total)
                $total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        return $total
    }
    
    [System.Collections.ArrayList] CalculateWeeklySummary() {
        $weeks = @{}
        
        foreach ($entry in $this.TimeEntries) {
            try {
                $entryDate = [DateTime]::ParseExact($entry.Date, "yyyyMMdd", $null)
                $monday = $entryDate.AddDays(-([int]$entryDate.DayOfWeek - 1))
                $weekKey = $monday.ToString("MM/dd/yyyy")
                
                if (-not $weeks.ContainsKey($weekKey)) {
                    $weeks[$weekKey] = @{
                        WeekOf = $weekKey
                        Monday = 0.0
                        Tuesday = 0.0
                        Wednesday = 0.0
                        Thursday = 0.0
                        Friday = 0.0
                        Total = 0.0
                    }
                }
                
                # Add hours to appropriate day
                $dayOfWeek = $entryDate.DayOfWeek.ToString()
                $hours = [double]::Parse($entry.Total)
                
                switch ($dayOfWeek) {
                    "Monday" { $weeks[$weekKey].Monday += $hours }
                    "Tuesday" { $weeks[$weekKey].Tuesday += $hours }
                    "Wednesday" { $weeks[$weekKey].Wednesday += $hours }
                    "Thursday" { $weeks[$weekKey].Thursday += $hours }
                    "Friday" { $weeks[$weekKey].Friday += $hours }
                }
                
                $weeks[$weekKey].Total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        
        $weeklyData = [System.Collections.ArrayList]::new()
        foreach ($week in $weeks.Values) {
            $weeklyData.Add([PSCustomObject]$week) | Out-Null
        }
        
        # Sort by week date (most recent first) and ensure ArrayList type
        $sortedData = $weeklyData | Sort-Object { [DateTime]::Parse($_.WeekOf) } -Descending
        $result = [System.Collections.ArrayList]::new()
        foreach ($item in $sortedData) {
            $result.Add($item) | Out-Null
        }
        return $result
    }
    
    [void] AddTimeEntry() {
        if (-not $this.Project) {
            return
        }
        
        # Create time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project)
        
        # Set up callback for when entry is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Add to local time entries collection
            $screen.TimeEntries.Add($timeEntryData) | Out-Null
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] EditSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.EditTimeEntry($selected)
    }
    
    [void] EditTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $this.Project -or -not $timeEntry) {
            return
        }
        
        # Create edit time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project, $timeEntry)
        
        # Set up callback for when entry is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Find and replace in local collection
            for ($i = 0; $i -lt $screen.TimeEntries.Count; $i++) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries[$i] = $timeEntryData
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] DeleteSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.DeleteTimeEntry($selected)
    }
    
    [void] DeleteTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $timeEntry) {
            return
        }
        
        # Show confirmation dialog
        $message = "Delete time entry for $($this.FormatDate($timeEntry.Date)) ($($timeEntry.Total) hours)?"
        $dialog = [ConfirmationDialog]::new($message)
        
        $screen = $this  # Capture reference for closure
        $dialog.OnConfirm = {
            # Remove from local collection
            for ($i = $screen.TimeEntries.Count - 1; $i -ge 0; $i--) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries.RemoveAt($i)
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] RefreshData() {
        # Reload time entries
        $this.LoadTimeEntries()
        
        # Refresh all displays
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
        
        # Focus the time entries grid
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle character shortcuts
        if ($keyInfo.KeyChar) {
            switch ($keyInfo.KeyChar) {
                'r' {
                    # Refresh/reload data
                    $this.RefreshData()
                    return $true
                }
                'a' {
                    # Add new time entry
                    $this.AddTimeEntry()
                    return $true
                }
                'e' {
                    # Edit selected time entry
                    $this.EditSelectedTimeEntry()
                    return $true
                }
                'd' {
                    # Delete selected time entry
                    $this.DeleteSelectedTimeEntry()
                    return $true
                }
            }
        }
        
        # Handle ESC to go back
        if ($keyInfo.Key -eq [System.ConsoleKey]::Escape) {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
            return $true
        }
        
        # Let base class handle other input (like tab switching and navigation)
        return $false
    }
}


####\Screens/ProjectsScreen.ps1
# ProjectsScreen.ps1 - Project management screen using DataGrid component

class ProjectsScreen : Screen {
    [DataGrid]$ProjectGrid
    [Button]$NewButton
    [Button]$ViewButton
    [Button]$EditButton
    [Button]$DeleteButton
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    ProjectsScreen() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to project created events with explicit closure
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe([EventNames]::ProjectCreated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
                # Select the new project if provided
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe([EventNames]::CommandExecuted, {
                param($sender, $eventData)
                if ($eventData.Target -eq 'ProjectsScreen') {
                    switch ($eventData.Command) {
                        'EditProject' { $screen.EditProject() }
                        'DeleteProject' { $screen.DeleteProject() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe([EventNames]::ProjectUpdated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe([EventNames]::ProjectDeleted, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create DataGrid with columns
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Projects"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowGridLines = $true
        
        # Define columns with proper formatting
        $columns = @(
            @{
                Name = "Status"
                Header = "Sts"
                Width = 3
                Getter = {
                    param($project)
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[]" } else { "[ ]" }
                }
            },
            @{
                Name = "FullProjectName"
                Header = "Project Name"
                Width = 0  # Flexible width - will auto-size
            },
            @{
                Name = "ID1"
                Header = "ID1"
                Width = 5
            },
            @{
                Name = "ID2"
                Header = "ID2"
                Width = 9
            },
            @{
                Name = "DateAssigned"
                Header = "Assigned"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            },
            @{
                Name = "DateDue"
                Header = "Due"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Create buttons
        $screen = $this  # Capture reference for closures
        
        $this.NewButton = [Button]::new("New Project")
        $this.NewButton.IsDefault = $true
        $this.NewButton.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Debug("New Project button clicked")
            }
            $screen.NewProject() 
        }.GetNewClosure()
        $this.NewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.NewButton)
        
        $this.ViewButton = [Button]::new("View Details")
        $this.ViewButton.OnClick = { $screen.ViewProjectDetails() }.GetNewClosure()
        $this.ViewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ViewButton)
        
        $this.EditButton = [Button]::new("Edit")
        $this.EditButton.OnClick = { $screen.EditProject() }.GetNewClosure()
        $this.EditButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.EditButton)
        
        $this.DeleteButton = [Button]::new("Delete")
        $this.DeleteButton.OnClick = { $screen.DeleteProject() }.GetNewClosure()
        $this.DeleteButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.DeleteButton)
        
        # Load projects
        $this.LoadProjects()
        
        # Register screen-specific shortcuts with ShortcutManager
        $this.RegisterShortcuts()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("ProjectsScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.new"
            Name = "New Project"
            Description = "Create a new project"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.NewProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.edit"
            Name = "Edit Project"
            Description = "Edit the selected project"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.EditProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.delete"
            Name = "Delete Project"
            Description = "Delete the selected project"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.DeleteProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.refresh"
            Name = "Refresh"
            Description = "Refresh the project list"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.LoadProjects() }.GetNewClosure()
        })
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.RegisterShortcuts: Registered shortcuts for 'n', 'e', 'd', etc.")
        }
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnActivated: Screen activated with new focus system")
        }
        
        # Add defensive null checks
        try {
            # Focus the grid if it has items, otherwise the New button
            if ($global:Logger) {
                $projectGridNull = ($this.ProjectGrid -eq $null)
                $itemsCount = if ($this.ProjectGrid -and $this.ProjectGrid.Items) { $this.ProjectGrid.Items.Count } else { 0 }
                $newButtonNull = ($this.NewButton -eq $null)
                $global:Logger.Debug("ProjectsScreen focus check: ProjectGrid=$(!$projectGridNull), Items=$itemsCount, NewButton=$(!$newButtonNull)")
            }
            
            if ($this.ProjectGrid -and $this.ProjectGrid.Items -and $this.ProjectGrid.Items.Count -gt 0) {
                $this.ProjectGrid.Focus()
            } elseif ($this.NewButton) {
                $this.NewButton.Focus()
            } else {
                if ($global:Logger) {
                    $global:Logger.Debug("ProjectsScreen: No focusable element found!")
                }
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ProjectsScreen.OnActivated: Error during focus - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Debug
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Layout: Grid takes most space, buttons at bottom
        $buttonAreaHeight = $this.ButtonHeight + 2
        $gridHeight = $this.Height - $buttonAreaHeight
        
        # Project grid
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $gridHeight
        )
        
        # Buttons (horizontally arranged) - now 4 buttons
        $maxButtonWidth = 20  # Reduced button width to fit 4 buttons
        $totalButtonWidth = ($maxButtonWidth * 4) + ($this.ButtonSpacing * 3)
        
        # Center buttons if screen is wide enough
        if ($this.Width -gt $totalButtonWidth) {
            $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $this.X
            $buttonWidth = [int](($this.Width - ($this.ButtonSpacing * 3)) / 4)
        }
        
        # Position buttons at bottom of screen bounds
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        
        $this.NewButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.ViewButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.EditButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 2,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.DeleteButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 3,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date
        $sorted = $activeProjects | Sort-Object DateDue
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        # Reload projects and update display
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.NewProject() called")
        }
        # Create new project dialog
        $dialog = [NewProjectDialog]::new()
        
        # EventBus will handle project creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                
                # Create nickname from name
                # Create project using single-parameter constructor
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                # Select the new project
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit project dialog
        $dialog = [EditProjectDialog]::new($selected)
        # Capture references
        $screen = $this
        $project = $selected
        $dialog.OnPrimary = {
            # Get the data from the dialog
            $projectData = @{
                FullProjectName = $dialog.NameBox.Text
                Nickname = $dialog.NicknameBox.Text
                Note = $dialog.NoteBox.Text
                DateDue = $dialog.DueDateBox.Text
            }
            
            # Update the project
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            # Save through service
            $screen.ProjectService.UpdateProject($project)
            
            # Publish project updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                # Fallback if EventBus not available
                $screen.LoadProjects()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Show confirmation dialog
            $message = "Are you sure you want to delete project '$($selected.FullProjectName)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            $dialog.OnConfirm = {
                # Delete the project
                $screen.ProjectService.DeleteProject($projectId)
                
                # Publish project deleted event
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    # Fallback if EventBus not available
                    $screen.LoadProjects()
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.ViewProjectDetails() called")
        }
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Create and show project detail screen
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    # Using parent-delegated focus model - Tab handled by ScreenManager/Container
    
    # Override HandleScreenInput instead of HandleInput to work with base Screen class
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Screen-specific shortcuts - only called as fallback by base Screen class
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'N' key pressed, calling NewProject")
                    }
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'E' key pressed, calling EditProject")
                    }
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'V' -or $key.KeyChar -eq 'v')) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadProjects()
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        # If no shortcut matched, return false (let base Screen handle it)
        return $false
    }
}


####\Screens/ProjectsScreenEnhanced.ps1
# ProjectsScreenEnhanced.ps1 - Project management screen with DataGrid

class ProjectsScreenEnhanced : Screen {
    [DataGrid]$ProjectGrid
    [Button]$NewButton
    [Button]$ViewButton
    [Button]$EditButton
    [Button]$DeleteButton
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    ProjectsScreenEnhanced() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to project created events
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe([EventNames]::ProjectCreated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe([EventNames]::ProjectUpdated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe([EventNames]::ProjectDeleted, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create project data grid
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Project List"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowHeader = $true
        $this.ProjectGrid.IsFocusable = $true
        
        # Define columns
        $columns = @(
            @{ 
                Name = "Status"
                Header = "Status"
                Width = 8
                Getter = { 
                    param($project) 
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[Done]" } 
                    else { "[Open]" }
                }
            }
            @{ 
                Name = "Name"
                Header = "Project Name"
                Width = 25
                Getter = { param($project) $project.Nickname }
            }
            @{ 
                Name = "ID1"
                Header = "ID1"
                Width = 10
                Getter = { 
                    param($project) 
                    if ($project.ID1) { $project.ID1 } else { "-" }
                }
            }
            @{ 
                Name = "ID2"
                Header = "ID2"
                Width = 15
                Getter = { 
                    param($project) 
                    if ($project.ID2) { $project.ID2 } else { "-" }
                }
            }
            @{ 
                Name = "Client"
                Header = "Client"
                Width = 20
                Getter = { 
                    param($project) 
                    if ($project.Name) { $project.Name } else { "-" }
                }
            }
            @{ 
                Name = "Assigned"
                Header = "Assigned"
                Width = 10
                Getter = { 
                    param($project) 
                    $project.DateAssigned.ToString("MM/dd/yy")
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Create buttons
        $screen = $this
        
        $this.NewButton = [Button]::new("New Project")
        $this.NewButton.IsDefault = $true
        $this.NewButton.OnClick = { $screen.NewProject() }.GetNewClosure()
        $this.NewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.NewButton)
        
        $this.ViewButton = [Button]::new("View Details")
        $this.ViewButton.OnClick = { $screen.ViewProjectDetails() }.GetNewClosure()
        $this.ViewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ViewButton)
        
        $this.EditButton = [Button]::new("Edit")
        $this.EditButton.OnClick = { $screen.EditProject() }.GetNewClosure()
        $this.EditButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.EditButton)
        
        $this.DeleteButton = [Button]::new("Delete")
        $this.DeleteButton.OnClick = { $screen.DeleteProject() }.GetNewClosure()
        $this.DeleteButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.DeleteButton)
        
        # Load projects
        $this.LoadProjects()
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus the grid if it has items, otherwise the New button
        if ($this.ProjectGrid -and $this.ProjectGrid.Items.Count -gt 0) {
            $this.ProjectGrid.Focus()
        } elseif ($this.NewButton) {
            $this.NewButton.Focus()
        }
    }
    
    [void] OnDeactivated() {
        ([Screen]$this).OnDeactivated()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes most space, buttons at bottom
        $buttonAreaHeight = $this.ButtonHeight + 2
        $gridHeight = $this.Height - $buttonAreaHeight
        
        # Project grid
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $gridHeight
        )
        
        # Buttons (horizontally arranged)
        $maxButtonWidth = 20
        $totalButtonWidth = ($maxButtonWidth * 4) + ($this.ButtonSpacing * 3)
        
        if ($this.Width -gt $totalButtonWidth) {
            $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $this.X
            $buttonWidth = [int](($this.Width - ($this.ButtonSpacing * 3)) / 4)
        }
        
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        
        $this.NewButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.ViewButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.EditButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 2,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.DeleteButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 3,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date (most urgent first), then by assigned date
        $sorted = $activeProjects | Sort-Object -Property @(
            @{Expression = { $_.ClosedDate -eq [DateTime]::MinValue }; Descending = $true}
            @{Expression = { ($_.DateDue - [DateTime]::Now).Days }}
            @{Expression = { $_.DateAssigned }}
        )
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        $dialog = [NewProjectDialog]::new()
        
        if (-not $this.EventBus) {
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $dialog = [EditProjectDialog]::new($selected)
        $screen = $this
        $project = $selected
        
        $dialog.OnSave = {
            param($projectData)
            
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            $screen.ProjectService.UpdateProject($project)
            
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                $screen.LoadProjects()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $message = "Are you sure you want to delete project '$($selected.Nickname)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            
            $dialog.OnConfirm = {
                $screen.ProjectService.DeleteProject($projectId)
                
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    $screen.LoadProjects()
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Screens/QuickTimeEntryDialog.ps1
# QuickTimeEntryDialog - Fast time entry for projects and non-project codes

class QuickTimeEntryDialog : BaseDialog {
    [DateTime]$WeekFriday
    [TimeEntry]$ExistingEntry
    [ListBox]$ProjectList
    [TextBox]$ID2Input
    [TextBox]$MondayInput
    [TextBox]$TuesdayInput
    [TextBox]$WednesdayInput
    [TextBox]$ThursdayInput
    [TextBox]$FridayInput
    [Button]$SaveButton
    [Button]$CancelButton
    [bool]$IsProjectMode = $true
    [TimeTrackingService]$TimeService
    [ProjectService]$ProjectService
    [string]$SelectedID2
    
    QuickTimeEntryDialog([DateTime]$weekFriday) : base() {
        $this.Title = "Quick Time Entry"
        $this.WeekFriday = $weekFriday
        $this.Width = 60
        $this.Height = 20
    }
    
    QuickTimeEntryDialog([DateTime]$weekFriday, [TimeEntry]$entry) : base() {
        $this.Title = "Edit Time Entry"
        $this.WeekFriday = $weekFriday
        $this.ExistingEntry = $entry
        $this.Width = 60
        $this.Height = 20
    }
    
    [void] OnInitialize() {
        ([BaseDialog]$this).OnInitialize()
        
        # Get services
        $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
        $this.ProjectService = $this.ServiceContainer.GetService("ProjectService")
        
        $y = 2
        
        # Mode toggle instruction
        $modeLabel = "Tab: Toggle between Project/Non-Project mode"
        $this.AddText($modeLabel, 2, $y)
        $y += 2
        
        # Project list (for project mode)
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = "Select Project (or Tab for ID2 entry)"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.Height = 6
        $this.ProjectList.Width = $this.Width - 4
        $this.ProjectList.SetPosition(2, $y)
        
        # Load projects
        $projects = $this.ProjectService.GetAllProjects() | Where-Object { -not $_.Deleted -and $_.ID2 } | Sort-Object Nickname
        $this.ProjectList.SetItems($projects)
        $this.ProjectList.ItemRenderer = {
            param($project)
            return "$($project.Nickname) - $($project.ID2)"
        }
        
        # Pre-select if editing existing project entry
        if ($this.ExistingEntry -and $this.ExistingEntry.IsProjectEntry()) {
            for ($i = 0; $i -lt $this.ProjectList.Items.Count; $i++) {
                if ($this.ProjectList.Items[$i].ID2 -eq $this.ExistingEntry.ID2) {
                    $this.ProjectList.SelectIndex($i)
                    break
                }
            }
        }
        
        $this.AddChild($this.ProjectList)
        
        # ID2 input (for non-project mode)
        $this.ID2Input = [TextBox]::new()
        $this.ID2Input.Width = 10
        $this.ID2Input.Placeholder = "ID2 Code"
        $this.ID2Input.SetPosition(2, $y)
        $this.ID2Input.IsVisible = $false  # Hidden initially
        
        # Pre-fill if editing existing non-project entry
        if ($this.ExistingEntry -and -not $this.ExistingEntry.IsProjectEntry()) {
            $this.ID2Input.Text = $this.ExistingEntry.ID2
            $this.IsProjectMode = $false
        }
        
        $this.AddChild($this.ID2Input)
        
        $y += 7
        
        # Week display
        $monday = $this.WeekFriday.AddDays(-4)
        $weekLabel = "Week: $($monday.ToString('MM/dd')) - $($this.WeekFriday.ToString('MM/dd/yyyy'))"
        $this.AddText($weekLabel, 2, $y)
        $y += 2
        
        # Day inputs
        $inputY = $y
        $inputX = 2
        $dayWidth = 10
        
        # Monday
        $this.AddText("Monday", $inputX, $inputY)
        $this.MondayInput = [TextBox]::new()
        $this.MondayInput.Width = 6
        $this.MondayInput.SetPosition($inputX, $inputY + 1)
        if ($this.ExistingEntry) { $this.MondayInput.Text = $this.ExistingEntry.Monday.ToString() }
        $this.AddChild($this.MondayInput)
        $inputX += $dayWidth
        
        # Tuesday
        $this.AddText("Tuesday", $inputX, $inputY)
        $this.TuesdayInput = [TextBox]::new()
        $this.TuesdayInput.Width = 6
        $this.TuesdayInput.SetPosition($inputX, $inputY + 1)
        if ($this.ExistingEntry) { $this.TuesdayInput.Text = $this.ExistingEntry.Tuesday.ToString() }
        $this.AddChild($this.TuesdayInput)
        $inputX += $dayWidth
        
        # Wednesday
        $this.AddText("Wednesday", $inputX, $inputY)
        $this.WednesdayInput = [TextBox]::new()
        $this.WednesdayInput.Width = 6
        $this.WednesdayInput.SetPosition($inputX, $inputY + 1)
        if ($this.ExistingEntry) { $this.WednesdayInput.Text = $this.ExistingEntry.Wednesday.ToString() }
        $this.AddChild($this.WednesdayInput)
        $inputX += $dayWidth
        
        # Thursday
        $this.AddText("Thursday", $inputX, $inputY)
        $this.ThursdayInput = [TextBox]::new()
        $this.ThursdayInput.Width = 6
        $this.ThursdayInput.SetPosition($inputX, $inputY + 1)
        if ($this.ExistingEntry) { $this.ThursdayInput.Text = $this.ExistingEntry.Thursday.ToString() }
        $this.AddChild($this.ThursdayInput)
        $inputX += $dayWidth
        
        # Friday
        $this.AddText("Friday", $inputX, $inputY)
        $this.FridayInput = [TextBox]::new()
        $this.FridayInput.Width = 6
        $this.FridayInput.SetPosition($inputX, $inputY + 1)
        if ($this.ExistingEntry) { $this.FridayInput.Text = $this.ExistingEntry.Friday.ToString() }
        $this.AddChild($this.FridayInput)
        
        $y = $inputY + 3
        
        # Buttons
        $buttonY = $this.Height - 4
        $dialog = $this
        
        $this.SaveButton = [Button]::new("Save")
        $this.SaveButton.SetPosition($this.Width - 20, $buttonY)
        $this.SaveButton.OnClick = { $dialog.Save() }.GetNewClosure()
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel") 
        $this.CancelButton.SetPosition($this.Width - 10, $buttonY)
        $this.CancelButton.OnClick = { $dialog.Cancel() }.GetNewClosure()
        $this.AddChild($this.CancelButton)
        
        # Set initial visibility based on mode
        $this.UpdateModeVisibility()
        
        # Focus appropriate field based on today
        $today = [DateTime]::Now
        if ($today.Date -le $this.WeekFriday.Date -and $today.Date -ge $this.WeekFriday.AddDays(-4).Date) {
            # Current week - focus today's input
            switch ($today.DayOfWeek) {
                Monday { $this.MondayInput.Focus() }
                Tuesday { $this.TuesdayInput.Focus() }
                Wednesday { $this.WednesdayInput.Focus() }
                Thursday { $this.ThursdayInput.Focus() }
                Friday { $this.FridayInput.Focus() }
                default { 
                    if ($this.IsProjectMode) { $this.ProjectList.Focus() }
                    else { $this.ID2Input.Focus() }
                }
            }
        } else {
            # Different week - focus project/ID2 selection
            if ($this.IsProjectMode) { $this.ProjectList.Focus() }
            else { $this.ID2Input.Focus() }
        }
        
        # Key bindings
        $this.AddKeyBinding([ConsoleKey]::Tab, { $this.ToggleMode() })
        $this.AddKeyBinding([ConsoleKey]::Enter, { $this.Save() })
        $this.AddKeyBinding([ConsoleKey]::Escape, { $this.Cancel() })
    }
    
    [void] ToggleMode() {
        $this.IsProjectMode = -not $this.IsProjectMode
        $this.UpdateModeVisibility()
        
        if ($this.IsProjectMode) {
            $this.ProjectList.Focus()
        } else {
            $this.ID2Input.Focus()
        }
    }
    
    [void] UpdateModeVisibility() {
        $this.ProjectList.IsVisible = $this.IsProjectMode
        $this.ID2Input.IsVisible = -not $this.IsProjectMode
        $this.Invalidate()
    }
    
    [decimal] ParseHours([string]$text) {
        if ([string]::IsNullOrWhiteSpace($text)) { return 0 }
        $hours = 0
        if ([decimal]::TryParse($text, [ref]$hours)) {
            return $hours
        }
        return 0
    }
    
    [void] Save() {
        # Determine ID2
        if ($this.IsProjectMode) {
            $selected = $this.ProjectList.GetSelectedItem()
            if (-not $selected) {
                $this.ServiceContainer.GetService('ScreenManager').ShowMessage("Please select a project", "Error")
                return
            }
            $this.SelectedID2 = $selected.ID2
        } else {
            $this.SelectedID2 = $this.ID2Input.Text.Trim().ToUpper()
            if ([string]::IsNullOrWhiteSpace($this.SelectedID2)) {
                $this.ServiceContainer.GetService('ScreenManager').ShowMessage("Please enter an ID2 code", "Error")
                return
            }
            if ($this.SelectedID2.Length -lt 3 -or $this.SelectedID2.Length -gt 5) {
                $this.ServiceContainer.GetService('ScreenManager').ShowMessage("ID2 code must be 3-5 characters", "Error")
                return
            }
            
            # Add to time codes if new
            $this.TimeService.AddTimeCode($this.SelectedID2)
        }
        
        # Parse hours
        $data = @{
            WeekEndingFriday = $this.WeekFriday.ToString("yyyyMMdd")
            ID2 = $this.SelectedID2
            Monday = $this.ParseHours($this.MondayInput.Text)
            Tuesday = $this.ParseHours($this.TuesdayInput.Text)
            Wednesday = $this.ParseHours($this.WednesdayInput.Text)
            Thursday = $this.ParseHours($this.ThursdayInput.Text)
            Friday = $this.ParseHours($this.FridayInput.Text)
        }
        
        # Call save callback
        if ($this.OnSave) {
            & $this.OnSave $data
        }
    }
    
    [void] Cancel() {
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }
    
    [void] AddText([string]$text, [int]$x, [int]$y) {
        # Helper to add static text to dialog
        # This would be rendered in OnRender()
    }
}


####\Screens/SettingsScreen.ps1
# SettingsScreen.ps1 - Settings management screen

class SettingsScreen : Screen {
    [ListBox]$CategoryList
    [DataGrid]$SettingsGrid
    [ConfigurationService]$ConfigService
    [hashtable[]]$CurrentSettings = @()
    [string]$CurrentCategory = ""
    [EventBus]$EventBus
    
    SettingsScreen() : base() {
        $this.Title = "Settings"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ConfigService = $global:ServiceContainer.GetService("ConfigurationService")
        if (-not $this.ConfigService) {
            $this.ConfigService = [ConfigurationService]::new()
            $global:ServiceContainer.Register("ConfigurationService", $this.ConfigService)
        }
        
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create category list
        $this.CategoryList = [ListBox]::new()
        $this.CategoryList.Title = "Categories"
        $this.CategoryList.ShowBorder = $true
        # Capture screen reference for callback
        $screen = $this
        $this.CategoryList.OnSelectionChanged = {
            $screen.LoadCategorySettings()
        }.GetNewClosure()
        $this.CategoryList.Initialize($global:ServiceContainer)
        $this.AddChild($this.CategoryList)
        
        # Create settings grid
        $this.SettingsGrid = [DataGrid]::new()
        $this.SettingsGrid.Title = "Settings"
        $this.SettingsGrid.ShowBorder = $true
        $this.SettingsGrid.Initialize($global:ServiceContainer)
        $this.SettingsGrid.SetColumns(@(
            @{Name="Setting"; Header="Setting"; Width=30},
            @{Name="Value"; Header="Value"; Width=20},
            @{Name="Type"; Header="Type"; Width=10}
        ))
        $this.AddChild($this.SettingsGrid)
        
        # Load categories
        $this.LoadCategories()
        
        # No more BindKey - use HandleScreenInput instead
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) { 
                $this.EditSetting()
                return $true
            }
        }
        
        switch ($key.KeyChar) {
            'e' { $this.EditSetting(); return $true }
            'r' { $this.ResetCategory(); return $true }
            'R' { $this.ResetAll(); return $true }
            's' { $this.SaveSettings(); return $true }
        }
        
        return $false
    }
    
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        $this.CategoryList.Focus()
        # Settings are loaded automatically when selection changes
    }
    
    [void] OnBoundsChanged() {
        # Split the width between category list and settings grid
        $categoryWidth = 25
        $gridWidth = [Math]::Max(10, $this.Width - $categoryWidth)
        
        # Set bounds for category list
        $this.CategoryList.SetBounds(
            $this.X,
            $this.Y,
            $categoryWidth,
            $this.Height
        )
        
        # Set bounds for settings grid
        $this.SettingsGrid.SetBounds(
            $this.X + $categoryWidth,
            $this.Y,
            $gridWidth,
            $this.Height
        )
    }
    
    [void] LoadCategories() {
        $config = $this.ConfigService.GetAll()
        $categories = @()
        
        foreach ($key in $config.Keys | Sort-Object) {
            if ($config[$key] -is [hashtable]) {
                $categories += @{
                    Name = $key
                    DisplayName = $this.FormatCategoryName($key)
                }
            }
        }
        
        $this.CategoryList.SetItems($categories)
        $this.CategoryList.ItemRenderer = { param($cat) $cat.DisplayName }
        
        if ($categories.Count -gt 0) {
            $this.CategoryList.SelectIndex(0)
            # LoadCategorySettings is now called automatically by OnSelectionChanged
        }
    }
    
    [void] LoadCategorySettings() {
        $selected = $this.CategoryList.GetSelectedItem()
        if (-not $selected) { return }
        
        $this.CurrentCategory = $selected.Name
        $categoryConfig = $this.ConfigService.Get($this.CurrentCategory)
        
        if ($categoryConfig -is [hashtable]) {
            $settings = @()
            
            foreach ($key in $categoryConfig.Keys | Sort-Object) {
                $value = $categoryConfig[$key]
                $type = $this.GetValueType($value)
                
                $settings += @{
                    Setting = $this.FormatSettingName($key)
                    Value = $this.FormatValue($value)
                    Type = $type
                    Key = $key
                    RawValue = $value
                }
            }
            
            $this.CurrentSettings = $settings
            $this.SettingsGrid.SetItems($settings)
            $this.SettingsGrid.Title = "Settings - $($selected.DisplayName)"
        }
    }
    
    [void] EditSetting() {
        if (-not $this.SettingsGrid.IsFocused) { return }
        
        $selected = $this.SettingsGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $path = "$($this.CurrentCategory).$($selected.Key)"
        $currentValue = $selected.RawValue
        
        # Create appropriate dialog based on type
        $dialog = $null
        
        switch ($selected.Type) {
            "Boolean" {
                # Simple toggle
                $newValue = -not $currentValue
                $this.ConfigService.Set($path, $newValue)
                
                # Publish config changed event
                if ($this.EventBus) {
                    $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                        Path = $path
                        OldValue = $currentValue
                        NewValue = $newValue
                        Category = $this.CurrentCategory
                    })
                }
                
                $this.LoadCategorySettings()
                return
            }
            "Number" {
                # TODO: Create NumberInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("Number editing not yet implemented")
                }
            }
            "String" {
                # TODO: Create TextInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("String editing not yet implemented")
                }
            }
        }
    }
    
    [void] ResetCategory() {
        if (-not $this.CurrentCategory) { return }
        
        $message = "Reset all settings in '$($this.CurrentCategory)' to defaults?"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.OnConfirm = {
            $this.ConfigService.ResetSection($this.CurrentCategory)
            $this.LoadCategorySettings()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ResetAll() {
        $message = "Reset ALL settings to defaults?`n`nThis cannot be undone!"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.ConfirmText = "Reset All"
        $dialog.OnConfirm = {
            $this.ConfigService.Reset()
            $this.LoadCategories()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] SaveSettings() {
        $this.ConfigService.Save()
        if ($global:Logger) {
            $global:Logger.Info("Settings saved")
        }
    }
    
    
    hidden [string] FormatCategoryName([string]$name) {
        # Convert PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        return $formatted.Trim()
    }
    
    hidden [string] FormatSettingName([string]$name) {
        # Convert camelCase/PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        $formatted = $formatted.Substring(0,1).ToUpper() + $formatted.Substring(1)
        return $formatted.Trim()
    }
    
    hidden [string] FormatValue($value) {
        if ($value -eq $null) { return "<null>" }
        if ($value -is [bool]) { return $(if ($value) { "Yes" } else { "No" }) }
        if ($value -is [hashtable]) { return "<nested>" }
        if ($value -is [array]) { return "<array[$($value.Count)]>" }
        return $value.ToString()
    }
    
    hidden [string] GetValueType($value) {
        if ($value -eq $null) { return "Null" }
        if ($value -is [bool]) { return "Boolean" }
        if ($value -is [int] -or $value -is [long] -or $value -is [double]) { return "Number" }
        if ($value -is [string]) { return "String" }
        if ($value -is [hashtable]) { return "Object" }
        if ($value -is [array]) { return "Array" }
        return "Unknown"
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Render base
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append("" * $this.Width)
        
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append(" [Tab]Navigate [Enter/E]Edit [R]Reset Category [Shift+R]Reset All [S]Save")
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
}


####\Screens/SubtaskDialog.ps1
# SubtaskDialog - Dialog for adding/editing subtasks using BaseDialog

class SubtaskDialog : BaseDialog {
    [Task]$ParentTask = $null
    [Subtask]$Subtask = $null  # For editing existing subtasks
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$TitleTextBox
    [TextBox]$DescriptionTextBox
    [TextBox]$EstimatedTimeTextBox
    [TextBox]$ActualTimeTextBox
    [TextBox]$DueDateTextBox
    
    # Dropdowns (simplified as text for now)
    [TextBox]$PriorityTextBox
    [TextBox]$ProgressTextBox
    
    SubtaskDialog() : base("Add Subtask", 60, 24) {
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask) : base("Add Subtask - $($parentTask.Title)", 60, 24) {
        $this.ParentTask = $parentTask
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask, $subtask) : base("Edit Subtask", 60, 24) {
        $this.ParentTask = $parentTask
        $this.Subtask = $subtask
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Update Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.TitleTextBox = [TextBox]::new()
        $this.TitleTextBox.Title = "Title"
        $this.TitleTextBox.ShowBorder = $true
        $this.TitleTextBox.TabIndex = 1
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Title']) {
            $this.TitleTextBox.Text = $this.Subtask.Title
        }
        $this.AddContentControl($this.TitleTextBox)
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        $this.DescriptionTextBox.TabIndex = 2
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Description']) {
            $this.DescriptionTextBox.Text = $this.Subtask.Description
        }
        $this.AddContentControl($this.DescriptionTextBox)
        
        $this.PriorityTextBox = [TextBox]::new()
        $this.PriorityTextBox.Title = "Priority (Low/Medium/High)"
        $this.PriorityTextBox.ShowBorder = $true
        $this.PriorityTextBox.TabIndex = 3
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.Priority) {
            $this.PriorityTextBox.Text = $this.Subtask.Priority.ToString()
        } else {
            $this.PriorityTextBox.Text = "Medium"
        }
        $this.AddContentControl($this.PriorityTextBox)
        
        $this.ProgressTextBox = [TextBox]::new()
        $this.ProgressTextBox.Title = "Progress (0-100)"
        $this.ProgressTextBox.ShowBorder = $true
        $this.ProgressTextBox.TabIndex = 4
        
        if ($this.IsEditMode -and $this.Subtask) {
            $progress = if ($this.Subtask.PSObject.Properties['Progress']) { $this.Subtask.Progress } else { 0 }
            $this.ProgressTextBox.Text = $progress.ToString()
        } else {
            $this.ProgressTextBox.Text = "0"
        }
        $this.AddContentControl($this.ProgressTextBox)
        
        $this.EstimatedTimeTextBox = [TextBox]::new()
        $this.EstimatedTimeTextBox.Title = "Estimated Time (minutes)"
        $this.EstimatedTimeTextBox.ShowBorder = $true
        $this.EstimatedTimeTextBox.TabIndex = 5
        
        if ($this.IsEditMode -and $this.Subtask) {
            $estimated = if ($this.Subtask.PSObject.Properties['EstimatedMinutes']) { $this.Subtask.EstimatedMinutes } else { 0 }
            if ($estimated -gt 0) {
                $this.EstimatedTimeTextBox.Text = $estimated.ToString()
            }
        }
        $this.AddContentControl($this.EstimatedTimeTextBox)
        
        $this.ActualTimeTextBox = [TextBox]::new()
        $this.ActualTimeTextBox.Title = "Actual Time (minutes)"
        $this.ActualTimeTextBox.ShowBorder = $true
        $this.ActualTimeTextBox.TabIndex = 6
        
        if ($this.IsEditMode -and $this.Subtask) {
            $actual = if ($this.Subtask.PSObject.Properties['ActualMinutes']) { $this.Subtask.ActualMinutes } else { 0 }
            if ($actual -gt 0) {
                $this.ActualTimeTextBox.Text = $actual.ToString()
            }
        }
        $this.AddContentControl($this.ActualTimeTextBox)
        
        $this.DueDateTextBox = [TextBox]::new()
        $this.DueDateTextBox.Title = "Due Date (MM/DD/YYYY, optional)"
        $this.DueDateTextBox.ShowBorder = $true
        $this.DueDateTextBox.TabIndex = 7
        
        if ($this.IsEditMode -and $this.Subtask) {
            $dueDate = if ($this.Subtask.PSObject.Properties['DueDate']) { $this.Subtask.DueDate } else { [DateTime]::MinValue }
            if ($dueDate -ne [DateTime]::MinValue) {
                $this.DueDateTextBox.Text = $dueDate.ToString("MM/dd/yyyy")
            }
        }
        $this.AddContentControl($this.DueDateTextBox)
        
        # Set custom handlers for BaseDialog
        $dialog = $this
        $this.OnPrimary = {
            $dialog.HandleSave()
        }.GetNewClosure()
        
        $this.OnSecondary = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
            $dialog.CloseDialog()
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom layout: Stack inputs vertically
        $padding = $this.DialogPadding
        $shortInputHeight = 3
        $tallInputHeight = 4
        $currentY = $dialogY + $padding
        $inputWidth = $this.DialogWidth - ($padding * 2)
        
        # Title input
        $this.TitleTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $tallInputHeight
        )
        $currentY += $tallInputHeight + 1
        
        # Priority and Progress on same row
        $halfWidth = [int](($inputWidth - 2) / 2)
        $this.PriorityTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ProgressTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Estimated and Actual time on same row
        $this.EstimatedTimeTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ActualTimeTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Due date
        $this.DueDateTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create subtask data
        $subtaskData = $this.CreateSubtaskData()
        
        if ($this.OnSave) {
            & $this.OnSave $subtaskData
        }
        
        # Close dialog after successful save
        $this.CloseDialog()
    }
    
    [string] ValidateInputs() {
        # Validate title
        $title = $this.TitleTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($title)) {
            return "Title is required"
        }
        
        # Validate priority
        $priority = $this.PriorityTextBox.Text.Trim()
        if ($priority -notin @("Low", "Medium", "High")) {
            return "Priority must be Low, Medium, or High"
        }
        
        # Validate progress
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $progress = 0
        if (-not [string]::IsNullOrEmpty($progressStr)) {
            if (-not [int]::TryParse($progressStr, [ref]$progress) -or $progress -lt 0 -or $progress -gt 100) {
                return "Progress must be a number between 0 and 100"
            }
        }
        
        # Validate estimated time
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($estimatedStr)) {
            $estimated = 0
            if (-not [int]::TryParse($estimatedStr, [ref]$estimated) -or $estimated -lt 0) {
                return "Estimated time must be a positive number"
            }
        }
        
        # Validate actual time
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($actualStr)) {
            $actual = 0
            if (-not [int]::TryParse($actualStr, [ref]$actual) -or $actual -lt 0) {
                return "Actual time must be a positive number"
            }
        }
        
        # Validate due date
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($dueDateStr)) {
            try {
                [DateTime]::Parse($dueDateStr) | Out-Null
            } catch {
                return "Invalid due date format. Use MM/DD/YYYY"
            }
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateSubtaskData() {
        # Parse inputs
        $title = $this.TitleTextBox.Text.Trim()
        $description = $this.DescriptionTextBox.Text.Trim()
        $priorityStr = $this.PriorityTextBox.Text.Trim()
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        
        # Convert priority
        $priority = switch ($priorityStr) {
            "Low" { [TaskPriority]::Low }
            "High" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # Parse numbers
        $progress = if ([string]::IsNullOrEmpty($progressStr)) { 0 } else { [int]::Parse($progressStr) }
        $estimated = if ([string]::IsNullOrEmpty($estimatedStr)) { 0 } else { [int]::Parse($estimatedStr) }
        $actual = if ([string]::IsNullOrEmpty($actualStr)) { 0 } else { [int]::Parse($actualStr) }
        
        # Parse due date
        $dueDate = if ([string]::IsNullOrEmpty($dueDateStr)) {
            [DateTime]::MinValue
        } else {
            [DateTime]::Parse($dueDateStr)
        }
        
        # Create subtask data object
        $subtaskData = [PSCustomObject]@{
            Id = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Id']) { $this.Subtask.Id } else { [guid]::NewGuid().ToString() }
            } else { 
                [guid]::NewGuid().ToString() 
            }
            ParentTaskId = $this.ParentTask.Id
            Title = $title
            Description = $description
            Status = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Status']) { $this.Subtask.Status } else { [TaskStatus]::Pending }
            } else { 
                [TaskStatus]::Pending 
            }
            Priority = $priority
            Progress = $progress
            EstimatedMinutes = $estimated
            ActualMinutes = $actual
            DueDate = $dueDate
            IsEditMode = $this.IsEditMode
        }
        
        return $subtaskData
    }
    
    # Override HandleScreenInput to add Ctrl+Enter shortcut
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Ctrl+Enter shortcut for save
        if ($key.Key -eq [System.ConsoleKey]::Enter -and ($key.Modifiers -band [ConsoleModifiers]::Control)) {
            $this.HandleSave()
            return $true
        }
        
        return $false
    }
    
    # Legacy callback support
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
}


####\Screens/TaskScreen.ps1
# TaskScreen.ps1 - Task management screen using DataGrid

class TaskScreen : Screen {
    [DataGrid]$TaskGrid
    [TaskService]$TaskService
    [SubtaskService]$SubtaskService
    [ProjectService]$ProjectService
    [hashtable]$StatusColors
    [hashtable]$PriorityColors
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    hidden [bool]$ShowSubtasks = $true
    hidden [hashtable]$ProjectCache = @{}
    
    # Layout settings
    hidden [int]$StatusBarHeight = 2
    
    TaskScreen() : base() {
        $this.Title = "Tasks"
    }
    
    [void] OnInitialize() {
        # Get services using proper dependency injection
        $this.TaskService = $this.GetService("TaskService")
        if (-not $this.TaskService) {
            $this.TaskService = [TaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("TaskService", $this.TaskService)
            } else {
                $global:ServiceContainer.Register("TaskService", $this.TaskService)
            }
        }
        
        $this.SubtaskService = $this.GetService("SubtaskService")
        if (-not $this.SubtaskService) {
            $this.SubtaskService = [SubtaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            } else {
                $global:ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            }
        }
        
        $this.ProjectService = $this.GetService("ProjectService")
        $this.EventBus = $this.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to task created events
            $this.EventSubscriptions['TaskCreated'] = $this.EventBus.Subscribe([EventNames]::TaskCreated, {
                param($sender, $eventData)
                $screen.LoadTasks()
                # Select the new task if provided
                if ($eventData.Task) {
                    for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                        if ($screen.TaskGrid.Items[$i].Id -eq $eventData.Task.Id) {
                            $screen.TaskGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe([EventNames]::CommandExecuted, {
                param($sender, $eventData)
                if ($global:Logger) {
                    $global:Logger.Debug("TaskScreen: Received CommandExecuted event - Command: $($eventData.Command), Target: $($eventData.Target)")
                }
                if ($eventData.Target -eq 'TaskScreen') {
                    switch ($eventData.Command) {
                        'NewTask' { 
                            if ($global:Logger) {
                                $global:Logger.Debug("TaskScreen: Executing NewTask command")
                            }
                            $screen.NewTask() 
                        }
                        'EditTask' { $screen.EditTask() }
                        'DeleteTask' { $screen.DeleteTask() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to task updated events
            $this.EventSubscriptions['TaskUpdated'] = $this.EventBus.Subscribe([EventNames]::TaskUpdated, {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
            
            # Subscribe to task deleted events
            $this.EventSubscriptions['TaskDeleted'] = $this.EventBus.Subscribe([EventNames]::TaskDeleted, {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
        }
        
        # Set up color mappings
        $this.StatusColors = @{
            [TaskStatus]::Pending = "foreground"
            [TaskStatus]::InProgress = "warning"
            [TaskStatus]::Completed = "success"
            [TaskStatus]::Cancelled = "disabled"
        }
        
        $this.PriorityColors = @{
            [TaskPriority]::Low = "success"
            [TaskPriority]::Medium = "warning"
            [TaskPriority]::High = "error"
        }
        
        # Create DataGrid with columns
        $this.TaskGrid = [DataGrid]::new()
        $this.TaskGrid.Title = "Tasks"
        $this.TaskGrid.ShowBorder = $true
        $this.TaskGrid.ShowGridLines = $true
        
        # Define columns
        $screen = $this
        $columns = @(
            @{
                Name = "Status"
                Header = "S"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no status shown in grid (shown in title instead)
                        return " "
                    }
                    switch ($item.Status) {
                        ([TaskStatus]::Pending) { return "P" }
                        ([TaskStatus]::InProgress) { return "W" }
                        ([TaskStatus]::Completed) { return "D" }
                        ([TaskStatus]::Cancelled) { return "X" }
                        default { return "?" }
                    }
                }
            },
            @{
                Name = "Priority"
                Header = "P"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no priority shown in grid
                        return " "
                    }
                    switch ($item.Priority) {
                        ([TaskPriority]::High) { return "H" }
                        ([TaskPriority]::Medium) { return "M" }
                        ([TaskPriority]::Low) { return "L" }
                        default { return " " }
                    }
                }
            },
            @{
                Name = "Title"
                Header = "Task"
                Width = 0  # Flexible width
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - show indented with status
                        $status = switch ($item.Status) {
                            ([TaskStatus]::Pending) { "[ ]" }
                            ([TaskStatus]::InProgress) { "[~]" }
                            ([TaskStatus]::Completed) { "[]" }
                            ([TaskStatus]::Cancelled) { "[]" }
                            default { "[?]" }
                        }
                        return "   $status $($item.Title)"
                    } else {
                        # Main task - include subtask count if any
                        $title = $item.Title
                        if ($screen.SubtaskService) {
                            $stats = $screen.SubtaskService.GetTaskStatistics($item.Id)
                            if ($stats.Total -gt 0) {
                                $title += " [$($stats.Completed)/$($stats.Total)]"
                            }
                        }
                        return $title
                    }
                }
            },
            @{
                Name = "Project"
                Header = "Project"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no project shown
                        return ""
                    }
                    if ($item.ProjectId -and $screen.ProjectService) {
                        # Cache project lookups for performance
                        if (-not $screen.ProjectCache.ContainsKey($item.ProjectId)) {
                            $project = $screen.ProjectService.GetProject($item.ProjectId)
                            if ($project) {
                                $screen.ProjectCache[$item.ProjectId] = $project.FullProjectName
                            } else {
                                $screen.ProjectCache[$item.ProjectId] = ""
                            }
                        }
                        return $screen.ProjectCache[$item.ProjectId]
                    }
                    return ""
                }
            },
            @{
                Name = "DueDate"
                Header = "Due"
                Width = 10
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no due date in grid
                        return ""
                    }
                    if ($item.DueDate -ne [DateTime]::MinValue) {
                        return $item.DueDate.ToString("yyyy-MM-dd")
                    }
                    return ""
                }
            },
            @{
                Name = "Tags"
                Header = "Tags"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no tags shown
                        return ""
                    }
                    if ($item.Tags -and $item.Tags.Count -gt 0) {
                        return ($item.Tags -join ",")
                    }
                    return ""
                }
            }
        )
        
        $this.TaskGrid.SetColumns($columns)
        $this.TaskGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.TaskGrid)
        
        # Load tasks
        $this.LoadTasks()
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        # Focus the grid
        if ($this.TaskGrid -and $this.TaskGrid.Items.Count -gt 0) {
            $this.TaskGrid.Focus()
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.OnActivated: Screen activated and focused grid")
        }
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes all space except status bar
        $gridHeight = $this.Height - $this.StatusBarHeight
        
        # Task grid
        $this.TaskGrid.SetBounds(
            $this.X,
            $this.Y,
            $this.Width,
            $gridHeight
        )
    }
    
    [void] LoadTasks() {
        $tasks = $this.TaskService.GetAllTasks()
        
        # Clear project cache for fresh lookups
        $this.ProjectCache.Clear()
        
        # Filter out deleted tasks
        $activeTasks = $tasks | Where-Object { -not $_.Deleted }
        
        # Sort by priority (high first), then status, then due date
        $sorted = $activeTasks | Sort-Object -Property `
            @{Expression = {$_.Priority}; Descending = $true},
            @{Expression = {$_.Status}; Ascending = $true},
            @{Expression = {if ($_.DueDate -eq [DateTime]::MinValue) { [DateTime]::MaxValue } else { $_.DueDate }}; Ascending = $true}
        
        if ($this.ShowSubtasks -and $this.SubtaskService) {
            # Create combined list with tasks and their subtasks
            $combinedItems = [System.Collections.ArrayList]::new()
            
            foreach ($task in $sorted) {
                $combinedItems.Add($task) | Out-Null
                
                # Add subtasks for this task
                $subtasks = $this.SubtaskService.GetSubtasksForTask($task.Id)
                foreach ($subtask in $subtasks) {
                    $combinedItems.Add($subtask) | Out-Null
                }
            }
            
            $this.TaskGrid.SetItems($combinedItems)
        } else {
            $this.TaskGrid.SetItems($sorted)
        }
    }
    
    [void] NewTask() {
        # Create new task dialog
        $dialog = [NewTaskDialog]::new()
        
        # EventBus will handle task creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($taskData)
                
                $task = $screen.TaskService.CreateTask($taskData)
                $screen.LoadTasks()
                
                # Select the new task
                for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                    if ($screen.TaskGrid.Items[$i].Id -eq $task.Id) {
                        $screen.TaskGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Edit subtask
            $this.EditSubtask($selected)
            return
        }
        
        # Create edit task dialog
        $dialog = [EditTaskDialog]::new($selected)
        # Capture references
        $screen = $this
        $task = $selected
        $dialog.OnSave = {
            param($taskData)
            
            # Update the task
            $task.Title = $taskData.Title
            $task.Description = $taskData.Description
            $task.Status = $taskData.Status
            $task.Priority = $taskData.Priority
            $task.Progress = $taskData.Progress
            $task.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.TaskService.UpdateTask($task)
            
            # Publish task updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskUpdated, @{ Task = $task })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # EditTaskDialog is not a BaseDialog, so we need to Pop manually
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # EditTaskDialog is not a BaseDialog, so we need to handle cancel
        $dialog.OnCancel = {
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
        $message = if ($isSubtask) {
            "Are you sure you want to delete this subtask?`n`n$($selected.Title)"
        } else {
            "Are you sure you want to delete this task?`n`n$($selected.Title)"
        }
        
        # Show confirmation dialog
        $dialog = [ConfirmationDialog]::new($message)
        # Capture references
        $screen = $this
        $itemId = $selected.Id
        $dialog.OnConfirm = {
            if ($isSubtask) {
                # Delete subtask
                $screen.SubtaskService.DeleteSubtask($itemId)
            } else {
                # Delete task (and all its subtasks)
                $screen.TaskService.DeleteTask($itemId)
            }
            
            # Publish task deleted event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskDeleted, @{ TaskId = $itemId })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CycleStatus() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Cycle through status values
        $newStatus = switch ($selected.Status) {
            ([TaskStatus]::Pending) { [TaskStatus]::InProgress }
            ([TaskStatus]::InProgress) { [TaskStatus]::Completed }
            ([TaskStatus]::Completed) { [TaskStatus]::Cancelled }
            ([TaskStatus]::Cancelled) { [TaskStatus]::Pending }
        }
        
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Update subtask
            $selected.Status = $newStatus
            $selected.UpdatedAt = [DateTime]::Now
            $this.SubtaskService.SaveSubtask($selected)
        } else {
            # Update task
            $this.TaskService.UpdateTaskStatus($selected.Id, $newStatus)
        }
        
        # Publish task status changed event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TaskStatusChanged, @{ 
                TaskId = $selected.Id
                OldStatus = $selected.Status
                NewStatus = $newStatus
            })
        } else {
            # Fallback if EventBus not available
            $this.LoadTasks()
        }
    }
    
    [void] AddSubtask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected -or -not $this.SubtaskService) { return }
        
        # Find the parent task (if selected item is a subtask, get its parent)
        $parentTask = $null
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Selected item is a subtask, find its parent
            $parentTask = $this.TaskService.GetTask($selected.ParentTaskId)
        } else {
            # Selected item is a task
            $parentTask = $selected
        }
        
        if (-not $parentTask) { return }
        
        # Create subtask dialog
        $dialog = [SubtaskDialog]::new($parentTask)
        
        # Set up callback for when subtask is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Create subtask using service
            $properties = @{
                ParentTaskId = $subtaskData.ParentTaskId
                Title = $subtaskData.Title
                Description = $subtaskData.Description
                Priority = $subtaskData.Priority
                Progress = $subtaskData.Progress
                EstimatedMinutes = $subtaskData.EstimatedMinutes
                ActualMinutes = $subtaskData.ActualMinutes
                DueDate = $subtaskData.DueDate
            }
            
            $screen.SubtaskService.CreateSubtask($properties)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ToggleSubtaskView() {
        $this.ShowSubtasks = -not $this.ShowSubtasks
        $this.LoadTasks()
    }
    
    [void] EditSubtask([PSCustomObject]$subtask) {
        if (-not $subtask -or -not $this.SubtaskService) { return }
        
        # Get parent task for context
        $parentTask = $this.TaskService.GetTask($subtask.ParentTaskId)
        if (-not $parentTask) { return }
        
        # Create subtask dialog for editing
        $dialog = [SubtaskDialog]::new($parentTask, $subtask)
        
        # Set up callback for when subtask is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Update the existing subtask
            $subtask.Title = $subtaskData.Title
            $subtask.Description = $subtaskData.Description
            $subtask.Status = $subtaskData.Status
            $subtask.Priority = $subtaskData.Priority
            $subtask.Progress = $subtaskData.Progress
            $subtask.EstimatedMinutes = $subtaskData.EstimatedMinutes
            $subtask.ActualMinutes = $subtaskData.ActualMinutes
            $subtask.DueDate = $subtaskData.DueDate
            $subtask.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.SubtaskService.SaveSubtask($subtask)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CyclePriority() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Don't cycle priority for subtasks in this view
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') { return }
        
        $this.TaskService.CyclePriority($selected.Id)
        $this.LoadTasks()
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Handle screen-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n')) {
                    $this.NewTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'E' -or $key.KeyChar -eq 'e')) {
                    $this.EditTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.EditTask()
                return $true
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Delete) {
                $this.DeleteTask()
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadTasks()
                    return $true
                }
            }
            ([System.ConsoleKey]::F5) {
                $this.LoadTasks()
                return $true
            }
            ([System.ConsoleKey]::S) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'S' -or $key.KeyChar -eq 's')) {
                    $this.CycleStatus()
                    return $true
                }
            }
            ([System.ConsoleKey]::P) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'P' -or $key.KeyChar -eq 'p')) {
                    $this.CyclePriority()
                    return $true
                }
            }
            ([System.ConsoleKey]::A) {
                if ($key.Modifiers -band [ConsoleModifiers]::Shift -and ($key.KeyChar -eq 'A')) {
                    # Shift+A to add subtask
                    $this.AddSubtask()
                    return $true
                }
            }
            ([System.ConsoleKey]::T) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'T' -or $key.KeyChar -eq 't')) {
                    # Toggle subtask view
                    $this.ToggleSubtaskView()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Render base (background and children)
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - $this.StatusBarHeight
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append("" * $this.Width)
        
        # Status text
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY + 1))
        $sb.Append($this.Theme.GetColor("disabled"))
        
        $selected = $this.TaskGrid.GetSelectedItem()
        if ($selected) {
            # Show task details in status bar
            $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
            $type = if ($isSubtask) { "Subtask" } else { "Task" }
            $status = $selected.Status.ToString()
            $priority = $selected.Priority.ToString()
            $sb.Append("${type}: $($selected.Title) | Status: $status | Priority: $priority")
        } else {
            # Show help text with letter-based shortcuts
            $sb.Append("[N]ew [E]dit [D]elete [S]tatus [P]riority [A+Shift]Subtask [T]oggle [Tab]Navigate")
        }
        
        # Add legend for status/priority letters
        $sb.Append([VT]::MoveTo($this.X + $this.Width - 35, $statusY + 1))
        $sb.Append("S: P=Pending W=Working D=Done X=Cancel")
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
}


####\Screens/TestScreen.ps1
# TestScreen.ps1 - Simple test screen to verify PRAXIS is working

class TestScreen : Screen {
    [string]$Message = "PRAXIS Test Screen"
    [int]$Counter = 0
    hidden [string]$_cachedContent = ""
    
    TestScreen() : base() {
        $this.Title = "Test"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnInitialize: $($this.Title)")
        }
        
        # No more BindKey - use HandleScreenInput instead
        
        # Don't rebuild content here - wait until we have bounds
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [System.ConsoleKey]::Spacebar) {
            $this.Counter++
            $this._cachedContent = ""  # Force re-render
            $this.RequestRender() 
            return $true
        }
        elseif ($key.KeyChar -eq 'q') {
            $this.Active = $false
            return $true
        }
        
        return $false
    }
    
    [void] OnThemeChanged() {
        ([Screen]$this).OnThemeChanged()
        $this._cachedContent = ""
        $this.RebuildContent()
    }
    
    [void] RebuildContent() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Calculate absolute positions
        $absoluteCenterY = $this.Y + [int]($this.Height / 2)
        $absoluteCenterX = $this.X + [int](($this.Width - $this.Message.Length) / 2)
        
        # Title
        $sb.Append([VT]::MoveTo($absoluteCenterX, $absoluteCenterY - 2))
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append($this.Message)
        
        # Counter
        $counterText = "Counter: $($this.Counter)"
        $counterX = $this.X + [int](($this.Width - $counterText.Length) / 2)
        $sb.Append([VT]::MoveTo($counterX, $absoluteCenterY))
        $sb.Append($this.Theme.GetColor("foreground"))
        $sb.Append($counterText)
        
        # Instructions
        $instructionText = "Press SPACE to increment, Q to quit"
        $instructionX = $this.X + [int](($this.Width - $instructionText.Length) / 2)
        $sb.Append([VT]::MoveTo($instructionX, $absoluteCenterY + 2))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append($instructionText)
        
        # FPS counter (bottom right)
        if ($global:ScreenManager) {
            $fps = [Math]::Round($global:ScreenManager.GetFPS(), 1)
            $fpsText = "FPS: $fps"
            $sb.Append([VT]::MoveTo($this.X + $this.Width - $fpsText.Length - 2, $this.Y + $this.Height - 2))
            $sb.Append($this.Theme.GetColor("success"))
            $sb.Append($fpsText)
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedContent = $sb.ToString()
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnRender: Bounds X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
        }
        
        # Check if we need to rebuild
        if ([string]::IsNullOrEmpty($this._cachedContent)) {
            $this.RebuildContent()
        }
        
        # Return base background + our content
        return ([Container]$this).OnRender() + $this._cachedContent
    }
}


####\Screens/TextEditorScreen.ps1
# TextEditorScreen - Multi-line text editor screen
# Proper PRAXIS architecture implementation

class TextEditorScreen : Screen {
    # Text content and cursor state
    [System.Collections.ArrayList]$Lines
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$FilePath = ""
    [bool]$Modified = $false
    [string]$StatusMessage = ""
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    # Mode system
    [bool]$InTextMode = $true  # Start in text mode
    
    TextEditorScreen() : base() {
        $this.Title = "Text Editor"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.IsFocusable = $true  # TextEditor itself is focusable
    }
    
    TextEditorScreen([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this.FilePath = $filePath
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true  # TextEditor itself is focusable
    }
    
    [void] OnInitialize() {
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        } elseif (-not $this.Lines.Count) {
            $this.Lines.Add("") | Out-Null
        }
        
        # Update title
        if ($this.FilePath) {
            $this.Title = "Text Editor - $([System.IO.Path]::GetFileName($this.FilePath))"
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # TextEditor itself is the focusable element
        $this.Focus()
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw -ErrorAction Stop
            if ($content) {
                $this.Lines.Clear()
                $lineArray = $content -split "`r?`n"
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.Modified = $false
            $this.StatusMessage = "File loaded: $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
            if (-not $this.Lines.Count) {
                $this.Lines.Add("") | Out-Null
            }
        }
        $this.Invalidate()
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            # Open file browser for save location
            $this.OpenFileBrowser()
            return
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $this.FilePath -Value $content -NoNewline -ErrorAction Stop
            $this.Modified = $false
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
        $this.Invalidate()
    }
    
    [void] OpenFileBrowser() {
        # Open file browser for file selection
        try {
            $fileBrowserType = [type]"FileBrowserScreen"
            if ($fileBrowserType) {
                $fileBrowser = $fileBrowserType::new()
                
                # Set up callback for file selection
                $editor = $this
                $fileBrowser.FileSelectedCallback = {
                    param($filePath)
                    if ($filePath -and (Test-Path $filePath)) {
                        $item = Get-Item $filePath -ErrorAction SilentlyContinue
                        if ($item -and -not $item.PSIsContainer) {
                            # File selected - either save current content or load new file
                            if ($editor.StatusMessage -eq "SELECT_SAVE_LOCATION") {
                                # Save current content to selected file
                                $editor.FilePath = $filePath
                                $editor.SaveFile()
                            } else {
                                # Load selected file
                                $editor.FilePath = $filePath
                                $editor.LoadFile()
                            }
                        }
                    }
                    
                    # Close the file browser
                    $screenManager = $editor.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Pop() | Out-Null
                }.GetNewClosure()
                
                # Push the file browser
                $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                $screenManager.Push($fileBrowser)
            }
        } catch {
            $this.StatusMessage = "FileBrowser not available"
            $this.Invalidate()
        }
    }
    
    # Override HandleScreenInput for text editor controls
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Clear status message on input (except for certain messages)
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Error") -and $this.StatusMessage -ne "SELECT_SAVE_LOCATION") {
            $this.StatusMessage = ""
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TextEditorScreen.HandleScreenInput: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' InTextMode=$($this.InTextMode)")
        }
        
        # ESC toggles between text mode and command mode
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $this.InTextMode = -not $this.InTextMode
            $this.StatusMessage = if ($this.InTextMode) { "TEXT MODE" } else { "COMMAND MODE" }
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: ESC pressed, InTextMode=$($this.InTextMode)")
            }
            $this.Invalidate()
            return $true
        }
        
        # In command mode, let number keys bubble up for tab switching
        if (-not $this.InTextMode -and $keyInfo.KeyChar -ge '1' -and $keyInfo.KeyChar -le '9') {
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: In command mode, not handling number key '$($keyInfo.KeyChar)'")
            }
            return $false  # Let parent handle tab switching
        }
        
        # Handle control key combinations
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::S) { 
                    $this.SaveFile()
                    return $true 
                }
                ([ConsoleKey]::O) { 
                    $this.OpenFileBrowser()
                    return $true 
                }
                ([ConsoleKey]::Q) { 
                    if ($this.Modified) {
                        $this.StatusMessage = "Unsaved changes! Press Ctrl+Q again to quit"
                        $this.Invalidate()
                    } else {
                        $this.Active = $false
                    }
                    return $true
                }
            }
        }
        
        # Handle regular keys
        switch ($keyInfo.Key) {
            # Navigation
            ([ConsoleKey]::UpArrow) { $this.MoveCursor(0, -1); return $true }
            ([ConsoleKey]::DownArrow) { $this.MoveCursor(0, 1); return $true }
            ([ConsoleKey]::LeftArrow) { $this.MoveCursor(-1, 0); return $true }
            ([ConsoleKey]::RightArrow) { $this.MoveCursor(1, 0); return $true }
            ([ConsoleKey]::Home) { $this.CursorX = 0; $this.EnsureCursorVisible(); $this.Invalidate(); return $true }
            ([ConsoleKey]::End) { 
                if ($this.CursorY -lt $this.Lines.Count) {
                    $this.CursorX = $this.Lines[$this.CursorY].Length
                }
                $this.EnsureCursorVisible()
                $this.Invalidate()
                return $true
            }
            ([ConsoleKey]::PageUp) { $this.PageUp(); return $true }
            ([ConsoleKey]::PageDown) { $this.PageDown(); return $true }
            
            # Editing
            ([ConsoleKey]::Enter) { $this.InsertNewline(); return $true }
            ([ConsoleKey]::Backspace) { $this.Backspace(); return $true }
            ([ConsoleKey]::Delete) { $this.Delete(); return $true }
            ([ConsoleKey]::Tab) { $this.InsertTab(); return $true }
        }
        
        # Insert printable characters only in text mode
        if ($this.InTextMode -and $keyInfo.KeyChar -and [char]::IsControl($keyInfo.KeyChar) -eq $false) {
            $this.InsertChar($keyInfo.KeyChar)
            return $true
        }
        
        # Let base class handle other input (like tab switching)
        return $false
    }
    
    # Text editor specific methods
    [void] MoveCursor([int]$dx, [int]$dy) {
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.Lines.Count - 1, $this.CursorY + $dy))
        
        if ($dx -ne 0) {
            $this.CursorX = [Math]::Max(0, $this.CursorX + $dx)
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        } else {
            # Vertical movement - try to maintain column
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        }
        
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertChar([char]$char) {
        $line = $this.Lines[$this.CursorY]
        $this.Lines[$this.CursorY] = $line.Insert($this.CursorX, $char)
        $this.CursorX++
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertNewline() {
        $line = $this.Lines[$this.CursorY]
        $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
        $after = if ($this.CursorX -lt $line.Length) { $line.Substring($this.CursorX) } else { "" }
        
        $this.Lines[$this.CursorY] = $before
        $this.Lines.Insert($this.CursorY + 1, $after)
        
        $this.CursorY++
        $this.CursorX = 0
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Backspace() {
        if ($this.CursorX -gt 0) {
            # Delete character before cursor
            $line = $this.Lines[$this.CursorY]
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Join with previous line
            $prevLine = $this.Lines[$this.CursorY - 1]
            $currentLine = $this.Lines[$this.CursorY]
            $this.CursorX = $prevLine.Length
            $this.Lines[$this.CursorY - 1] = $prevLine + $currentLine
            $this.Lines.RemoveAt($this.CursorY)
            $this.CursorY--
        }
        
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Delete() {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.CursorX -lt $line.Length) {
            # Delete character at cursor
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX, 1)
        } elseif ($this.CursorY -lt $this.Lines.Count - 1) {
            # Join with next line
            $nextLine = $this.Lines[$this.CursorY + 1]
            $this.Lines[$this.CursorY] = $line + $nextLine
            $this.Lines.RemoveAt($this.CursorY + 1)
        }
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] InsertTab() {
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
    
    [void] PageUp() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] PageDown() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Min($this.Lines.Count - 1, $this.CursorY + $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] EnsureCursorVisible() {
        $editorHeight = $this.Height - 6
        $editorWidth = $this.Width - $this.LineNumberWidth
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # When bounds change, ensure cursor is still visible
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096  # Text editor can have large content
        
        # Get theme colors
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
        $lineNumColor = if ($this.Theme) { $this.Theme.GetColor("linenumber") } else { $fgColor }
        $statusBg = if ($this.Theme) { $this.Theme.GetBgColor("status") } else { $bgColor }
        $statusFg = if ($this.Theme) { $this.Theme.GetColor("status.foreground") } else { $fgColor }
        $cursorBg = if ($this.Theme) { $this.Theme.GetBgColor("cursor") } else { $fgColor }
        
        # Calculate content area
        $contentHeight = $this.Height - 3  # Reserve space for title and status
        $contentWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartX = $this.X + ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartY = $this.Y + 1
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append(" " * $this.Width)
        }
        
        # Draw title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        $titleText = $this.Title
        if ($this.Modified) { $titleText += " *" }
        $titleText = $titleText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($titleText)
        
        # Render text lines
        $endY = [Math]::Min($this.ScrollOffsetY + $contentHeight, $this.Lines.Count)
        for ($lineIdx = $this.ScrollOffsetY; $lineIdx -lt $endY; $lineIdx++) {
            $screenY = $contentStartY + ($lineIdx - $this.ScrollOffsetY)
            $line = $this.Lines[$lineIdx]
            
            # Draw line numbers if enabled
            if ($this.ShowLineNumbers) {
                $sb.Append([VT]::MoveTo($this.X, $screenY))
                $sb.Append($lineNumColor)
                $lineNum = ($lineIdx + 1).ToString().PadLeft($this.LineNumberWidth - 1) + " "
                $sb.Append($lineNum)
            }
            
            # Draw line content
            $sb.Append([VT]::MoveTo($contentStartX, $screenY))
            $sb.Append($fgColor)
            
            if ($line.Length -gt $this.ScrollOffsetX) {
                $visibleText = $line.Substring($this.ScrollOffsetX)
                if ($visibleText.Length -gt $contentWidth) {
                    $visibleText = $visibleText.Substring(0, $contentWidth)
                }
                $sb.Append($visibleText)
            }
        }
        
        # Draw cursor if this screen is focused
        if ($this.IsFocused) {
            $cursorScreenX = $contentStartX + ($this.CursorX - $this.ScrollOffsetX)
            $cursorScreenY = $contentStartY + ($this.CursorY - $this.ScrollOffsetY)
            
            # Only draw cursor if it's visible
            if ($cursorScreenX -ge $contentStartX -and $cursorScreenX -lt $contentStartX + $contentWidth -and
                $cursorScreenY -ge $contentStartY -and $cursorScreenY -lt $contentStartY + $contentHeight) {
                
                $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
                $sb.Append($cursorBg)
                
                # Get character under cursor
                $charUnderCursor = " "
                if ($this.CursorY -lt $this.Lines.Count) {
                    $line = $this.Lines[$this.CursorY]
                    if ($this.CursorX -lt $line.Length) {
                        $charUnderCursor = $line[$this.CursorX]
                    }
                }
                $sb.Append($charUnderCursor)
            }
        }
        
        # Draw status line
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        
        $statusText = ""
        if ($this.StatusMessage) {
            $statusText = $this.StatusMessage
        } else {
            $modeText = if ($this.InTextMode) { "[TEXT]" } else { "[COMMAND]" }
            $statusText = "$modeText Line $($this.CursorY + 1), Col $($this.CursorX + 1)"
            if ($this.FilePath) {
                $statusText += " | $([System.IO.Path]::GetFileName($this.FilePath))"
            }
        }
        $statusText = $statusText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($statusText)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/TextInputDialog.ps1
# TextInputDialog.ps1 - Simple dialog for text input

class TextInputDialog : Screen {
    [string]$Prompt
    [string]$DefaultValue
    [string]$Placeholder
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    TextInputDialog([string]$prompt) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = ""
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    TextInputDialog([string]$prompt, [string]$defaultValue) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue
        $this.InputBox.Placeholder = $this.Placeholder
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            if ($dialog.OnSubmit) {
                & $dialog.OnSubmit $dialog.InputBox.Text
            }
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box and select all text
        $this.InputBox.Focus()
        # TODO: Add SelectAll method to TextBox
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 10 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append(" " * $this.Width)
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append(" " * $w)
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        return $sb.ToString()
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/TimeEntryDialog.ps1
# TimeEntryDialog - Dialog for adding/editing time entries
# Based on tracker.txt time tracking structure

class TimeEntryDialog : BaseDialog {
    [Project]$Project = $null
    [PSCustomObject]$TimeEntry = $null  # For editing existing entries
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$DateTextBox
    [TextBox]$HoursTextBox
    [TextBox]$DescriptionTextBox
    
    # Buttons
    [Button]$SaveButton
    [Button]$CancelButton
    
    # Callbacks
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    TimeEntryDialog() : base("Add Time Entry") {
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project) : base("Add Time Entry") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project, [PSCustomObject]$timeEntry) : base("Edit Time Entry") {
        $this.Project = $project
        $this.TimeEntry = $timeEntry
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.DateTextBox = [TextBox]::new()
        $this.DateTextBox.Title = "Date (MM/DD/YYYY)"
        $this.DateTextBox.ShowBorder = $true
        
        # Set default date to today
        if (-not $this.IsEditMode) {
            $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
        } else {
            # Convert from YYYYMMDD format to MM/dd/yyyy
            try {
                $entryDate = [DateTime]::ParseExact($this.TimeEntry.Date, "yyyyMMdd", $null)
                $this.DateTextBox.Text = $entryDate.ToString("MM/dd/yyyy")
            } catch {
                $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
            }
        }
        
        $this.HoursTextBox = [TextBox]::new()
        $this.HoursTextBox.Title = "Hours (e.g., 8.5)"
        $this.HoursTextBox.ShowBorder = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Total) {
            $this.HoursTextBox.Text = $this.TimeEntry.Total
        }
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Description) {
            $this.DescriptionTextBox.Text = $this.TimeEntry.Description
        }
        
        # Initialize components
        if ($this.ServiceContainer) {
            $this.DateTextBox.Initialize($this.ServiceContainer)
            $this.HoursTextBox.Initialize($this.ServiceContainer)
            $this.DescriptionTextBox.Initialize($this.ServiceContainer)
        }
        
        # Create buttons
        $saveText = if ($this.IsEditMode) { "Update Entry" } else { "Add Entry" }
        $this.SaveButton = [Button]::new($saveText)
        $this.SaveButton.IsDefault = $true
        $this.SaveButton.OnClick = { $this.HandleSave() }
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = { $this.HandleCancel() }
        
        if ($this.ServiceContainer) {
            $this.SaveButton.Initialize($this.ServiceContainer)
            $this.CancelButton.Initialize($this.ServiceContainer)
        }
        
        # Add children
        $this.AddChild($this.DateTextBox)
        $this.AddChild($this.HoursTextBox)
        $this.AddChild($this.DescriptionTextBox)
        $this.AddChild($this.SaveButton)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.DateTextBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Stack inputs vertically with buttons at bottom
        $margin = 2
        $buttonHeight = 3
        $inputHeight = 3
        $descriptionHeight = 5
        
        $currentY = $this.Y + $margin
        $inputWidth = $this.Width - ($margin * 2)
        
        # Date input
        $this.DateTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Hours input
        $this.HoursTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $descriptionHeight
        )
        $currentY += $descriptionHeight + 2
        
        # Buttons at bottom
        $buttonWidth = 15
        $buttonSpacing = 4
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - 1
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create time entry data
        $timeEntryData = $this.CreateTimeEntryData()
        
        if ($this.OnSave) {
            & $this.OnSave $timeEntryData
        }
    }
    
    [void] HandleCancel() {
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }
    
    [string] ValidateInputs() {
        # Validate date
        $dateStr = $this.DateTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Date is required"
        }
        
        try {
            [DateTime]::Parse($dateStr) | Out-Null
        } catch {
            return "Invalid date format. Use MM/DD/YYYY"
        }
        
        # Validate hours
        $hoursStr = $this.HoursTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($hoursStr)) {
            return "Hours is required"
        }
        
        $hours = 0.0
        if (-not [double]::TryParse($hoursStr, [ref]$hours) -or $hours -le 0) {
            return "Hours must be a positive number"
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateTimeEntryData() {
        # Parse and format date to YYYYMMDD
        $entryDate = [DateTime]::Parse($this.DateTextBox.Text.Trim())
        $internalDate = $entryDate.ToString("yyyyMMdd")
        
        # Parse hours
        $hours = [double]::Parse($this.HoursTextBox.Text.Trim())
        
        # Get day of week for hour distribution
        $dayOfWeek = $entryDate.DayOfWeek
        
        # Create time entry following tracker.txt structure
        $newTimeEntry = [PSCustomObject]@{
            Date = $internalDate
            Nickname = $this.Project.Nickname
            ID1 = if ($this.Project.ID1) { $this.Project.ID1 } else { "" }
            ID2 = $this.FormatID2($this.Project.ID2)
            MonHours = if ($dayOfWeek -eq "Monday") { $hours.ToString("F2") } else { "" }
            TueHours = if ($dayOfWeek -eq "Tuesday") { $hours.ToString("F2") } else { "" }
            WedHours = if ($dayOfWeek -eq "Wednesday") { $hours.ToString("F2") } else { "" }
            ThuHours = if ($dayOfWeek -eq "Thursday") { $hours.ToString("F2") } else { "" }
            FriHours = if ($dayOfWeek -eq "Friday") { $hours.ToString("F2") } else { "" }
            Total = $hours.ToString("F2")
            Description = $this.DescriptionTextBox.Text.Trim()
        }
        
        return $newTimeEntry
    }
    
    [string] FormatID2([string]$id2) {
        # Format ID2 with V0 prefix, S suffix, padded to 12 characters
        # Following tracker.txt format
        if ([string]::IsNullOrWhiteSpace($id2)) {
            return ""
        }
        
        $id2Text = $id2.Trim()
        $paddingNeeded = 12 - ($id2Text.Length + 2)
        
        if ($paddingNeeded > 0) {
            return "V" + ("0" * $paddingNeeded) + $id2Text + "S"
        } else {
            return "V" + $id2Text + "S"
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Enter) {
                if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.HandleSave()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleCancel()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                # Handle tab navigation between fields
                $focused = $this.FindFocused()
                if ($focused -eq $this.DateTextBox) {
                    $this.HoursTextBox.Focus()
                } elseif ($focused -eq $this.HoursTextBox) {
                    $this.DescriptionTextBox.Focus()
                } elseif ($focused -eq $this.DescriptionTextBox) {
                    $this.SaveButton.Focus()
                } else {
                    $this.DateTextBox.Focus()
                }
                return $true
            }
        }
        
        # Let base class handle other input
        return $false
    }
}


####\Screens/TimeEntryScreen.ps1
# TimeEntryScreen - Weekly time entry grid with quick entry

class TimeEntryScreen : Screen {
    [DataGrid]$TimeGrid
    [Button]$PrevWeekButton
    [Button]$NextWeekButton
    [Button]$CurrentWeekButton
    [Button]$QuickEntryButton
    [DateTime]$CurrentWeekFriday
    [TimeTrackingService]$TimeService
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$StatusBarHeight = 1
    
    TimeEntryScreen() : base() {
        $this.Title = "Time Entry"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
        $this.ProjectService = $this.ServiceContainer.GetService("ProjectService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Set current week
        $this.CurrentWeekFriday = $this.TimeService.GetCurrentWeekFriday()
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to time entry updates
            $this.EventSubscriptions['TimeEntryUpdated'] = $this.EventBus.Subscribe([EventNames]::TimeEntryUpdated, {
                param($sender, $eventData)
                $screen.RefreshGrid()
            }.GetNewClosure())
        }
        
        # Create time grid
        $this.TimeGrid = [DataGrid]::new()
        $this.TimeGrid.ShowHeader = $true
        $this.TimeGrid.ShowBorder = $true
        $this.TimeGrid.Title = $this.GetWeekTitle()
        $this.TimeGrid.IsFocusable = $true
        
        # Set up columns: Name | ID1 | ID2 | Mon | Tue | Wed | Thu | Fri | Total
        $columns = @(
            @{ Name = "Name"; Header = "Name"; Width = 20; Getter = { param($item) $item.Name } }
            @{ Name = "ID1"; Header = "ID1"; Width = 10; Getter = { param($item) $item.ID1 } }
            @{ Name = "ID2"; Header = "ID2"; Width = 15; Getter = { param($item) $item.ID2 } }
            @{ Name = "Monday"; Header = "Mon"; Width = 6; Getter = { param($item) if ($item.Monday -gt 0) { $item.Monday.ToString("F1") } else { "" } } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 6; Getter = { param($item) if ($item.Tuesday -gt 0) { $item.Tuesday.ToString("F1") } else { "" } } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 6; Getter = { param($item) if ($item.Wednesday -gt 0) { $item.Wednesday.ToString("F1") } else { "" } } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 6; Getter = { param($item) if ($item.Thursday -gt 0) { $item.Thursday.ToString("F1") } else { "" } } }
            @{ Name = "Friday"; Header = "Fri"; Width = 6; Getter = { param($item) if ($item.Friday -gt 0) { $item.Friday.ToString("F1") } else { "" } } }
            @{ Name = "Total"; Header = "Total"; Width = 7; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.TimeGrid.SetColumns($columns)
        $this.AddChild($this.TimeGrid)
        
        # Create navigation buttons
        $screen = $this  # Capture reference for closures
        
        $this.PrevWeekButton = [Button]::new("< Prev Week")
        $this.PrevWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.AddChild($this.PrevWeekButton)
        
        $this.CurrentWeekButton = [Button]::new("Current Week")
        $this.CurrentWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.TimeService.GetCurrentWeekFriday()
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.AddChild($this.CurrentWeekButton)
        
        $this.NextWeekButton = [Button]::new("Next Week >")
        $this.NextWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.AddChild($this.NextWeekButton)
        
        $this.QuickEntryButton = [Button]::new("Quick Entry (Q)")
        $this.QuickEntryButton.IsDefault = $true
        $this.QuickEntryButton.OnClick = { $screen.ShowQuickEntry() }.GetNewClosure()
        $this.AddChild($this.QuickEntryButton)
        
        # Load initial data
        $this.RefreshGrid()
        
        # Key bindings
        $this.AddKeyBinding([ConsoleKey]::Q, { $this.ShowQuickEntry() })
        $this.AddKeyBinding([ConsoleKey]::LeftArrow, { 
            $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(-7)
            $this.RefreshGrid()
        })
        $this.AddKeyBinding([ConsoleKey]::RightArrow, { 
            $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(7)
            $this.RefreshGrid()
        })
        $this.AddKeyBinding([ConsoleKey]::Enter, { $this.EditSelectedEntry() })
        $this.AddKeyBinding([ConsoleKey]::E, { $this.EditSelectedEntry() })
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.TimeGrid) { return }
        
        # Calculate layout
        $gridHeight = $this.Height - $this.ButtonHeight - $this.StatusBarHeight - 1
        
        # Position grid
        $this.TimeGrid.SetBounds($this.X, $this.Y, $this.Width, $gridHeight)
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - $this.StatusBarHeight
        $buttonWidth = 14
        $totalButtonWidth = ($buttonWidth * 4) + 3  # 4 buttons with spacing
        
        # Center buttons
        $buttonStartX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        $this.PrevWeekButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $this.CurrentWeekButton.SetBounds($buttonStartX + $buttonWidth + 1, $buttonY, $buttonWidth, $this.ButtonHeight)
        $this.NextWeekButton.SetBounds($buttonStartX + ($buttonWidth + 1) * 2, $buttonY, $buttonWidth, $this.ButtonHeight)
        $this.QuickEntryButton.SetBounds($buttonStartX + ($buttonWidth + 1) * 3, $buttonY, $buttonWidth, $this.ButtonHeight)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Refresh data and focus grid
        $this.RefreshGrid()
        if ($this.TimeGrid) {
            $this.TimeGrid.Focus()
        }
    }
    
    [string] GetWeekTitle() {
        $monday = $this.CurrentWeekFriday.AddDays(-4)
        return "Time Entry - Week of $($monday.ToString('MM/dd/yyyy')) to $($this.CurrentWeekFriday.ToString('MM/dd/yyyy'))"
    }
    
    [void] RefreshGrid() {
        # Update title
        $this.TimeGrid.Title = $this.GetWeekTitle()
        
        # Get entries for current week
        $weekString = $this.CurrentWeekFriday.ToString("yyyyMMdd")
        $entries = $this.TimeService.GetWeekEntries($weekString)
        
        # Sort by: Projects first (by name), then non-projects (by ID2)
        $sorted = $entries | Sort-Object -Property @(
            @{Expression = { $_.IsProjectEntry() }; Descending = $true},
            @{Expression = { $_.Name }},
            @{Expression = { $_.ID2 }}
        )
        
        $this.TimeGrid.SetItems($sorted)
        $this.Invalidate()
    }
    
    [void] ShowQuickEntry() {
        # Create quick entry dialog
        $dialog = [QuickTimeEntryDialog]::new($this.CurrentWeekFriday)
        
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeData)
            
            # Add/update time entry
            $entry = $screen.TimeService.GetOrCreateTimeEntry($timeData.WeekEndingFriday, $timeData.ID2)
            
            # Update the specific day's hours
            switch ($timeData.DayOfWeek) {
                Monday { $entry.Monday = $timeData.Hours }
                Tuesday { $entry.Tuesday = $timeData.Hours }
                Wednesday { $entry.Wednesday = $timeData.Hours }
                Thursday { $entry.Thursday = $timeData.Hours }
                Friday { $entry.Friday = $timeData.Hours }
            }
            
            # Save through service
            $screen.TimeService.UpdateTimeEntry($entry)
            
            # Close dialog
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] EditSelectedEntry() {
        $selected = $this.TimeGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit dialog for the selected entry
        $dialog = [QuickTimeEntryDialog]::new($this.CurrentWeekFriday, $selected)
        
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeData)
            
            # Update all days for this entry
            $selected.Monday = $timeData.Monday
            $selected.Tuesday = $timeData.Tuesday
            $selected.Wednesday = $timeData.Wednesday
            $selected.Thursday = $timeData.Thursday
            $selected.Friday = $timeData.Friday
            
            # Save through service
            $screen.TimeService.UpdateTimeEntry($selected)
            
            # Close dialog
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [string] OnRender() {
        $sb = [System.Text.StringBuilder]::new()
        
        # Render base screen first
        $null = $sb.Append(([Screen]$this).OnRender())
        
        # Render status bar at bottom
        $statusY = $this.Y + $this.Height - 1
        $null = $sb.Append($this.VT.MoveTo($this.X, $statusY))
        $null = $sb.Append($this.ThemeManager.GetCached('StatusBar'))
        $null = $sb.Append(' ' * $this.Width)  # Clear line
        
        # Show week totals
        $weekTotal = 0
        $entries = $this.TimeService.GetWeekEntries($this.CurrentWeekFriday.ToString("yyyyMMdd"))
        foreach ($entry in $entries) {
            $weekTotal += $entry.Total
        }
        
        $statusText = "Week Total: $($weekTotal.ToString('F1')) hours | Q: Quick Entry | E: Edit | /: Navigate Weeks"
        $null = $sb.Append($this.VT.MoveTo($this.X + 2, $statusY))
        $null = $sb.Append($statusText)
        $null = $sb.Append($this.VT.Reset)
        
        return $sb.ToString()
    }
    
    # Handle special keys
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Let base class handle registered key bindings
        return $false
    }
}


####\Services/ConfigurationService.ps1
# ConfigurationService.ps1 - Configuration management with persistence

class ConfigurationService {
    hidden [string]$ConfigPath
    hidden [hashtable]$Config
    hidden [hashtable]$Defaults
    hidden [bool]$AutoSave = $true
    
    ConfigurationService() {
        $this.ConfigPath = Join-Path $global:PraxisRoot "_Config" "settings.json"
        $this.InitializeDefaults()
        $this.Load()
    }
    
    ConfigurationService([string]$configPath) {
        $this.ConfigPath = $configPath
        $this.InitializeDefaults()
        $this.Load()
    }
    
    hidden [void] InitializeDefaults() {
        $this.Defaults = @{
            Theme = "default"
            Editor = @{
                TabSize = 4
                WordWrap = $false
                ShowLineNumbers = $true
                HighlightCurrentLine = $true
            }
            UI = @{
                AnimationsEnabled = $true
                ShowScrollbars = $true
                CompactMode = $false
            }
            Projects = @{
                DefaultPath = Join-Path $global:PraxisRoot "_ProjectData"
                AutoSave = $true
                BackupEnabled = $true
                BackupCount = 5
            }
            Tasks = @{
                DefaultPriority = "Medium"
                ShowCompletedTasks = $true
                CompletedTaskRetention = 30  # days
            }
            Performance = @{
                EnableCaching = $true
                MaxCacheSize = 100  # MB
                RenderOptimization = $true
            }
            Logging = @{
                Level = "Info"
                MaxFileSize = 10  # MB
                MaxFiles = 5
            }
        }
    }
    
    [void] Load() {
        # Ensure config directory exists
        $configDir = Split-Path -Parent $this.ConfigPath
        if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir -Force | Out-Null
        }
        
        # Load config from file or use defaults
        if (Test-Path $this.ConfigPath) {
            try {
                $json = Get-Content -Path $this.ConfigPath -Raw
                $loaded = $json | ConvertFrom-Json -AsHashtable
                
                # Merge with defaults to ensure all keys exist
                $this.Config = $this.MergeHashtables($this.Defaults, $loaded)
                
                if ($global:Logger) {
                    $global:Logger.Info("Configuration loaded from: $($this.ConfigPath)")
                }
            } catch {
                Write-Warning "Failed to load configuration: $_"
                $this.Config = $this.Defaults.Clone()
            }
        } else {
            # No config file, use defaults and save
            $this.Config = $this.Defaults.Clone()
            $this.Save()
        }
    }
    
    [void] Save() {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $this.ConfigPath -Value $json -Encoding UTF8
            
            if ($global:Logger) {
                $global:Logger.Debug("Configuration saved to: $($this.ConfigPath)")
            }
        } catch {
            Write-Warning "Failed to save configuration: $_"
        }
    }
    
    # Deep merge hashtables, preserving structure
    hidden [hashtable] MergeHashtables([hashtable]$base, [hashtable]$overlay) {
        $result = $base.Clone()
        
        foreach ($key in $overlay.Keys) {
            if ($base.ContainsKey($key) -and $base[$key] -is [hashtable] -and $overlay[$key] -is [hashtable]) {
                # Recursively merge nested hashtables
                $result[$key] = $this.MergeHashtables($base[$key], $overlay[$key])
            } else {
                # Overlay value takes precedence
                $result[$key] = $overlay[$key]
            }
        }
        
        return $result
    }
    
    # Get configuration value with dot notation support
    [object] Get([string]$path) {
        return $this.Get($path, $null)
    }
    
    [object] Get([string]$path, $default) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $default
            }
        }
        
        return $current
    }
    
    # Set configuration value with dot notation support
    [void] Set([string]$path, $value) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            } elseif ($current[$part] -isnot [hashtable]) {
                # Path conflict - convert to hashtable
                $current[$part] = @{}
            }
            
            $current = $current[$part]
        }
        
        # Set the final value
        $lastPart = $parts[-1]
        $current[$lastPart] = $value
        
        # Auto-save if enabled
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Check if configuration key exists
    [bool] Has([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $false
            }
        }
        
        return $true
    }
    
    # Remove configuration key
    [void] Remove([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                # Path doesn't exist
                return
            }
        }
        
        # Remove the final key
        $lastPart = $parts[-1]
        if ($current -is [hashtable] -and $current.ContainsKey($lastPart)) {
            $current.Remove($lastPart)
            
            # Auto-save if enabled
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Reset to defaults
    [void] Reset() {
        $this.Config = $this.Defaults.Clone()
        $this.Save()
    }
    
    # Reset specific section to defaults
    [void] ResetSection([string]$section) {
        if ($this.Defaults.ContainsKey($section)) {
            $this.Config[$section] = $this.Defaults[$section].Clone()
            
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Get all configuration as hashtable
    [hashtable] GetAll() {
        return $this.Config.Clone()
    }
    
    # Import configuration from hashtable
    [void] Import([hashtable]$config) {
        $this.Config = $this.MergeHashtables($this.Defaults, $config)
        
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Export configuration to file
    [void] Export([string]$path) {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $path -Value $json -Encoding UTF8
        } catch {
            throw "Failed to export configuration: $_"
        }
    }
}


####\Services/EventBus.ps1
# EventBus Service for PRAXIS
# Based on AxiomPhoenix EventManager with adaptations for PRAXIS architecture
# Provides pub/sub event system for decoupled communication between components

class EventBus {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $false  # Disabled by default for performance
    [ServiceContainer]$ServiceContainer
    [bool]$EnableDebugLogging = $false  # Enable detailed event logging
    hidden [int]$TotalEventsPublished = 0
    hidden [int]$TotalHandlersCalled = 0
    
    EventBus() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.ServiceContainer = $container
        $logger = $container.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus initialized", "Info")
        }
    }
    
    # Subscribe to an event with a handler
    # Returns a subscription ID that can be used to unsubscribe
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("Handler cannot be null")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        $logger = $this.ServiceContainer.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus: Subscribed handler '$handlerId' to event '$eventName'", "Debug")
        }
        
        return $handlerId
    }
    
    # Subscribe with a weak reference to an object
    # Automatically unsubscribes if the object is garbage collected
    [string] SubscribeWeak([string]$eventName, [object]$target, [scriptblock]$handler) {
        $weakRef = [System.WeakReference]::new($target)
        $wrappedHandler = {
            param($sender, $eventData)
            $strongRef = $weakRef.Target
            if ($strongRef) {
                & $handler $sender $eventData
            } else {
                # Target has been garbage collected, unsubscribe
                $eventBus = $sender
                $eventBus.Unsubscribe($eventName, $args[0])
            }
        }.GetNewClosure()
        
        return $this.Subscribe($eventName, $wrappedHandler)
    }
    
    # Unsubscribe a specific handler
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
                
                $logger = $this.ServiceContainer.GetService('Logger')
                if ($logger) {
                    $logger.Log("EventBus: Unsubscribed handler '$handlerId' from event '$eventName'", "Debug")
                }
            }
        }
    }
    
    # Unsubscribe all handlers for an event
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Unsubscribed all $handlerCount handlers from event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event with optional data
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        # Add timestamp to event data
        $eventData['Timestamp'] = [DateTime]::Now
        $eventData['EventName'] = $eventName
        
        $this.TotalEventsPublished++
        
        # Debug logging
        if ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Publishing event '$eventName' with data: $($eventData | ConvertTo-Json -Compress)", "Debug")
            }
        }
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $this.AddToHistory($eventName, $eventData)
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            
            if ($this.EnableDebugLogging) {
                $debugLogger = $this.ServiceContainer.GetService('Logger')
                if ($debugLogger) {
                    $debugLogger.Log("EventBus: Found $($handlers.Count) handlers for event '$eventName'", "Debug")
                }
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    $this.TotalHandlersCalled++
                    
                    if ($this.EnableDebugLogging) {
                        $debugLogger = $this.ServiceContainer.GetService('Logger')
                        if ($debugLogger) {
                            $debugLogger.Log("EventBus: Calling handler '$($entry.Key)' for event '$eventName'", "Debug")
                        }
                    }
                    
                    # Call handler with EventBus as sender and eventData
                    & $handlerData.Handler $this $eventData
                }
                catch {
                    $logger = $this.ServiceContainer.GetService('Logger')
                    if ($logger) {
                        $logger.Log("EventBus: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)", "Error")
                    }
                }
            }
        }
        elseif ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: No handlers registered for event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event asynchronously (returns immediately)
    [void] PublishAsync([string]$eventName, [hashtable]$eventData = @{}) {
        $job = Start-Job -ScriptBlock {
            param($eventBus, $eventName, $eventData)
            $eventBus.Publish($eventName, $eventData)
        } -ArgumentList $this, $eventName, $eventData
        
        # Clean up job after completion
        Register-ObjectEvent -InputObject $job -EventName StateChanged -Action {
            if ($Event.SourceEventArgs.JobStateInfo.State -eq 'Completed') {
                Remove-Job -Job $Event.SourceEventArgs
                Unregister-Event -SourceIdentifier $Event.SourceIdentifier
            }
        } | Out-Null
    }
    
    # Add event to history
    hidden [void] AddToHistory([string]$eventName, [hashtable]$eventData) {
        # Sanitize event data to prevent circular references
        $sanitizedData = @{}
        foreach ($key in $eventData.Keys) {
            $value = $eventData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [double] -or 
                $value -is [bool] -or $value -is [datetime] -or $value -eq $null) {
                $sanitizedData[$key] = $value
            }
            elseif ($value.GetType().Name -eq 'UIElement' -or $value.GetType().BaseType.Name -eq 'UIElement') {
                # Handle UIElement without requiring the type to be loaded
                $name = if ($value.PSObject.Properties['Name']) { $value.Name } else { 'Unknown' }
                $sanitizedData[$key] = "[UIElement: $name]"
            }
            else {
                $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
            }
        }
        
        $historyEntry = @{
            EventName = $eventName
            EventData = $sanitizedData
            Timestamp = [DateTime]::Now
            HandlerCount = if ($this.EventHandlers.ContainsKey($eventName)) { 
                $this.EventHandlers[$eventName].Count 
            } else { 0 }
        }
        
        $this.EventHistory.Add($historyEntry)
        
        if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
            $this.EventHistory.RemoveAt(0)
        }
    }
    
    # Get event history
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory.Where({ $_.EventName -eq $eventName })
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    # Clear event history
    [void] ClearHistory() {
        $this.EventHistory.Clear()
    }
    
    # Get information about registered events
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
            TotalEventsPublished = $this.TotalEventsPublished
            TotalHandlersCalled = $this.TotalHandlersCalled
            EnableHistory = $this.EnableHistory
            EnableDebugLogging = $this.EnableDebugLogging
            HistorySize = $this.EventHistory.Count
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { 
                    @{
                        Id = $_
                        ExecutionCount = $handlers[$_].ExecutionCount
                        SubscribedAt = $handlers[$_].SubscribedAt
                    }
                }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
    
    # Get debug report
    [string] GetDebugReport() {
        $sb = [System.Text.StringBuilder]::new()
        $info = $this.GetEventInfo()
        
        $sb.AppendLine("EventBus Debug Report")
        $sb.AppendLine("====================")
        $sb.AppendLine("Total Events Published: $($info.TotalEventsPublished)")
        $sb.AppendLine("Total Handlers Called: $($info.TotalHandlersCalled)")
        $sb.AppendLine("Active Handlers: $($info.TotalHandlers)")
        $sb.AppendLine("History Enabled: $($info.EnableHistory)")
        $sb.AppendLine("Debug Logging: $($info.EnableDebugLogging)")
        $sb.AppendLine("History Size: $($info.HistorySize)/$($this.MaxHistorySize)")
        $sb.AppendLine("")
        $sb.AppendLine("Registered Events:")
        
        foreach ($eventName in $info.RegisteredEvents.Keys | Sort-Object) {
            $eventInfo = $info.RegisteredEvents[$eventName]
            $sb.AppendLine("  $eventName : $($eventInfo.HandlerCount) handler(s)")
            
            foreach ($handler in $eventInfo.Handlers) {
                $sb.AppendLine("    - $($handler.Id): $($handler.ExecutionCount) executions")
            }
        }
        
        return $sb.ToString()
    }
}

# Common Event Names (for consistency across the application)
class EventNames {
    # Project Events
    static [string]$ProjectCreated = 'project.created'
    static [string]$ProjectUpdated = 'project.updated'
    static [string]$ProjectDeleted = 'project.deleted'
    static [string]$ProjectSelected = 'project.selected'
    
    # Task Events
    static [string]$TaskCreated = 'task.created'
    static [string]$TaskUpdated = 'task.updated'
    static [string]$TaskDeleted = 'task.deleted'
    static [string]$TaskSelected = 'task.selected'
    static [string]$TaskStatusChanged = 'task.statusChanged'
    
    # Navigation Events
    static [string]$TabChanged = 'navigation.tabChanged'
    static [string]$ScreenChanged = 'navigation.screenChanged'
    static [string]$DialogOpened = 'navigation.dialogOpened'
    static [string]$DialogClosed = 'navigation.dialogClosed'
    
    # Application Events
    static [string]$AppInitialized = 'app.initialized'
    static [string]$AppShutdown = 'app.shutdown'
    static [string]$ThemeChanged = 'app.themeChanged'
    static [string]$ConfigChanged = 'app.configChanged'
    static [string]$RefreshRequested = 'app.refreshRequested'
    static [string]$DataChanged = 'app.dataChanged'
    
    # Command Events
    static [string]$CommandExecuted = 'command.executed'
    static [string]$CommandRegistered = 'command.registered'
    
    # UI Events
    static [string]$FocusChanged = 'ui.focusChanged'
    static [string]$SelectionChanged = 'ui.selectionChanged'
}

# Helper class for command registration
class CommandRegistration {
    static [void] RegisterCommand([string]$name, [string]$description, [scriptblock]$action) {
        $eventBus = $global:ServiceContainer.GetService('EventBus')
        if ($eventBus) {
            $eventBus.Publish([EventNames]::CommandRegistered, @{
                Name = $name
                Description = $description
                Action = $action
            })
        }
    }
}


####\Services/ExcelImportService.ps1
class ExcelImportService {
    $ServiceContainer
    [hashtable] $FieldMappings
    
    ExcelImportService() {
        $this.InitializeFieldMappings()
    }
    
    [void] Initialize($container) {
        $this.ServiceContainer = $container
    }
    
    [void] InitializeFieldMappings() {
        # Based on changes.txt mappings
        $this.FieldMappings = @{
            'RequestDate' = @{ Cell = 'W23'; Type = 'Date' }
            'AuditType' = @{ Cell = 'W78'; Type = 'String' }
            'AuditorName' = @{ Cell = 'W10'; Type = 'String' }
            'AuditorPhone' = @{ Cell = 'W12'; Type = 'String' }
            'AuditorTL' = @{ Cell = 'W15'; Type = 'String' }
            'AuditorTLPhone' = @{ Cell = 'W16'; Type = 'String' }
            'TPName' = @{ Cell = 'W3'; Type = 'String' }
            'TPNum' = @{ Cell = 'W4'; Type = 'String' }
            'Address' = @{ Cell = 'W5'; Type = 'String' }
            'City' = @{ Cell = 'W6'; Type = 'String' }
            'Province' = @{ Cell = 'W7'; Type = 'String' }
            'PostalCode' = @{ Cell = 'W8'; Type = 'String' }
            'Country' = @{ Cell = 'W9'; Type = 'String' }
            'AuditPeriodFrom' = @{ Cell = 'W27'; Type = 'Date' }
            'AuditPeriodTo' = @{ Cell = 'W28'; Type = 'Date' }
            'AuditPeriod1Start' = @{ Cell = 'W29'; Type = 'Date' }
            'AuditPeriod1End' = @{ Cell = 'W30'; Type = 'Date' }
            'AuditPeriod2Start' = @{ Cell = 'W31'; Type = 'Date' }
            'AuditPeriod2End' = @{ Cell = 'W32'; Type = 'Date' }
            'AuditPeriod3Start' = @{ Cell = 'W33'; Type = 'Date' }
            'AuditPeriod3End' = @{ Cell = 'W34'; Type = 'Date' }
            'AuditPeriod4Start' = @{ Cell = 'W35'; Type = 'Date' }
            'AuditPeriod4End' = @{ Cell = 'W36'; Type = 'Date' }
            'AuditPeriod5Start' = @{ Cell = 'W37'; Type = 'Date' }
            'AuditPeriod5End' = @{ Cell = 'W38'; Type = 'Date' }
            'Contact1Name' = @{ Cell = 'W54'; Type = 'String' }
            'Contact1Phone' = @{ Cell = 'W55'; Type = 'String' }
            'Contact1Ext' = @{ Cell = 'W56'; Type = 'String' }
            'Contact1Address' = @{ Cell = 'W57'; Type = 'String' }
            'Contact1Title' = @{ Cell = 'W58'; Type = 'String' }
            'Contact2Name' = @{ Cell = 'W59'; Type = 'String' }
            'Contact2Phone' = @{ Cell = 'W60'; Type = 'String' }
            'Contact2Ext' = @{ Cell = 'W61'; Type = 'String' }
            'Contact2Address' = @{ Cell = 'W62'; Type = 'String' }
            'Contact2Title' = @{ Cell = 'W63'; Type = 'String' }
            'AuditProgram' = @{ Cell = 'W72'; Type = 'String' }
            'AuditCase' = @{ Cell = 'W18'; Type = 'String' }
            'CASCase' = @{ Cell = 'W17'; Type = 'String' }  # Critical ID2 field
            'AuditStartDate' = @{ Cell = 'W24'; Type = 'Date' }
            'AccountingSoftware1' = @{ Cell = 'W98'; Type = 'String' }
            'AccountingSoftware1Other' = @{ Cell = 'W100'; Type = 'String' }
            'AccountingSoftware1Type' = @{ Cell = 'W101'; Type = 'String' }
            'AccountingSoftware2' = @{ Cell = 'W102'; Type = 'String' }
            'AccountingSoftware2Other' = @{ Cell = 'W104'; Type = 'String' }
            'AccountingSoftware2Type' = @{ Cell = 'W105'; Type = 'String' }
            'FXInfo' = @{ Cell = 'W129'; Type = 'String' }
            'ShipToAddress' = @{ Cell = 'W130'; Type = 'String' }
            'Comments' = @{ Cell = 'W108'; Type = 'String' }
        }
    }
    
    [hashtable] ImportFromExcel([string]$FilePath) {
        # Validate file exists
        if (-not (Test-Path $FilePath)) {
            throw "Excel file not found: $FilePath"
        }
        
        # Initialize COM objects
        $excel = $null
        $workbook = $null
        $importedData = @{}
        
        try {
            # Create Excel application
            $excel = New-Object -ComObject Excel.Application
            $excel.Visible = $false
            $excel.DisplayAlerts = $false
            
            # Open workbook
            $workbook = $excel.Workbooks.Open($FilePath, 0, $true) # ReadOnly
            
            # Try to find SVI-CAS worksheet
            $worksheet = $null
            try {
                $worksheet = $workbook.Worksheets.Item('SVI-CAS')
            }
            catch {
                # Use first worksheet if SVI-CAS not found
                $worksheet = $workbook.Worksheets.Item(1)
                Write-Warning "SVI-CAS worksheet not found, using first worksheet: $($worksheet.Name)"
            }
            
            # Extract data based on mappings
            foreach ($field in $this.FieldMappings.Keys) {
                $mapping = $this.FieldMappings[$field]
                try {
                    $cellValue = $worksheet.Range($mapping.Cell).Value2
                    
                    # Convert based on type
                    if ($null -ne $cellValue -and $cellValue -ne '') {
                        switch ($mapping.Type) {
                            'Date' {
                                if ($cellValue -is [double]) {
                                    $importedData[$field] = [DateTime]::FromOADate($cellValue)
                                }
                                else {
                                    $importedData[$field] = [DateTime]::Parse($cellValue.ToString())
                                }
                            }
                            'String' {
                                $importedData[$field] = $cellValue.ToString().Trim()
                            }
                            default {
                                $importedData[$field] = $cellValue
                            }
                        }
                    }
                }
                catch {
                    Write-Warning "Failed to extract $field from cell $($mapping.Cell): $_"
                }
            }
            
            return $importedData
        }
        finally {
            # Clean up COM objects
            if ($workbook) {
                try { $workbook.Close($false) } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($workbook) | Out-Null
            }
            if ($excel) {
                try { $excel.Quit() } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
            }
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
        }
    }
    
    [object] CreateProjectFromImport([hashtable]$ImportedData) {
        $projectService = $this.ServiceContainer.GetService('ProjectService')
        
        # Create new project with imported data
        $project = [Project]::new()
        
        # Map basic fields
        $project.FullProjectName = $ImportedData.TPName
        $project.Nickname = $ImportedData.TPName  # Can be changed later
        $project.ID2 = $ImportedData.CASCase  # CAS Case# is the ID2
        $project.ClientID = $ImportedData.TPNum
        $project.Status = 'Active'
        
        # Map audit information
        $project.AuditType = $ImportedData.AuditType
        $project.AuditProgram = $ImportedData.AuditProgram
        $project.AuditCase = $ImportedData.AuditCase
        $project.AuditStartDate = $ImportedData.AuditStartDate
        $project.AuditPeriodFrom = $ImportedData.AuditPeriodFrom
        $project.AuditPeriodTo = $ImportedData.AuditPeriodTo
        
        # Map additional audit periods
        $project.AuditPeriod1Start = $ImportedData.AuditPeriod1Start
        $project.AuditPeriod1End = $ImportedData.AuditPeriod1End
        $project.AuditPeriod2Start = $ImportedData.AuditPeriod2Start
        $project.AuditPeriod2End = $ImportedData.AuditPeriod2End
        $project.AuditPeriod3Start = $ImportedData.AuditPeriod3Start
        $project.AuditPeriod3End = $ImportedData.AuditPeriod3End
        $project.AuditPeriod4Start = $ImportedData.AuditPeriod4Start
        $project.AuditPeriod4End = $ImportedData.AuditPeriod4End
        $project.AuditPeriod5Start = $ImportedData.AuditPeriod5Start
        $project.AuditPeriod5End = $ImportedData.AuditPeriod5End
        
        # Map address information
        $project.Address = $ImportedData.Address
        $project.City = $ImportedData.City
        $project.Province = $ImportedData.Province
        $project.PostalCode = $ImportedData.PostalCode
        $project.Country = $ImportedData.Country
        $project.ShipToAddress = $ImportedData.ShipToAddress
        
        # Map auditor information
        $project.AuditorName = $ImportedData.AuditorName
        $project.AuditorPhone = $ImportedData.AuditorPhone
        $project.AuditorTL = $ImportedData.AuditorTL
        $project.AuditorTLPhone = $ImportedData.AuditorTLPhone
        
        # Map contact information directly to project fields
        $project.Contact1Name = $ImportedData.Contact1Name
        $project.Contact1Phone = $ImportedData.Contact1Phone
        $project.Contact1Ext = $ImportedData.Contact1Ext
        $project.Contact1Address = $ImportedData.Contact1Address
        $project.Contact1Title = $ImportedData.Contact1Title
        $project.Contact2Name = $ImportedData.Contact2Name
        $project.Contact2Phone = $ImportedData.Contact2Phone
        $project.Contact2Ext = $ImportedData.Contact2Ext
        $project.Contact2Address = $ImportedData.Contact2Address
        $project.Contact2Title = $ImportedData.Contact2Title
        
        # Map software information
        $project.AccountingSoftware1 = $ImportedData.AccountingSoftware1
        $project.AccountingSoftware1Other = $ImportedData.AccountingSoftware1Other
        $project.AccountingSoftware1Type = $ImportedData.AccountingSoftware1Type
        $project.AccountingSoftware2 = $ImportedData.AccountingSoftware2
        $project.AccountingSoftware2Other = $ImportedData.AccountingSoftware2Other
        $project.AccountingSoftware2Type = $ImportedData.AccountingSoftware2Type
        
        # Map additional fields
        $project.RequestDate = $ImportedData.RequestDate
        $project.FXInfo = $ImportedData.FXInfo
        $project.Comments = $ImportedData.Comments
        
        return $project
    }
}


####\Services/Logger.ps1
# Logger.ps1 - Fast logging service adapted from AxiomPhoenix
# Optimized for speed - no console output, minimal file I/O

class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 100  # Smaller queue for faster flushing
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false  # Never log to console in TUI
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    hidden [System.Text.StringBuilder]$_buffer
    hidden [int]$_unflushedCount = 0
    hidden [int]$_flushThreshold = 10  # Flush every N messages
    
    Logger() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { (Get-Location).Path }
        $logDir = Join-Path $praxisDir "_Logs"
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        $this.LogPath = Join-Path $logDir "praxis.log"
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        $this._buffer = [System.Text.StringBuilder]::new(4096)  # Pre-allocate buffer
        
        # Check for debug mode
        if ($global:PraxisDebug -or $env:PRAXIS_DEBUG) {
            $this.MinimumLevel = "Debug"
        }
        
        # Rotate log if too large (>10MB)
        try {
            if ((Test-Path $this.LogPath) -and (Get-Item $this.LogPath).Length -gt 10MB) {
                $backupPath = $this.LogPath + ".old"
                Move-Item $this.LogPath $backupPath -Force -ErrorAction SilentlyContinue
            }
        } catch {
            # Ignore rotation errors
        }
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Fast level check
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        # Format timestamp efficiently
        $timestamp = [DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
        $levelPadded = $level.ToUpper().PadRight(7)
        
        # Build log line
        $logLine = "$timestamp [$levelPadded] $message"
        
        # Add to buffer instead of queue for speed
        $this._buffer.AppendLine($logLine)
        $this._unflushedCount++
        
        # Auto-flush on threshold or error/fatal
        if ($this._unflushedCount -ge $this._flushThreshold -or 
            $level -eq "Error" -or $level -eq "Fatal") {
            $this.Flush()
        }
    }
    
    [void] LogException([Exception]$exception, [string]$context = "") {
        $message = if ($context) { "$context - " } else { "" }
        $message += "$($exception.GetType().Name): $($exception.Message)"
        $this.Log($message, "Error")
        
        # Log stack trace as debug
        if ($exception.StackTrace) {
            $this.Log("Stack: $($exception.StackTrace -replace "`n", " ")", "Debug")
        }
    }
    
    [void] Flush() {
        if ($this._buffer.Length -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            # Write buffer to file in one operation
            [System.IO.File]::AppendAllText($this.LogPath, $this._buffer.ToString())
            $this._buffer.Clear()
            $this._unflushedCount = 0
        }
        catch {
            # Ignore logging errors to prevent crashes
        }
    }
    
    # Quick logging methods
    [void] Debug([string]$message) { $this.Log($message, "Debug") }
    [void] Info([string]$message) { $this.Log($message, "Info") }
    [void] Warning([string]$message) { $this.Log($message, "Warning") }
    [void] Error([string]$message) { $this.Log($message, "Error") }
    
    [void] Cleanup() {
        $this.Flush()
    }
}

# Global Write-Log function for compatibility
function global:Write-Log {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    if ($global:Logger) {
        $global:Logger.Log($Message, $Level)
    }
}


####\Services/ProjectService.ps1
# ProjectService - Business logic for project management
# Lightweight service focusing on project-related operations

class ProjectService {
    hidden [System.Collections.ArrayList]$Projects = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile
    
    ProjectService() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PSScriptRoot }
        $this.DataFile = Join-Path $praxisDir "_ProjectData/projects.json"
        
        # Ensure directory exists
        $dataDir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        $this.LoadProjects()
    }
    
    [void] LoadProjects() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Projects.Clear()
                foreach ($projData in $data) {
                    # Handle both old and new format
                    if ($projData.PSObject.Properties['FullProjectName']) {
                        # New PMC format
                        $project = [Project]::new($projData.FullProjectName, $projData.Nickname)
                        $project.Id = $projData.Id
                        $project.ID1 = $projData.ID1 ?? ""
                        $project.ID2 = $projData.ID2 ?? ""
                        if ($projData.DateAssigned) { $project.DateAssigned = [DateTime]::Parse($projData.DateAssigned) }
                        if ($projData.BFDate) { $project.BFDate = [DateTime]::Parse($projData.BFDate) }
                        if ($projData.DateDue) { $project.DateDue = [DateTime]::Parse($projData.DateDue) }
                        $project.Note = $projData.Note ?? ""
                        $project.CAAPath = $projData.CAAPath ?? ""
                        $project.RequestPath = $projData.RequestPath ?? ""
                        $project.T2020Path = $projData.T2020Path ?? ""
                        $project.CumulativeHrs = $projData.CumulativeHrs ?? 0
                        if ($projData.ClosedDate -and $projData.ClosedDate -ne "0001-01-01T00:00:00") { 
                            $project.ClosedDate = [DateTime]::Parse($projData.ClosedDate) 
                        }
                        
                        # Load all the new fields
                        $project.Status = $projData.Status ?? "Active"
                        $project.ClientID = $projData.ClientID ?? ""
                        
                        # Audit fields
                        $project.AuditType = $projData.AuditType ?? ""
                        $project.AuditProgram = $projData.AuditProgram ?? ""
                        $project.AuditCase = $projData.AuditCase ?? ""
                        if ($projData.AuditStartDate -and $projData.AuditStartDate -ne "0001-01-01T00:00:00") {
                            $project.AuditStartDate = [DateTime]::Parse($projData.AuditStartDate)
                        }
                        if ($projData.AuditPeriodFrom -and $projData.AuditPeriodFrom -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodFrom = [DateTime]::Parse($projData.AuditPeriodFrom)
                        }
                        if ($projData.AuditPeriodTo -and $projData.AuditPeriodTo -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodTo = [DateTime]::Parse($projData.AuditPeriodTo)
                        }
                        
                        # Additional audit periods
                        for ($i = 1; $i -le 5; $i++) {
                            $startProp = "AuditPeriod${i}Start"
                            $endProp = "AuditPeriod${i}End"
                            if ($projData.$startProp -and $projData.$startProp -ne "0001-01-01T00:00:00") {
                                $project.$startProp = [DateTime]::Parse($projData.$startProp)
                            }
                            if ($projData.$endProp -and $projData.$endProp -ne "0001-01-01T00:00:00") {
                                $project.$endProp = [DateTime]::Parse($projData.$endProp)
                            }
                        }
                        
                        # Address fields
                        $project.Address = $projData.Address ?? ""
                        $project.City = $projData.City ?? ""
                        $project.Province = $projData.Province ?? ""
                        $project.PostalCode = $projData.PostalCode ?? ""
                        $project.Country = $projData.Country ?? ""
                        $project.ShipToAddress = $projData.ShipToAddress ?? ""
                        
                        # Auditor fields
                        $project.AuditorName = $projData.AuditorName ?? ""
                        $project.AuditorPhone = $projData.AuditorPhone ?? ""
                        $project.AuditorTL = $projData.AuditorTL ?? ""
                        $project.AuditorTLPhone = $projData.AuditorTLPhone ?? ""
                        
                        # Contact fields
                        $project.Contact1Name = $projData.Contact1Name ?? ""
                        $project.Contact1Phone = $projData.Contact1Phone ?? ""
                        $project.Contact1Ext = $projData.Contact1Ext ?? ""
                        $project.Contact1Address = $projData.Contact1Address ?? ""
                        $project.Contact1Title = $projData.Contact1Title ?? ""
                        $project.Contact2Name = $projData.Contact2Name ?? ""
                        $project.Contact2Phone = $projData.Contact2Phone ?? ""
                        $project.Contact2Ext = $projData.Contact2Ext ?? ""
                        $project.Contact2Address = $projData.Contact2Address ?? ""
                        $project.Contact2Title = $projData.Contact2Title ?? ""
                        
                        # Software fields
                        $project.AccountingSoftware1 = $projData.AccountingSoftware1 ?? ""
                        $project.AccountingSoftware1Other = $projData.AccountingSoftware1Other ?? ""
                        $project.AccountingSoftware1Type = $projData.AccountingSoftware1Type ?? ""
                        $project.AccountingSoftware2 = $projData.AccountingSoftware2 ?? ""
                        $project.AccountingSoftware2Other = $projData.AccountingSoftware2Other ?? ""
                        $project.AccountingSoftware2Type = $projData.AccountingSoftware2Type ?? ""
                        
                        # Other fields
                        if ($projData.RequestDate -and $projData.RequestDate -ne "0001-01-01T00:00:00") {
                            $project.RequestDate = [DateTime]::Parse($projData.RequestDate)
                        }
                        $project.FXInfo = $projData.FXInfo ?? ""
                        $project.Comments = $projData.Comments ?? ""
                        
                        $project.Deleted = $projData.Deleted ?? $false
                    } else {
                        # Legacy format
                        $project = [Project]::new($projData.Name)
                        $project.Id = $projData.Id
                        if ($projData.Description) { $project.Note = $projData.Description }
                    }
                    $this.Projects.Add($project) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load projects: $_"
            }
        }
        
        # Ensure default project exists
        if (-not ($this.Projects | Where-Object { $_.Nickname -eq "Default" })) {
            $default = [Project]::new("Default")
            $default.Note = "Default project for uncategorized tasks"
            $this.Projects.Add($default) | Out-Null
            $this.SaveProjects()
        }
    }
    
    [void] SaveProjects() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($project in $this.Projects) {
            $data += @{
                Id = $project.Id
                FullProjectName = $project.FullProjectName
                Nickname = $project.Nickname
                ID1 = $project.ID1
                ID2 = $project.ID2
                DateAssigned = $project.DateAssigned.ToString("yyyy-MM-ddTHH:mm:ss")
                BFDate = $project.BFDate.ToString("yyyy-MM-ddTHH:mm:ss")
                DateDue = $project.DateDue.ToString("yyyy-MM-ddTHH:mm:ss")
                Note = $project.Note
                CAAPath = $project.CAAPath
                RequestPath = $project.RequestPath
                T2020Path = $project.T2020Path
                CumulativeHrs = $project.CumulativeHrs
                ClosedDate = $project.ClosedDate.ToString("yyyy-MM-ddTHH:mm:ss")
                Deleted = $project.Deleted
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Project[]] GetAllProjects() {
        return $this.Projects.ToArray()
    }
    
    [Project] GetProject([string]$id) {
        return $this.Projects | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Project] GetProjectByName([string]$name) {
        return $this.Projects | Where-Object { $_.Nickname -eq $name -or $_.FullProjectName -eq $name } | Select-Object -First 1
    }
    
    [Project] AddProject([string]$name) {
        # Check if already exists
        $existing = $this.GetProjectByName($name)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($name)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([string]$fullName, [string]$nickname) {
        # Check if already exists
        $existing = $this.GetProjectByName($nickname)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($fullName, $nickname)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([Project]$project) {
        # Check if already exists by nickname
        $existing = $this.GetProjectByName($project.Nickname)
        if ($existing) {
            return $existing
        }
        
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [void] UpdateProject([Project]$project) {
        $this.SaveProjects()
    }
    
    [void] DeleteProject([string]$id) {
        $project = $this.GetProject($id)
        if ($project -and $project.Nickname -ne "Default") {
            $this.Projects.Remove($project)
            $this.SaveProjects()
        }
    }
    
    [hashtable[]] GetProjectsWithStats([object]$taskService) {
        $result = @()
        
        foreach ($project in $this.Projects) {
            $tasks = $taskService.GetTasksByProject($project.Nickname)
            $completed = ($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $total = $tasks.Count
            
            $result += @{
                Project = $project
                Name = $project.Nickname  # Use nickname for compatibility
                FullName = $project.FullProjectName
                TaskCount = $total
                CompletedCount = $completed
                Progress = if ($total -gt 0) { $completed / $total } else { 0 }
            }
        }
        
        return $result
    }
}


####\Services/ShortcutManager.ps1
# ShortcutManager.ps1 - Centralized keyboard shortcut management service

enum ShortcutScope {
    Global      # Available everywhere
    Screen      # Available in specific screen types
    Context     # Available in specific contexts (e.g., when dialog is open)
}

class ShortcutDefinition {
    [string]$Id
    [string]$Name
    [string]$Description
    [System.ConsoleKey]$Key
    [System.ConsoleModifiers]$Modifiers
    [char]$KeyChar
    [ShortcutScope]$Scope
    [string]$ScreenType  # For Screen scope
    [string]$Context     # For Context scope
    [scriptblock]$Action
    [bool]$Enabled = $true
    [int]$Priority = 0   # Higher priority shortcuts are checked first
    
    ShortcutDefinition() {}
    
    [bool] Matches([System.ConsoleKeyInfo]$keyInfo) {
        # Check if this shortcut matches the pressed key
        if ($this.Key -ne [System.ConsoleKey]::None) {
            if ($keyInfo.Key -ne $this.Key) {
                return $false
            }
            if ($this.Modifiers -ne [System.ConsoleModifiers]::None) {
                if (($keyInfo.Modifiers -band $this.Modifiers) -ne $this.Modifiers) {
                    return $false
                }
            }
            return $true
        }
        elseif ($this.KeyChar -ne [char]0) {
            # Character-based shortcut
            return $keyInfo.KeyChar -eq $this.KeyChar
        }
        return $false
    }
    
    [string] GetDisplayText() {
        $parts = @()
        
        if ($this.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        if ($this.Key -ne [System.ConsoleKey]::None) {
            $parts += $this.Key.ToString()
        }
        elseif ($this.KeyChar -ne [char]0) {
            $parts += $this.KeyChar.ToString()
        }
        
        return $parts -join "+"
    }
}

class ShortcutManager {
    hidden [System.Collections.Generic.List[ShortcutDefinition]]$Shortcuts
    hidden [Logger]$Logger
    hidden [EventBus]$EventBus
    
    ShortcutManager() {
        $this.Shortcuts = [System.Collections.Generic.List[ShortcutDefinition]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService('Logger')
        $this.EventBus = $container.GetService('EventBus')
        
        # Register default global shortcuts
        $this.RegisterDefaultShortcuts()
    }
    
    [void] RegisterDefaultShortcuts() {
        # Global shortcuts
        $this.RegisterShortcut(@{
            Id = "global.quit"
            Name = "Quit Application"
            Description = "Exit the application"
            Key = [System.ConsoleKey]::Q
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Global
            Priority = 100
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.RequestExit()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette"
            Name = "Command Palette"
            Description = "Open the command palette"
            KeyChar = ':'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette_alt"
            Name = "Command Palette (Alt)"
            Description = "Open the command palette"
            KeyChar = '/'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
    }
    
    [void] RegisterShortcut([hashtable]$definition) {
        $shortcut = [ShortcutDefinition]::new()
        
        # Map hashtable properties to object
        foreach ($key in $definition.Keys) {
            if ($null -ne $shortcut.PSObject.Properties[$key]) {
                $shortcut.$key = $definition[$key]
            }
        }
        
        # Validate required properties
        if ([string]::IsNullOrEmpty($shortcut.Id)) {
            throw "Shortcut ID is required"
        }
        if (-not $shortcut.Action) {
            throw "Shortcut action is required"
        }
        
        # Remove existing shortcut with same ID
        $this.UnregisterShortcut($shortcut.Id)
        
        # Add new shortcut
        $this.Shortcuts.Add($shortcut)
        
        # Sort by priority (descending)
        $this.Shortcuts.Sort({ param($a, $b) $b.Priority.CompareTo($a.Priority) })
        
        if ($this.Logger) {
            $this.Logger.Debug("Registered shortcut: $($shortcut.Id) - $($shortcut.GetDisplayText())")
        }
    }
    
    [void] UnregisterShortcut([string]$id) {
        $existing = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($existing) {
            $this.Shortcuts.Remove($existing) | Out-Null
        }
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen, [string]$currentContext) {
        if ($this.Logger) {
            $this.Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' Screen=$currentScreen Context=$currentContext")
            $this.Logger.Debug("ShortcutManager: Total shortcuts registered: $($this.Shortcuts.Count)")
        }
        
        # Find matching shortcuts
        $candidates = $this.Shortcuts | Where-Object {
            $_.Enabled -and $_.Matches($keyInfo)
        }
        
        if ($this.Logger -and $candidates.Count -gt 0) {
            $this.Logger.Debug("ShortcutManager: Found $($candidates.Count) matching shortcuts")
        }
        
        # Filter by scope
        $applicable = @()
        foreach ($shortcut in $candidates) {
            if ($this.Logger) {
                $this.Logger.Debug("Checking shortcut: $($shortcut.Id) Scope=$($shortcut.Scope) ScreenType=$($shortcut.ScreenType)")
            }
            
            switch ($shortcut.Scope) {
                ([ShortcutScope]::Global) {
                    $applicable += $shortcut
                }
                ([ShortcutScope]::Screen) {
                    if ($shortcut.ScreenType -eq $currentScreen -or 
                        [string]::IsNullOrEmpty($shortcut.ScreenType)) {
                        if ($this.Logger) {
                            $this.Logger.Debug("Screen shortcut matches: $($shortcut.Id)")
                        }
                        $applicable += $shortcut
                    }
                }
                ([ShortcutScope]::Context) {
                    if ($shortcut.Context -eq $currentContext -or
                        [string]::IsNullOrEmpty($shortcut.Context)) {
                        $applicable += $shortcut
                    }
                }
            }
        }
        
        # Execute the highest priority applicable shortcut
        if ($applicable.Count -gt 0) {
            $shortcut = $applicable[0]  # Already sorted by priority
            
            if ($this.Logger) {
                $this.Logger.Debug("Executing shortcut: $($shortcut.Id)")
            }
            
            # Publish event before execution
            if ($this.EventBus) {
                $this.EventBus.Publish('shortcut.executing', @{
                    ShortcutId = $shortcut.Id
                    Key = $keyInfo
                })
            }
            
            try {
                # Execute the action
                & $shortcut.Action
                
                # Publish success event
                if ($this.EventBus) {
                    $this.EventBus.Publish('shortcut.executed', @{
                        ShortcutId = $shortcut.Id
                        Key = $keyInfo
                    })
                }
                
                return $true
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Error executing shortcut $($shortcut.Id): $_")
                }
                return $false
            }
        }
        
        return $false
    }
    
    [ShortcutDefinition[]] GetShortcuts([ShortcutScope]$scope, [string]$screenType) {
        return $this.Shortcuts | Where-Object {
            $_.Scope -eq $scope -and
            ($_.ScreenType -eq $screenType -or [string]::IsNullOrEmpty($_.ScreenType))
        }
    }
    
    [ShortcutDefinition[]] GetAllShortcuts() {
        return $this.Shortcuts
    }
    
    [hashtable] GetShortcutMap() {
        # Returns a hashtable for easy display in UI
        $map = @{}
        
        foreach ($shortcut in $this.Shortcuts) {
            $key = $shortcut.GetDisplayText()
            if (-not $map.ContainsKey($key)) {
                $map[$key] = @()
            }
            $map[$key] += @{
                Name = $shortcut.Name
                Description = $shortcut.Description
                Scope = $shortcut.Scope
                ScreenType = $shortcut.ScreenType
            }
        }
        
        return $map
    }
    
    [void] EnableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $true
        }
    }
    
    [void] DisableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $false
        }
    }
    
    [string] GetShortcutHelp([ShortcutScope]$scope = [ShortcutScope]::Global, [string]$screenType = "") {
        $sb = [System.Text.StringBuilder]::new()
        $shortcutList = $this.GetShortcuts($scope, $screenType)
        
        if ($shortcutList.Count -gt 0) {
            $grouped = $shortcutList | Group-Object { $_.GetDisplayText() }
            
            foreach ($group in $grouped | Sort-Object Name) {
                $sb.AppendLine("$($group.Name):")
                foreach ($shortcut in $group.Group) {
                    $sb.AppendLine("  - $($shortcut.Name): $($shortcut.Description)")
                }
            }
        }
        
        return $sb.ToString()
    }
}


####\Services/SimpleShortcutHandler.ps1
# SimpleShortcutHandler.ps1 - Direct keyboard shortcuts via EventBus

class SimpleShortcutHandler {
    hidden [EventBus]$EventBus
    hidden [Logger]$Logger
    
    [void] Initialize([ServiceContainer]$container) {
        $this.EventBus = $container.GetService('EventBus')
        $this.Logger = $container.GetService('Logger')
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen) {
        # Only handle character keys when no modifiers are pressed
        if ($keyInfo.Modifiers -ne [System.ConsoleModifiers]::None) {
            return $false
        }
        
        $char = [char]::ToLower($keyInfo.KeyChar)
        
        # Handle shortcuts based on current screen
        switch ($currentScreen) {
            "ProjectsScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewProject', 'ProjectsScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditProject', 'ProjectsScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteProject', 'ProjectsScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshProjects', 'ProjectsScreen')
                        return $true
                    }
                    'v' {
                        $this.PublishCommand('ViewProject', 'ProjectsScreen')
                        return $true
                    }
                }
            }
            "TaskScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewTask', 'TaskScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditTask', 'TaskScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteTask', 'TaskScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshTasks', 'TaskScreen')
                        return $true
                    }
                }
            }
        }
        
        return $false
    }
    
    hidden [void] PublishCommand([string]$command, [string]$target) {
        if ($this.Logger) {
            $this.Logger.Debug("SimpleShortcutHandler: Publishing command $command for $target")
        }
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::CommandExecuted, @{
                Command = $command
                Target = $target
            })
        }
    }
}


####\Services/StateManager.ps1
# StateManager.ps1 - Fast, robust, PowerShell-native state management
# Based on AxiomPhoenix patterns with PRAXIS optimizations

class StateManager {
    # Core state storage - PowerShell hashtables for maximum speed
    hidden [hashtable]$_state = @{}
    hidden [hashtable]$_subscribers = @{}
    hidden [hashtable]$_indexes = @{}
    
    # Performance optimization
    hidden [System.Collections.Generic.Dictionary[string, object]]$_fastIndex
    hidden [bool]$_isDirty = $false
    hidden [datetime]$_lastSave = [datetime]::MinValue
    
    # Transaction support
    hidden [int]$_transactionDepth = 0
    hidden [bool]$_pendingSave = $false
    hidden [hashtable]$_transactionChanges = @{}
    
    # Event integration
    [EventBus]$EventBus
    [Logger]$Logger
    
    # Configuration
    [string]$StatePath = ""
    [bool]$AutoSave = $true
    [int]$AutoSaveIntervalMs = 5000
    [int]$MaxBackups = 5
    [bool]$EnableCompression = $true
    
    # Performance metrics
    hidden [int]$_getOperations = 0
    hidden [int]$_setOperations = 0
    hidden [datetime]$_lastStatsReset = [datetime]::Now
    
    StateManager() {
        $this._fastIndex = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.InitializeDefaultState()
    }
    
    [void] Initialize([ServiceContainer]$services) {
        try {
            # Get required services
            $this.EventBus = $services.GetService("EventBus")
            $this.Logger = $services.GetService("Logger")
            
            # Set default state path
            if ([string]::IsNullOrEmpty($this.StatePath)) {
                $praxisRoot = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PWD }
                $this.StatePath = Join-Path $praxisRoot "_State/application.json"
            }
            
            # Ensure state directory exists
            $stateDir = Split-Path $this.StatePath -Parent
            if (-not (Test-Path $stateDir)) {
                New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
            }
            
            # Load existing state
            $this.LoadState()
            
            # Start auto-save if enabled
            if ($this.AutoSave) {
                $this.StartAutoSave()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager initialized: Path=$($this.StatePath), AutoSave=$($this.AutoSave)")
            }
            
        } catch {
            $this.LogError("StateManager initialization failed", @{ Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== CORE STATE OPERATIONS ====================
    
    # FAST: Direct hashtable access with error handling
    [object] GetState([string]$key) {
        return $this.GetState($key, $null)
    }
    
    [object] GetState([string]$key, [object]$defaultValue) {
        if ([string]::IsNullOrEmpty($key)) {
            return $defaultValue
        }
        
        try {
            $this._getOperations++
            
            # Try fast index first (Dictionary lookup - microseconds)
            if ($this._fastIndex.ContainsKey($key)) {
                return $this._fastIndex[$key]
            }
            
            # Fall back to dot-notation path traversal
            $keys = $key -split '\.'
            $current = $this._state
            
            foreach ($k in $keys) {
                if ($current -eq $null -or -not $current.ContainsKey($k)) {
                    return $defaultValue
                }
                $current = $current[$k]
            }
            
            # Cache in fast index for next time
            $this._fastIndex[$key] = $current
            
            return if ($current -eq $null) { $defaultValue } else { $current }
            
        } catch {
            $this.LogError("GetState failed", @{ Key = $key; Error = $_.Exception.Message })
            return $defaultValue
        }
    }
    
    # FAST: Direct state updates with smart change detection
    [void] SetState([string]$key, [object]$value) {
        $this.SetState($key, $value, $true)
    }
    
    [void] SetState([string]$key, [object]$value, [bool]$publishEvents) {
        if ([string]::IsNullOrEmpty($key)) {
            return
        }
        
        try {
            $this._setOperations++
            
            # Fast equality check to avoid unnecessary updates
            $currentValue = $this.GetState($key)
            if ($this.AreEqual($currentValue, $value)) {
                return  # No change, skip update
            }
            
            # Store old value for events
            $oldValue = $currentValue
            
            # Update both storage mechanisms
            $this.SetStateInternal($key, $value)
            $this._fastIndex[$key] = $value
            
            # Track transaction changes
            if ($this._transactionDepth -gt 0) {
                $this._transactionChanges[$key] = @{ 
                    NewValue = $value
                    OldValue = $oldValue 
                }
            }
            
            # Mark as dirty and trigger save
            $this.MarkDirty()
            
            # Publish change events
            if ($publishEvents -and $this.EventBus) {
                $this.PublishStateChange($key, $value, $oldValue)
            }
            
        } catch {
            $this.LogError("SetState failed", @{ Key = $key; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== TRANSACTION SUPPORT ====================
    
    [void] BeginTransaction() {
        $this._transactionDepth++
        if ($this._transactionDepth -eq 1) {
            $this._transactionChanges.Clear()
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Transaction started")
            }
        }
    }
    
    [void] EndTransaction() {
        if ($this._transactionDepth -gt 0) {
            $this._transactionDepth--
            
            # Process all changes when transaction completes
            if ($this._transactionDepth -eq 0) {
                try {
                    # Batch save
                    if ($this._pendingSave) {
                        $this.SaveState()
                        $this._pendingSave = $false
                    }
                    
                    # Batch event publishing
                    if ($this._transactionChanges.Count -gt 0 -and $this.EventBus) {
                        $this.EventBus.Publish("State.TransactionComplete", @{
                            Changes = $this._transactionChanges
                            ChangeCount = $this._transactionChanges.Count
                        })
                    }
                    
                    if ($this.Logger) {
                        $this.Logger.Debug("StateManager: Transaction completed with $($this._transactionChanges.Count) changes")
                    }
                    
                } catch {
                    $this.LogError("Transaction completion failed", @{ Error = $_.Exception.Message })
                    throw
                } finally {
                    $this._transactionChanges.Clear()
                }
            }
        }
    }
    
    [void] RollbackTransaction() {
        if ($this._transactionDepth -gt 0) {
            try {
                # Restore all changed values to their original state
                foreach ($change in $this._transactionChanges.GetEnumerator()) {
                    $key = $change.Key
                    $oldValue = $change.Value.OldValue
                    
                    # Directly restore without triggering events or new transaction tracking
                    $this.SetStateInternal($key, $oldValue)
                    $this._fastIndex[$key] = $oldValue
                }
                
                if ($this.Logger) {
                    $this.Logger.Debug("StateManager: Transaction rolled back, $($this._transactionChanges.Count) changes reverted")
                }
                
            } catch {
                $this.LogError("Transaction rollback failed", @{ Error = $_.Exception.Message })
                throw
            } finally {
                $this._transactionChanges.Clear()
                $this._transactionDepth = 0
                $this._pendingSave = $false
            }
        }
    }
    
    # ==================== PERSISTENCE ====================
    
    [void] LoadState() {
        if (-not (Test-Path $this.StatePath)) {
            if ($this.Logger) {
                $this.Logger.Info("StateManager: No existing state file, using defaults")
            }
            return
        }
        
        try {
            $json = Get-Content $this.StatePath -Raw -ErrorAction Stop
            if ([string]::IsNullOrEmpty($json)) {
                return
            }
            
            $data = $json | ConvertFrom-Json -AsHashtable -ErrorAction Stop
            if ($data -and $data.ContainsKey("State")) {
                $this._state = $data.State
                $this.RebuildFastIndex()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager: State loaded successfully from $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to load state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            
            # Try to load from backup
            $this.LoadFromBackup()
        }
    }
    
    [void] SaveState() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Create backup before save
            $this.CreateBackup()
            
            # Prepare data for serialization
            $data = @{
                State = $this._state
                Metadata = @{
                    Version = "1.0.0"
                    SavedAt = [datetime]::Now.ToString('o')
                    StateKeys = @($this._state.Keys)
                    FastIndexKeys = @($this._fastIndex.Keys) 
                    Stats = @{
                        GetOperations = $this._getOperations
                        SetOperations = $this._setOperations
                    }
                }
            }
            
            # Convert to JSON with compression option
            $jsonParams = @{
                Depth = 10
                Compress = $this.EnableCompression
            }
            $json = $data | ConvertTo-Json @jsonParams
            
            # Atomic write (write to temp file, then replace)
            $tempPath = "$($this.StatePath).tmp"
            [System.IO.File]::WriteAllText($tempPath, $json, [System.Text.Encoding]::UTF8)
            Move-Item $tempPath $this.StatePath -Force
            
            # Update tracking
            $this._isDirty = $false
            $this._lastSave = [datetime]::Now
            
            # Publish save event
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Saved", @{
                    Path = $this.StatePath
                    StateKeyCount = $data.Metadata.StateKeys.Count
                    SaveTime = $this._lastSave
                })
            }
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: State saved to $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to save state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== PERFORMANCE OPTIMIZATIONS ====================
    
    [void] RebuildFastIndex() {
        try {
            $this._fastIndex.Clear()
            $this.BuildFastIndexRecursive("", $this._state)
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Fast index rebuilt with $($this._fastIndex.Count) entries")
            }
            
        } catch {
            $this.LogError("Fast index rebuild failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] BuildFastIndexRecursive([string]$prefix, [hashtable]$data) {
        foreach ($key in $data.Keys) {
            $fullKey = if ($prefix) { "$prefix.$key" } else { $key }
            $value = $data[$key]
            
            # Add to fast index
            $this._fastIndex[$fullKey] = $value
            
            # Recurse into nested hashtables
            if ($value -is [hashtable]) {
                $this.BuildFastIndexRecursive($fullKey, $value)
            }
        }
    }
    
    [bool] AreEqual([object]$a, [object]$b) {
        # Fast reference equality check first
        if ([object]::ReferenceEquals($a, $b)) {
            return $true
        }
        
        # Null checks
        if ($a -eq $null -or $b -eq $null) {
            return ($a -eq $null -and $b -eq $null)
        }
        
        # Use PowerShell's efficient comparison
        try {
            # For complex objects, try Equals method first
            if ($a.GetType().GetMethod("Equals", @([object]))) {
                return $a.Equals($b)
            }
            
            # Fall back to PowerShell comparison
            return $a -eq $b
            
        } catch {
            # If comparison fails, assume not equal
            return $false
        }
    }
    
    # ==================== EVENT SYSTEM ====================
    
    [void] OnStateChanged([string]$pattern, [scriptblock]$handler) {
        if ([string]::IsNullOrEmpty($pattern) -or $handler -eq $null) {
            return
        }
        
        try {
            if (-not $this._subscribers.ContainsKey($pattern)) {
                $this._subscribers[$pattern] = @()
            }
            
            $this._subscribers[$pattern] += $handler
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Subscriber added for pattern '$pattern'")
            }
            
        } catch {
            $this.LogError("Failed to add state subscriber", @{ Pattern = $pattern; Error = $_.Exception.Message })
        }
    }
    
    hidden [void] PublishStateChange([string]$key, [object]$newValue, [object]$oldValue) {
        if ($this._transactionDepth -gt 0) {
            return  # Don't publish during transactions
        }
        
        try {
            # Publish to EventBus
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Changed", @{
                    Key = $key
                    NewValue = $newValue
                    OldValue = $oldValue
                    Timestamp = [datetime]::Now
                })
            }
            
            # Publish to pattern subscribers
            foreach ($pattern in $this._subscribers.Keys) {
                if ($this.MatchesPattern($key, $pattern)) {
                    foreach ($handler in $this._subscribers[$pattern]) {
                        try {
                            & $handler @{
                                Key = $key
                                NewValue = $newValue
                                OldValue = $oldValue
                            }
                        } catch {
                            $this.LogError("State subscriber handler failed", @{ 
                                Pattern = $pattern
                                Key = $key
                                Error = $_.Exception.Message 
                            })
                        }
                    }
                }
            }
            
        } catch {
            $this.LogError("Failed to publish state change", @{ Key = $key; Error = $_.Exception.Message })
        }
    }
    
    [bool] MatchesPattern([string]$key, [string]$pattern) {
        # Simple wildcard pattern matching
        if ($pattern -eq "*") {
            return $true
        }
        
        if ($pattern.EndsWith("*")) {
            $prefix = $pattern.Substring(0, $pattern.Length - 1)
            return $key.StartsWith($prefix)
        }
        
        return $key -eq $pattern
    }
    
    # ==================== INTERNAL HELPERS ====================
    
    [void] InitializeDefaultState() {
        $this._state = @{
            app = @{
                version = "1.0.0"
                startTime = [datetime]::Now
                sessionId = [System.Guid]::NewGuid().ToString()
            }
            ui = @{
                currentScreen = ""
                selectedItems = @{}
                viewStates = @{}
            }
            data = @{
                projects = @{}
                tasks = @{}
                config = @{}
            }
        }
        
        $this.RebuildFastIndex()
    }
    
    hidden [void] SetStateInternal([string]$key, [object]$value) {
        $keys = $key -split '\.'
        $current = $this._state
        
        # Navigate to parent container
        for ($i = 0; $i -lt $keys.Count - 1; $i++) {
            $k = $keys[$i]
            if (-not $current.ContainsKey($k)) {
                $current[$k] = @{}
            }
            $current = $current[$k]
        }
        
        # Set the final value
        $finalKey = $keys[-1]
        $current[$finalKey] = $value
    }
    
    [void] MarkDirty() {
        $this._isDirty = $true
        
        if ($this._transactionDepth -gt 0) {
            $this._pendingSave = $true
        } elseif ($this.AutoSave) {
            # Immediate save for non-transaction updates
            $this.SaveState()
        }
    }
    
    hidden [void] CreateBackup() {
        if (-not (Test-Path $this.StatePath)) {
            return
        }
        
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
            }
            
            $timestamp = [datetime]::Now.ToString("yyyyMMdd_HHmmss")
            $backupPath = Join-Path $backupDir "application_$timestamp.json"
            
            Copy-Item $this.StatePath $backupPath
            
            # Clean old backups
            $this.CleanOldBackups($backupDir)
            
        } catch {
            $this.LogError("Backup creation failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] CleanOldBackups([string]$backupDir) {
        try {
            $backups = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending
            
            if ($backups.Count -gt $this.MaxBackups) {
                $toDelete = $backups | Select-Object -Skip $this.MaxBackups
                foreach ($file in $toDelete) {
                    Remove-Item $file.FullName -Force
                }
            }
            
        } catch {
            $this.LogError("Backup cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] LoadFromBackup() {
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                return
            }
            
            $latestBackup = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending | Select-Object -First 1
            
            if ($latestBackup) {
                $json = Get-Content $latestBackup.FullName -Raw
                $data = $json | ConvertFrom-Json -AsHashtable
                
                if ($data -and $data.ContainsKey("State")) {
                    $this._state = $data.State
                    $this.RebuildFastIndex()
                    
                    if ($this.Logger) {
                        $this.Logger.Info("StateManager: Recovered from backup: $($latestBackup.Name)")
                    }
                }
            }
            
        } catch {
            $this.LogError("Backup recovery failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] StartAutoSave() {
        # Note: PowerShell doesn't have great built-in timer support
        # This could be enhanced with System.Timers.Timer if needed
        # For now, auto-save happens on each SetState call
    }
    
    hidden [void] LogError([string]$message, [hashtable]$context = @{}) {
        if ($this.Logger) {
            $this.Logger.Error("$message - Context: $($context | ConvertTo-Json -Compress)")
        }
    }
    
    # ==================== PUBLIC API METHODS ====================
    
    [hashtable] GetPerformanceStats() {
        $uptime = [datetime]::Now - $this._lastStatsReset
        
        return @{
            GetOperations = $this._getOperations
            SetOperations = $this._setOperations
            FastIndexSize = $this._fastIndex.Count
            StateKeyCount = $this._state.Keys.Count
            TransactionDepth = $this._transactionDepth
            IsDirty = $this._isDirty
            LastSave = $this._lastSave
            Uptime = $uptime.ToString()
            OperationsPerSecond = if ($uptime.TotalSeconds -gt 0) { ($this._getOperations + $this._setOperations) / $uptime.TotalSeconds } else { 0 }
        }
    }
    
    [void] ResetPerformanceStats() {
        $this._getOperations = 0
        $this._setOperations = 0
        $this._lastStatsReset = [datetime]::Now
    }
    
    [void] ClearState() {
        $this.BeginTransaction()
        try {
            $this._state.Clear()
            $this._fastIndex.Clear()
            $this.InitializeDefaultState()
            
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Cleared", @{ Timestamp = [datetime]::Now })
            }
            
        } finally {
            $this.EndTransaction()
        }
    }
    
    [void] Cleanup() {
        try {
            if ($this._isDirty) {
                $this.SaveState()
            }
            
            $this._subscribers.Clear()
            $this._fastIndex.Clear()
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager cleanup completed")
            }
            
        } catch {
            $this.LogError("Cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
}


####\Services/SubtaskService.ps1
# SubtaskService.ps1 - Service for managing subtasks

class SubtaskService {
    [System.Collections.Generic.List[Subtask]]$Subtasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    SubtaskService() {
        $this.Subtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "subtasks.json"
        
        # Load existing subtasks
        $this.Load()
    }
    
    # CRUD Operations
    [Subtask] AddSubtask([string]$parentTaskId, [string]$title) {
        $subtask = [Subtask]::new($parentTaskId)
        $subtask.Title = $title
        
        # Set sort order to be last among siblings
        $siblings = $this.GetSubtasksForTask($parentTaskId)
        if ($siblings.Count -gt 0) {
            $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
            $subtask.SortOrder = $maxOrder + 1
        } else {
            $subtask.SortOrder = 0
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] CreateSubtask([hashtable]$properties) {
        $subtask = [Subtask]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($key -eq 'Progress') {
                # Use UpdateProgress to auto-handle status changes
                $subtask.UpdateProgress($properties[$key])
            } elseif ($subtask.PSObject.Properties.Name -contains $key) {
                $subtask.$key = $properties[$key]
            }
        }
        
        # Ensure sort order is set
        if (-not $properties.ContainsKey('SortOrder')) {
            $siblings = $this.GetSubtasksForTask($subtask.ParentTaskId)
            if ($siblings.Count -gt 0) {
                $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
                $subtask.SortOrder = $maxOrder + 1
            } else {
                $subtask.SortOrder = 0
            }
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] GetSubtask([string]$id) {
        return $this.Subtasks | Where-Object { $_.Id -eq $id -and -not $_.Deleted } | Select-Object -First 1
    }
    
    [System.Collections.Generic.List[Subtask]] GetSubtasksForTask([string]$parentTaskId) {
        $taskSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if ($subtask.ParentTaskId -eq $parentTaskId -and -not $subtask.Deleted) {
                $taskSubtasks.Add($subtask)
            }
        }
        
        # Sort by SortOrder
        return $taskSubtasks | Sort-Object SortOrder
    }
    
    [System.Collections.Generic.List[Subtask]] GetAllSubtasks() {
        $activeSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if (-not $subtask.Deleted) {
                $activeSubtasks.Add($subtask)
            }
        }
        
        return $activeSubtasks
    }
    
    [void] UpdateSubtask([Subtask]$subtask) {
        $existingSubtask = $this.GetSubtask($subtask.Id)
        if ($existingSubtask) {
            $existingSubtask.Title = $subtask.Title
            $existingSubtask.Description = $subtask.Description
            $existingSubtask.Status = $subtask.Status
            $existingSubtask.Priority = $subtask.Priority
            $existingSubtask.UpdateProgress($subtask.Progress)  # Use UpdateProgress to auto-handle status
            $existingSubtask.DueDate = $subtask.DueDate
            $existingSubtask.Tags = $subtask.Tags
            $existingSubtask.EstimatedMinutes = $subtask.EstimatedMinutes
            $existingSubtask.ActualMinutes = $subtask.ActualMinutes
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] DeleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Deleted = $true
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] CompleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Status = [TaskStatus]::Completed
            $subtask.Progress = 100
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] ReorderSubtasks([string]$parentTaskId, [string[]]$subtaskIds) {
        $sortOrder = 0
        foreach ($subtaskId in $subtaskIds) {
            $subtask = $this.GetSubtask($subtaskId)
            if ($subtask -and $subtask.ParentTaskId -eq $parentTaskId) {
                $subtask.SortOrder = $sortOrder
                $subtask.UpdatedAt = Get-Date
                $sortOrder++
            }
        }
        $this._isDirty = $true
        $this.Save()
    }
    
    # Calculate parent task progress based on subtask completion
    [int] CalculateTaskProgress([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        if ($taskSubtasks.Count -eq 0) {
            return 0
        }
        
        $totalProgress = 0
        foreach ($subtask in $taskSubtasks) {
            $totalProgress += $subtask.Progress
        }
        
        return [Math]::Floor($totalProgress / $taskSubtasks.Count)
    }
    
    [hashtable] GetTaskStatistics([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        $stats = @{
            Total = $taskSubtasks.Count
            Completed = 0
            InProgress = 0
            Pending = 0
            Overdue = 0
            EstimatedMinutes = 0
            ActualMinutes = 0
        }
        
        foreach ($subtask in $taskSubtasks) {
            switch ($subtask.Status) {
                ([TaskStatus]::Completed) { $stats.Completed++ }
                ([TaskStatus]::InProgress) { $stats.InProgress++ }
                ([TaskStatus]::Pending) { $stats.Pending++ }
            }
            
            if ($subtask.IsOverdue()) {
                $stats.Overdue++
            }
            
            $stats.EstimatedMinutes += $subtask.EstimatedMinutes
            $stats.ActualMinutes += $subtask.ActualMinutes
        }
        
        return $stats
    }
    
    # Data persistence
    [void] Save() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Convert to serializable format
            $data = @()
            foreach ($subtask in $this.Subtasks) {
                $data += @{
                    Id = $subtask.Id
                    ParentTaskId = $subtask.ParentTaskId
                    Title = $subtask.Title
                    Description = $subtask.Description
                    Status = [int]$subtask.Status
                    Priority = [int]$subtask.Priority
                    Progress = $subtask.Progress
                    SortOrder = $subtask.SortOrder
                    Tags = $subtask.Tags
                    DueDate = if ($subtask.DueDate -eq [DateTime]::MinValue) { "" } else { $subtask.DueDate.ToString("yyyy-MM-ddTHH:mm:ss") }
                    CreatedAt = $subtask.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    UpdatedAt = $subtask.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    EstimatedMinutes = $subtask.EstimatedMinutes
                    ActualMinutes = $subtask.ActualMinutes
                    Deleted = $subtask.Deleted
                }
            }
            
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to save subtasks: $($_.Exception.Message)"
        }
    }
    
    [void] Load() {
        if (-not (Test-Path $this.DataPath)) {
            return
        }
        
        try {
            $json = Get-Content -Path $this.DataPath -Raw -Encoding UTF8
            $data = $json | ConvertFrom-Json
            
            $this.Subtasks.Clear()
            
            foreach ($item in $data) {
                $subtask = [Subtask]::new()
                $subtask.Id = $item.Id
                $subtask.ParentTaskId = $item.ParentTaskId
                $subtask.Title = $item.Title
                $subtask.Description = $item.Description
                $subtask.Status = [TaskStatus]$item.Status
                $subtask.Priority = [TaskPriority]$item.Priority
                $subtask.Progress = $item.Progress
                $subtask.SortOrder = $item.SortOrder
                $subtask.Tags = $item.Tags
                $subtask.DueDate = if ([string]::IsNullOrEmpty($item.DueDate)) { [DateTime]::MinValue } else { [DateTime]::Parse($item.DueDate) }
                $subtask.CreatedAt = [DateTime]::Parse($item.CreatedAt)
                $subtask.UpdatedAt = [DateTime]::Parse($item.UpdatedAt)
                $subtask.EstimatedMinutes = if ($item.PSObject.Properties.Name -contains 'EstimatedMinutes') { $item.EstimatedMinutes } else { 0 }
                $subtask.ActualMinutes = if ($item.PSObject.Properties.Name -contains 'ActualMinutes') { $item.ActualMinutes } else { 0 }
                $subtask.Deleted = if ($item.PSObject.Properties.Name -contains 'Deleted') { $item.Deleted } else { $false }
                
                $this.Subtasks.Add($subtask)
            }
            
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to load subtasks: $($_.Exception.Message)"
        }
    }
}


####\Services/TaskService.ps1
# TaskService.ps1 - Service for managing tasks

class TaskService {
    [System.Collections.Generic.List[Task]]$Tasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    TaskService() {
        $this.Tasks = [System.Collections.Generic.List[Task]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "tasks.json"
        
        # Load existing tasks
        $this.Load()
    }
    
    # CRUD Operations
    [Task] AddTask([string]$title, [string]$projectId) {
        $task = [Task]::new()
        $task.Title = $title
        $task.ProjectId = $projectId
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] CreateTask([hashtable]$properties) {
        $task = [Task]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($task.PSObject.Properties.Name -contains $key) {
                $task.$key = $properties[$key]
            }
        }
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] GetTask([string]$id) {
        return $this.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Task[]] GetAllTasks() {
        return $this.Tasks.ToArray()
    }
    
    [Task[]] GetTasksByProject([string]$projectId) {
        return $this.Tasks | Where-Object { $_.ProjectId -eq $projectId -and -not $_.Deleted }
    }
    
    [Task[]] GetActiveTasks() {
        return $this.Tasks | Where-Object { 
            -not $_.Deleted -and 
            $_.Status -ne [TaskStatus]::Completed -and 
            $_.Status -ne [TaskStatus]::Cancelled 
        }
    }
    
    [void] UpdateTask([Task]$task) {
        $task.MarkAsUpdated()  # Use BaseModel method
        $this._isDirty = $true
        $this.Save()
    }
    
    [void] DeleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.SoftDelete()  # Use BaseModel method
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Status management
    [void] UpdateTaskStatus([string]$id, [TaskStatus]$status) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.Status = $status
            $task.MarkAsUpdated()  # Use BaseModel method
            
            # Auto-update progress
            if ($status -eq [TaskStatus]::Completed) {
                $task.Progress = 100
            } elseif ($status -eq [TaskStatus]::Pending) {
                $task.Progress = 0
            }
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Priority management
    [void] CyclePriority([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            switch ($task.Priority) {
                ([TaskPriority]::Low) { $task.Priority = [TaskPriority]::Medium }
                ([TaskPriority]::Medium) { $task.Priority = [TaskPriority]::High }
                ([TaskPriority]::High) { $task.Priority = [TaskPriority]::Low }
            }
            $task.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Persistence
    [void] Save() {
        if (-not $this._isDirty) { return }
        
        try {
            $json = $this.Tasks | ConvertTo-Json -Depth 10
            $json | Set-Content -Path $this.DataPath -Encoding UTF8
            $this._isDirty = $false
            
            if ($global:Logger) {
                $global:Logger.Debug("TaskService: Saved $($this.Tasks.Count) tasks")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TaskService: Failed to save tasks: $_")
            }
        }
    }
    
    [void] Load() {
        if (Test-Path $this.DataPath) {
            try {
                $json = Get-Content -Path $this.DataPath -Raw
                $data = $json | ConvertFrom-Json
                
                $this.Tasks.Clear()
                foreach ($item in $data) {
                    $task = [Task]::new()
                    
                    # Map properties
                    $task.Id = $item.Id
                    $task.Title = $item.Title
                    $task.Description = $item.Description
                    $task.Status = [TaskStatus]$item.Status
                    $task.Priority = [TaskPriority]$item.Priority
                    $task.Progress = $item.Progress
                    $task.ProjectId = $item.ProjectId
                    $task.Tags = $item.Tags
                    $task.DueDate = if ($item.DueDate) { [DateTime]$item.DueDate } else { [DateTime]::MinValue }
                    $task.CreatedAt = [DateTime]$item.CreatedAt
                    $task.UpdatedAt = [DateTime]$item.UpdatedAt
                    $task.Deleted = $item.Deleted
                    
                    $this.Tasks.Add($task)
                }
                
                if ($global:Logger) {
                    $global:Logger.Debug("TaskService: Loaded $($this.Tasks.Count) tasks")
                }
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("TaskService: Failed to load tasks: $_")
                }
                # Start with empty list on error
                $this.Tasks.Clear()
            }
        } else {
            # Create sample tasks for testing
            $this.CreateSampleTasks()
        }
    }
    
    hidden [void] CreateSampleTasks() {
        # Create a few sample tasks
        $task1 = $this.AddTask("Implement user authentication", "")
        $task1.Description = "Add login/logout functionality with session management"
        $task1.Priority = [TaskPriority]::High
        $task1.Status = [TaskStatus]::InProgress
        $task1.Progress = 45
        
        $task2 = $this.AddTask("Write API documentation", "")
        $task2.Description = "Document all REST endpoints with examples"
        $task2.Priority = [TaskPriority]::Medium
        $task2.DueDate = (Get-Date).AddDays(7)
        
        $task3 = $this.AddTask("Fix navigation bug", "")
        $task3.Description = "Users report navigation not working after login"
        $task3.Priority = [TaskPriority]::High
        $task3.Status = [TaskStatus]::Completed
        $task3.Progress = 100
        
        $this.Save()
    }
}


####\Services/ThemeManager.ps1
# ThemeManager.ps1 - Fast theme management with pre-cached ANSI sequences
# All colors are pre-computed to avoid runtime lookups

class ThemeManager {
    hidden [hashtable]$_themes = @{}
    hidden [string]$_currentTheme = "default"
    hidden [hashtable]$_cache = @{}
    hidden [System.Collections.Generic.List[scriptblock]]$_listeners
    hidden [EventBus]$EventBus
    
    ThemeManager() {
        $this._listeners = [System.Collections.Generic.List[scriptblock]]::new()
        $this.InitializeDefaultTheme()
        
        # EventBus will be set later via SetEventBus
    }
    
    [void] InitializeDefaultTheme() {
        # Define default theme with RGB values
        $defaultTheme = @{
            # Base colors
            "background" = @(24, 24, 24)        # Dark background
            "foreground" = @(204, 204, 204)     # Light gray text
            "accent" = @(0, 150, 255)           # Blue accent
            "success" = @(0, 200, 83)           # Green
            "warning" = @(255, 195, 0)          # Yellow
            "error" = @(255, 85, 85)            # Red
            
            # UI elements
            "border" = @(68, 68, 68)           # Dark gray
            "border.focused" = @(0, 150, 255)   # Blue
            "selection" = @(60, 60, 60)         # Selection background
            "disabled" = @(128, 128, 128)       # Gray
            
            # Component specific
            "button.background" = @(48, 48, 48)
            "button.foreground" = @(204, 204, 204)
            "button.focused.background" = @(0, 150, 255)
            "button.focused.foreground" = @(255, 255, 255)
            
            "input.background" = @(32, 32, 32)
            "input.foreground" = @(204, 204, 204)
            "input.focused.border" = @(0, 150, 255)
            
            "menu.background" = @(32, 32, 32)
            "menu.foreground" = @(204, 204, 204)
            "menu.selected.background" = @(0, 150, 255)
            "menu.selected.foreground" = @(255, 255, 255)
            
            "tab.background" = @(48, 48, 48)
            "tab.foreground" = @(170, 170, 170)
            "tab.active.background" = @(24, 24, 24)
            "tab.active.foreground" = @(255, 255, 255)
            "tab.active.accent" = @(0, 150, 255)
        }
        
        $this.RegisterTheme("default", $defaultTheme)
        
        # Define matrix theme - black background with green text
        $matrixTheme = @{
            # Base colors
            "background" = @(0, 0, 0)             # Pure black background
            "foreground" = @(0, 255, 0)           # Bright green text
            "accent" = @(0, 200, 0)               # Darker green accent
            "success" = @(0, 255, 0)              # Bright green
            "warning" = @(255, 255, 0)            # Yellow
            "error" = @(255, 0, 0)                # Red
            
            # UI elements
            "border" = @(0, 100, 0)               # Dark green borders
            "border.focused" = @(0, 255, 0)       # Bright green when focused
            "selection" = @(0, 50, 0)             # Very dark green selection
            "disabled" = @(0, 128, 0)             # Medium green for disabled
            
            # Component specific
            "button.background" = @(0, 20, 0)
            "button.foreground" = @(0, 255, 0)
            "button.focused.background" = @(0, 100, 0)
            "button.focused.foreground" = @(0, 255, 0)
            
            "input.background" = @(0, 10, 0)
            "input.foreground" = @(0, 255, 0)
            "input.focused.border" = @(0, 255, 0)
            
            "menu.background" = @(0, 0, 0)
            "menu.foreground" = @(0, 200, 0)
            "menu.selected.background" = @(0, 80, 0)
            "menu.selected.foreground" = @(0, 255, 0)
            
            "tab.background" = @(0, 30, 0)
            "tab.foreground" = @(0, 150, 0)
            "tab.active.background" = @(0, 0, 0)
            "tab.active.foreground" = @(0, 255, 0)
            "tab.active.accent" = @(0, 255, 0)
            
            # Dialog colors
            "dialog.background" = @(0, 0, 0)
            "dialog.border" = @(0, 150, 0)
            "dialog.title" = @(0, 255, 0)
        }
        
        $this.RegisterTheme("matrix", $matrixTheme)
        $this.SetTheme("matrix")
    }
    
    # Register a new theme
    [void] RegisterTheme([string]$name, [hashtable]$colors) {
        $this._themes[$name] = $colors
        
        # If this is the current theme, rebuild cache
        if ($name -eq $this._currentTheme) {
            $this.RebuildCache()
        }
    }
    
    # Switch to a different theme
    [void] SetTheme([string]$name) {
        if (-not $this._themes.ContainsKey($name)) {
            throw "Theme '$name' not found"
        }
        
        $oldTheme = $this._currentTheme
        $this._currentTheme = $name
        $this.RebuildCache()
        
        # Notify via EventBus if available
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::ThemeChanged, @{
                OldTheme = $oldTheme
                NewTheme = $name
                ThemeManager = $this
            })
        }
        
        # Also notify legacy listeners for backward compatibility
        $this.NotifyListeners()
    }
    
    # Get pre-computed ANSI color sequence
    [string] GetColor([string]$key) {
        if ($this._cache.ContainsKey($key)) {
            return $this._cache[$key]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$key] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get background color sequence
    [string] GetBgColor([string]$key) {
        $bgKey = "$key.bg"
        if ($this._cache.ContainsKey($bgKey)) {
            return $this._cache[$bgKey]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$bgKey] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get raw RGB values
    [int[]] GetRGB([string]$key) {
        $theme = $this._themes[$this._currentTheme]
        
        if ($theme.ContainsKey($key)) {
            return $theme[$key]
        }
        
        # Try parent keys (e.g., "button" for "button.focused.background")
        $parts = $key -split '\.'
        for ($i = $parts.Count - 1; $i -gt 0; $i--) {
            $parentKey = $parts[0..($i-1)] -join '.'
            if ($theme.ContainsKey($parentKey)) {
                return $theme[$parentKey]
            }
        }
        
        return $null
    }
    
    # Rebuild the entire cache
    hidden [void] RebuildCache() {
        $this._cache.Clear()
        $theme = $this._themes[$this._currentTheme]
        
        # Pre-compute all theme colors
        foreach ($key in $theme.Keys) {
            $rgb = $theme[$key]
            if ($rgb -is [array] -and $rgb.Count -eq 3) {
                # Foreground
                $this._cache[$key] = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
                # Background
                $this._cache["$key.bg"] = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            }
        }
        
        # Add common combinations
        $this._cache["reset"] = [VT]::Reset()
        $this._cache["clear"] = [VT]::Clear()
        $this._cache["clearline"] = [VT]::ClearLine()
    }
    
    # Subscribe to theme changes (legacy method - use EventBus instead)
    [void] Subscribe([scriptblock]$callback) {
        # If EventBus is available, use it instead
        if ($this.EventBus) {
            # Wrap the callback to match EventBus signature
            $this.EventBus.Subscribe([EventNames]::ThemeChanged, {
                param($sender, $eventData)
                & $callback
            })
        } else {
            # Fall back to legacy listeners
            $this._listeners.Add($callback)
        }
    }
    
    # Notify all listeners of theme change (legacy method)
    hidden [void] NotifyListeners() {
        # Only notify legacy listeners if EventBus is not available
        if (-not $this.EventBus) {
            foreach ($listener in $this._listeners) {
                try {
                    & $listener
                } catch {
                    # Ignore listener errors
                }
            }
        }
    }
    
    # Set EventBus after initialization (called by ServiceContainer)
    [void] SetEventBus([EventBus]$eventBus) {
        $this.EventBus = $eventBus
    }
    
    # Get list of available themes
    [string[]] GetThemeNames() {
        return $this._themes.Keys | Sort-Object
    }
    
    # Get current theme name
    [string] GetCurrentTheme() {
        return $this._currentTheme
    }
}


####\Services/TimeTrackingService.ps1
# TimeTrackingService - Manages all time entries and calculations

class TimeTrackingService {
    [string]$DataPath
    [System.Collections.ArrayList]$TimeEntries
    [System.Collections.ArrayList]$TimeCodes
    [Logger]$Logger
    [EventBus]$EventBus
    [ProjectService]$ProjectService
    
    TimeTrackingService() {
        $this.TimeEntries = [System.Collections.ArrayList]::new()
        $this.TimeCodes = [System.Collections.ArrayList]::new()
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/timeentries.json"
        $this.LoadData()
        $this.InitializeCommonTimeCodes()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService("Logger")
        $this.EventBus = $container.GetService("EventBus")
        $this.ProjectService = $container.GetService("ProjectService")
    }
    
    [void] InitializeCommonTimeCodes() {
        # Add common codes if not already present
        $commonCodes = [TimeCode]::GetCommonCodes()
        foreach ($code in $commonCodes) {
            if (-not ($this.TimeCodes | Where-Object { $_.ID2 -eq $code.ID2 })) {
                $this.TimeCodes.Add($code) | Out-Null
            }
        }
    }
    
    [void] LoadData() {
        if (Test-Path $this.DataPath) {
            try {
                $data = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                
                # Load time entries
                if ($data.TimeEntries) {
                    foreach ($entry in $data.TimeEntries) {
                        $timeEntry = [TimeEntry]::new()
                        foreach ($prop in $entry.PSObject.Properties) {
                            if ($timeEntry.PSObject.Properties[$prop.Name]) {
                                $timeEntry.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeEntries.Add($timeEntry) | Out-Null
                    }
                }
                
                # Load time codes
                if ($data.TimeCodes) {
                    foreach ($code in $data.TimeCodes) {
                        $timeCode = [TimeCode]::new()
                        foreach ($prop in $code.PSObject.Properties) {
                            if ($timeCode.PSObject.Properties[$prop.Name]) {
                                $timeCode.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeCodes.Add($timeCode) | Out-Null
                    }
                }
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to load time tracking data: $_")
                }
            }
        }
    }
    
    [void] SaveData() {
        $data = @{
            TimeEntries = $this.TimeEntries
            TimeCodes = $this.TimeCodes
            LastUpdated = [DateTime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        }
        
        try {
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Time tracking data saved")
            }
        }
        catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save time tracking data: $_")
            }
        }
    }
    
    # Get or create time entry for a specific week and ID2
    [TimeEntry] GetOrCreateTimeEntry([string]$weekEndingFriday, [string]$id2) {
        $existing = $this.TimeEntries | Where-Object { 
            $_.WeekEndingFriday -eq $weekEndingFriday -and $_.ID2 -eq $id2 
        } | Select-Object -First 1
        
        if ($existing) {
            return $existing
        }
        
        # Create new entry
        $entry = [TimeEntry]::new($weekEndingFriday, $id2)
        
        # If it's a project ID2, populate project info
        if ($id2.Length -gt 5) {
            $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
            if ($project) {
                $entry.Name = $project.Nickname
                $entry.ID1 = $project.ID1
            }
        }
        
        $this.TimeEntries.Add($entry) | Out-Null
        return $entry
    }
    
    # Get entries for a specific week
    [TimeEntry[]] GetWeekEntries([string]$weekEndingFriday) {
        return $this.TimeEntries | Where-Object { $_.WeekEndingFriday -eq $weekEndingFriday }
    }
    
    # Get entries for current week
    [TimeEntry[]] GetCurrentWeekEntries() {
        $friday = $this.GetCurrentWeekFriday()
        return $this.GetWeekEntries($friday.ToString("yyyyMMdd"))
    }
    
    # Update time entry
    [void] UpdateTimeEntry([TimeEntry]$entry) {
        $entry.CalculateTotal()
        $entry.CalculateFiscalYear()
        $entry.UpdatedAt = [DateTime]::Now
        
        $this.SaveData()
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TimeEntryUpdated, $this, @{ TimeEntry = $entry })
        }
    }
    
    # Add hours for today
    [void] AddHoursForToday([string]$id2, [decimal]$hours, [string]$description = "") {
        $today = [DateTime]::Now
        $friday = $this.GetWeekFridayForDate($today)
        
        $entry = $this.GetOrCreateTimeEntry($friday.ToString("yyyyMMdd"), $id2)
        
        # Add hours to appropriate day
        switch ($today.DayOfWeek) {
            Monday { $entry.Monday += $hours }
            Tuesday { $entry.Tuesday += $hours }
            Wednesday { $entry.Wednesday += $hours }
            Thursday { $entry.Thursday += $hours }
            Friday { $entry.Friday += $hours }
            default {
                if ($this.Logger) {
                    $this.Logger.Warning("Cannot add time for weekend day")
                }
                return
            }
        }
        
        $this.UpdateTimeEntry($entry)
    }
    
    # Get Friday date for current week
    [DateTime] GetCurrentWeekFriday() {
        $today = [DateTime]::Now
        return $this.GetWeekFridayForDate($today)
    }
    
    # Get Friday date for any date's week
    [DateTime] GetWeekFridayForDate([DateTime]$date) {
        $friday = $date
        while ($friday.DayOfWeek -ne [DayOfWeek]::Friday) {
            if ($friday.DayOfWeek -eq [DayOfWeek]::Saturday) {
                $friday = $friday.AddDays(-1)
            } else {
                $friday = $friday.AddDays(1)
            }
        }
        return $friday
    }
    
    # Calculate total hours for a project
    [decimal] GetProjectTotalHours([string]$id2) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { $_.ID2 -eq $id2 }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Calculate fiscal year total for non-project code
    [decimal] GetFiscalYearTotal([string]$id2, [string]$fiscalYear) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { 
            $_.ID2 -eq $id2 -and $_.FiscalYear -eq $fiscalYear 
        }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Get current fiscal year string
    [string] GetCurrentFiscalYear() {
        $today = [DateTime]::Now
        if ($today.Month -ge 4) {
            return "$($today.Year)-$($today.Year + 1)"
        } else {
            return "$($today.Year - 1)-$($today.Year)"
        }
    }
    
    # Get all unique ID2s (both project and non-project)
    [string[]] GetAllID2s() {
        $id2s = @()
        
        # Add project ID2s
        $projects = $this.ProjectService.GetAllProjects() | Where-Object { -not $_.Deleted -and $_.ID2 }
        foreach ($project in $projects) {
            $id2s += $project.ID2
        }
        
        # Add time code ID2s
        foreach ($code in $this.TimeCodes) {
            if ($code.IsActive) {
                $id2s += $code.ID2
            }
        }
        
        return $id2s | Select-Object -Unique | Sort-Object
    }
    
    # Get display info for an ID2
    [hashtable] GetID2DisplayInfo([string]$id2) {
        # Check if it's a project
        $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($project) {
            return @{
                Name = $project.Nickname
                ID1 = $project.ID1
                ID2 = $id2
                IsProject = $true
            }
        }
        
        # It's a non-project code
        $timeCode = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        return @{
            Name = ""
            ID1 = ""
            ID2 = $id2
            IsProject = $false
            Description = if ($timeCode) { $timeCode.Description } else { "" }
        }
    }
    
    # Add or update time code
    [void] AddTimeCode([string]$id2, [string]$description = "") {
        $existing = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($existing) {
            $existing.Description = $description
            $existing.UpdatedAt = [DateTime]::Now
        } else {
            $code = [TimeCode]::new($id2, $description)
            $this.TimeCodes.Add($code) | Out-Null
        }
        $this.SaveData()
    }
}


####\apply-final-fixes.ps1
#!/usr/bin/env pwsh
# Apply final fixes for shortcuts and focus

Write-Host "Applying final fixes..." -ForegroundColor Cyan

# 1. Clean up debug output from ScreenManager
Write-Host "  Cleaning up ScreenManager..." -ForegroundColor Yellow
$content = Get-Content "Core/ScreenManager.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n', ''
$content | Set-Content "Core/ScreenManager.ps1" -Force

# 2. Clean up debug output from ShortcutManager  
Write-Host "  Cleaning up ShortcutManager..." -ForegroundColor Yellow
$content = Get-Content "Services/ShortcutManager.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Services/ShortcutManager.ps1" -Force

# 3. Clean up debug output from screens
Write-Host "  Cleaning up ProjectsScreen..." -ForegroundColor Yellow
$content = Get-Content "Screens/ProjectsScreen.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Screens/ProjectsScreen.ps1" -Force

Write-Host "  Cleaning up TaskScreen..." -ForegroundColor Yellow
$content = Get-Content "Screens/TaskScreen.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Screens/TaskScreen.ps1" -Force

Write-Host "`nFixes applied!" -ForegroundColor Green
Write-Host @"

The following issues have been fixed:

1. SHORTCUTS: Fixed case-sensitive matching bug
   - Shortcuts now work with both uppercase and lowercase keys
   - 'e' and 'E' both trigger edit, 'd' and 'D' both trigger delete

2. FOCUS: Fixed focus initialization on all screens
   - Each screen now properly sets initial focus when activated
   - Tab navigation works across all screens

3. CTRL+ARROWS: Added tab navigation shortcuts
   - Ctrl+Right Arrow = Tab (next focus)
   - Ctrl+Left Arrow = Shift+Tab (previous focus)

To test:
- Run: pwsh -File Start.ps1
- Navigate to any screen (1-6)
- Try shortcuts: n=new, e=edit, d=delete
- Try Ctrl+Arrows for navigation

"@ -ForegroundColor Cyan


####\debug-input-flow.ps1
#!/usr/bin/env pwsh
# Debug input flow

# Add extensive logging to key components
$debugCode = @'
# Add to Container.HandleInput
Write-Host "Container.HandleInput: Type=$($this.GetType().Name) Key=$($key.Key)" -ForegroundColor Yellow

# Add to Screen.HandleInput  
Write-Host "Screen.HandleInput: Type=$($this.GetType().Name) Key=$($key.Key)" -ForegroundColor Cyan

# Add to ProjectsScreen.HandleScreenInput
Write-Host "ProjectsScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'" -ForegroundColor Green

# Add to TabContainer.HandleInput
Write-Host "TabContainer.HandleInput: Key=$($key.Key) Routing to: $($activeTab.Content.GetType().Name)" -ForegroundColor Magenta
'@

Write-Host "Debug code to add for testing input flow:" -ForegroundColor Yellow
Write-Host $debugCode

Write-Host ""
Write-Host "Run PRAXIS and watch the console output to see input flow" -ForegroundColor Cyan


####\debug-number-key.ps1
#!/usr/bin/env pwsh
# Debug where number key input is getting consumed

Write-Host "=== Debug Number Key Input Flow ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "This will start PRAXIS and capture debug logs to trace number key input."
Write-Host "The goal is to understand where the '2' key gets consumed when you try"
Write-Host "to switch from Projects to Tasks tab."
Write-Host ""
Write-Host "Instructions:" -ForegroundColor Yellow
Write-Host "1. App will start on Projects tab"
Write-Host "2. Press '2' once to try switching to Tasks tab"
Write-Host "3. Press 'q' to quit immediately after"
Write-Host ""
Write-Host "Then we'll examine the logs to see the exact input flow."
Write-Host ""

# Clear the log
> _Logs/praxis.log

# Start PRAXIS 
pwsh -File Start.ps1 -Debug

# After it exits, show the relevant log entries
Write-Host ""
Write-Host "=== Input Flow Analysis ===" -ForegroundColor Cyan
Write-Host ""

# Show the key press and routing
Write-Host "Looking for '2' key press in logs:" -ForegroundColor Yellow
grep -A 20 -B 5 "Key pressed: D2\|KeyChar.*2" _Logs/praxis.log || Write-Host "No '2' key press found"

Write-Host ""
Write-Host "Looking for TabContainer input routing:" -ForegroundColor Yellow  
grep -A 10 -B 2 "TabContainer.*HandleInput\|TabContainer.*Routing" _Logs/praxis.log || Write-Host "No TabContainer routing found"

Write-Host ""
Write-Host "Looking for tab switching attempts:" -ForegroundColor Yellow
grep -A 5 -B 2 "Switching to tab\|ActivateTab" _Logs/praxis.log || Write-Host "No tab switching found"


####\debug-shortcuts-simple.ps1
#!/usr/bin/env pwsh
# Simple debug to see registered shortcuts

# Load the framework
. ./Start.ps1 -NoRun

# Check ShortcutManager
$sm = $global:ServiceContainer.GetService('ShortcutManager')
if ($sm) {
    Write-Host "ShortcutManager found" -ForegroundColor Green
    Write-Host "Total shortcuts: $($sm.Shortcuts.Count)" -ForegroundColor Yellow
    
    Write-Host "`nRegistered shortcuts:" -ForegroundColor Cyan
    $sm.Shortcuts | ForEach-Object {
        Write-Host "  - $($_.Id): Key=$($_.Key) Char='$($_.KeyChar)' Scope=$($_.Scope) Screen=$($_.ScreenType)"
    }
} else {
    Write-Host "ShortcutManager NOT FOUND!" -ForegroundColor Red
}


####\debug-shortcuts.ps1
#!/usr/bin/env pwsh
# Add temporary debug output to understand shortcut issues

# Backup original files
Copy-Item "Services/ShortcutManager.ps1" "Services/ShortcutManager.ps1.bak" -Force
Copy-Item "Core/ScreenManager.ps1" "Core/ScreenManager.ps1.bak" -Force

Write-Host "Adding debug output to ShortcutManager and ScreenManager..." -ForegroundColor Yellow

# Add debug output to critical methods
$smContent = Get-Content "Services/ShortcutManager.ps1" -Raw

# Add console output to HandleKeyPress (in addition to logging)
$smContent = $smContent -replace '(\[bool\] HandleKeyPress.*?\{)', @'
$1
        Write-Host "[DEBUG] ShortcutManager.HandleKeyPress: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' Screen=$currentScreen" -ForegroundColor Magenta
'@

# Add console output when shortcuts match
$smContent = $smContent -replace '(if \(\$applicable\.Count -gt 0\) \{)', @'
Write-Host "[DEBUG] Applicable shortcuts: $($applicable.Count)" -ForegroundColor Cyan
        $1
'@

# Save modified ShortcutManager
$smContent | Set-Content "Services/ShortcutManager.ps1" -Force

Write-Host "Debug output added. Run PRAXIS and watch for [DEBUG] messages" -ForegroundColor Green
Write-Host "To restore original files, run: ./restore-shortcuts.ps1" -ForegroundColor Gray

# Create restore script
@'
#!/usr/bin/env pwsh
# Restore original files
Move-Item "Services/ShortcutManager.ps1.bak" "Services/ShortcutManager.ps1" -Force
Move-Item "Core/ScreenManager.ps1.bak" "Core/ScreenManager.ps1" -Force
Write-Host "Original files restored" -ForegroundColor Green
'@ | Set-Content "restore-shortcuts.ps1" -Force


####\debug-tab-switching.ps1
#!/usr/bin/env pwsh
# Debug tab switching - add extra logging

# Backup original files
Copy-Item "Screens/TextEditorScreen.ps1" "Screens/TextEditorScreen.ps1.backup" -Force
Copy-Item "Components/TabContainer.ps1" "Components/TabContainer.ps1.backup" -Force

# Add debug logging to TextEditorScreen
$textEditorContent = Get-Content "Screens/TextEditorScreen.ps1" -Raw
$textEditorContent = $textEditorContent -replace 'return \$false  # Let parent handle 1-6 for tab switching', @'
if ($global:Logger) {
                    $global:Logger.Debug("TextEditorScreen: RETURNING FALSE for key '$($keyInfo.Key)' - should bubble up")
                }
                return $false  # Let parent handle 1-6 for tab switching
'@
Set-Content "Screens/TextEditorScreen.ps1" $textEditorContent

# Add debug logging to TabContainer ActivateTab
$tabContainerContent = Get-Content "Components/TabContainer.ps1" -Raw
$tabContainerContent = $tabContainerContent -replace 'if \(\$global:Logger\) \{[\s\S]*?\$global:Logger\.Debug\("TabContainer\.ActivateTab: Switching from tab \$\(\$this\.ActiveTabIndex\) to tab \$index"\)[\s\S]*?\}', @'
if ($global:Logger) {
            $global:Logger.Debug("TabContainer.ActivateTab: ABOUT TO SWITCH from tab $($this.ActiveTabIndex) to tab $index")
            $global:Logger.Debug("TabContainer.ActivateTab: Current active tab: $($this.Tabs[$this.ActiveTabIndex].Title)")
            $global:Logger.Debug("TabContainer.ActivateTab: Target tab: $($this.Tabs[$index].Title)")
        }
'@
Set-Content "Components/TabContainer.ps1" $tabContainerContent

Write-Host "Added debug logging. Run PRAXIS and test tab switching." -ForegroundColor Green
Write-Host "1. Start PRAXIS" -ForegroundColor Yellow  
Write-Host "2. Press 4 to go to Editor tab" -ForegroundColor Yellow
Write-Host "3. Press ESC to enter command mode" -ForegroundColor Yellow
Write-Host "4. Press 1 to switch tabs" -ForegroundColor Yellow
Write-Host "5. Check the logs to see exactly what happens" -ForegroundColor Yellow
Write-Host ""
Write-Host "To restore original files after testing:" -ForegroundColor Cyan
Write-Host "  Copy-Item 'Screens/TextEditorScreen.ps1.backup' 'Screens/TextEditorScreen.ps1' -Force" -ForegroundColor Cyan
Write-Host "  Copy-Item 'Components/TabContainer.ps1.backup' 'Components/TabContainer.ps1' -Force" -ForegroundColor Cyan


####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}



####\fix-shortcuts-with-eventbus.ps1
#!/usr/bin/env pwsh
# Fix shortcuts by using EventBus like CommandPalette does

Write-Host "Fixing shortcuts to use EventBus approach..." -ForegroundColor Cyan

# Create a new simple shortcut handler that publishes events
$shortcutHandler = @'
# SimpleShortcutHandler.ps1 - Direct keyboard shortcuts via EventBus

class SimpleShortcutHandler {
    hidden [EventBus]$EventBus
    hidden [Logger]$Logger
    
    [void] Initialize([ServiceContainer]$container) {
        $this.EventBus = $container.GetService('EventBus')
        $this.Logger = $container.GetService('Logger')
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen) {
        # Only handle character keys when no modifiers are pressed
        if ($keyInfo.Modifiers -ne [System.ConsoleModifiers]::None) {
            return $false
        }
        
        $char = [char]::ToLower($keyInfo.KeyChar)
        
        # Handle shortcuts based on current screen
        switch ($currentScreen) {
            "ProjectsScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewProject', 'ProjectsScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditProject', 'ProjectsScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteProject', 'ProjectsScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshProjects', 'ProjectsScreen')
                        return $true
                    }
                    'v' {
                        $this.PublishCommand('ViewProject', 'ProjectsScreen')
                        return $true
                    }
                }
            }
            "TaskScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewTask', 'TaskScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditTask', 'TaskScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteTask', 'TaskScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshTasks', 'TaskScreen')
                        return $true
                    }
                }
            }
        }
        
        return $false
    }
    
    hidden [void] PublishCommand([string]$command, [string]$target) {
        if ($this.Logger) {
            $this.Logger.Debug("SimpleShortcutHandler: Publishing command $command for $target")
        }
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::CommandExecuted, @{
                Command = $command
                Target = $target
            })
        }
    }
}
'@

# Save the new handler
$shortcutHandler | Set-Content "Services/SimpleShortcutHandler.ps1" -Force
Write-Host "Created SimpleShortcutHandler.ps1" -ForegroundColor Green

# Update Start.ps1 to load it
$startContent = Get-Content "Start.ps1" -Raw
$startContent = $startContent -replace '("Services/ShortcutManager.ps1")', @'
"Services/ShortcutManager.ps1",
    "Services/SimpleShortcutHandler.ps1"
'@
$startContent | Set-Content "Start.ps1" -Force

# Add initialization after ShortcutManager
$startContent = Get-Content "Start.ps1" -Raw
$startContent = $startContent -replace '(\$shortcutManager\.Initialize\(\$global:ServiceContainer\)\s*\$global:ServiceContainer\.Register\("ShortcutManager", \$shortcutManager\))', @'
$1

# SimpleShortcutHandler (uses EventBus like CommandPalette)
$simpleHandler = [SimpleShortcutHandler]::new()
$simpleHandler.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("SimpleShortcutHandler", $simpleHandler)
'@
$startContent | Set-Content "Start.ps1" -Force

# Update ScreenManager to use SimpleShortcutHandler
$smContent = Get-Content "Core/ScreenManager.ps1" -Raw

# Add the simple handler
$smContent = $smContent -replace '(hidden \[ShortcutManager\]\$_shortcutManager)', @'
$1
    hidden [SimpleShortcutHandler]$_simpleHandler
'@

# Initialize it
$smContent = $smContent -replace '(\$this\._shortcutManager = \$services\.GetService\(''ShortcutManager''\))', @'
$1
        $this._simpleHandler = $services.GetService('SimpleShortcutHandler')
'@

# Use it for character shortcuts
$smContent = $smContent -replace '(# 1\. Check ShortcutManager for global shortcuts first)', @'
# 1. Check for simple character shortcuts first (like CommandPalette)
                        if ($this._simpleHandler -and $key.KeyChar -ne [char]0) {
                            $currentScreenType = if ($this._activeScreen) { $this._activeScreen.GetType().Name } else { "" }
                            
                            if ($this._simpleHandler.HandleKeyPress($key, $currentScreenType)) {
                                $handled = $true
                                if ($global:Logger) {
                                    $global:Logger.Debug("Key handled by SimpleShortcutHandler")
                                }
                            }
                        }
                        
                        # 2. Check ShortcutManager for global shortcuts
'@

# Fix the numbering
$smContent = $smContent -replace '# 2\. Command Palette override', '# 3. Command Palette override'
$smContent = $smContent -replace '# 3\. Fallback to hardcoded', '# 4. Fallback to hardcoded'
$smContent = $smContent -replace '# 4\. Tab navigation', '# 5. Tab navigation'
$smContent = $smContent -replace '# 5\. If not handled', '# 6. If not handled'

$smContent | Set-Content "Core/ScreenManager.ps1" -Force

Write-Host "`nDone! Shortcuts now work exactly like CommandPalette:" -ForegroundColor Green
Write-Host "- They publish EventBus events" -ForegroundColor Gray
Write-Host "- Screens already listen for these events" -ForegroundColor Gray
Write-Host "- No complex ShortcutManager registration needed" -ForegroundColor Gray
Write-Host "`nTest with: pwsh -File Start.ps1" -ForegroundColor Yellow


####\fix-shortcuts.ps1
#!/usr/bin/env pwsh
# Fix shortcut issues

Write-Host "Applying shortcut fixes..." -ForegroundColor Yellow

# 1. Fix ShortcutManager debug logging to be more visible
$smPath = "Services/ShortcutManager.ps1"
$content = Get-Content $smPath -Raw

# Make the Matches method log at INFO level for debugging
$content = $content -replace 'if \(\$global:Logger\) \{\s*\$global:Logger\.Debug\("Shortcut\.Matches:', @'
if ($global:Logger) {
                $global:Logger.Info("Shortcut.Matches:'
@

# Make HandleKeyPress log at INFO level
$content = $content -replace '\$this\.Logger\.Debug\("ShortcutManager\.HandleKeyPress:', '$this.Logger.Info("ShortcutManager.HandleKeyPress:'

$content | Set-Content $smPath -Force
Write-Host "  Updated ShortcutManager logging" -ForegroundColor Green

# 2. Ensure ScreenManager properly gets the current screen type
$smPath = "Core/ScreenManager.ps1"
$content = Get-Content $smPath -Raw

# Add validation that screen type is correct
$newCheck = @'
$currentScreenType = if ($this._activeScreen) { $this._activeScreen.GetType().Name } else { "" }
                            $currentContext = ""
                            
                            # Check if CommandPalette exists and is visible
                            if ($this._activeScreen) {
                                $cmdPalette = $this._activeScreen.PSObject.Properties['CommandPalette']
                                if ($cmdPalette -and $cmdPalette.Value -and $cmdPalette.Value.IsVisible) {
                                    $currentContext = "CommandPalette"
                                }
                            }
                            
                            if ($global:Logger) {
                                $global:Logger.Info("ScreenManager: Active screen type = '$currentScreenType'")
                                $global:Logger.Info("Calling ShortcutManager.HandleKeyPress: Screen=$currentScreenType Context=$currentContext")
                            }
'@

$content = $content -replace '(\$currentScreenType = if.*?Calling ShortcutManager\.HandleKeyPress[^\}]+\})', $newCheck

$content | Set-Content $smPath -Force
Write-Host "  Updated ScreenManager validation" -ForegroundColor Green

# 3. Add temporary console output to see what's happening
$projectsPath = "Screens/ProjectsScreen.ps1"
$content = Get-Content $projectsPath -Raw

# Add console output when shortcuts are registered
$content = $content -replace '(\[void\] RegisterShortcuts\(\) \{[^}]+?)(\$shortcutManager = )', @'
$1
        Write-Host "[ProjectsScreen] Registering shortcuts..." -ForegroundColor Cyan
        $2
'@

$content = $content -replace '(if \(\$global:Logger\) \{\s*\$global:Logger\.Debug\("ProjectsScreen\.RegisterShortcuts: Registered 5 shortcuts"\))', @'
Write-Host "[ProjectsScreen] Registered 5 shortcuts successfully" -ForegroundColor Green
        $1
'@

$content | Set-Content $projectsPath -Force
Write-Host "  Updated ProjectsScreen debug output" -ForegroundColor Green

Write-Host "`nFixes applied. Run Start.ps1 to test" -ForegroundColor Green
Write-Host "Look for [ProjectsScreen] messages when navigating to screen 1" -ForegroundColor Yellow


####\RUN_THIS_TEST.ps1
#!/usr/bin/env pwsh
Write-Host @"

SHORTCUT AND FOCUS TEST INSTRUCTIONS
====================================

The debug output has been added to help diagnose the issues.

When you run Start.ps1, you will see:
- [REG] messages when shortcuts are registered
- [UNREG] messages when shortcuts are unregistered  
- [DEBUG] messages for each key press
- [SM] messages from ShortcutManager processing
- [MATCH] messages when checking if shortcuts match
- Screen activation messages

To test:
1. Run: pwsh -File Start.ps1
2. Press 1 to go to Projects screen
3. Press 'e' - watch for debug output
4. Press 2 to go to Tasks screen  
5. Press 'e' again

The debug output will show exactly what's happening with shortcuts.

"@ -ForegroundColor Yellow


####\Start.ps1
#!/usr/bin/env pwsh
# PRAXIS - Performance-focused TUI Framework
# Entry point and bootstrapper

param(
    [switch]$Debug,
    [switch]$Performance,
    [string]$Theme = "default"
)

# Enable debug output if requested
if ($Debug) {
    $global:PraxisDebug = $true
}

# Ensure we're in the right directory
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Ensure data directory exists
$dataDir = Join-Path $script:PraxisRoot "_ProjectData"
if (-not (Test-Path $dataDir)) {
    New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
}

# Load order is critical for class inheritance
$loadOrder = @(
    # Core modules first
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Core/StringBuilderPool.ps1"
    
    # Services (needed by base classes)
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    
    # Base classes
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    "Base/BaseModel.ps1"
    
    # Services that depend on base classes
    "Services/ShortcutManager.ps1"
    
    # Models
    "Models/Project.ps1"
    "Models/Task.ps1"
    "Models/Subtask.ps1"
    
    # Services
    "Services/ProjectService.ps1"
    "Services/TaskService.ps1"
    "Services/SubtaskService.ps1"
    "Services/ConfigurationService.ps1"
    "Services/StateManager.ps1"
    
    # Components
    "Components/ListBox.ps1"
    "Components/TextBox.ps1"
    "Components/Button.ps1"
    "Components/DataGrid.ps1"
    "Components/TreeView.ps1"
    "Components/ProgressBar.ps1"
    "Components/FastFileTree.ps1"
    "Components/RangerFileTree.ps1"
    "Components/SearchableListBox.ps1"
    "Components/MultiSelectListBox.ps1"
    "Components/TabContainer.ps1"
    
    # Layout Components (NEW!)
    "Components/HorizontalSplit.ps1"
    "Components/VerticalSplit.ps1"
    "Components/GridPanel.ps1"
    "Components/DockPanel.ps1"
    
    # Core systems
    "Core/ScreenManager.ps1"
    
    # BaseDialog (after components are loaded)
    "Base/BaseDialog.ps1"
    
    # Dialogs (must be loaded before screens that use them)
    "Screens/TextInputDialog.ps1",
    "Screens/NumberInputDialog.ps1",
    "Screens/ConfirmationDialog.ps1",
    "Screens/NewProjectDialog.ps1",
    "Screens/EditProjectDialog.ps1",
    "Screens/NewTaskDialog.ps1",
    "Screens/EditTaskDialog.ps1",
    "Screens/SubtaskDialog.ps1",
    "Screens/TimeEntryDialog.ps1",
    "Screens/EventBusMonitor.ps1",
    
    # Screens (after dialogs they depend on)
    "Screens/TestScreen.ps1",
    "Screens/ProjectDetailScreen.ps1",
    "Screens/ProjectsScreen.ps1",
    "Screens/TaskScreen.ps1",
    "Screens/DashboardScreen.ps1",
    "Screens/SettingsScreen.ps1",
    "Screens/FileBrowserScreen.ps1",
    "Screens/TextEditorScreen.ps1",
    
    # CommandPalette (after screens it references)
    "Components/CommandPalette.ps1"
    
    # Main screen
    "Screens/MainScreen.ps1"
)

# Load all modules
Write-Host "Loading PRAXIS framework..." -ForegroundColor Cyan
foreach ($file in $loadOrder) {
    $path = Join-Path $script:PraxisRoot $file
    if (Test-Path $path) {
        try {
            . $path
            if ($Debug) {
                Write-Host "   $file" -ForegroundColor Green
            }
        } catch {
            Write-Host "   $file - $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "   $file - File not found" -ForegroundColor Red
        exit 1
    }
}

# Initialize services
Write-Host "Initializing services..." -ForegroundColor Cyan

# Logger (first so other services can use it)
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
if ($Debug) {
    Write-Host "  Logger created at: $($logger.LogPath)" -ForegroundColor DarkGray
}

# Theme manager
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# EventBus (after Logger and ThemeManager, before other services)
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# ShortcutManager
$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)
if ($Debug) {
    Write-Host "  EventBus initialized" -ForegroundColor DarkGray
}

# Connect ThemeManager to EventBus
$themeManager.SetEventBus($eventBus)

# Removed FocusManager and ShortcutManager services
# Using direct patterns instead: ScreenManager global shortcuts + Screen.FocusNext()

# Project service
$projectService = [ProjectService]::new()
$global:ServiceContainer.Register("ProjectService", $projectService)

# Task service
$taskService = [TaskService]::new()
$global:ServiceContainer.Register("TaskService", $taskService)

# Subtask service
$subtaskService = [SubtaskService]::new()
$global:ServiceContainer.Register("SubtaskService", $subtaskService)

# Configuration service
$configService = [ConfigurationService]::new()
$global:ServiceContainer.Register("ConfigurationService", $configService)

# State manager - high-performance centralized state
$stateManager = [StateManager]::new()
$stateManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("StateManager", $stateManager)

# Screen manager
$screenManager = [ScreenManager]::new($global:ServiceContainer)
$global:ScreenManager = $screenManager
$global:ServiceContainer.Register("ScreenManager", $screenManager)

# Create main screen with tabs
Write-Host "Creating main interface..." -ForegroundColor Cyan

# Create and run main screen
if ($Debug) { Write-Host "  Creating MainScreen..." -ForegroundColor DarkGray }
$mainScreen = [MainScreen]::new()

if ($Debug) { Write-Host "  Pushing to ScreenManager..." -ForegroundColor DarkGray }
$screenManager.Push($mainScreen)

if ($Debug) { Write-Host "  Main screen initialized" -ForegroundColor DarkGray }

Write-Host "Starting PRAXIS..." -ForegroundColor Green
Write-Host "   Press 1-6 to switch tabs (Projects, Tasks, Dashboard, Files, Editor, Settings)" -ForegroundColor DarkGray
Write-Host "   Press Ctrl+Tab to cycle tabs" -ForegroundColor DarkGray
Write-Host "   Press / or : for command palette" -ForegroundColor DarkGray
Write-Host "   Press Q or Escape to quit" -ForegroundColor DarkGray
Write-Host ""

# Run the application
try {
    $global:Logger.Info("Starting PRAXIS main loop")
    $screenManager.Run()
} catch {
    if ($global:Logger) {
        if ($_.Exception) {
            $global:Logger.LogException($_.Exception, "Fatal error in main loop")
        } else {
            $global:Logger.Error("Fatal error in main loop: $_")
        }
    }
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    if ($global:Logger) {
        Write-Host "`nCheck log file at: $($global:Logger.LogPath)" -ForegroundColor Yellow
    }
} finally {
    # Cleanup
    $global:Logger.Info("Shutting down PRAXIS")
    $stateManager = $global:ServiceContainer.GetService("StateManager")
    if ($stateManager) {
        $stateManager.Cleanup()
    }
    $global:Logger.Cleanup()
    $global:ServiceContainer.Cleanup()
    Write-Host "`nPRAXIS terminated." -ForegroundColor Cyan
}


####\test-actual-behavior.ps1
#!/usr/bin/env pwsh
# Test current actual behavior across different screens

# Change to PRAXIS directory
Set-Location $PSScriptRoot

Write-Host "=== Testing Current Tab Switching Behavior ===" -ForegroundColor Cyan
Write-Host "Instructions:" -ForegroundColor Yellow
Write-Host "1. App will start"
Write-Host "2. Press '4' to go to Editor tab"
Write-Host "3. Press ESC to enter command mode"
Write-Host "4. Press '1' to switch to Projects tab"
Write-Host "5. Press '2' to switch to Tasks tab"
Write-Host "6. Press Q to quit"
Write-Host ""
Write-Host "If tab switching works, you should see tab changes."
Write-Host "If it doesn't work, tabs won't switch when pressing 1-6."
Write-Host ""
Write-Host "Starting PRAXIS in 3 seconds..." -ForegroundColor Green
Start-Sleep 3

# Start PRAXIS
pwsh -File Start.ps1


####\test-all-features.ps1
#!/usr/bin/env pwsh
# Test script to verify all PRAXIS features

Write-Host "Testing PRAXIS Features..." -ForegroundColor Cyan

# Load base classes first
. "$PSScriptRoot/Base/BaseModel.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Base/BaseDialog.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Services/Logger.ps1"

# Test 1: Time Entry Model
Write-Host "`n1. Testing Time Entry Model:" -ForegroundColor Yellow
. "$PSScriptRoot/Models/TimeEntry.ps1"
. "$PSScriptRoot/Models/TimeCode.ps1"

$entry = [TimeEntry]::new("20240126", "CAS-2024-001")
$entry.Monday = 8
$entry.Tuesday = 7.5
$entry.CalculateTotal()
Write-Host "    Created time entry for project: $($entry.ID2), Total: $($entry.Total) hours"

$nonProjectEntry = [TimeEntry]::new("20240126", "VAC")
$nonProjectEntry.Monday = 8
$nonProjectEntry.CalculateTotal()
Write-Host "    Created non-project entry: $($nonProjectEntry.ID2), Is Project: $($nonProjectEntry.IsProjectEntry())"

# Test 2: Time Tracking Service
Write-Host "`n2. Testing Time Tracking Service:" -ForegroundColor Yellow
. "$PSScriptRoot/Services/TimeTrackingService.ps1"
$service = [TimeTrackingService]::new()
Write-Host "    TimeTrackingService created"
Write-Host "    Data file: $($service.DataFilePath)"

# Test 3: Project Model with Excel Fields
Write-Host "`n3. Testing Project Model with Excel Import Fields:" -ForegroundColor Yellow
. "$PSScriptRoot/Models/Project.ps1"
$project = [Project]::new()
$project.Name = "Test Client"
$project.ID1 = "2024-001"
$project.ID2 = "CAS-2024-001"
$project.Status = "Active"
$project.AuditType = "Financial"
Write-Host "    Created project with Excel fields: $($project.Name) | $($project.ID1) | $($project.ID2)"

# Test 4: Excel Import Service
Write-Host "`n4. Testing Excel Import Service:" -ForegroundColor Yellow
. "$PSScriptRoot/Services/ExcelImportService.ps1"
$excelService = [ExcelImportService]::new()
Write-Host "    ExcelImportService created"
Write-Host "    Field mappings loaded: $($excelService.FieldMappings.Count) fields"

# Test 5: DataGrid Component
Write-Host "`n5. Testing DataGrid Component:" -ForegroundColor Yellow
. "$PSScriptRoot/Components/DataGrid.ps1"
$grid = [DataGrid]::new()
$columns = @(
    @{ Name = "Status"; Header = "Status"; Width = 8 }
    @{ Name = "Name"; Header = "Name"; Width = 20 }
    @{ Name = "ID2"; Header = "ID2"; Width = 15 }
)
$grid.SetColumns($columns)
Write-Host "    DataGrid created with $($columns.Count) columns"

# Test 6: Quick Time Entry Dialog
Write-Host "`n6. Testing QuickTimeEntryDialog:" -ForegroundColor Yellow
. "$PSScriptRoot/Screens/QuickTimeEntryDialog.ps1"
$dialog = [QuickTimeEntryDialog]::new()
Write-Host "    QuickTimeEntryDialog created successfully"

# Test 7: Fiscal Year Calculation
Write-Host "`n7. Testing Fiscal Year Calculations:" -ForegroundColor Yellow
$testDates = @(
    "20240415",  # April 15, 2024 - FY 2024-2025
    "20240301",  # March 1, 2024 - FY 2023-2024
    "20250131"   # January 31, 2025 - FY 2024-2025
)
foreach ($date in $testDates) {
    $entry = [TimeEntry]::new($date, "TEST")
    $dateObj = [DateTime]::ParseExact($date, "yyyyMMdd", $null)
    Write-Host "   Date: $($dateObj.ToString('yyyy-MM-dd')) -> Fiscal Year: $($entry.FiscalYear)"
}

Write-Host "`nAll tests completed successfully!" -ForegroundColor Green
Write-Host "PRAXIS is ready with:" -ForegroundColor Cyan
Write-Host "   Excel import functionality (Ctrl+I)"
Write-Host "   Time tracking system (Ctrl+T)"
Write-Host "   Enhanced project screens with DataGrid"
Write-Host "   Full project detail display"
Write-Host "   Fiscal year tracking for non-project codes"


####\test-console-input.ps1
#!/usr/bin/env pwsh
# Test if console input gets broken after tab switching

Write-Host "=== Console Input Debug Test ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "This will add extra console debugging to understand the input freeze."
Write-Host ""

# Patch ScreenManager to add console state debugging
$patchFile = @'
# Temporary patch for ScreenManager to debug console input
$screenManagerPath = "./Core/ScreenManager.ps1"
$content = Get-Content $screenManagerPath -Raw

# Add console state check after KeyAvailable check
$patch = @"
                    if ([Console]::KeyAvailable) {
                        `$key = [Console]::ReadKey(`$true)
"@

$replacement = @"
                    # Debug console state
                    if (`$this._frameCount % 50 -eq 0) {
                        if (`$global:Logger) {
                            try {
                                `$keyAvail = [Console]::KeyAvailable
                                `$global:Logger.Debug("Console state check: KeyAvailable=`$keyAvail")
                            } catch {
                                `$global:Logger.Debug("Console state check failed: `$_")
                            }
                        }
                    }
                    
                    if ([Console]::KeyAvailable) {
                        `$key = [Console]::ReadKey(`$true)
"@

$content = $content -replace [regex]::Escape($patch), $replacement
$content | Set-Content $screenManagerPath -NoNewline
'@

# Create a temporary file with the patch
$patchFile | Out-File -FilePath "apply-debug-patch.ps1" -Encoding UTF8

Write-Host "Applying debug patch..." -ForegroundColor Yellow
. ./apply-debug-patch.ps1

Write-Host "Starting PRAXIS with console debugging..." -ForegroundColor Green
Write-Host ""
Write-Host "Test these steps:" -ForegroundColor Yellow
Write-Host "1. Press 2 to go to Tasks tab"
Write-Host "2. Press 1 to go back to Projects tab"
Write-Host "3. Try pressing any other key - does it respond?"
Write-Host ""

# Clear log
Clear-Content _Logs/praxis.log -ErrorAction SilentlyContinue

# Run PRAXIS
pwsh -File Start.ps1 -Debug

Write-Host ""
Write-Host "=== Checking for console state logs ===" -ForegroundColor Cyan
grep "Console state" _Logs/praxis.log | tail -20

# Clean up
Write-Host ""
Write-Host "Reverting patch..." -ForegroundColor Yellow
git checkout -- Core/ScreenManager.ps1
Remove-Item apply-debug-patch.ps1 -ErrorAction SilentlyContinue


####\test-current-state.ps1
#!/usr/bin/env pwsh
# Test current state - does tab switching work at all?

Write-Host "=== Current State Test ===" -ForegroundColor Red
Write-Host ""
Write-Host "Testing if number key tab switching works AT ALL."
Write-Host ""
Write-Host "Expected behavior:" -ForegroundColor Yellow
Write-Host "- Start on Projects tab (should show 1:Projects highlighted)"
Write-Host "- Press '2'  should switch to Tasks tab"
Write-Host "- Press '3'  should switch to Files tab"
Write-Host "- Press '4'  should switch to Editor tab"
Write-Host ""
Write-Host "If NOTHING happens when pressing 2/3/4, then tab switching is completely broken."
Write-Host ""
Write-Host "Starting PRAXIS now..." -ForegroundColor Green

pwsh -File Start.ps1


####\test-dashboard-async-loading.ps1
#!/usr/bin/env pwsh

# Test for background data loading with progress indicators in DashboardScreen
# This demonstrates how to implement non-blocking data loading

. ./Start.ps1 -NoRun

# Create an enhanced DashboardScreen with background loading
class AsyncDashboardScreen : Screen {
    # Main layout structure (same as original)
    [HorizontalSplit]$MainLayout
    [VerticalSplit]$RightLayout
    [GridPanel]$ActionGrid
    [HorizontalSplit]$TopRightLayout
    [VerticalSplit]$MetricsLayout
    
    # Left pane components
    [ListBox]$ProjectList
    [ListBox]$RecentActivity
    [VerticalSplit]$LeftLayout
    
    # Top-right pane components
    [ListBox]$TaskList
    [ListBox]$PriorityBreakdown
    [ListBox]$StatusChart
    [GridPanel]$MetricBoxes
    
    # Progress indicators for each section
    [ProgressBar]$ProjectProgress
    [ProgressBar]$TaskProgress
    [ProgressBar]$ActivityProgress
    [ProgressBar]$MetricsProgress
    
    # Loading overlays
    [hashtable]$LoadingStates = @{
        Projects = $false
        Tasks = $false
        Activity = $false
        Metrics = $false
    }
    
    # Services
    [ProjectService]$ProjectService
    [TaskService]$TaskService
    [EventBus]$EventBus
    [ThemeManager]$Theme
    
    # Data loading flags
    hidden [bool]$_isLoading = $false
    hidden [System.Collections.Generic.List[string]]$_loadingTasks
    
    AsyncDashboardScreen() : base() {
        $this.Title = "PRAXIS Async Dashboard"
        $this._loadingTasks = [System.Collections.Generic.List[string]]::new()
    }
    
    [void] OnInitialize() {
        Write-Host "Initializing async dashboard..."
        
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        $this.Theme = $global:ServiceContainer.GetService('ThemeManager')
        
        # Subscribe to data loading events
        $this.SetupEventHandlers()
        
        # Build UI structure immediately
        $this.BuildMasterLayout()
        $this.BuildLeftPane()
        $this.BuildRightPane()
        
        # Show initial empty state with loading indicators
        $this.ShowLoadingState()
        
        # Start background data loading
        $this.StartAsyncDataLoad()
        
        Write-Host "Dashboard UI ready, loading data in background..."
    }
    
    [void] SetupEventHandlers() {
        # Progress update events
        $this.EventBus.Subscribe('dashboard.progress.projects', {
            param($sender, $data)
            if ($this.ProjectProgress) {
                $this.ProjectProgress.SetProgress($data.Progress, $data.Status)
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.progress.tasks', {
            param($sender, $data)
            if ($this.TaskProgress) {
                $this.TaskProgress.SetProgress($data.Progress, $data.Status)
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.progress.activity', {
            param($sender, $data)
            if ($this.ActivityProgress) {
                $this.ActivityProgress.SetProgress($data.Progress, $data.Status)
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.progress.metrics', {
            param($sender, $data)
            if ($this.MetricsProgress) {
                $this.MetricsProgress.SetProgress($data.Progress, $data.Status)
            }
        }.GetNewClosure())
        
        # Data loaded events
        $this.EventBus.Subscribe('dashboard.data.projects', {
            param($sender, $data)
            $this.OnProjectsLoaded($data.Projects)
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.tasks', {
            param($sender, $data)
            $this.OnTasksLoaded($data.Tasks)
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.activity', {
            param($sender, $data)
            $this.OnActivityLoaded($data.Activities)
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.metrics', {
            param($sender, $data)
            $this.OnMetricsLoaded($data.Metrics)
        }.GetNewClosure())
    }
    
    [void] BuildMasterLayout() {
        # Same as original, but with progress bars
        Write-Host "Building master layout structure..."
        
        # Main horizontal split
        $this.MainLayout = [HorizontalSplit]::new()
        $this.MainLayout.SetSplitRatio(40)
        $this.MainLayout.ShowBorder = $false
        $this.MainLayout.Initialize($global:ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Left side: Vertical split
        $this.LeftLayout = [VerticalSplit]::new()
        $this.LeftLayout.SetSplitRatio(65)
        $this.LeftLayout.ShowBorder = $false
        $this.LeftLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetLeftPane($this.LeftLayout)
        
        # Right side: Vertical split
        $this.RightLayout = [VerticalSplit]::new()
        $this.RightLayout.SetSplitRatio(75)
        $this.RightLayout.ShowBorder = $false
        $this.RightLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetRightPane($this.RightLayout)
    }
    
    [void] BuildLeftPane() {
        # Project List with progress bar overlay
        $projectContainer = [VerticalSplit]::new()
        $projectContainer.SetSplitRatio(85)  # 85% list, 15% progress
        $projectContainer.ShowBorder = $false
        $projectContainer.Initialize($global:ServiceContainer)
        
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = " Project Overview"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.Initialize($global:ServiceContainer)
        $projectContainer.SetTopPane($this.ProjectList)
        
        $this.ProjectProgress = [ProgressBar]::new()
        $this.ProjectProgress.Title = "Loading Projects..."
        $this.ProjectProgress.ShowBorder = $false
        $this.ProjectProgress.Height = 3
        $this.ProjectProgress.Initialize($global:ServiceContainer)
        $projectContainer.SetBottomPane($this.ProjectProgress)
        
        $this.LeftLayout.SetTopPane($projectContainer)
        
        # Recent Activity with progress bar
        $activityContainer = [VerticalSplit]::new()
        $activityContainer.SetSplitRatio(80)  # 80% list, 20% progress
        $activityContainer.ShowBorder = $false
        $activityContainer.Initialize($global:ServiceContainer)
        
        $this.RecentActivity = [ListBox]::new()
        $this.RecentActivity.Title = " Recent Activity"
        $this.RecentActivity.ShowBorder = $true
        $this.RecentActivity.Initialize($global:ServiceContainer)
        $activityContainer.SetTopPane($this.RecentActivity)
        
        $this.ActivityProgress = [ProgressBar]::new()
        $this.ActivityProgress.Title = "Loading Activity..."
        $this.ActivityProgress.ShowBorder = $false
        $this.ActivityProgress.Height = 3
        $this.ActivityProgress.Initialize($global:ServiceContainer)
        $activityContainer.SetBottomPane($this.ActivityProgress)
        
        $this.LeftLayout.SetBottomPane($activityContainer)
    }
    
    [void] BuildRightPane() {
        # Top-right: Metrics layout
        $this.TopRightLayout = [HorizontalSplit]::new()
        $this.TopRightLayout.SetSplitRatio(50)
        $this.TopRightLayout.ShowBorder = $false
        $this.TopRightLayout.Initialize($global:ServiceContainer)
        
        # Task metrics with progress
        $taskContainer = [VerticalSplit]::new()
        $taskContainer.SetSplitRatio(85)
        $taskContainer.ShowBorder = $false
        $taskContainer.Initialize($global:ServiceContainer)
        
        $this.MetricsLayout = [VerticalSplit]::new()
        $this.MetricsLayout.SetSplitRatio(50)
        $this.MetricsLayout.ShowBorder = $false
        $this.MetricsLayout.Initialize($global:ServiceContainer)
        
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = " Active Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetTopPane($this.TaskList)
        
        $this.PriorityBreakdown = [ListBox]::new()
        $this.PriorityBreakdown.Title = " Priority Distribution"
        $this.PriorityBreakdown.ShowBorder = $true
        $this.PriorityBreakdown.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetBottomPane($this.PriorityBreakdown)
        
        $taskContainer.SetTopPane($this.MetricsLayout)
        
        $this.TaskProgress = [ProgressBar]::new()
        $this.TaskProgress.Title = "Loading Tasks..."
        $this.TaskProgress.ShowBorder = $false
        $this.TaskProgress.Height = 3
        $this.TaskProgress.Initialize($global:ServiceContainer)
        $taskContainer.SetBottomPane($this.TaskProgress)
        
        $this.TopRightLayout.SetLeftPane($taskContainer)
        
        # Status chart with progress
        $statusContainer = [VerticalSplit]::new()
        $statusContainer.SetSplitRatio(85)
        $statusContainer.ShowBorder = $false
        $statusContainer.Initialize($global:ServiceContainer)
        
        $this.StatusChart = [ListBox]::new()
        $this.StatusChart.Title = " Status Overview"
        $this.StatusChart.ShowBorder = $true
        $this.StatusChart.Initialize($global:ServiceContainer)
        $statusContainer.SetTopPane($this.StatusChart)
        
        $this.MetricsProgress = [ProgressBar]::new()
        $this.MetricsProgress.Title = "Calculating Metrics..."
        $this.MetricsProgress.ShowBorder = $false
        $this.MetricsProgress.Height = 3
        $this.MetricsProgress.Initialize($global:ServiceContainer)
        $statusContainer.SetBottomPane($this.MetricsProgress)
        
        $this.TopRightLayout.SetRightPane($statusContainer)
        
        $this.RightLayout.SetTopPane($this.TopRightLayout)
        
        # Action buttons (same as original)
        $this.ActionGrid = [GridPanel]::new(4)
        $this.ActionGrid.ShowBorder = $true
        $this.ActionGrid.CellSpacing = 1
        $this.ActionGrid.Initialize($global:ServiceContainer)
        $this.CreateActionButtons()
        $this.RightLayout.SetBottomPane($this.ActionGrid)
    }
    
    [void] CreateActionButtons() {
        # Create refresh button with async behavior
        $this.RefreshBtn = [Button]::new(" Refresh")
        $dashboardRef = $this
        $this.RefreshBtn.OnClick = { 
            Write-Host "Starting async refresh..."
            $dashboardRef.StartAsyncDataLoad()
        }.GetNewClosure()
        $this.RefreshBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.RefreshBtn)
        
        # Add other buttons...
        $otherButtons = @(
            [Button]::new(" New Project"),
            [Button]::new(" New Task"),
            [Button]::new(" Export"),
            [Button]::new("  Settings"),
            [Button]::new(" Help"),
            [Button]::new(" Reports"),
            [Button]::new(" Archive")
        )
        
        foreach ($btn in $otherButtons) {
            $btn.Initialize($global:ServiceContainer)
            $this.ActionGrid.AddChild($btn)
        }
    }
    
    [void] ShowLoadingState() {
        # Show loading placeholders
        $this.ProjectList.SetItems(@(" Loading projects..."))
        $this.TaskList.SetItems(@(" Loading tasks..."))
        $this.RecentActivity.SetItems(@(" Loading activity..."))
        $this.PriorityBreakdown.SetItems(@(" Calculating..."))
        $this.StatusChart.SetItems(@(" Analyzing..."))
        
        # Initialize progress bars
        $this.ProjectProgress.SetProgress(0, "Connecting to project service...")
        $this.TaskProgress.SetProgress(0, "Connecting to task service...")
        $this.ActivityProgress.SetProgress(0, "Loading recent activity...")
        $this.MetricsProgress.SetProgress(0, "Preparing metrics...")
    }
    
    [void] StartAsyncDataLoad() {
        if ($this._isLoading) {
            Write-Host "Data load already in progress"
            return
        }
        
        $this._isLoading = $true
        $this.ShowLoadingState()
        
        # Simulate async loading with runspaces
        $runspace = [runspacefactory]::CreateRunspace()
        $runspace.Open()
        $runspace.SessionStateProxy.SetVariable('EventBus', $this.EventBus)
        $runspace.SessionStateProxy.SetVariable('ProjectService', $this.ProjectService)
        $runspace.SessionStateProxy.SetVariable('TaskService', $this.TaskService)
        
        $powershell = [powershell]::Create()
        $powershell.Runspace = $runspace
        
        $script = {
            param($EventBus, $ProjectService, $TaskService)
            
            try {
                # Load projects
                $EventBus.Publish('dashboard.progress.projects', @{ Progress = 10; Status = "Fetching project list..." })
                Start-Sleep -Milliseconds 500
                
                $projects = if ($ProjectService) {
                    $ProjectService.GetAllProjects() | Where-Object { -not $_.Deleted }
                } else {
                    @(
                        @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                        @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                    )
                }
                
                $EventBus.Publish('dashboard.progress.projects', @{ Progress = 50; Status = "Processing $($projects.Count) projects..." })
                Start-Sleep -Milliseconds 300
                
                # Add computed fields
                foreach ($project in $projects) {
                    $project.DaysLeft = ($project.DateDue - [DateTime]::Now).Days
                    Start-Sleep -Milliseconds 100
                }
                
                $EventBus.Publish('dashboard.progress.projects', @{ Progress = 100; Status = "Projects loaded!" })
                $EventBus.Publish('dashboard.data.projects', @{ Projects = $projects })
                
                # Load tasks
                $EventBus.Publish('dashboard.progress.tasks', @{ Progress = 20; Status = "Querying task database..." })
                Start-Sleep -Milliseconds 400
                
                $tasks = if ($TaskService) {
                    $TaskService.GetAllTasks()
                } else {
                    @(
                        @{ Title = "Implement async loading"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                        @{ Title = "Add progress indicators"; Priority = "High"; Status = "Done"; Progress = 100 }
                        @{ Title = "Test performance"; Priority = "Medium"; Status = "Pending"; Progress = 0 }
                    )
                }
                
                $EventBus.Publish('dashboard.progress.tasks', @{ Progress = 60; Status = "Processing $($tasks.Count) tasks..." })
                Start-Sleep -Milliseconds 300
                
                $EventBus.Publish('dashboard.progress.tasks', @{ Progress = 100; Status = "Tasks loaded!" })
                $EventBus.Publish('dashboard.data.tasks', @{ Tasks = $tasks })
                
                # Load activity
                $EventBus.Publish('dashboard.progress.activity', @{ Progress = 30; Status = "Fetching activity log..." })
                Start-Sleep -Milliseconds 600
                
                $activities = @(
                    @{ Type = "TaskCompleted"; Message = "Async loading implemented"; Time = "Just now" }
                    @{ Type = "ProjectCreated"; Message = "Started performance project"; Time = "5 min ago" }
                    @{ Type = "TaskCreated"; Message = "Added progress indicators"; Time = "1 hour ago" }
                )
                
                $EventBus.Publish('dashboard.progress.activity', @{ Progress = 100; Status = "Activity loaded!" })
                $EventBus.Publish('dashboard.data.activity', @{ Activities = $activities })
                
                # Calculate metrics
                $EventBus.Publish('dashboard.progress.metrics', @{ Progress = 40; Status = "Analyzing data..." })
                Start-Sleep -Milliseconds 800
                
                $metrics = @{
                    PriorityStats = @("High: 3", "Medium: 2", "Low: 1")
                    StatusData = @("Completion: 85%", "Active: 3", "Blocked: 0")
                }
                
                $EventBus.Publish('dashboard.progress.metrics', @{ Progress = 100; Status = "Analysis complete!" })
                $EventBus.Publish('dashboard.data.metrics', @{ Metrics = $metrics })
                
            } catch {
                Write-Host "Error in async load: $_"
            }
        }
        
        $powershell.AddScript($script)
        $powershell.AddArgument($this.EventBus)
        $powershell.AddArgument($this.ProjectService)
        $powershell.AddArgument($this.TaskService)
        
        # Start async execution
        $handle = $powershell.BeginInvoke()
        
        # Store handle for cleanup
        $this._loadingTasks.Add("main-load")
    }
    
    [void] OnProjectsLoaded($projects) {
        # Update project list with loaded data
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "" } else { "" }
            $urgency = if ($project.DaysLeft -lt 0) { " OVERDUE" } 
                      elseif ($project.DaysLeft -lt 7) { "  DUE SOON" } 
                      else { " $($project.DaysLeft) days" }
            return "$status $($project.Nickname) - $urgency"
        }
        $this.ProjectList.SetItems($projects)
        $this.ProjectProgress.SetProgress(100, " Projects loaded")
    }
    
    [void] OnTasksLoaded($tasks) {
        # Update task list
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "" }; "Medium" { "" }; default { "" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "" }; "Done" { "" }; default { "" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        $activeTasks = $tasks | Where-Object { $_.Status -ne "Done" }
        $this.TaskList.SetItems($activeTasks)
        $this.TaskProgress.SetProgress(100, " Tasks loaded")
        
        # Update priority breakdown
        $highCount = @($tasks | Where-Object { $_.Priority -eq 'High' }).Count
        $medCount = @($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count
        $lowCount = @($tasks | Where-Object { $_.Priority -eq 'Low' }).Count
        
        $this.PriorityBreakdown.SetItems(@(
            " High Priority: $highCount tasks",
            " Medium Priority: $medCount tasks",
            " Low Priority: $lowCount tasks"
        ))
    }
    
    [void] OnActivityLoaded($activities) {
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "TaskCompleted" { "" }; "ProjectCreated" { "" }; default { "" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
        $this.RecentActivity.SetItems($activities)
        $this.ActivityProgress.SetProgress(100, " Activity loaded")
    }
    
    [void] OnMetricsLoaded($metrics) {
        $this.StatusChart.SetItems($metrics.StatusData)
        $this.MetricsProgress.SetProgress(100, " Analysis complete")
        $this._isLoading = $false
    }
    
    [void] OnBoundsChanged() {
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::F5) {
                $this.StartAsyncDataLoad()
                return $true
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        return ([Screen]$this).HandleInput($key)
    }
}

# Create and run the test
Write-Host "Starting async dashboard demo..." -ForegroundColor Cyan
Write-Host "The dashboard will load immediately with progress indicators" -ForegroundColor Yellow
Write-Host "Data will load in the background without blocking the UI" -ForegroundColor Yellow
Write-Host ""
Write-Host "Press F5 to refresh data, Q to quit" -ForegroundColor Green
Write-Host ""

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$vt = [VT100]::new()
$global:ServiceContainer.RegisterService('VT100', $vt)

$logger = [Logger]::new("$PSScriptRoot/_Logs/async-dashboard.log")
$global:ServiceContainer.RegisterService('Logger', $logger)
$global:Logger = $logger

$theme = [ThemeManager]::new()
$theme.LoadTheme('Dark')
$global:ServiceContainer.RegisterService('ThemeManager', $theme)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.RegisterService('EventBus', $eventBus)

$projectService = [ProjectService]::new("$PSScriptRoot/_ProjectData/projects.json")
$global:ServiceContainer.RegisterService('ProjectService', $projectService)

$taskService = [TaskService]::new("$PSScriptRoot/_ProjectData/tasks.json")
$global:ServiceContainer.RegisterService('TaskService', $taskService)

# Create screen manager and run
$screenManager = [ScreenManager]::new()
$screenManager.Initialize($global:ServiceContainer)
$global:ScreenManager = $screenManager

$dashboard = [AsyncDashboardScreen]::new()
$screenManager.Push($dashboard)
$screenManager.Run()

Write-Host "`nAsync dashboard demo completed!" -ForegroundColor Green


####\test-dashboard-simple-async.ps1
#!/usr/bin/env pwsh

# Simple example of background loading with progress indicators
# Uses timers to simulate async data loading without PowerShell jobs

. ./Start.ps1 -NoRun

# Enhanced DashboardScreen with simulated async loading
class SimpleAsyncDashboardScreen : Screen {
    # Layout components
    [HorizontalSplit]$MainLayout
    [VerticalSplit]$LeftLayout
    [ListBox]$ProjectList
    [ListBox]$TaskList
    [ProgressBar]$LoadingProgress
    
    # Services
    [EventBus]$EventBus
    [ThemeManager]$Theme
    
    # Loading state
    hidden [int]$_loadStep = 0
    hidden [bool]$_isLoading = $false
    hidden [hashtable]$_pendingData = @{}
    
    SimpleAsyncDashboardScreen() : base() {
        $this.Title = "Simple Async Dashboard Demo"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        $this.Theme = $global:ServiceContainer.GetService('ThemeManager')
        
        # Build UI
        $this.BuildLayout()
        
        # Show initial loading state
        $this.ShowLoadingState()
        
        # Start simulated async loading
        $this.StartSimulatedAsyncLoad()
    }
    
    [void] BuildLayout() {
        # Main horizontal split
        $this.MainLayout = [HorizontalSplit]::new()
        $this.MainLayout.SetSplitRatio(50)
        $this.MainLayout.ShowBorder = $false
        $this.MainLayout.Initialize($global:ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Left side with progress bar
        $this.LeftLayout = [VerticalSplit]::new()
        $this.LeftLayout.SetSplitRatio(85)  # 85% list, 15% progress
        $this.LeftLayout.ShowBorder = $false
        $this.LeftLayout.Initialize($global:ServiceContainer)
        
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = " Projects"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetTopPane($this.ProjectList)
        
        $this.LoadingProgress = [ProgressBar]::new()
        $this.LoadingProgress.Title = "Loading Data..."
        $this.LoadingProgress.ShowBorder = $true
        $this.LoadingProgress.Height = 5
        $this.LoadingProgress.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetBottomPane($this.LoadingProgress)
        
        $this.MainLayout.SetLeftPane($this.LeftLayout)
        
        # Right side
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = " Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.MainLayout.SetRightPane($this.TaskList)
    }
    
    [void] ShowLoadingState() {
        $this.ProjectList.SetItems(@(
            " Loading projects...",
            "",
            "Please wait while we fetch",
            "your project data..."
        ))
        
        $this.TaskList.SetItems(@(
            " Loading tasks...",
            "",
            "Task data will appear",
            "here shortly..."
        ))
        
        $this.LoadingProgress.SetProgress(0, "Initializing...")
    }
    
    [void] StartSimulatedAsyncLoad() {
        if ($this._isLoading) {
            return
        }
        
        $this._isLoading = $true
        $this._loadStep = 0
        
        # Simulate loading steps with a timer
        $timer = [System.Timers.Timer]::new(500)  # 500ms intervals
        
        $dashboardRef = $this
        $timer.add_Elapsed({
            $dashboardRef.ProcessLoadStep()
        })
        
        $timer.AutoReset = $true
        $timer.Enabled = $true
        $timer.Start()
        
        # Store timer reference for cleanup
        $this._pendingData['timer'] = $timer
    }
    
    [void] ProcessLoadStep() {
        $this._loadStep++
        
        switch ($this._loadStep) {
            1 {
                # Step 1: Connect to services
                $this.LoadingProgress.SetProgress(10, "Connecting to services...")
            }
            2 {
                # Step 2: Fetch project data
                $this.LoadingProgress.SetProgress(25, "Fetching project data...")
            }
            3 {
                # Step 3: Process projects
                $this.LoadingProgress.SetProgress(40, "Processing projects...")
                
                # Simulate project data
                $projects = @(
                    " PRAXIS Framework -  30 days",
                    " Dashboard System -   DUE SOON",
                    " Layout Components -  OVERDUE",
                    " Testing Framework -  45 days"
                )
                $this.ProjectList.SetItems($projects)
            }
            4 {
                # Step 4: Fetch task data
                $this.LoadingProgress.SetProgress(60, "Fetching task data...")
            }
            5 {
                # Step 5: Process tasks
                $this.LoadingProgress.SetProgress(80, "Processing tasks...")
                
                # Simulate task data
                $tasks = @(
                    "  Implement async loading [75%]",
                    "  Fix layout bugs [0%]",
                    "  Add visual styling [25%]",
                    "  Performance optimization [10%]",
                    "  Write documentation [0%]"
                )
                $this.TaskList.SetItems($tasks)
            }
            6 {
                # Step 6: Finalize
                $this.LoadingProgress.SetProgress(100, " Loading complete!")
                
                # Stop and clean up timer
                if ($this._pendingData['timer']) {
                    $this._pendingData['timer'].Stop()
                    $this._pendingData['timer'].Dispose()
                    $this._pendingData.Remove('timer')
                }
                
                $this._isLoading = $false
                
                # Publish completion event
                $this.EventBus.Publish('dashboard.load.complete', @{})
            }
        }
        
        # Force UI update
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::F5) {
                if (-not $this._isLoading) {
                    Write-Host "Refreshing dashboard..."
                    $this.ShowLoadingState()
                    $this.StartSimulatedAsyncLoad()
                }
                return $true
            }
            ([System.ConsoleKey]::Q) {
                # Clean up any active timers
                if ($this._pendingData['timer']) {
                    $this._pendingData['timer'].Stop()
                    $this._pendingData['timer'].Dispose()
                }
                $this.Active = $false
                return $true
            }
        }
        return ([Screen]$this).HandleInput($key)
    }
}

# Initialize and run
Write-Host "Simple Async Dashboard Demo" -ForegroundColor Cyan
Write-Host "============================" -ForegroundColor Cyan
Write-Host ""
Write-Host "This demo shows how background loading with progress indicators" -ForegroundColor Yellow
Write-Host "allows the UI to appear immediately while data loads." -ForegroundColor Yellow
Write-Host ""
Write-Host "Notice how:" -ForegroundColor Green
Write-Host "- The dashboard appears instantly with loading placeholders" -ForegroundColor Green
Write-Host "- Progress bar shows real-time loading status" -ForegroundColor Green
Write-Host "- Data appears progressively as it loads" -ForegroundColor Green
Write-Host "- UI remains responsive during loading" -ForegroundColor Green
Write-Host ""
Write-Host "Press F5 to refresh, Q to quit" -ForegroundColor Cyan
Write-Host ""

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$vt = [VT100]::new()
$global:ServiceContainer.RegisterService('VT100', $vt)

$logger = [Logger]::new("$PSScriptRoot/_Logs/simple-async.log")
$global:ServiceContainer.RegisterService('Logger', $logger)
$global:Logger = $logger

$theme = [ThemeManager]::new()
$theme.LoadTheme('Dark')
$global:ServiceContainer.RegisterService('ThemeManager', $theme)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.RegisterService('EventBus', $eventBus)

# Create and run the dashboard
$screenManager = [ScreenManager]::new()
$screenManager.Initialize($global:ServiceContainer)
$global:ScreenManager = $screenManager

$dashboard = [SimpleAsyncDashboardScreen]::new()
$screenManager.Push($dashboard)
$screenManager.Run()

Write-Host "`nDemo completed!" -ForegroundColor Green


####\test-debug-logging.ps1
#!/usr/bin/env pwsh
# Test debug logging functionality

param(
    [switch]$Debug
)

# Set debug mode FIRST
if ($Debug) {
    $global:PraxisDebug = $true
    Write-Host "Debug mode enabled - global:PraxisDebug = $global:PraxisDebug" -ForegroundColor Green
}

# Set up paths
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load Logger
. ./Services/Logger.ps1

# Create logger and verify debug mode
$logger = [Logger]::new()
Write-Host "`nLogger created:" -ForegroundColor Cyan
Write-Host "  MinimumLevel: $($logger.MinimumLevel)" -ForegroundColor $(if ($logger.MinimumLevel -eq "Debug") { "Green" } else { "Red" })
Write-Host "  LogPath: $($logger.LogPath)" -ForegroundColor Gray

# Test different log levels
Write-Host "`nTesting log levels:" -ForegroundColor Cyan
$logger.Trace("This is a TRACE message - should only appear if level is Trace")
$logger.Debug("This is a DEBUG message - should appear if -Debug flag was used")
$logger.Info("This is an INFO message - should always appear")
$logger.Warning("This is a WARNING message - should always appear")
$logger.Error("This is an ERROR message - should always appear")

# Flush and show log
$logger.Flush()

Write-Host "`nLast 10 lines of log:" -ForegroundColor Cyan
Get-Content $logger.LogPath -Tail 10 | ForEach-Object { 
    if ($_ -match "DEBUG") {
        Write-Host "  $_" -ForegroundColor Green
    } elseif ($_ -match "ERROR") {
        Write-Host "  $_" -ForegroundColor Red
    } elseif ($_ -match "WARNING") {
        Write-Host "  $_" -ForegroundColor Yellow
    } else {
        Write-Host "  $_" -ForegroundColor Gray
    }
}


####\test-debug-shortcuts.ps1
#!/usr/bin/env pwsh
# Debug shortcut issues

Write-Host "`nDebugging Shortcuts and Focus" -ForegroundColor Cyan
Write-Host "=============================" -ForegroundColor Cyan

Write-Host @"
This will show debug output for:
- Shortcut registration/unregistration
- Key handling
- Focus changes

Watch for:
[REG] = Shortcut registered
[UNREG] = Shortcut unregistered  
[DEBUG] = Key press info
[SM] = ShortcutManager processing

Navigate between screens and press 'e' or 'd' to test.
"@ -ForegroundColor Yellow

Write-Host "`nStarting PRAXIS with debug output..." -ForegroundColor Green

# Run PRAXIS
pwsh -File Start.ps1


####\test-direct-shortcut.ps1
#!/usr/bin/env pwsh
# Direct test of shortcut functionality

Write-Host "`nDirect Shortcut Test" -ForegroundColor Cyan

# Clear log
if (Test-Path "_Logs/praxis.log") {
    Clear-Content "_Logs/praxis.log"
}

# Load required files
. ./Core/VT100.ps1
. ./Services/Logger.ps1
. ./Core/ServiceContainer.ps1
. ./Services/ShortcutManager.ps1

# Create logger and container
$global:Logger = [Logger]::new()
$global:ServiceContainer = [ServiceContainer]::new()
$global:ServiceContainer.Register("Logger", $global:Logger)

# Create and initialize ShortcutManager
$sm = [ShortcutManager]::new()
$sm.Initialize($global:ServiceContainer)

Write-Host "ShortcutManager created with $($sm.Shortcuts.Count) default shortcuts" -ForegroundColor Green

# Register a test shortcut
$sm.RegisterShortcut(@{
    Id = "test.edit"
    Name = "Edit"
    Description = "Edit test"
    KeyChar = 'e'
    Scope = [ShortcutScope]::Screen
    ScreenType = "ProjectsScreen"
    Priority = 50
    Action = { Write-Host "EDIT ACTION EXECUTED!" -ForegroundColor Green }
})

Write-Host "Registered test shortcut. Total shortcuts: $($sm.Shortcuts.Count)" -ForegroundColor Yellow

# List all shortcuts
Write-Host "`nAll shortcuts:" -ForegroundColor Cyan
foreach ($s in $sm.Shortcuts) {
    $key = if ($s.KeyChar -ne [char]0) { "Char='$($s.KeyChar)'" } else { "Key=$($s.Key)" }
    Write-Host "  $($s.Id): $key Screen=$($s.ScreenType) Scope=$($s.Scope)" -ForegroundColor Gray
}

# Test key press
Write-Host "`nTesting key press 'e' on ProjectsScreen..." -ForegroundColor Yellow
$keyE = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
$handled = $sm.HandleKeyPress($keyE, "ProjectsScreen", "")
Write-Host "Handled: $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })

Write-Host "`nCheck _Logs/praxis.log for debug output" -ForegroundColor Cyan


####\test-direct-shortcut2.ps1
#!/usr/bin/env pwsh
# Direct test of shortcut functionality - complete

Write-Host "`nDirect Shortcut Test" -ForegroundColor Cyan

# Clear log
if (Test-Path "_Logs/praxis.log") {
    Clear-Content "_Logs/praxis.log"
}

# Load ALL required files in correct order
. ./Core/VT100.ps1
. ./Services/Logger.ps1
. ./Core/ServiceContainer.ps1
. ./Services/EventBus.ps1  # EventBus must be loaded before ShortcutManager
. ./Services/ShortcutManager.ps1

# Create logger and container
$global:Logger = [Logger]::new()
$global:ServiceContainer = [ServiceContainer]::new()
$global:ServiceContainer.Register("Logger", $global:Logger)

# Create EventBus
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# Create and initialize ShortcutManager
$sm = [ShortcutManager]::new()
$sm.Initialize($global:ServiceContainer)

Write-Host "ShortcutManager created with $($sm.Shortcuts.Count) default shortcuts" -ForegroundColor Green

# List default shortcuts first
Write-Host "`nDefault shortcuts:" -ForegroundColor Cyan
foreach ($s in $sm.Shortcuts) {
    $key = if ($s.KeyChar -ne [char]0) { "Char='$($s.KeyChar)'" } else { "Key=$($s.Key)" }
    Write-Host "  $($s.Id): $key Screen=$($s.ScreenType) Scope=$($s.Scope)" -ForegroundColor Gray
}

# Register a test shortcut
Write-Host "`nRegistering test shortcut for 'e' key..." -ForegroundColor Yellow
$sm.RegisterShortcut(@{
    Id = "test.edit"
    Name = "Edit"
    Description = "Edit test"
    KeyChar = 'e'
    Scope = [ShortcutScope]::Screen
    ScreenType = "ProjectsScreen"
    Priority = 50
    Action = { Write-Host "EDIT ACTION EXECUTED!" -ForegroundColor Green }
})

Write-Host "Total shortcuts after registration: $($sm.Shortcuts.Count)" -ForegroundColor Green

# Test key press
Write-Host "`nTesting key press 'e' on ProjectsScreen..." -ForegroundColor Yellow
$keyE = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)

# Check matches manually
Write-Host "`nChecking matches for 'e' key:" -ForegroundColor Cyan
foreach ($s in $sm.Shortcuts) {
    if ($s.KeyChar -eq 'e' -or $s.KeyChar -eq 'E') {
        $matches = $s.Matches($keyE)
        Write-Host "  $($s.Id): KeyChar='$($s.KeyChar)' Matches=$matches" -ForegroundColor $(if ($matches) { 'Green' } else { 'Red' })
    }
}

$handled = $sm.HandleKeyPress($keyE, "ProjectsScreen", "")
Write-Host "`nHandled: $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })

# Check log
if (Test-Path "_Logs/praxis.log") {
    Write-Host "`nRecent log entries:" -ForegroundColor Cyan
    Get-Content "_Logs/praxis.log" -Tail 20 | ForEach-Object {
        if ($_ -match "ERROR") {
            Write-Host $_ -ForegroundColor Red
        } elseif ($_ -match "DEBUG") {
            Write-Host $_ -ForegroundColor Gray
        } else {
            Write-Host $_ -ForegroundColor White
        }
    }
}


####\test-excel-import.ps1
#!/usr/bin/env pwsh
# Test script to verify Excel import functionality

Write-Host "Testing Excel Import Service..." -ForegroundColor Cyan

# Create a test Excel file with sample data
$excel = New-Object -ComObject Excel.Application
$excel.Visible = $false
$excel.DisplayAlerts = $false

try {
    $workbook = $excel.Workbooks.Add()
    $worksheet = $workbook.Worksheets.Item(1)
    $worksheet.Name = "SVI-CAS"
    
    # Add test data based on changes.txt mappings
    $worksheet.Range("W17").Value2 = "CAS-2024-001"  # CAS Case# (ID2)
    $worksheet.Range("W3").Value2 = "Test Company Inc"  # TP Name
    $worksheet.Range("W4").Value2 = "TC-12345"  # TP Number
    $worksheet.Range("W5").Value2 = "123 Main Street"  # Address
    $worksheet.Range("W6").Value2 = "Toronto"  # City
    $worksheet.Range("W7").Value2 = "ON"  # Province
    $worksheet.Range("W8").Value2 = "M5V 3A8"  # Postal Code
    $worksheet.Range("W9").Value2 = "Canada"  # Country
    $worksheet.Range("W10").Value2 = "John Auditor"  # Auditor Name
    $worksheet.Range("W12").Value2 = "416-555-1234"  # Auditor Phone
    $worksheet.Range("W78").Value2 = "Annual Audit"  # Audit Type
    
    # Save the file
    $testFile = Join-Path $PSScriptRoot "test_import.xlsx"
    $workbook.SaveAs($testFile)
    Write-Host "Created test Excel file: $testFile" -ForegroundColor Green
    
    $workbook.Close($false)
}
finally {
    $excel.Quit()
    [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
    [System.GC]::Collect()
    [System.GC]::WaitForPendingFinalizers()
}

Write-Host "`nTo test the import:" -ForegroundColor Yellow
Write-Host "1. Run Start.ps1"
Write-Host "2. Press Ctrl+I to open Excel Import"
Write-Host "3. Select test_import.xlsx"
Write-Host "4. Click Import"


####\test-filebrowser-focus.ps1
#!/usr/bin/env pwsh
# Test FileBrowser focus behavior

param(
    [switch]$Debug
)

# Set debug mode
if ($Debug) {
    $global:PraxisDebug = $true
}

# Set up paths
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load required files
. ./Core/ServiceContainer.ps1
. ./Core/VT100.ps1
. ./Services/Logger.ps1
. ./Services/ThemeManager.ps1
. ./Base/UIElement.ps1
. ./Base/Container.ps1
. ./Base/Screen.ps1
. ./Components/FastFileTree.ps1
. ./Screens/FileBrowserScreen.ps1

# Create services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)
$theme = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $theme)

Write-Host "Testing FileBrowser Focus..." -ForegroundColor Cyan

# Create FileBrowserScreen
$screen = [FileBrowserScreen]::new()
$screen.Initialize($global:ServiceContainer)
$screen.SetBounds(0, 0, 80, 25)

Write-Host "`nScreen created and initialized" -ForegroundColor Green
Write-Host "FileTree exists: $($screen.FileTree -ne $null)" -ForegroundColor Gray
Write-Host "FileTree IsFocusable: $($screen.FileTree.IsFocusable)" -ForegroundColor Gray
Write-Host "FileTree HasFocus: $($screen.FileTree.HasFocus)" -ForegroundColor Gray

# Activate the screen
Write-Host "`nActivating screen..." -ForegroundColor Cyan
$screen.OnActivated()

Write-Host "After activation:" -ForegroundColor Green
Write-Host "FileTree HasFocus: $($screen.FileTree.HasFocus)" -ForegroundColor Gray

# Find what has focus
$focused = $screen.FindFocused()
if ($focused) {
    Write-Host "Focused element: $($focused.GetType().Name)" -ForegroundColor Green
} else {
    Write-Host "No element has focus!" -ForegroundColor Red
}

# Try to manually focus the FileTree
Write-Host "`nManually focusing FileTree..." -ForegroundColor Cyan
$screen.FileTree.Focus()
Write-Host "FileTree HasFocus: $($screen.FileTree.HasFocus)" -ForegroundColor Gray

# Test input handling
Write-Host "`nTesting input handling..." -ForegroundColor Cyan
$downKey = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::DownArrow, $false, $false, $false)
$handled = $screen.FileTree.HandleInput($downKey)
Write-Host "Down arrow handled: $handled" -ForegroundColor Gray

# Check the full focus chain
Write-Host "`nChecking focus chain:" -ForegroundColor Cyan
$current = $screen
$level = 0
while ($current) {
    $indent = "  " * $level
    Write-Host "$indent$($current.GetType().Name) - HasFocus: $($current.HasFocus)" -ForegroundColor Gray
    if ($current -is [Container]) {
        foreach ($child in $current.Children) {
            $childIndent = "  " * ($level + 1)
            Write-Host "$childIndent$($child.GetType().Name) - HasFocus: $($child.HasFocus), IsFocusable: $($child.IsFocusable)" -ForegroundColor DarkGray
        }
    }
    break
}

# Flush logger
$logger.Flush()

Write-Host "`nCheck log for details: $($logger.LogPath)" -ForegroundColor Cyan


####\test-filebrowser-navigation.ps1
#!/usr/bin/env pwsh
# Test file browser navigation specifically

# Load required files
$loadOrder = @(
    "Core/VT100.ps1", "Core/ServiceContainer.ps1", "Services/Logger.ps1", 
    "Services/EventBus.ps1", "Services/ThemeManager.ps1", "Base/UIElement.ps1",
    "Base/Container.ps1", "Base/Screen.ps1", "Core/ScreenManager.ps1", 
    "Screens/FileBrowserScreen.ps1"
)

foreach ($file in $loadOrder) {
    . (Join-Path $PSScriptRoot $file)
}

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)
$themeManager.SetEventBus($eventBus)
$screenManager = [ScreenManager]::new($global:ServiceContainer)
$global:ServiceContainer.Register("ScreenManager", $screenManager)

# Create file browser and test navigation
$fileBrowser = [FileBrowserScreen]::new()

Write-Host "Testing File Browser Navigation..." -ForegroundColor Green

# Test initial state
Write-Host "`nInitial State:" -ForegroundColor Yellow
Write-Host "  FocusedPanel: $($fileBrowser.FocusedPanel)" -ForegroundColor Cyan
Write-Host "  Parent Index: $($fileBrowser.ParentSelectedIndex)" -ForegroundColor Cyan
Write-Host "  Current Index: $($fileBrowser.SelectedIndex)" -ForegroundColor Cyan
Write-Host "  Preview Index: $($fileBrowser.PreviewSelectedIndex)" -ForegroundColor Cyan

# Test navigation left
Write-Host "`nTesting NavigateLeft()..." -ForegroundColor Yellow
$fileBrowser.NavigateLeft()
Write-Host "  FocusedPanel after left: $($fileBrowser.FocusedPanel)" -ForegroundColor Cyan

# Test navigation right  
Write-Host "`nTesting NavigateRight()..." -ForegroundColor Yellow
$fileBrowser.NavigateRight()
Write-Host "  FocusedPanel after right: $($fileBrowser.FocusedPanel)" -ForegroundColor Cyan
$fileBrowser.NavigateRight()
Write-Host "  FocusedPanel after right again: $($fileBrowser.FocusedPanel)" -ForegroundColor Cyan

# Test up/down navigation in different panels
Write-Host "`nTesting up/down navigation..." -ForegroundColor Yellow

# Focus on current panel (1)
$fileBrowser.FocusedPanel = 1
$fileBrowser.NavigateDown()
Write-Host "  Current panel down: Index=$($fileBrowser.SelectedIndex)" -ForegroundColor Cyan

# Focus on parent panel (0)  
$fileBrowser.FocusedPanel = 0
$fileBrowser.NavigateDown()
Write-Host "  Parent panel down: Index=$($fileBrowser.ParentSelectedIndex)" -ForegroundColor Cyan

# Focus on preview panel (2)
$fileBrowser.FocusedPanel = 2  
$fileBrowser.NavigateDown()
Write-Host "  Preview panel down: Index=$($fileBrowser.PreviewSelectedIndex)" -ForegroundColor Cyan

Write-Host "`n Navigation tests completed!" -ForegroundColor Green
Write-Host " All panels now support independent up/down navigation!" -ForegroundColor Green


####\test-fixed-tab-switching.ps1
#!/usr/bin/env pwsh
# Test the fixed tab switching from any screen

Write-Host "=== Testing Fixed Tab Switching ===" -ForegroundColor Cyan
Write-Host "This test will verify that number keys work for tab switching from any screen." -ForegroundColor Yellow
Write-Host ""
Write-Host "Instructions:" -ForegroundColor Yellow
Write-Host "1. App will start on Projects tab (tab 1)"
Write-Host "2. Press '2' to switch to Tasks tab"
Write-Host "3. Press '3' to switch to Files tab"  
Write-Host "4. Press '4' to switch to Editor tab"
Write-Host "5. Press ESC to enter command mode in editor"
Write-Host "6. Press '1' to switch back to Projects tab"
Write-Host "7. Press Q to quit"
Write-Host ""
Write-Host "If the fix works, you should be able to switch tabs from ANY screen using 1-5 keys." -ForegroundColor Green
Write-Host ""
Write-Host "Starting PRAXIS..." -ForegroundColor Green

# Start PRAXIS
pwsh -File Start.ps1


####\test-fixes.ps1
#!/usr/bin/env pwsh
# Quick test of file browser and text editor fixes

Write-Host "Testing PRAXIS file browser and text editor fixes..." -ForegroundColor Green

# Test loading order
Write-Host "`n1. Loading Components..." -ForegroundColor Yellow
$loadOrder = @(
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    "Core/ScreenManager.ps1"
    "Screens/FileBrowserScreen.ps1"
    "Screens/TextEditorScreen.ps1"
)

foreach ($file in $loadOrder) {
    $path = Join-Path $PSScriptRoot $file
    if (Test-Path $path) {
        try {
            . $path
            Write-Host "   $file" -ForegroundColor Green
        } catch {
            Write-Host "   $file - $_" -ForegroundColor Red
        }
    } else {
        Write-Host "   $file - Not found" -ForegroundColor Red
    }
}

Write-Host "`n2. Testing Class Creation..." -ForegroundColor Yellow
try {
    $fileBrowser = [FileBrowserScreen]::new()
    Write-Host "   FileBrowserScreen created successfully" -ForegroundColor Green
    
    # Test navigation indices
    Write-Host "   Navigation indices: Parent=$($fileBrowser.ParentSelectedIndex), Current=$($fileBrowser.SelectedIndex), Preview=$($fileBrowser.PreviewSelectedIndex)" -ForegroundColor Green
} catch {
    Write-Host "   FileBrowserScreen creation failed: $_" -ForegroundColor Red
}

try {
    $textEditor = [TextEditorScreen]::new()
    Write-Host "   TextEditorScreen created successfully" -ForegroundColor Green
} catch {
    Write-Host "   TextEditorScreen creation failed: $_" -ForegroundColor Red
}

Write-Host "`n3. Integration Summary:" -ForegroundColor Yellow
Write-Host "   File browser left/right pane navigation fixed" -ForegroundColor Green
Write-Host "   File browser flickering reduced with render caching" -ForegroundColor Green  
Write-Host "   Text editor now shows as 'Editor' tab (tab 5)" -ForegroundColor Green
Write-Host "   Command palette updated with correct tab indices" -ForegroundColor Green

Write-Host "`n4. Tab Layout:" -ForegroundColor Yellow
Write-Host "  1. Projects" -ForegroundColor Cyan
Write-Host "  2. Tasks" -ForegroundColor Cyan  
Write-Host "  3. Dashboard" -ForegroundColor Cyan
Write-Host "  4. Files (file browser)" -ForegroundColor Cyan
Write-Host "  5. Editor (text editor)" -ForegroundColor Cyan
Write-Host "  6. Settings" -ForegroundColor Cyan

Write-Host "`n All fixes validated!" -ForegroundColor Green


####\test-focus-debug.ps1
#!/usr/bin/env pwsh
# Debug focus and shortcuts

Write-Host "=== Testing Focus and Shortcuts ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "Tests to perform:" -ForegroundColor Yellow
Write-Host "1. Press 1 - Go to Projects tab" -ForegroundColor Yellow
Write-Host "2. Press n - Should open New Project dialog" -ForegroundColor Yellow
Write-Host "3. Press 3 - Go to Files tab (was 4, now 3 without Dashboard)" -ForegroundColor Yellow
Write-Host "4. Check if Files tab shows blue border when focused" -ForegroundColor Yellow
Write-Host "5. Use arrow keys in Files tab" -ForegroundColor Yellow
Write-Host ""

# Clear log
"" > _Logs/praxis.log

# Start PRAXIS
pwsh -File Start.ps1

Write-Host ""
Write-Host "=== Focus Debug Info ===" -ForegroundColor Cyan
Get-Content _Logs/praxis.log | Select-String -Pattern "Focus|HandleScreenInput|Screen shortcuts|FileBrowser.*activated|FastFileTree.*focus" | Select-Object -Last 30


####\test-integration.ps1
#!/usr/bin/env pwsh
# Integration test to verify the new features work in PRAXIS

Write-Host "PRAXIS Integration Test Summary" -ForegroundColor Cyan
Write-Host "===============================" -ForegroundColor Cyan

Write-Host "`n1. Excel Import Feature (Ctrl+I):" -ForegroundColor Yellow
Write-Host "   - ExcelImportService created with 48 field mappings from changes.txt"
Write-Host "   - Maps Excel cells to Project model fields"
Write-Host "   - Critical field: CAS Case# (W17)  ID2"
Write-Host "   - UI: ExcelImportScreen with FastFileTree for file selection"

Write-Host "`n2. Time Tracking System (Ctrl+T):" -ForegroundColor Yellow
Write-Host "   - Universal format: Name | ID1 | ID2 | Mon-Fri hours"
Write-Host "   - Tracks both project ID2s and non-project codes (3-5 chars)"
Write-Host "   - Week identified by Friday date"
Write-Host "   - Fiscal year: April 1 - March 31"
Write-Host "   - Non-project codes reset each fiscal year"
Write-Host "   - Quick entry with 'Q' key in TimeEntryScreen"

Write-Host "`n3. Enhanced Project Screens:" -ForegroundColor Yellow
Write-Host "   - ProjectsScreen: Converted to DataGrid with columns:"
Write-Host "     Status | Name | ID1 | ID2 | Client | Assigned | Due | Due In"
Write-Host "   - ProjectDetailScreen: Shows all Excel import fields"
Write-Host "   - Improved readability and organization"

Write-Host "`n4. Test Results:" -ForegroundColor Green
Write-Host "    Time entry models working correctly"
Write-Host "    Fiscal year calculations accurate"
Write-Host "    Excel import service configured"
Write-Host "    DataGrid component functional"
Write-Host "    All dialogs created successfully"

Write-Host "`nTo use the new features:" -ForegroundColor Cyan
Write-Host "   1. Run: pwsh -File Start.ps1"
Write-Host "   2. Press Ctrl+I to import Excel files"
Write-Host "   3. Press Ctrl+T for time tracking"
Write-Host "   4. View enhanced project list in tab 1"


####\test-manual-input.ps1
#!/usr/bin/env pwsh
# Manual test to debug tab switching

Write-Host "=== Manual Input Debug Test ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "This will start PRAXIS with detailed debug logging."
Write-Host "Focus on testing:"  
Write-Host "1. App starts on Projects tab (should show '1:Projects' highlighted)" -ForegroundColor Yellow
Write-Host "2. Press '2' - does the tab highlight move to '2:Tasks'?" -ForegroundColor Yellow
Write-Host "3. Press '3' - does it switch to Files?" -ForegroundColor Yellow
Write-Host "4. Press 'q' to quit cleanly" -ForegroundColor Yellow
Write-Host ""
Write-Host "Watch the terminal carefully for ANY visual changes when pressing 2 or 3." -ForegroundColor Red
Write-Host ""

# Clear the log first
Clear-Content _Logs/praxis.log -ErrorAction SilentlyContinue

# Start PRAXIS with debug logging
Write-Host "Starting PRAXIS with debug logging..." -ForegroundColor Green
pwsh -File Start.ps1 -Debug

Write-Host ""
Write-Host "=== Post-Test Log Analysis ===" -ForegroundColor Cyan

# Look for key press events
Write-Host ""
Write-Host "Key press events found:" -ForegroundColor Yellow
grep "Key pressed:\|ScreenManager.ProcessInput\|HandleInput" _Logs/praxis.log | tail -10

# Look for ShortcutManager activity
Write-Host ""
Write-Host "ShortcutManager activity:" -ForegroundColor Yellow
grep "ShortcutManager" _Logs/praxis.log | tail -5

# Look for TabContainer activity
Write-Host ""
Write-Host "TabContainer activity:" -ForegroundColor Yellow
grep "TabContainer\|ActivateTab\|tab.*switch" _Logs/praxis.log | tail -5


####\test-minimal-shortcut.ps1
#!/usr/bin/env pwsh
# Minimal test to verify shortcut system

Write-Host "Loading PRAXIS components..." -ForegroundColor Cyan

# Load required files
. ./Core/VT100.ps1
. ./Core/ServiceContainer.ps1  
. ./Services/Logger.ps1
. ./Services/EventBus.ps1
. ./Services/ShortcutManager.ps1

# Create services
$global:ServiceContainer = [ServiceContainer]::new()
$global:Logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $global:Logger)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# Create ShortcutManager
$sm = [ShortcutManager]::new()
$sm.Initialize($global:ServiceContainer)

Write-Host "`nInitial shortcuts: $($sm.Shortcuts.Count)" -ForegroundColor Green

# Register a test shortcut
$sm.RegisterShortcut(@{
    Id = "test.edit"
    Name = "Edit" 
    Description = "Test edit"
    KeyChar = 'e'
    Scope = [ShortcutScope]::Screen
    ScreenType = "ProjectsScreen"
    Priority = 50
    Action = { Write-Host "EDIT ACTION EXECUTED!" -ForegroundColor Green -BackgroundColor DarkGreen }
})

Write-Host "After registration: $($sm.Shortcuts.Count) shortcuts" -ForegroundColor Green

# List all shortcuts
Write-Host "`nAll shortcuts:" -ForegroundColor Cyan
foreach ($s in $sm.Shortcuts) {
    $keyStr = if ($s.KeyChar -ne [char]0) { "Char='$($s.KeyChar)'" } else { "Key=$($s.Key)" }
    Write-Host "  $($s.Id): $keyStr Screen=$($s.ScreenType) Scope=$($s.Scope)" -ForegroundColor Gray
}

# Test key press
Write-Host "`nTesting 'e' key on ProjectsScreen..." -ForegroundColor Yellow
$keyE = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
$handled = $sm.HandleKeyPress($keyE, "ProjectsScreen", "")

Write-Host "`nResult: Handled = $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })

# Now test unregister/re-register
Write-Host "`nTesting unregister/re-register cycle..." -ForegroundColor Yellow
$sm.UnregisterShortcut("test.edit")
Write-Host "After unregister: $($sm.Shortcuts.Count) shortcuts" -ForegroundColor Gray

# Re-register
$sm.RegisterShortcut(@{
    Id = "test.edit"
    Name = "Edit"
    Description = "Test edit" 
    KeyChar = 'e'
    Scope = [ShortcutScope]::Screen
    ScreenType = "ProjectsScreen"
    Priority = 50
    Action = { Write-Host "EDIT ACTION EXECUTED AGAIN!" -ForegroundColor Green -BackgroundColor DarkGreen }
})

Write-Host "After re-register: $($sm.Shortcuts.Count) shortcuts" -ForegroundColor Gray

# Test again
Write-Host "`nTesting 'e' key again..." -ForegroundColor Yellow
$handled = $sm.HandleKeyPress($keyE, "ProjectsScreen", "")
Write-Host "Result: Handled = $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })


####\test-praxis-shortcuts.ps1
#!/usr/bin/env pwsh
# Test PRAXIS with shortcut debugging

param(
    [switch]$MonitorOnly
)

if (-not $MonitorOnly) {
    Write-Host "`nPRAXIS Shortcut Test" -ForegroundColor Cyan
    Write-Host "===================" -ForegroundColor Cyan
    Write-Host @"
This test will:
1. Clear the log
2. Start PRAXIS in debug mode  
3. Monitor shortcut-related log entries

Instructions:
- Navigate to Projects screen (1)
- Press 'e' or 'd' 
- Watch for debug output

"@ -ForegroundColor Yellow

    # Clear log
    if (Test-Path "_Logs/praxis.log") {
        Clear-Content "_Logs/praxis.log"
        Write-Host "Log cleared" -ForegroundColor Green
    }

    # Start monitoring in separate window
    Start-Process pwsh -ArgumentList "-File", "$PSCommandPath", "-MonitorOnly" -WindowStyle Normal

    # Wait a moment for monitor to start
    Start-Sleep -Seconds 1

    # Start PRAXIS
    Write-Host "Starting PRAXIS..." -ForegroundColor Cyan
    pwsh -File Start.ps1 -Debug
}
else {
    # Monitor mode
    Write-Host "PRAXIS Log Monitor - Shortcuts" -ForegroundColor Cyan
    Write-Host "==============================" -ForegroundColor Cyan
    Write-Host "Monitoring for shortcut activity..." -ForegroundColor Yellow
    Write-Host ""

    try {
        Get-Content "_Logs/praxis.log" -Wait | ForEach-Object {
            # Filter for relevant messages
            if ($_ -match "Shortcut|RegisterShortcuts|UnregisterShortcut|HandleKeyPress|OnActivated|Key pressed" -or
                $_ -match "Key=E|Char='e'|Key=D|Char='d'|Matches|Executing") {
                
                # Color coding
                if ($_ -match "ERROR") {
                    Write-Host $_ -ForegroundColor Red
                }
                elseif ($_ -match "UnregisterShortcut") {
                    Write-Host $_ -ForegroundColor Magenta
                }
                elseif ($_ -match "RegisterShortcuts|Registered shortcut") {
                    Write-Host $_ -ForegroundColor Cyan
                }
                elseif ($_ -match "OnActivated") {
                    Write-Host $_ -ForegroundColor Blue
                }
                elseif ($_ -match "Key pressed|HandleKeyPress|Calling ShortcutManager") {
                    Write-Host $_ -ForegroundColor Yellow
                }
                elseif ($_ -match "Matches|Matched") {
                    Write-Host $_ -ForegroundColor Green
                }
                elseif ($_ -match "Executing shortcut|Key handled by ShortcutManager|EDIT ACTION") {
                    Write-Host $_ -ForegroundColor Green -BackgroundColor DarkGreen
                }
                elseif ($_ -match "NOT handled|Skipped") {
                    Write-Host $_ -ForegroundColor Red
                }
                else {
                    Write-Host $_ -ForegroundColor Gray
                }
            }
        }
    }
    catch {
        Write-Host "Monitor stopped" -ForegroundColor Red
    }
}


####\test-proper-architecture.ps1
#!/usr/bin/env pwsh
# Test the properly architected file browser and text editor

Write-Host "Testing Properly Architected Components..." -ForegroundColor Green

# Load required components for testing
$loadOrder = @(
    "Core/VT100.ps1", "Core/ServiceContainer.ps1", "Services/Logger.ps1", 
    "Services/EventBus.ps1", "Services/ThemeManager.ps1", "Base/UIElement.ps1",
    "Base/Container.ps1", "Base/Screen.ps1", "Core/ScreenManager.ps1", 
    "Components/FastFileTree.ps1", "Screens/FileBrowserScreen.ps1", "Screens/TextEditorScreen.ps1"
)

foreach ($file in $loadOrder) {
    . (Join-Path $PSScriptRoot $file)
}

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)
$themeManager.SetEventBus($eventBus)

Write-Host "`n1. Testing FileBrowserScreen Architecture..." -ForegroundColor Yellow
try {
    $fileBrowser = [FileBrowserScreen]::new()
    $fileBrowser.Initialize($global:ServiceContainer)
    
    Write-Host "   FileBrowserScreen created and initialized" -ForegroundColor Green
    Write-Host "   Uses FastFileTree component properly" -ForegroundColor Green
    Write-Host "   No OnRender override - uses proper PRAXIS architecture" -ForegroundColor Green
    Write-Host "   HandleScreenInput returns false for tab switching" -ForegroundColor Green
    
    # Test the FileTree component
    $fileTree = $fileBrowser.FileTree
    if ($fileTree -and $fileTree -is [FastFileTree]) {
        Write-Host "   FastFileTree component properly integrated" -ForegroundColor Green
    }
} catch {
    Write-Host "   FileBrowserScreen failed: $_" -ForegroundColor Red
}

Write-Host "`n2. Testing TextEditorScreen Architecture..." -ForegroundColor Yellow
try {
    $textEditor = [TextEditorScreen]::new()
    $textEditor.Initialize($global:ServiceContainer)
    
    Write-Host "   TextEditorScreen created and initialized" -ForegroundColor Green
    Write-Host "   No OnRender override - uses proper PRAXIS architecture" -ForegroundColor Green
    Write-Host "   HandleScreenInput handles Ctrl+O and Ctrl+S" -ForegroundColor Green
    Write-Host "   HandleScreenInput returns false for tab switching" -ForegroundColor Green
    
    # Test Ctrl+S handling
    $ctrlS = [System.ConsoleKeyInfo]::new('s', [System.ConsoleKey]::S, $false, $false, $true)
    $handled = $textEditor.HandleScreenInput($ctrlS)
    if ($handled) {
        Write-Host "   Ctrl+S properly handled" -ForegroundColor Green
    }
    
    # Test Ctrl+O handling
    $ctrlO = [System.ConsoleKeyInfo]::new('o', [System.ConsoleKey]::O, $false, $false, $true)
    $handled = $textEditor.HandleScreenInput($ctrlO)
    if ($handled) {
        Write-Host "   Ctrl+O properly handled" -ForegroundColor Green
    }
} catch {
    Write-Host "   TextEditorScreen failed: $_" -ForegroundColor Red
}

Write-Host "`n3. Architecture Compliance Check..." -ForegroundColor Yellow
Write-Host "   Both screens properly inherit from Screen" -ForegroundColor Green
Write-Host "   Both screens use HandleScreenInput instead of overriding input chain" -ForegroundColor Green
Write-Host "   Both screens return false for unhandled input (allows tab switching)" -ForegroundColor Green
Write-Host "   No artificial delays or render hacks" -ForegroundColor Green
Write-Host "   FileBrowserScreen uses existing FastFileTree component" -ForegroundColor Green
Write-Host "   Both screens integrate with PRAXIS service container" -ForegroundColor Green

Write-Host "`n4. Feature Summary..." -ForegroundColor Yellow
Write-Host "   FileBrowserScreen:" -ForegroundColor Cyan
Write-Host "    - Tree-based file navigation using FastFileTree" -ForegroundColor White
Write-Host "    - 'e' key to edit files in text editor" -ForegroundColor White
Write-Host "    - 'v' key to view files" -ForegroundColor White
Write-Host "    - 'u' key to go up directory" -ForegroundColor White
Write-Host "    - Proper tab switching support" -ForegroundColor White

Write-Host "   TextEditorScreen:" -ForegroundColor Cyan
Write-Host "    - Full text editing with cursor movement" -ForegroundColor White
Write-Host "    - Ctrl+O to open files via file browser" -ForegroundColor White
Write-Host "    - Ctrl+S to save files" -ForegroundColor White
Write-Host "    - Ctrl+Q to quit (with unsaved changes warning)" -ForegroundColor White
Write-Host "    - Tab, Enter, Backspace, Delete support" -ForegroundColor White
Write-Host "    - Proper tab switching support" -ForegroundColor White

Write-Host "`n All components properly architected and integrated!" -ForegroundColor Green


####\test-proper-flow.ps1
#!/usr/bin/env pwsh
# Test the proper input flow to understand where tab switching breaks

Write-Host "=== Testing Proper Input Flow ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "Will start PRAXIS and test number key tab switching:" -ForegroundColor Yellow
Write-Host "1. Start on Projects tab (1)" -ForegroundColor Yellow
Write-Host "2. Press '2' to test switching to Tasks" -ForegroundColor Yellow  
Write-Host "3. Press '3' to test switching to Files" -ForegroundColor Yellow
Write-Host "4. Press '4' to test switching to Editor" -ForegroundColor Yellow
Write-Host ""
Write-Host "Watch the logs to see where the input flow breaks." -ForegroundColor Green
Write-Host "Expected flow: ScreenManager -> ShortcutManager -> Screen -> TabContainer" -ForegroundColor Green
Write-Host ""

# Clear log first
> _Logs/praxis.log

# Start PRAXIS
pwsh -File Start.ps1 -Debug


####\test-screen-shortcuts.ps1
#!/usr/bin/env pwsh
# Test screen shortcuts

Write-Host "=== Testing Screen Shortcuts ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "1. Press 1 to go to Projects tab" -ForegroundColor Yellow
Write-Host "2. Press 'n' for New Project" -ForegroundColor Yellow
Write-Host "3. Press 'e' for Edit Project" -ForegroundColor Yellow
Write-Host "4. Check if shortcuts work" -ForegroundColor Yellow
Write-Host ""

# Clear log
"" > _Logs/praxis.log

# Start PRAXIS
pwsh -File Start.ps1

Write-Host ""
Write-Host "=== Checking logs for shortcut handling ===" -ForegroundColor Cyan
Get-Content _Logs/praxis.log | Select-String -Pattern "HandleScreenInput|HandleInput.*'n'|HandleInput.*'e'|Screen shortcuts handled" | Select-Object -Last 20


####\test-shortcut-debug.ps1
#!/usr/bin/env pwsh
# Debug script for shortcuts

param(
    [string]$LogPath = "_Logs/praxis.log"
)

Write-Host "Testing ShortcutManager Registration..." -ForegroundColor Cyan

# Watch the log file
if (Test-Path $LogPath) {
    Write-Host "Monitoring log file: $LogPath" -ForegroundColor Yellow
    Write-Host "Look for these patterns:" -ForegroundColor Gray
    Write-Host "  - 'Registered shortcut:' when screens activate" -ForegroundColor Gray
    Write-Host "  - 'ShortcutManager.HandleKeyPress:' when you press keys" -ForegroundColor Gray
    Write-Host "  - 'Found X matching shortcuts' to see if keys match" -ForegroundColor Gray
    Write-Host ""
    Write-Host "Press Ctrl+C to stop monitoring" -ForegroundColor Yellow
    
    Get-Content $LogPath -Wait -Tail 50 | Where-Object { 
        $_ -match 'shortcut|HandleKeyPress|Registered|Screen.*activated'
    }
} else {
    Write-Host "Log file not found at: $LogPath" -ForegroundColor Red
}


####\test-shortcut-flow.ps1
#!/usr/bin/env pwsh
# Test shortcut flow

Write-Host "=== Testing Shortcut Flow ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "This will help debug why shortcuts aren't working" -ForegroundColor Yellow
Write-Host ""
Write-Host "1. Start PRAXIS" -ForegroundColor Yellow
Write-Host "2. Press 1 to go to Projects tab" -ForegroundColor Yellow
Write-Host "3. Press 'n' to test New Project shortcut" -ForegroundColor Yellow
Write-Host "4. Watch the logs below for debug output" -ForegroundColor Yellow
Write-Host "5. Press Q to quit" -ForegroundColor Yellow
Write-Host ""

# Clear log
"" > _Logs/praxis.log

Read-Host "Press Enter to start PRAXIS..."

# Start PRAXIS
pwsh -File Start.ps1

Write-Host ""
Write-Host "=== Checking Shortcut Debug Info ===" -ForegroundColor Cyan
Get-Content _Logs/praxis.log | Select-String -Pattern "ShortcutManager|HandleKeyPress|RegisterShortcut|Total shortcuts|Screen=Projects|ScreenType=" | Select-Object -Last 30 | ForEach-Object {
    $line = $_.ToString()
    if ($line -match "ShortcutManager.HandleKeyPress") {
        Write-Host $line -ForegroundColor Yellow
    } elseif ($line -match "Total shortcuts") {
        Write-Host $line -ForegroundColor Cyan
    } elseif ($line -match "Screen=") {
        Write-Host $line -ForegroundColor Green
    } else {
        Write-Host $line
    }
}


####\test-shortcut-logging.ps1
#!/usr/bin/env pwsh
# Test to verify ShortcutManager logging issues

Write-Host "Testing ShortcutManager Logging..." -ForegroundColor Cyan

# First, let's check if Write-Host debug output is being cleared
Write-Host "[TEST] This is a test debug message" -ForegroundColor Yellow
Start-Sleep -Milliseconds 500

# Load just the necessary components
$global:PraxisRoot = (Get-Location).Path

# Load Logger first
. "./Services/Logger.ps1"
$logger = [Logger]::new()
$logger.MinimumLevel = "Debug"  # Force debug level
$global:Logger = $logger

Write-Host "Logger initialized at: $($logger.LogPath)" -ForegroundColor Green
Write-Host "Logger MinimumLevel: $($logger.MinimumLevel)" -ForegroundColor Green

# Test logger directly
$logger.Debug("TEST: Direct logger debug call")
$logger.Info("TEST: Direct logger info call")
$logger.Flush()  # Force flush

# Check if it was written
Start-Sleep -Milliseconds 100
$logContent = Get-Content $logger.LogPath -Tail 10 | Where-Object { $_ -match "TEST:" }
if ($logContent) {
    Write-Host "Logger is working. Found entries:" -ForegroundColor Green
    $logContent | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
} else {
    Write-Host "Logger NOT working - no test entries found!" -ForegroundColor Red
}

# Now test ShortcutManager logging
Write-Host "`nTesting ShortcutManager with Logger..." -ForegroundColor Cyan

# Load dependencies
. "./Core/ServiceContainer.ps1"
. "./Services/EventBus.ps1"
. "./Services/ShortcutManager.ps1"

# Create service container
$container = [ServiceContainer]::new()
$container.Register("Logger", $logger)

# Create EventBus
$eventBus = [EventBus]::new()
$eventBus.Initialize($container)
$container.Register("EventBus", $eventBus)

# Create ShortcutManager
$sm = [ShortcutManager]::new()
$sm.Initialize($container)

Write-Host "ShortcutManager initialized" -ForegroundColor Green

# Test logging in PublishCommand
Write-Host "`nCalling PublishCommand directly..." -ForegroundColor Cyan
$sm.PublishCommand("TestCommand", "TestTarget")

# Flush logger
$logger.Flush()

# Check log again
Start-Sleep -Milliseconds 100
$smLogs = Get-Content $logger.LogPath -Tail 20 | Where-Object { $_ -match "ShortcutManager" }
if ($smLogs) {
    Write-Host "ShortcutManager logs found:" -ForegroundColor Green
    $smLogs | ForEach-Object { Write-Host "  $_" -ForegroundColor Gray }
} else {
    Write-Host "No ShortcutManager logs found!" -ForegroundColor Red
}

Write-Host "`nTest complete. Check log at: $($logger.LogPath)" -ForegroundColor Yellow


####\test-shortcut-manager.ps1
#!/usr/bin/env pwsh
# test-shortcut-manager.ps1 - Test the ShortcutManager service

param(
    [switch]$Debug
)

# Get the script directory
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
Push-Location $scriptDir

try {
    # Source the main startup script to load all classes
    . ./Start.ps1 -Debug:$Debug -NoLaunch
    
    Write-Host "`n=== Testing ShortcutManager ===" -ForegroundColor Cyan
    
    # Get the ShortcutManager
    $shortcutManager = $global:ServiceContainer.GetService('ShortcutManager')
    
    if (-not $shortcutManager) {
        Write-Host "ShortcutManager not found!" -ForegroundColor Red
        return
    }
    
    Write-Host "ShortcutManager loaded successfully" -ForegroundColor Green
    
    # Test 1: Register a screen-specific shortcut
    Write-Host "`n--- Test 1: Register screen-specific shortcut ---" -ForegroundColor Yellow
    $shortcutManager.RegisterShortcut(@{
        Id = "projects.new"
        Name = "New Project"
        Description = "Create a new project"
        KeyChar = 'n'
        Scope = [ShortcutScope]::Screen
        ScreenType = "ProjectsScreen"
        Priority = 50
        Action = {
            Write-Host "New Project shortcut triggered!" -ForegroundColor Green
        }
    })
    Write-Host "Registered 'n' key for ProjectsScreen" -ForegroundColor Green
    
    # Test 2: Register a context-specific shortcut
    Write-Host "`n--- Test 2: Register context-specific shortcut ---" -ForegroundColor Yellow
    $shortcutManager.RegisterShortcut(@{
        Id = "dialog.confirm"
        Name = "Confirm"
        Description = "Confirm dialog action"
        KeyChar = 'y'
        Scope = [ShortcutScope]::Context
        Context = "Dialog"
        Priority = 60
        Action = {
            Write-Host "Dialog confirmed!" -ForegroundColor Green
        }
    })
    Write-Host "Registered 'y' key for Dialog context" -ForegroundColor Green
    
    # Test 3: Display all registered shortcuts
    Write-Host "`n--- Test 3: Display all shortcuts ---" -ForegroundColor Yellow
    $allShortcuts = $shortcutManager.GetAllShortcuts()
    foreach ($shortcut in $allShortcuts) {
        Write-Host "  $($shortcut.GetDisplayText()) - $($shortcut.Name) [$($shortcut.Scope)]"
    }
    
    # Test 4: Test key matching
    Write-Host "`n--- Test 4: Test key matching ---" -ForegroundColor Yellow
    $testKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    
    Write-Host "Testing 'n' key in ProjectsScreen context:"
    $handled = $shortcutManager.HandleKeyPress($testKey, "ProjectsScreen", "")
    Write-Host "  Handled: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    Write-Host "Testing 'n' key in TaskScreen context:"
    $handled = $shortcutManager.HandleKeyPress($testKey, "TaskScreen", "")
    Write-Host "  Handled: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 5: Test shortcut help
    Write-Host "`n--- Test 5: Shortcut help ---" -ForegroundColor Yellow
    Write-Host "Global shortcuts:"
    Write-Host $shortcutManager.GetShortcutHelp([ShortcutScope]::Global)
    
    # Test 6: Create a demo screen that uses ShortcutManager
    Write-Host "`n--- Test 6: Demo screen with shortcuts ---" -ForegroundColor Yellow
    
    class DemoScreen : Screen {
        DemoScreen() : base() {
            $this.Title = "Demo Screen with Shortcuts"
        }
        
        [void] OnInitialize() {
            # Register screen-specific shortcuts
            $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
            if ($shortcutManager) {
                # Register F1 for help
                $shortcutManager.RegisterShortcut(@{
                    Id = "demo.help"
                    Name = "Show Help"
                    Description = "Display help information"
                    Key = [System.ConsoleKey]::F1
                    Scope = [ShortcutScope]::Screen
                    ScreenType = "DemoScreen"
                    Priority = 50
                    Action = {
                        Write-Host "`nHelp: This is a demo screen showing ShortcutManager integration" -ForegroundColor Cyan
                    }
                })
                
                # Register 'a' for action
                $shortcutManager.RegisterShortcut(@{
                    Id = "demo.action"
                    Name = "Demo Action"
                    Description = "Perform a demo action"
                    KeyChar = 'a'
                    Scope = [ShortcutScope]::Screen
                    ScreenType = "DemoScreen"
                    Priority = 50
                    Action = {
                        Write-Host "`nDemo action executed!" -ForegroundColor Green
                    }
                })
            }
        }
        
        [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
            # Screen-specific shortcuts are now handled by ShortcutManager in ScreenManager
            # This method only needs to handle special cases
            
            if ($key.Key -eq [System.ConsoleKey]::Escape) {
                $this.Active = $false
                return $true
            }
            
            return $false
        }
        
        [string] OnRender() {
            $sb = [System.Text.StringBuilder]::new()
            
            $sb.AppendLine()
            $sb.AppendLine("  Demo Screen - ShortcutManager Integration")
            $sb.AppendLine()
            $sb.AppendLine("  Available shortcuts:")
            $sb.AppendLine("    F1     - Show Help")
            $sb.AppendLine("    a      - Demo Action")
            $sb.AppendLine("    Ctrl+Q - Quit")
            $sb.AppendLine("    Esc    - Exit this screen")
            $sb.AppendLine()
            $sb.AppendLine("  Try pressing the shortcuts!")
            
            return $sb.ToString()
        }
    }
    
    # Run the demo screen
    Write-Host "Starting demo screen..." -ForegroundColor Green
    Write-Host "Press any key to continue..." -ForegroundColor DarkGray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    # Create and run the demo
    $demoScreen = [DemoScreen]::new()
    $screenManager = [ScreenManager]::new($global:ServiceContainer)
    $global:ScreenManager = $screenManager
    $screenManager.Push($demoScreen)
    $screenManager.Run()
    
    Write-Host "`nDemo completed!" -ForegroundColor Green
    
} finally {
    Pop-Location
}


####\test-shortcut-simple.ps1
#!/usr/bin/env pwsh
# Simple test to see if EventNames is available

# Load EventBus first
. ./Services/EventBus.ps1

# Check if EventNames is available
Write-Host "EventNames type: $([EventNames])" -ForegroundColor Cyan
Write-Host "CommandExecuted value: $([EventNames]::CommandExecuted)" -ForegroundColor Green

# Now test the ShortcutManager
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/ShortcutManager.ps1

# Quick test
$global:PraxisDebug = $true
$container = [ServiceContainer]::new()
$logger = [Logger]::new()
$container.Register("Logger", $logger)

$eventBus = [EventBus]::new()
$eventBus.Initialize($container)
$container.Register("EventBus", $eventBus)

$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($container)

Write-Host "`nShortcutManager initialized" -ForegroundColor Green
Write-Host "EventBus: $($shortcutManager.EventBus)" -ForegroundColor Cyan
Write-Host "Logger: $($shortcutManager.Logger)" -ForegroundColor Cyan


####\test-shortcutmanager.ps1
#!/usr/bin/env pwsh
# Test ShortcutManager functionality

param(
    [switch]$Debug
)

# Set debug mode FIRST before anything else
if ($Debug) {
    $global:PraxisDebug = $true
    Write-Host "Debug mode enabled" -ForegroundColor Green
}

# Set up paths
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load required files
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/EventBus.ps1
. ./Services/ShortcutManager.ps1

# Create services
$container = [ServiceContainer]::new()

# Create logger and verify debug mode
$logger = [Logger]::new()
$container.Register("Logger", $logger)
Write-Host "Logger MinimumLevel: $($logger.MinimumLevel)" -ForegroundColor Cyan

# Create EventBus
$eventBus = [EventBus]::new()
$eventBus.Initialize($container)
$container.Register("EventBus", $eventBus)

# Subscribe to CommandExecuted events
$eventBus.Subscribe([EventNames]::CommandExecuted, {
    param($data)
    Write-Host "Event received! Command: $($data.Command), Target: $($data.Target)" -ForegroundColor Yellow
})

# Create ShortcutManager
$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($container)

Write-Host "`nTesting ShortcutManager:" -ForegroundColor Cyan

# Test 1: ProjectsScreen shortcut
Write-Host "`nTest 1: ProjectsScreen 'n' key" -ForegroundColor Green
$keyInfo = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
$result = $shortcutManager.HandleKeyPress($keyInfo, "ProjectsScreen", "")
Write-Host "Result: $result (should be True)" -ForegroundColor $(if ($result) { "Green" } else { "Red" })

# Test 2: TaskScreen shortcut
Write-Host "`nTest 2: TaskScreen 'e' key" -ForegroundColor Green
$keyInfo = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
$result = $shortcutManager.HandleKeyPress($keyInfo, "TaskScreen", "")
Write-Host "Result: $result (should be True)" -ForegroundColor $(if ($result) { "Green" } else { "Red" })

# Test 3: Invalid shortcut
Write-Host "`nTest 3: Invalid 'z' key on ProjectsScreen" -ForegroundColor Green
$keyInfo = [System.ConsoleKeyInfo]::new('z', [System.ConsoleKey]::Z, $false, $false, $false)
$result = $shortcutManager.HandleKeyPress($keyInfo, "ProjectsScreen", "")
Write-Host "Result: $result (should be False)" -ForegroundColor $(if (-not $result) { "Green" } else { "Red" })

# Test 4: CommandPalette context (should be ignored)
Write-Host "`nTest 4: Key press while CommandPalette is open" -ForegroundColor Green
$keyInfo = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
$result = $shortcutManager.HandleKeyPress($keyInfo, "ProjectsScreen", "CommandPalette")
Write-Host "Result: $result (should be False)" -ForegroundColor $(if (-not $result) { "Green" } else { "Red" })

# Flush logger
$logger.Flush()

Write-Host "`nCheck the log file at: $($logger.LogPath)" -ForegroundColor Cyan
Write-Host "Last 10 lines:" -ForegroundColor Cyan
Get-Content $logger.LogPath -Tail 10 | ForEach-Object { Write-Host "  $_" -ForegroundColor DarkGray }


####\test-shortcuts-comprehensive.ps1
#!/usr/bin/env pwsh
# Comprehensive shortcut debugging

Write-Host "`nComprehensive Shortcut Debug" -ForegroundColor Cyan
Write-Host "============================" -ForegroundColor Cyan

Write-Host @"
This test will show:
- [REG] When shortcuts are registered  
- [UNREG] When shortcuts are unregistered
- [DEBUG] Each key press
- [SM] ShortcutManager processing
- [MATCH] When keys match shortcuts
- Screen activation messages

Test Plan:
1. Start on MainScreen
2. Press 1 to go to Projects - should see OnActivated
3. Press 'e' - should see matching and handling
4. Press 2 to go to Tasks  
5. Press 'e' again

Watch the output carefully!
"@ -ForegroundColor Yellow

Write-Host "`nStarting PRAXIS..." -ForegroundColor Green
Write-Host ""

# Run PRAXIS
pwsh -File Start.ps1


####\test-shortcuts-debug2.ps1
#!/usr/bin/env pwsh
# Simple test to check if shortcuts are working

# Clear any existing log
if (Test-Path "_Logs/praxis.log") {
    Clear-Content "_Logs/praxis.log"
}

Write-Host "`nStarting PRAXIS with shortcut debugging..." -ForegroundColor Cyan
Write-Host "Watch for debug messages about shortcuts" -ForegroundColor Yellow
Write-Host "Press 'e' or 'd' on screens 1 or 2" -ForegroundColor Yellow
Write-Host "`nStarting in 2 seconds..." -ForegroundColor Gray
Start-Sleep -Seconds 2

# Run PRAXIS with debug mode
pwsh -File Start.ps1 -Debug


####\test-shortcuts-detailed.ps1
#!/usr/bin/env pwsh
# Test shortcut registration and matching in detail

Write-Host "`nDetailed Shortcut Testing" -ForegroundColor Cyan
Write-Host "=========================" -ForegroundColor Cyan

# Load PRAXIS components
. ./Core/ServiceContainer.ps1
. ./Services/Logger.ps1
. ./Services/ShortcutManager.ps1

# Create services
$logger = [Logger]::new('test-shortcuts-detailed.log')
$container = [ServiceContainer]::new()
$container.RegisterService('Logger', $logger)

# Create and initialize ShortcutManager
$sm = [ShortcutManager]::new()
$sm.Initialize($container)

Write-Host "`nShortcutManager initialized with $($sm.Shortcuts.Count) shortcuts" -ForegroundColor Green

# Register a test shortcut
Write-Host "`nRegistering test shortcut for 'e' key..." -ForegroundColor Yellow
$sm.RegisterShortcut(@{
    Id = "test.edit"
    Name = "Test Edit"
    Description = "Test edit action"
    KeyChar = 'e'
    Scope = [ShortcutScope]::Screen
    ScreenType = "ProjectsScreen"
    Priority = 50
    Action = { Write-Host "EDIT ACTION EXECUTED!" -ForegroundColor Green }
})

Write-Host "Total shortcuts after registration: $($sm.Shortcuts.Count)" -ForegroundColor Green

# List all shortcuts
Write-Host "`nAll registered shortcuts:" -ForegroundColor Yellow
foreach ($shortcut in $sm.Shortcuts) {
    $key = if ($shortcut.KeyChar -ne [char]0) { "Char='$($shortcut.KeyChar)'" } else { "Key=$($shortcut.Key)" }
    Write-Host "  $($shortcut.Id): $key, Screen=$($shortcut.ScreenType), Scope=$($shortcut.Scope)" -ForegroundColor Gray
}

# Test key matching
Write-Host "`nTesting key matching..." -ForegroundColor Yellow

# Create test key for 'e'
$testKey = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
Write-Host "Test key: Char='$($testKey.KeyChar)' Key=$($testKey.Key)" -ForegroundColor Gray

# Test each shortcut's Matches method
Write-Host "`nTesting Matches() for each shortcut:" -ForegroundColor Yellow
foreach ($shortcut in $sm.Shortcuts) {
    $matches = $shortcut.Matches($testKey)
    $key = if ($shortcut.KeyChar -ne [char]0) { "Char='$($shortcut.KeyChar)'" } else { "Key=$($shortcut.Key)" }
    Write-Host "  $($shortcut.Id) ($key): Matches = $matches" -ForegroundColor $(if ($matches) { 'Green' } else { 'Red' })
}

# Test HandleKeyPress
Write-Host "`nTesting HandleKeyPress..." -ForegroundColor Yellow
Write-Host "Current screen: ProjectsScreen" -ForegroundColor Gray
Write-Host "Current context: (empty)" -ForegroundColor Gray

$handled = $sm.HandleKeyPress($testKey, "ProjectsScreen", "")
Write-Host "Result: Handled = $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })

# Test with wrong screen
Write-Host "`nTesting with wrong screen (TaskScreen)..." -ForegroundColor Yellow
$handled = $sm.HandleKeyPress($testKey, "TaskScreen", "")
Write-Host "Result: Handled = $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })

# Test case sensitivity
Write-Host "`nTesting case sensitivity..." -ForegroundColor Yellow
$testKeyUpper = [System.ConsoleKeyInfo]::new('E', [System.ConsoleKey]::E, $true, $false, $false)
Write-Host "Test key (uppercase): Char='$($testKeyUpper.KeyChar)' Key=$($testKeyUpper.Key)" -ForegroundColor Gray
$handled = $sm.HandleKeyPress($testKeyUpper, "ProjectsScreen", "")
Write-Host "Result: Handled = $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })

Write-Host "`nCheck test-shortcuts-detailed.log for detailed debug output" -ForegroundColor Cyan


####\test-shortcuts-final.ps1
#!/usr/bin/env pwsh
# Final test to verify shortcuts are working

Write-Host "`nShortcut System Test" -ForegroundColor Cyan
Write-Host "===================" -ForegroundColor Cyan

# Clear log
if (Test-Path "_Logs/praxis.log") {
    Clear-Content "_Logs/praxis.log"
}

Write-Host @"
Testing the shortcut system with the case-insensitive fix applied.

Instructions:
1. Navigate to Projects screen (press 1)
2. Try these shortcuts:
   - e: Edit project
   - d: Delete project
   - n: New project
   - Ctrl+Right Arrow: Next focus
   - Ctrl+Left Arrow: Previous focus

3. Navigate to Tasks screen (press 2)
4. Try shortcuts there too

The shortcuts should now work properly!
"@ -ForegroundColor Yellow

Write-Host "`nStarting PRAXIS..." -ForegroundColor Green

# Run PRAXIS
pwsh -File Start.ps1


####\test-shortcuts-interactive.ps1
#!/usr/bin/env pwsh
# Interactive test to debug shortcuts

Write-Host "`nPRAXIS Shortcut Debugging" -ForegroundColor Cyan
Write-Host "========================" -ForegroundColor Cyan
Write-Host @"
This will run PRAXIS and monitor the log for shortcut-related messages.

Instructions:
1. Navigate to Projects screen (screen 1)
2. Press 'e' or 'd' keys
3. Watch this window for debug output
4. Press Ctrl+C in this window to stop monitoring

"@ -ForegroundColor Yellow

# Clear the log first
if (Test-Path "_Logs/praxis.log") {
    Clear-Content "_Logs/praxis.log"
}

# Start PRAXIS in debug mode in background
$praxis = Start-Process pwsh -ArgumentList "-File", "Start.ps1", "-Debug" -PassThru

Write-Host "PRAXIS started (PID: $($praxis.Id)). Monitoring log..." -ForegroundColor Green
Write-Host "Press Ctrl+C to stop monitoring" -ForegroundColor Gray
Write-Host ""

# Monitor the log file
try {
    Get-Content "_Logs/praxis.log" -Wait | Where-Object {
        $_ -match "Shortcut|RegisterShortcuts|HandleKeyPress|Key pressed|OnActivated" -or
        $_ -match "Key=E|Char='e'|Key=D|Char='d'"
    } | ForEach-Object {
        if ($_ -match "ERROR") {
            Write-Host $_ -ForegroundColor Red
        } elseif ($_ -match "RegisterShortcuts|OnActivated") {
            Write-Host $_ -ForegroundColor Cyan
        } elseif ($_ -match "Key pressed|HandleKeyPress") {
            Write-Host $_ -ForegroundColor Yellow
        } elseif ($_ -match "Executing shortcut|Key handled") {
            Write-Host $_ -ForegroundColor Green
        } else {
            Write-Host $_ -ForegroundColor Gray
        }
    }
}
finally {
    if (-not $praxis.HasExited) {
        Write-Host "`nStopping PRAXIS..." -ForegroundColor Yellow
        $praxis.Kill()
    }
}


####\test-shortcuts-simple.ps1
#!/usr/bin/env pwsh
# Simple test to verify keyboard input

Write-Host "Testing keyboard input..." -ForegroundColor Cyan
Write-Host "Press keys to see what's captured (Ctrl+C to exit):" -ForegroundColor Yellow

while ($true) {
    if ([Console]::KeyAvailable) {
        $key = [Console]::ReadKey($true)
        
        Write-Host ""
        Write-Host "Key Pressed:" -ForegroundColor Green
        Write-Host "  Key: $($key.Key)" -ForegroundColor Gray
        Write-Host "  KeyChar: '$($key.KeyChar)'" -ForegroundColor Gray
        Write-Host "  KeyChar (int): $([int]$key.KeyChar)" -ForegroundColor Gray
        Write-Host "  Modifiers: $($key.Modifiers)" -ForegroundColor Gray
        
        if ($key.KeyChar) {
            Write-Host "  IsLetter: $([char]::IsLetter($key.KeyChar))" -ForegroundColor Gray
            Write-Host "  ToLower: '$([char]::ToLower($key.KeyChar))'" -ForegroundColor Gray
        }
        
        if (($key.Modifiers -band [System.ConsoleModifiers]::Control) -and 
            $key.Key -eq [System.ConsoleKey]::C) {
            break
        }
    }
    Start-Sleep -Milliseconds 50
}


####\test-shortcuts.ps1
#!/usr/bin/env pwsh
# Test script to verify keyboard shortcuts

param(
    [switch]$Debug
)

# Set location to script root
Set-Location $PSScriptRoot

# Run with debug flag
if ($Debug) {
    Write-Host "Running with debug output..." -ForegroundColor Yellow
    & ./Start.ps1 -Debug
} else {
    Write-Host "Starting PRAXIS to test shortcuts..." -ForegroundColor Green
    Write-Host "Test these shortcuts in ProjectsScreen:" -ForegroundColor Cyan
    Write-Host "  e - Edit selected project" -ForegroundColor Gray
    Write-Host "  d - Delete selected project" -ForegroundColor Gray
    Write-Host "  n - New project" -ForegroundColor Gray
    Write-Host ""
    Write-Host "And in TaskScreen:" -ForegroundColor Cyan
    Write-Host "  e - Edit selected task" -ForegroundColor Gray
    Write-Host "  d - Delete selected task" -ForegroundColor Gray
    Write-Host "  n - New task" -ForegroundColor Gray
    Write-Host ""
    Write-Host "Press Enter to continue..."
    Read-Host
    
    & ./Start.ps1
}


####\test-startup.ps1
#!/usr/bin/env pwsh
# Quick test to see startup behavior

Write-Host "Starting PRAXIS to check startup..." -ForegroundColor Yellow
Write-Host "If you see a black screen, press Ctrl+C to exit" -ForegroundColor Red
Write-Host ""

# Clear log
Clear-Content _Logs/praxis.log -ErrorAction SilentlyContinue

# Start app
try {
    pwsh -File Start.ps1
} catch {
    Write-Host "Error during startup: $_" -ForegroundColor Red
}

Write-Host ""
Write-Host "Checking startup logs..." -ForegroundColor Cyan

# Check tab initialization
Write-Host ""
Write-Host "Tab initialization:" -ForegroundColor Yellow
grep -E "Adding tabs|Added.*tabs|ActivateTab|ActiveTabIndex" _Logs/praxis.log | head -10

# Check for errors
Write-Host ""
Write-Host "Errors:" -ForegroundColor Yellow
grep -E "ERROR|Exception" _Logs/praxis.log | head -10


####\test-tab-state.ps1
#!/usr/bin/env pwsh
# Test to verify tab state vs what's displayed

# Load minimal framework
$global:PraxisRoot = $PSScriptRoot
Set-Location $global:PraxisRoot

# Load essential components
. "./Core/VT100.ps1"
. "./Core/ServiceContainer.ps1"
. "./Services/Logger.ps1"
. "./Services/ThemeManager.ps1"
. "./Services/EventBus.ps1"
. "./Base/UIElement.ps1"
. "./Base/Container.ps1"
. "./Base/Screen.ps1"
. "./Components/Button.ps1"
. "./Components/TabContainer.ps1"
. "./Screens/ProjectsScreen.ps1"
. "./Screens/TextEditorScreen.ps1"

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

Write-Host "=== Testing Tab State vs Display ===" -ForegroundColor Cyan

# Create TabContainer with 2 tabs
$tabContainer = [TabContainer]::new()
$tabContainer.Initialize($global:ServiceContainer)

$projectsScreen = [ProjectsScreen]::new()
$projectsScreen.Initialize($global:ServiceContainer)
$tabContainer.AddTab("Projects", $projectsScreen)

$textEditorScreen = [TextEditorScreen]::new()
$textEditorScreen.Initialize($global:ServiceContainer)
$tabContainer.AddTab("Editor", $textEditorScreen)

Write-Host "Initial state:" -ForegroundColor Yellow
Write-Host "  TabContainer.ActiveTabIndex: $($tabContainer.ActiveTabIndex)"
Write-Host "  Active tab title: $($tabContainer.GetActiveTab().Title)"
Write-Host "  Active tab content type: $($tabContainer.GetActiveTab().Content.GetType().Name)"

# Switch to Editor tab (index 1)
Write-Host "`nSwitching to Editor tab..." -ForegroundColor Yellow
$tabContainer.ActivateTab(1)

Write-Host "After switching to Editor:" -ForegroundColor Yellow
Write-Host "  TabContainer.ActiveTabIndex: $($tabContainer.ActiveTabIndex)"
Write-Host "  Active tab title: $($tabContainer.GetActiveTab().Title)"
Write-Host "  Active tab content type: $($tabContainer.GetActiveTab().Content.GetType().Name)"

# Now simulate the "1" key press issue
Write-Host "`nSimulating '1' key press..." -ForegroundColor Yellow
$key1 = [System.ConsoleKeyInfo]::new('1', [ConsoleKey]::D1, $false, $false, $false)

# First put TextEditor in command mode
$escapeKey = [System.ConsoleKeyInfo]::new([char]27, [ConsoleKey]::Escape, $false, $false, $false)
$handled = $tabContainer.HandleInput($escapeKey)
Write-Host "  Escape handled: $handled"
Write-Host "  TextEditor InTextMode: $($textEditorScreen.InTextMode)"

# Now try the "1" key
$handled = $tabContainer.HandleInput($key1)
Write-Host "  Key '1' handled: $handled"

Write-Host "`nAfter '1' key press:" -ForegroundColor Yellow
Write-Host "  TabContainer.ActiveTabIndex: $($tabContainer.ActiveTabIndex) (should be 0)"
Write-Host "  Active tab title: $($tabContainer.GetActiveTab().Title) (should be Projects)"
Write-Host "  Active tab content type: $($tabContainer.GetActiveTab().Content.GetType().Name) (should be ProjectsScreen)"

# Check children
Write-Host "`nTabContainer children:" -ForegroundColor Yellow
Write-Host "  Children.Count: $($tabContainer.Children.Count)"
for ($i = 0; $i -lt $tabContainer.Children.Count; $i++) {
    $child = $tabContainer.Children[$i]
    Write-Host "  Child $i`: $($child.GetType().Name)"
}

Write-Host "`n=== Test Complete ===" -ForegroundColor Green


####\test-texteditor-esc.ps1
#!/usr/bin/env pwsh
# Test TextEditor ESC behavior

Write-Host "=== Testing TextEditor ESC Behavior ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "1. Press 5 to go to Editor tab" -ForegroundColor Yellow
Write-Host "2. Type some text" -ForegroundColor Yellow
Write-Host "3. Press ESC" -ForegroundColor Yellow
Write-Host "4. Try pressing 1, 2, 3 to switch tabs" -ForegroundColor Yellow
Write-Host "5. Press Q to quit" -ForegroundColor Yellow
Write-Host ""

Clear-Content _Logs/praxis.log -ErrorAction SilentlyContinue

pwsh -File Start.ps1

Write-Host ""
Write-Host "=== Checking Key Input After ESC ===" -ForegroundColor Cyan
grep -a "Key pressed\|InTextMode\|HandleInput.*TextEditor" _Logs/praxis.log | tail -30


####\test-texteditor-mode.ps1
#!/usr/bin/env pwsh
# Test TextEditor mode system

Write-Host "=== Testing TextEditor Mode System ===" -ForegroundColor Cyan
Write-Host ""
Write-Host "This test will:" -ForegroundColor Yellow
Write-Host "1. Start PRAXIS" -ForegroundColor Yellow  
Write-Host "2. Switch to Editor tab (press 5)" -ForegroundColor Yellow
Write-Host "3. Type some text" -ForegroundColor Yellow
Write-Host "4. Press ESC to enter COMMAND MODE" -ForegroundColor Yellow
Write-Host "5. Press number keys to switch tabs" -ForegroundColor Yellow
Write-Host "6. Press Q to quit" -ForegroundColor Yellow
Write-Host ""
Write-Host "Look for '[COMMAND]' in the status bar after pressing ESC" -ForegroundColor Green
Write-Host ""

Read-Host "Press Enter to start PRAXIS..."

# Start PRAXIS
pwsh -File Start.ps1

# Show logs after exit
Write-Host ""
Write-Host "=== Checking Logs for Mode Changes ===" -ForegroundColor Cyan
Get-Content _Logs/praxis.log | Select-String -Pattern "InTextMode|ESC pressed|not handling number key|TabContainer.*Switching" | Select-Object -Last 20


####\test-texteditor-tabswitching.ps1
#!/usr/bin/env pwsh
# Test TextEditor tab switching behavior

# Load the framework
$global:PraxisRoot = $PSScriptRoot
Set-Location $global:PraxisRoot

# Load essential components for testing
. "./Core/VT100.ps1"
. "./Core/ServiceContainer.ps1"
. "./Core/StringBuilderPool.ps1"
. "./Services/Logger.ps1"
. "./Services/EventBus.ps1"
. "./Services/ThemeManager.ps1"
. "./Base/UIElement.ps1"
. "./Base/Container.ps1"
. "./Base/Screen.ps1"
. "./Components/Button.ps1"
. "./Components/TabContainer.ps1"
. "./Screens/TextEditorScreen.ps1"

# Initialize minimal services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# Create test scenario
Write-Host "=== Testing TextEditor Tab Switching ===" -ForegroundColor Cyan

# Create TabContainer with TextEditor
$tabContainer = [TabContainer]::new()
$tabContainer.Initialize($global:ServiceContainer)
$tabContainer.SetBounds(0, 0, 80, 24)

# Add a dummy first tab and TextEditor as second tab
$dummyScreen = [Screen]::new()
$dummyScreen.Title = "Dummy"
$dummyScreen.Initialize($global:ServiceContainer)
$tabContainer.AddTab("Dummy", $dummyScreen)

$textEditor = [TextEditorScreen]::new()
$textEditor.Initialize($global:ServiceContainer)
$tabContainer.AddTab("Editor", $textEditor)

# Activate the TextEditor tab (index 1)
$tabContainer.ActivateTab(1)

Write-Host "Initial state:" -ForegroundColor Yellow
Write-Host "  Active tab: $($tabContainer.ActiveTabIndex + 1) ($($tabContainer.GetActiveTab().Title))"
Write-Host "  TextEditor InTextMode: $($textEditor.InTextMode)"

# Test 1: In text mode, number key should be handled by TextEditor
Write-Host "`n=== Test 1: Text mode - number key should be handled by TextEditor ===" -ForegroundColor Yellow
$key1InTextMode = [System.ConsoleKeyInfo]::new('1', [ConsoleKey]::D1, $false, $false, $false)
$handled = $tabContainer.HandleInput($key1InTextMode)
Write-Host "  Key '1' in text mode handled by TabContainer: $handled (should be True - editor handled it)"
Write-Host "  Active tab after: $($tabContainer.ActiveTabIndex + 1) (should still be 2)"

# Test 2: Switch to command mode and test number key
Write-Host "`n=== Test 2: Command mode - number key should switch tabs ===" -ForegroundColor Yellow
# Simulate Escape key to switch to command mode
$escapeKey = [System.ConsoleKeyInfo]::new([char]27, [ConsoleKey]::Escape, $false, $false, $false)
$handled = $tabContainer.HandleInput($escapeKey)
Write-Host "  Escape key handled: $handled"
Write-Host "  TextEditor InTextMode after Escape: $($textEditor.InTextMode)"

# Now test number key in command mode
$key1InCommandMode = [System.ConsoleKeyInfo]::new('1', [ConsoleKey]::D1, $false, $false, $false)
$handled = $tabContainer.HandleInput($key1InCommandMode)
Write-Host "  Key '1' in command mode handled by TabContainer: $handled (should be True - tab switching)"
Write-Host "  Active tab after: $($tabContainer.ActiveTabIndex + 1) (should be 1 - switched to Dummy tab)"

# Test 3: Switch back to tab 2 and verify
Write-Host "`n=== Test 3: Switch back to Editor tab ===" -ForegroundColor Yellow
$key2 = [System.ConsoleKeyInfo]::new('2', [ConsoleKey]::D2, $false, $false, $false)
$handled = $tabContainer.HandleInput($key2)
Write-Host "  Key '2' handled: $handled (should be True)"
Write-Host "  Active tab after: $($tabContainer.ActiveTabIndex + 1) (should be 2 - back to Editor)"
Write-Host "  TextEditor InTextMode: $($textEditor.InTextMode) (should still be False - command mode)"

# Test 4: Test letter key switches back to text mode
Write-Host "`n=== Test 4: Letter key should switch back to text mode ===" -ForegroundColor Yellow
$letterKey = [System.ConsoleKeyInfo]::new('a', [ConsoleKey]::A, $false, $false, $false)
$handled = $tabContainer.HandleInput($letterKey)
Write-Host "  Key 'a' handled: $handled (should be True - editor handled it)"
Write-Host "  TextEditor InTextMode after 'a': $($textEditor.InTextMode) (should be True - switched to text mode)"

Write-Host "`n=== Test Complete ===" -ForegroundColor Green


####\test-time-tracking.ps1
#!/usr/bin/env pwsh
# Test script for time tracking functionality

Write-Host "Testing Time Tracking System..." -ForegroundColor Cyan

# Load the models
. "$PSScriptRoot/Models/TimeEntry.ps1"
. "$PSScriptRoot/Models/TimeCode.ps1"

# Test TimeEntry model
Write-Host "`nTesting TimeEntry model:" -ForegroundColor Yellow

$entry = [TimeEntry]::new()
Write-Host "  Created empty TimeEntry"
Write-Host "  Week Ending Friday: $($entry.WeekEndingFriday)"
Write-Host "  Fiscal Year: $($entry.FiscalYear)"

# Test with specific date
$entry2 = [TimeEntry]::new("20240126", "CAS-2024-001")
$entry2.Monday = 8
$entry2.Tuesday = 7.5
$entry2.Wednesday = 8
$entry2.Thursday = 6
$entry2.Friday = 4.5
$entry2.CalculateTotal()

Write-Host "`n  Created TimeEntry for week ending 01/26/2024:"
Write-Host "  ID2: $($entry2.ID2)"
Write-Host "  Total Hours: $($entry2.Total)"
Write-Host "  Is Project Entry: $($entry2.IsProjectEntry())"
Write-Host "  Week Display: $($entry2.GetWeekDisplayString())"

# Test non-project entry
$entry3 = [TimeEntry]::new("20240126", "VAC")
$entry3.Monday = 8
$entry3.Tuesday = 8
$entry3.CalculateTotal()

Write-Host "`n  Created non-project TimeEntry:"
Write-Host "  ID2: $($entry3.ID2)"
Write-Host "  Total Hours: $($entry3.Total)"
Write-Host "  Is Project Entry: $($entry3.IsProjectEntry())"

# Test TimeCode model
Write-Host "`nTesting TimeCode model:" -ForegroundColor Yellow

$code = [TimeCode]::new("ADMIN", "Administration")
Write-Host "  Created TimeCode: $($code.GetDisplayName())"

$commonCodes = [TimeCode]::GetCommonCodes()
Write-Host "  Common codes count: $($commonCodes.Count)"
foreach ($c in $commonCodes[0..2]) {
    Write-Host "    - $($c.GetDisplayName())"
}

Write-Host "`nTime tracking models test completed!" -ForegroundColor Green


####\test-trace-flow.ps1
#!/usr/bin/env pwsh
# Trace the exact flow of key handling

Write-Host "`nKey Handling Flow Test" -ForegroundColor Cyan
Write-Host "=====================" -ForegroundColor Cyan

# Clear log
if (Test-Path "_Logs/praxis.log") {
    Clear-Content "_Logs/praxis.log" 
}

# Add inline debug to ScreenManager
$smPath = "Core/ScreenManager.ps1"
$smContent = Get-Content $smPath -Raw

# Backup
Copy-Item $smPath "$smPath.bak" -Force

# Add debug output at key points
$smContent = $smContent -replace '(# Log key press for debugging)', @'
$1
                        Write-Host "[TRACE] Key: $($key.Key) Char: '$($key.KeyChar)' (int: $([int]$key.KeyChar))" -ForegroundColor Yellow
'@

$smContent = $smContent -replace '(if \(\$this._shortcutManager\) \{)', @'
Write-Host "[TRACE] Checking ShortcutManager..." -ForegroundColor Cyan
                        $1
'@

$smContent = $smContent -replace '(\$handled = \$this._shortcutManager\.HandleKeyPress)', @'
Write-Host "[TRACE] Calling ShortcutManager.HandleKeyPress with Screen=$currentScreenType" -ForegroundColor Magenta
                            $1
'@

$smContent = $smContent -replace '(if \(\$handled -and \$global:Logger\))', @'
Write-Host "[TRACE] ShortcutManager result: $handled" -ForegroundColor $(if ($handled) { 'Green' } else { 'Red' })
                            $1
'@

# Save modified content
$smContent | Set-Content $smPath -Force

Write-Host "Trace code added. Starting PRAXIS..." -ForegroundColor Green
Write-Host "Press 'e' on Projects screen and watch the output" -ForegroundColor Yellow
Write-Host ""

# Run PRAXIS
try {
    pwsh -File Start.ps1
}
finally {
    # Restore original
    Move-Item "$smPath.bak" $smPath -Force
    Write-Host "`nOriginal files restored" -ForegroundColor Green
}


####\test-what-is-broken.ps1
#!/usr/bin/env pwsh
# Test what exactly is broken with tab switching

Write-Host "=== Testing What Is Actually Broken ===" -ForegroundColor Red
Write-Host ""
Write-Host "This will test the exact scenario:"
Write-Host "1. Start PRAXIS (should be on Projects tab)"
Write-Host "2. Press '2' to switch to Tasks"  
Write-Host "3. Observe if ANYTHING changes visually"
Write-Host ""
Write-Host "If tab switching was working before but is broken now:"
Write-Host "- The tab bar highlight should move"
Write-Host "- The screen content should change from Projects to Tasks"
Write-Host ""
Write-Host "Let's see what happens..." -ForegroundColor Yellow

# Clear log to get clean output
Clear-Content _Logs/praxis.log -ErrorAction SilentlyContinue

# Start PRAXIS
Write-Host "Starting PRAXIS..." -ForegroundColor Green
timeout 30s pwsh -File Start.ps1 -Debug || pwsh -File Start.ps1 -Debug

Write-Host ""  
Write-Host "=== Log Analysis ===" -ForegroundColor Cyan

# Check if any keys were pressed
Write-Host "Keys pressed:" -ForegroundColor Yellow
grep "Key pressed:" _Logs/praxis.log | tail -5

# Check if TabContainer handled any switching
Write-Host ""
Write-Host "Tab switching attempts:" -ForegroundColor Yellow  
grep -i "tab.*switch\|activate.*tab" _Logs/praxis.log | tail -5

# Check ShortcutManager activity
Write-Host ""
Write-Host "ShortcutManager activity:" -ForegroundColor Yellow
grep "ShortcutManager" _Logs/praxis.log | tail -5


