####\Actions/AppendFieldAction.ps1
# AppendFieldAction.ps1 - Adds a calculated field to the database
# Core data cleaning action for Phase 0

class AppendFieldAction : BaseAction {
    AppendFieldAction() : base() {
        $this.Name = "Append Calculated Field"
        $this.Description = "Adds a new field based on a calculation or equation"
        $this.Category = "Data Cleaning"
        $this.Icon = "‚ûï"
        
        $this.Consumes = @(
            @{
                Name = "fieldName"
                Type = "String"
                Description = "Name for the new field"
            },
            @{
                Name = "fieldEquation"
                Type = "String"
                Description = "IDEA equation for the field calculation"
            },
            @{
                Name = "fieldType"
                Type = "String"
                Description = "Data type: Character, Numeric, Date, Logical"
            },
            @{
                Name = "fieldLength"
                Type = "String"
                Description = "Field length (optional, for Character fields)"
            }
        )
        
        $this.Produces = @(
            @{
                Name = "newField"
                Type = "Field"
                Description = "The newly created field"
            }
        )
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        $fieldName = $macroContext["fieldName"]
        $equation = $macroContext["fieldEquation"]
        $fieldType = $macroContext["fieldType"]
        $fieldLength = $macroContext["fieldLength"]
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Build the append field script
        $sb.AppendLine("Set db = Client.OpenDatabase(""$($macroContext['ActiveDatabase'])"")")
        $sb.AppendLine("Set task = db.TableManagement.AppendDatabase")
        
        # Set field properties
        $sb.AppendLine("task.AddFieldToAppend ""$fieldName"", ""$equation""")
        
        # Set field type
        switch ($fieldType.ToUpper()) {
            "CHARACTER" { 
                $length = if ($fieldLength) { $fieldLength } else { "50" }
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_CHAR_FIELD, $length")
            }
            "NUMERIC" { 
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_VIRT_NUM_FIELD")
            }
            "DATE" { 
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_VIRT_DATE_FIELD")
            }
            "LOGICAL" { 
                $sb.AppendLine("task.SetFieldType ""$fieldName"", WI_VIRT_BOOL_FIELD")
            }
        }
        
        # Execute the task
        $sb.AppendLine("task.PerformTask")
        $sb.AppendLine("Set db = Nothing")
        $sb.AppendLine("Set task = Nothing")
        
        return $sb.ToString()
    }
}


####\Actions/CustomIdeaCommandAction.ps1
# CustomIdeaCommandAction.ps1 - Allows insertion of custom IDEA@ commands from CommandLibrary
# Integrates with existing CommandService to pull available commands

class CustomIdeaCommandAction : BaseAction {
    [string]$SelectedCommand = ""
    [hashtable]$CommandParameters = @{}
    
    CustomIdeaCommandAction() : base() {
        $this.Name = "Custom IDEA@ Command"
        $this.Description = "Execute a custom IDEA@ command from your command library or type in manually"
        $this.Category = "Custom"
        $this.Icon = "üìù"
        $this.AllowsCustomCommands = $true
        
        # This action is flexible - consumes/produces depend on the selected command
        $this.Consumes = @()
        $this.Produces = @()
    }
    
    # Set the command to execute
    [void] SetCommand([string]$commandText) {
        $this.SelectedCommand = $commandText
        $this.UpdateDataContract()
    }
    
    # Update Consumes/Produces based on selected command
    [void] UpdateDataContract() {
        # Clear existing contracts
        $this.Consumes = @()
        $this.Produces = @()
        
        if ([string]::IsNullOrWhiteSpace($this.SelectedCommand)) {
            return
        }
        
        # Parse command for @function references and add as requirements
        $functions = $this.ExtractFunctions($this.SelectedCommand)
        foreach ($func in $functions) {
            $this.Consumes += @{
                Name = $func
                Type = "Variable"
                Description = "Value for $func"
            }
        }
        
        # Most IDEA@ commands produce some kind of output
        # This is generic since we don't know the specific command's output
        $this.Produces += @{
            Name = "commandResult"
            Type = "Unknown"
            Description = "Result of custom IDEA@ command"
        }
    }
    
    # Extract @function references from command text
    [string[]] ExtractFunctions([string]$commandText) {
        $functions = @()
        $pattern = '@(\w+(?:\([^)]*\))?)'
        $matches = [regex]::Matches($commandText, $pattern)
        
        foreach ($match in $matches) {
            $functions += $match.Groups[1].Value
        }
        
        return $functions
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        if ([string]::IsNullOrWhiteSpace($this.SelectedCommand)) {
            return "' No command specified"
        }
        
        $scriptText = $this.SelectedCommand
        
        # Replace @function references with values from macro context
        $functions = $this.ExtractFunctions($scriptText)
        foreach ($func in $functions) {
            if ($macroContext.ContainsKey($func)) {
                $value = $macroContext[$func]
                $scriptText = $scriptText.Replace("@$func", $value)
            }
        }
        
        # Add comment with original command for reference
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine("' Custom IDEA@ Command: $($this.SelectedCommand)")
        $sb.AppendLine($scriptText)
        
        return $sb.ToString()
    }
    
    # Get available commands from CommandService
    [System.Collections.ArrayList] GetAvailableCommands([object]$commandService) {
        if (-not $commandService) {
            return [System.Collections.ArrayList]::new()
        }
        
        # Filter commands that are IDEA@ related
        $ideaCommands = [System.Collections.ArrayList]::new()
        foreach ($command in $commandService.Commands) {
            # Look for commands that contain IDEA@ syntax or are tagged as IDEA commands
            if ($command.Command -match '@\w+' -or 
                $command.Tags -contains "idea" -or 
                $command.Tags -contains "ideascript" -or
                $command.Group -eq "IDEA") {
                $ideaCommands.Add($command) | Out-Null
            }
        }
        
        return $ideaCommands
    }
}


####\Actions/ExportToExcelAction.ps1
# ExportToExcelAction.ps1 - Exports current database to Excel
# Data I/O action for Phase 0

class ExportToExcelAction : BaseAction {
    ExportToExcelAction() : base() {
        $this.Name = "Export to Excel"
        $this.Description = "Exports the current database to an Excel file"
        $this.Category = "Data I/O"
        $this.Icon = "üìà"
        
        $this.Consumes = @(
            @{
                Name = "outputPath"
                Type = "String"
                Description = "Full path for the output Excel file"
            },
            @{
                Name = "includeAllRecords"
                Type = "Boolean"
                Description = "Include all records or only extracted ones"
            }
        )
        
        $this.Produces = @(
            @{
                Name = "excelFile"
                Type = "File"
                Description = "The created Excel file"
            }
        )
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        $outputPath = $macroContext["outputPath"]
        $includeAll = $macroContext["includeAllRecords"]
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Build the export script
        $sb.AppendLine("Set db = Client.OpenDatabase(""$($macroContext['ActiveDatabase'])"")")
        $sb.AppendLine("Set task = db.ExternalFiles.ExcelFiles.NewExport")
        
        # Set output file
        $sb.AppendLine("task.OutputFileName = ""$outputPath""")
        
        # Set record selection
        if ($includeAll -eq "True" -or $includeAll -eq $true) {
            $sb.AppendLine("task.UseAllRecords")
        } else {
            $sb.AppendLine("task.UseExtractedRecords")
        }
        
        # Export all fields
        $sb.AppendLine("task.UseAllFields")
        
        # Execute the export
        $sb.AppendLine("task.PerformTask")
        $sb.AppendLine("Set db = Nothing")
        $sb.AppendLine("Set task = Nothing")
        
        return $sb.ToString()
    }
}


####\Actions/SummarizationAction.ps1
# SummarizationAction.ps1 - Performs IDEA summarization operation
# One of the core Phase 0 actions for data analysis

class SummarizationAction : BaseAction {
    SummarizationAction() : base() {
        $this.Name = "Summarization"
        $this.Description = "Summarizes data by grouping fields and calculating totals"
        $this.Category = "Core Analysis"
        $this.Icon = "üìä"
        
        $this.Consumes = @(
            @{
                Name = "summaryFields"
                Type = "FieldList"
                Description = "Fields to group by in the summarization"
            },
            @{
                Name = "totalFields"
                Type = "FieldList"
                Description = "Numeric fields to total (optional)"
            },
            @{
                Name = "outputDatabase"
                Type = "String"
                Description = "Name for the output database"
            }
        )
        
        $this.Produces = @(
            @{
                Name = "summaryResult"
                Type = "Database"
                Description = "Database containing summarized results"
            }
        )
    }
    
    [string] RenderScript([hashtable]$macroContext) {
        $summaryFields = $macroContext["summaryFields"]
        $totalFields = $macroContext["totalFields"]
        $outputDb = $macroContext["outputDatabase"]
        
        $sb = [System.Text.StringBuilder]::new()
        
        # Build the summarization script
        $sb.AppendLine("Set db = Client.OpenDatabase(""$($macroContext['ActiveDatabase'])"")")
        $sb.AppendLine("Set task = db.Summarization")
        
        # Add grouping fields
        if ($summaryFields) {
            $sb.AppendLine("task.AddFieldToSummarize ""$summaryFields""")
        }
        
        # Add total fields if specified
        if ($totalFields -and $totalFields -ne "") {
            $sb.AppendLine("task.AddFieldToTotal ""$totalFields""")
        }
        
        # Set output database
        $sb.AppendLine("task.OutputDBName = ""$outputDb""")
        
        # Execute the task
        $sb.AppendLine("task.CreatePercentage = False")
        $sb.AppendLine("task.AppendDB = True")
        $sb.AppendLine("dbName = task.Run()")
        $sb.AppendLine("Set db = Nothing")
        $sb.AppendLine("Set task = Nothing")
        
        return $sb.ToString()
    }
}


####\Base/BaseDialog.ps1
# BaseDialog.ps1 - Base class for modal dialogs to eliminate code duplication

class BaseDialog : Screen {
    # Dialog properties
    [int]$DialogWidth = 50
    [int]$DialogHeight = 14
    [int]$DialogPadding = 2
    [int]$ButtonHeight = 3
    [int]$ButtonSpacing = 2
    [int]$MaxButtonWidth = 12
    
    # Common buttons
    [Button]$PrimaryButton
    [Button]$SecondaryButton
    [string]$PrimaryButtonText = "OK"
    [string]$SecondaryButtonText = "Cancel"
    
    # Event handlers
    [scriptblock]$OnPrimary = {}
    [scriptblock]$OnSecondary = {}
    [scriptblock]$OnCreate = {}  # Legacy support
    [scriptblock]$OnCancel = {}  # Legacy support
    
    # Internal state
    hidden [hashtable]$_dialogBounds = @{}
    hidden [System.Collections.ArrayList]$_contentControls
    hidden [bool]$_initialized = $false
    [EventBus]$EventBus
    
    BaseDialog([string]$title) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    BaseDialog([string]$title, [int]$width, [int]$height) : base() {
        $this.Title = $title
        $this.DrawBackground = $true
        $this.DialogWidth = $width
        $this.DialogHeight = $height
        $this._contentControls = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Prevent double initialization
        if ($this._initialized) {
            return
        }
        $this._initialized = $true
        
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create default buttons
        $this.CreateDefaultButtons()
        
        # Call derived class initialization
        $this.InitializeContent()
    }
    
    # Virtual method for derived classes to override
    [void] InitializeContent() {
        # Override in derived classes
    }
    
    [void] CreateDefaultButtons() {
        # Create primary button
        $this.PrimaryButton = [Button]::new($this.PrimaryButtonText)
        $this.PrimaryButton.IsDefault = $true
        $dialog = $this  # Capture reference
        $this.PrimaryButton.OnClick = {
            $dialog.HandlePrimaryAction()
        }.GetNewClosure()
        $this.PrimaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.PrimaryButton)
        
        # Create secondary button
        $this.SecondaryButton = [Button]::new($this.SecondaryButtonText)
        $this.SecondaryButton.OnClick = {
            $dialog.HandleSecondaryAction()
        }.GetNewClosure()
        $this.SecondaryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SecondaryButton)
    }
    
    [void] AddContentControl([UIElement]$control, [int]$tabIndex = -1) {
        if ($tabIndex -gt 0) {
            $control.TabIndex = $tabIndex
        }
        $control.Initialize($global:ServiceContainer)
        $this.AddChild($control)
        $this._contentControls.Add($control) | Out-Null
    }
    
    [void] HandlePrimaryAction() {
        # Call custom handler first
        if ($this.OnPrimary -and $this.OnPrimary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnPrimary
        }
        
        # Legacy support
        if ($this.OnCreate -and $this.OnCreate.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCreate
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] HandleSecondaryAction() {
        # Call custom handler first
        if ($this.OnSecondary -and $this.OnSecondary.GetType().Name -eq 'ScriptBlock') {
            & $this.OnSecondary
        }
        
        # Legacy support  
        if ($this.OnCancel -and $this.OnCancel.GetType().Name -eq 'ScriptBlock') {
            & $this.OnCancel
        }
        
        # Default behavior - close dialog
        $this.CloseDialog()
    }
    
    [void] CloseDialog() {
        if ($global:ScreenManager) {
            $global:ScreenManager.Pop()
        }
    }
    
    # PARENT-DELEGATED INPUT MODEL (inherits from Screen)
    # Dialog shortcuts are handled via HandleScreenInput
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Dialog-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                if (-not $key.Modifiers) {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleSecondaryAction()
                return $true
            }
        }
        return $false
    }
    
    [void] OnActivated() {
        # Publish dialog opened event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::DialogOpened, @{ 
                Dialog = $this.GetType().Name
            })
        }
        
        # Focus first content control
        if ($this._contentControls.Count -gt 0) {
            $this._contentControls[0].Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog position (centered)
        $centerX = [int](($this.Width - $this.DialogWidth) / 2)
        $centerY = [int](($this.Height - $this.DialogHeight) / 2)
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $this.DialogWidth
            Height = $this.DialogHeight
        }
        
        # Position content controls
        $this.PositionContentControls($centerX, $centerY)
        
        # Position buttons
        $this.PositionButtons($centerX, $centerY)
    }
    
    # Virtual method for derived classes to override content positioning
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Default implementation - stack controls vertically
        $currentY = $dialogY + $this.DialogPadding
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $controlHeight = 3
        
        foreach ($control in $this._contentControls) {
            $control.SetBounds(
                $dialogX + $this.DialogPadding,
                $currentY,
                $controlWidth,
                $controlHeight
            )
            $currentY += $controlHeight + 1
        }
    }
    
    [void] PositionButtons([int]$dialogX, [int]$dialogY) {
        # Calculate button positioning
        $buttonY = $dialogY + $this.DialogHeight - $this.ButtonHeight - 1
        $totalButtonWidth = ($this.MaxButtonWidth * 2) + $this.ButtonSpacing
        
        # Center buttons if dialog is wide enough
        if ($this.DialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $dialogX + [int](($this.DialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $this.MaxButtonWidth
        } else {
            $buttonStartX = $dialogX + $this.DialogPadding
            $buttonWidth = [int](($this.DialogWidth - ($this.DialogPadding * 2) - $this.ButtonSpacing) / 2)
        }
        
        # Position primary button
        $this.PrimaryButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        # Position secondary button
        $this.SecondaryButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024  # Dialogs need moderate capacity
        
        # Render overlay background
        $this.RenderOverlay($sb)
        
        # Render dialog box
        if ($this._dialogBounds.Count -gt 0) {
            $this.RenderDialogBox($sb)
            $this.RenderTitle($sb)
        }
        
        # Render children (content controls and buttons) only within dialog bounds
        $this.RenderDialogChildren($sb)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [void] RenderOverlay([System.Text.StringBuilder]$sb) {
        # Dark overlay background
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
    }
    
    [void] RenderDialogBox([System.Text.StringBuilder]$sb) {
        $borderColor = $this.Theme.GetColor("dialog.border")
        $bgColor = $this.Theme.GetBgColor("dialog.background")
        
        $x = $this._dialogBounds.X
        $y = $this._dialogBounds.Y
        $w = $this._dialogBounds.Width
        $h = $this._dialogBounds.Height
        
        # Fill background
        for ($i = 0; $i -lt $h; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($w))
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo($x, $y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($w - 2) + [VT]::TR())
        
        for ($i = 1; $i -lt $h - 1; $i++) {
            $sb.Append([VT]::MoveTo($x, $y + $i))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo($x, $y + $h - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($w - 2) + [VT]::BR())
    }
    
    [void] RenderTitle([System.Text.StringBuilder]$sb) {
        if (-not [string]::IsNullOrEmpty($this.Title)) {
            $titleColor = $this.Theme.GetColor("dialog.title")
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            
            # Calculate title position (centered)
            $titleText = " $($this.Title) "
            $titleX = $x + [int](($w - $titleText.Length) / 2)
            
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($titleText)
        }
    }
    
    [void] RenderDialogChildren([System.Text.StringBuilder]$sb) {
        # Render all visible children - they should be positioned correctly by OnBoundsChanged
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
    }
}


####\Base/BaseModel.ps1
# BaseModel.ps1 - Base class for all data models to standardize common properties

class BaseModel {
    [string]$Id
    [DateTime]$CreatedAt
    [DateTime]$UpdatedAt
    [bool]$Deleted = $false
    
    BaseModel() {
        $this.Id = [guid]::NewGuid().ToString()
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    BaseModel([string]$id) {
        $this.Id = $id
        $this.CreatedAt = Get-Date
        $this.UpdatedAt = $this.CreatedAt
    }
    
    # Method to update the UpdatedAt timestamp when model is modified
    [void] MarkAsUpdated() {
        $this.UpdatedAt = Get-Date
    }
    
    # Method to soft delete the model
    [void] SoftDelete() {
        $this.Deleted = $true
        $this.MarkAsUpdated()
    }
    
    # Method to restore a soft deleted model
    [void] Restore() {
        $this.Deleted = $false
        $this.MarkAsUpdated()
    }
    
    # Helper method to check if model is active (not deleted)
    [bool] IsActive() {
        return -not $this.Deleted
    }
    
    # Helper method to get age of the model
    [TimeSpan] GetAge() {
        return (Get-Date) - $this.CreatedAt
    }
    
    # Helper method to get time since last update
    [TimeSpan] GetTimeSinceUpdate() {
        return (Get-Date) - $this.UpdatedAt
    }
}


####\Base/Container.ps1
# Container.ps1 - Base class for components that contain other components
# Optimized for fast string aggregation

class Container : UIElement {
    # Optional background
    [bool]$DrawBackground = $false
    hidden [string]$_cachedBackground = ""
    hidden [string]$_cachedBgColor = ""
    hidden [ThemeManager]$Theme
    
    Container() : base() {
    }
    
    # Efficient child rendering with string builder
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Draw background if enabled
        if ($this.DrawBackground -and $this._cachedBackground) {
            $sb.Append($this._cachedBackground)
        }
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Pre-compute background
    [void] SetBackgroundColor([string]$ansiColor) {
        $this._cachedBgColor = $ansiColor
        $this.InvalidateBackground()
    }
    
    [void] InvalidateBackground() {
        if (-not $this.DrawBackground -or $this.Width -le 0 -or $this.Height -le 0) { 
            $this._cachedBackground = ""
            return 
        }
        
        $sb = Get-PooledStringBuilder ($this.Width * $this.Height * 2)
        $line = [StringCache]::GetSpaces($this.Width)
        
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            if ($this._cachedBgColor) {
                $sb.Append($this._cachedBgColor)
            }
            $sb.Append($line)
        }
        
        if ($this._cachedBgColor) {
            $sb.Append([VT]::Reset())
        }
        
        $this._cachedBackground = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    [void] OnBoundsChanged() {
        # Recalculate background when size changes
        if ($this.DrawBackground) {
            $this.InvalidateBackground()
        }
        
        # Let derived classes handle child layout
        $this.LayoutChildren()
    }
    
    # Override in derived classes for custom layouts
    [void] LayoutChildren() {
        # Base implementation does nothing
        # Derived classes like HorizontalSplit, VerticalSplit, etc. will implement
    }
    
    # Find child at specific coordinates
    [UIElement] HitTest([int]$x, [int]$y) {
        # Check if point is within our bounds
        if ($x -lt $this.X -or $x -ge ($this.X + $this.Width) -or
            $y -lt $this.Y -or $y -ge ($this.Y + $this.Height)) {
            return $null
        }
        
        # Check children in reverse order (top to bottom)
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                $hit = if ($child -is [Container]) {
                    $child.HitTest($x, $y)
                } else {
                    # Non-containers do simple bounds check
                    if ($x -ge $child.X -and $x -lt ($child.X + $child.Width) -and
                        $y -ge $child.Y -and $y -lt ($child.Y + $child.Height)) {
                        $child
                    } else {
                        $null
                    }
                }
                
                if ($hit) { return $hit }
            }
        }
        
        # No child hit, return self
        return $this
    }
    
    # Route input to focused child
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Debug logging removed for performance
        
        # Simple rule: Let focused child handle first
        $focused = $this.FindFocusedChild()
        if ($focused) {
            if ($global:Logger) {
                $global:Logger.Debug("Container: Routing to focused child $($focused.GetType().Name)")
            }
            return $focused.HandleInput($key)
        }
        
        # No focused child
        return $false
    }
    
    # Find direct focused child (not deep search)
    [UIElement] FindFocusedChild() {
        foreach ($child in $this.Children) {
            if ($child.Visible -and $child.IsFocused) {
                if ($global:Logger) {
                    $global:Logger.Debug("Container.FindFocusedChild: Found focused child $($child.GetType().Name)")
                }
                return $child
            }
        }
        if ($global:Logger) {
            $global:Logger.Debug("Container.FindFocusedChild: No focused child found among $($this.Children.Count) children")
        }
        return $null
    }
    
    # Parent-delegated focus navigation
    [void] FocusNextChild([UIElement]$currentChild) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.FocusNextChild: Type=$($this.GetType().Name), CurrentChild=$($currentChild.GetType().Name)")
        }
        
        # For containers, we need to consider both focusable children AND containers
        $allChildren = $this.Children | Where-Object { $_.Visible }
        $currentIndex = -1
        
        # Find current child index
        for ($i = 0; $i -lt $allChildren.Count; $i++) {
            if ($allChildren[$i] -eq $currentChild) {
                $currentIndex = $i
                break
            }
        }
        
        if ($currentIndex -eq -1) {
            # Current child not found, shouldn't happen
            return
        }
        
        # Look for next child that either is focusable or contains focusable elements
        for ($i = $currentIndex + 1; $i -lt $allChildren.Count; $i++) {
            $child = $allChildren[$i]
            if ($child.IsFocusable) {
                $child.Focus()
                return
            } elseif ($child -is [Container]) {
                # Try to focus first element in this container
                $child.FocusFirstInTree()
                if ($this.GetRoot().FindFocused()) {
                    return  # Focus was set
                }
            }
        }
        
        # No next child found, bubble up or wrap
        if ($this.Parent) {
            $this.Parent.FocusNextChild($this)
        } else {
            # We're at root, wrap to beginning
            $this.FocusFirstInTree()
        }
    }
    
    [void] FocusPreviousChild([UIElement]$currentChild) {
        if ($global:Logger) {
            $global:Logger.Debug("Container.FocusPreviousChild: Type=$($this.GetType().Name), CurrentChild=$($currentChild.GetType().Name)")
        }
        
        # For containers, we need to consider both focusable children AND containers
        $allChildren = $this.Children | Where-Object { $_.Visible }
        $currentIndex = -1
        
        # Find current child index
        for ($i = 0; $i -lt $allChildren.Count; $i++) {
            if ($allChildren[$i] -eq $currentChild) {
                $currentIndex = $i
                break
            }
        }
        
        if ($currentIndex -eq -1) {
            # Current child not found, shouldn't happen
            return
        }
        
        # Look for previous child that either is focusable or contains focusable elements
        for ($i = $currentIndex - 1; $i -ge 0; $i--) {
            $child = $allChildren[$i]
            if ($child.IsFocusable) {
                $child.Focus()
                return
            } elseif ($child -is [Container]) {
                # Try to focus last element in this container
                $child.FocusLastInTree()
                if ($this.GetRoot().FindFocused()) {
                    return  # Focus was set
                }
            }
        }
        
        # No previous child found, bubble up or wrap
        if ($this.Parent) {
            $this.Parent.FocusPreviousChild($this)
        } else {
            # We're at root, wrap to end
            $this.FocusLastInTree()
        }
    }
    
    # Focus first focusable child
    [void] FocusFirst() {
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
        }
    }
    
    # Focus first focusable element in the entire tree
    [void] FocusFirstInTree() {
        # First check if any direct children are focusable
        $focusable = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible } | Select-Object -First 1
        if ($focusable) {
            $focusable.Focus()
            return
        }
        
        # Otherwise check children's children
        foreach ($child in $this.Children) {
            if ($child -is [Container] -and $child.Visible) {
                $child.FocusFirstInTree()
                # If focus was set, we're done
                $root = $this.GetRoot()
                if ($root.FindFocused()) {
                    return
                }
            }
        }
    }
    
    # Focus last focusable element in the entire tree
    [void] FocusLastInTree() {
        # Check children in reverse order
        for ($i = $this.Children.Count - 1; $i -ge 0; $i--) {
            $child = $this.Children[$i]
            if ($child.Visible) {
                if ($child -is [Container]) {
                    # Recurse into container
                    $child.FocusLastInTree()
                    # If focus was set, we're done
                    $root = $this.GetRoot()
                    if ($root.FindFocused()) {
                        return
                    }
                } elseif ($child.IsFocusable) {
                    $child.Focus()
                    return
                }
            }
        }
    }
}


####\Base/Screen.ps1
# Screen.ps1 - Base class for all screens
# Simplified from ALCAR with focus on speed

class Screen : Container {
    [string]$Title = "Screen"
    [bool]$Active = $true
    hidden [hashtable]$_keyBindings = @{}
    hidden [ThemeManager]$Theme
    
    # Protected service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    Screen() : base() {
        $this.IsFocusable = $false  # Screens are containers, not focusable elements
        $this.DrawBackground = $true
    }
    
    # Initialize with services
    [void] Initialize([ServiceContainer]$services) {
        # Call base initialization
        ([UIElement]$this).Initialize($services)
        
        # Screen-specific initialization
        $this.Theme = $services.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    # Helper method for service access with error handling
    [object] GetService([string]$serviceName) {
        if (-not $this.ServiceContainer) {
            if ($global:Logger) {
                $global:Logger.Warning("Screen.GetService: ServiceContainer not available, falling back to global access for $serviceName")
            }
            return $global:ServiceContainer.GetService($serviceName)
        }
        return $this.ServiceContainer.GetService($serviceName)
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Theme change handler
    [void] OnThemeChanged() {
        # Use background color for screen background
        $bgColor = $this.Theme.GetBgColor("background")
        $this.SetBackgroundColor($bgColor)
        $this.InvalidateBackground()
        $this.Invalidate()
    }
    
    # Override this method in derived screens to handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        return $false  # Base implementation - no screen-specific handling
    }
    
    # PARENT-DELEGATED INPUT MODEL
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        # Debug logging removed for performance
        
        # 1. Let focused child handle first (components get priority)
        $handled = ([Container]$this).HandleInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen base handled: $handled")
        }
        if ($handled) {
            return $true
        }
        
        # 2. Screen shortcuts as fallback only
        $screenHandled = $this.HandleScreenInput($keyInfo)
        if ($global:Logger) {
            $global:Logger.Debug("Screen shortcuts handled: $screenHandled")
        }
        return $screenHandled
    }
    
    # Lifecycle methods - simple and fast
    [void] OnActivated() {
        # Force a render when screen is activated
        $this.Invalidate()
    }
    
    [void] OnDeactivated() {
        # Override in derived classes if needed
    }
    
    # Removed old FocusNext/FocusPrevious - now handled by parent delegation
    
    # Delegate to Container's FocusFirst
    [void] FocusFirst() {
        ([Container]$this).FocusFirst()
    }

    # Request a re-render
    [void] RequestRender() {
        $this.Invalidate()
        # The ScreenManager will handle the actual rendering
    }
}


####\Base/UIElement.ps1
# UIElement.ps1 - Fast base class for all UI components
# Inspired by AxiomPhoenix architecture but optimized for string-based rendering

class UIElement {
    # Position and dimensions
    [int]$X = 0
    [int]$Y = 0
    [int]$Width = 0
    [int]$Height = 0
    
    # Visibility and focus
    [bool]$Visible = $true
    [bool]$IsFocusable = $false
    [bool]$IsFocused = $false
    [int]$TabIndex = 0
    
    # Hierarchy
    [UIElement]$Parent = $null
    [System.Collections.Generic.List[UIElement]]$Children
    
    # Service container for dependency injection
    hidden [ServiceContainer]$ServiceContainer
    
    # Caching for maximum speed
    hidden [string]$_renderCache = ""
    hidden [bool]$_cacheInvalid = $true
    
    # Pre-computed values
    hidden [string]$_cachedPosition = ""
    hidden [string]$_cachedClear = ""
    
    UIElement() {
        $this.Children = [System.Collections.Generic.List[UIElement]]::new()
    }
    
    # Fast render - returns cached string if valid
    [string] Render() {
        if (-not $this.Visible) { return "" }
        
        if ($this._cacheInvalid) {
            # Rebuild cache only when needed
            $this._renderCache = $this.OnRender()
            $this._cacheInvalid = $false
        }
        
        return $this._renderCache
    }
    
    # Override in derived classes
    [string] OnRender() {
        return ""
    }
    
    # Mark this element (and parents) as needing re-render
    [void] Invalidate() {
        if ($this._cacheInvalid) { return }  # Already invalid
        
        $this._cacheInvalid = $true
        $this.InvalidatePosition()  # Position might have changed too
        
        # Propagate up the tree
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
        
        # Render request is handled by propagation to root
    }
    
    # Pre-compute position strings
    [void] InvalidatePosition() {
        # Pre-compute ANSI sequences for this element's position
        $this._cachedPosition = [VT]::MoveTo($this.X, $this.Y)
        
        # Pre-compute clear sequence for this element's area
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $clearLine = [StringCache]::GetSpaces($this.Width)
            $clearSeq = Get-PooledStringBuilder ($this.Height * ($this.Width + 10))
            for ($i = 0; $i -lt $this.Height; $i++) {
                $clearSeq.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $clearSeq.Append($clearLine)
            }
            $this._cachedClear = $clearSeq.ToString()
            Return-PooledStringBuilder $clearSeq
        } else {
            $this._cachedClear = ""
        }
    }
    
    # Layout management
    [void] SetBounds([int]$x, [int]$y, [int]$width, [int]$height) {
        if ($this.X -eq $x -and $this.Y -eq $y -and 
            $this.Width -eq $width -and $this.Height -eq $height) {
            return  # No change
        }
        
        $this.X = $x
        $this.Y = $y
        $this.Width = $width
        $this.Height = $height
        
        $this.InvalidatePosition()
        $this.Invalidate()
        $this.OnBoundsChanged()
    }
    
    # Override for custom layout logic
    [void] OnBoundsChanged() {
        # Base implementation does nothing
    }
    
    # Child management - now invalidates focus cache
    [void] AddChild([UIElement]$child) {
        $child.Parent = $this
        $this.Children.Add($child)
        
        # No focus cache invalidation needed - using simple direct focus
        
        $this.Invalidate()
    }
    
    [void] RemoveChild([UIElement]$child) {
        $child.Parent = $null
        $this.Children.Remove($child)
        
        # No focus cache invalidation needed - using simple direct focus
        
        $this.Invalidate()
    }
    
    # Simple focus management - works with PowerShell patterns
    [void] Focus() {
        if (-not $this.IsFocusable -or -not $this.Visible) { 
            if ($global:Logger) {
                $global:Logger.Debug("UIElement.Focus: Cannot focus $($this.GetType().Name) - IsFocusable=$($this.IsFocusable), Visible=$($this.Visible)")
            }
            return 
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("UIElement.Focus: Focusing $($this.GetType().Name)")
        }
        
        # Find root and clear any existing focus
        $root = $this
        while ($root.Parent) { $root = $root.Parent }
        $current = $this.FindFocusedElement($root)
        if ($current -and $current -ne $this) {
            $current.IsFocused = $false
            $current.OnLostFocus()
            $current.Invalidate()
        }
        
        # Focus this element
        $this.IsFocused = $true
        $this.OnGotFocus()
        $this.Invalidate()
    }
    
    # Find focused element in tree
    [UIElement] FindFocusedElement([UIElement]$element) {
        if ($element.IsFocused) { return $element }
        foreach ($child in $element.Children) {
            $found = $this.FindFocusedElement($child)
            if ($found) { return $found }
        }
        return $null
    }
    
    [UIElement] GetRoot() {
        $current = $this
        while ($current.Parent) {
            $current = $current.Parent
        }
        return $current
    }
    
    [UIElement] FindFocused() {
        if ($this.IsFocused) { return $this }
        
        foreach ($child in $this.Children) {
            $focused = $child.FindFocused()
            if ($focused) { return $focused }
        }
        
        return $null
    }
    
    # Override for focus behavior
    [void] OnGotFocus() {}
    [void] OnLostFocus() {}
    
    # Initialize with service container
    [void] Initialize([ServiceContainer]$services) {
        $this.ServiceContainer = $services
        $this.OnInitialize()
    }
    
    # Override for custom initialization
    [void] OnInitialize() {}
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Base implementation does nothing
        return $false
    }
}


####\Components/Button.ps1
# Button.ps1 - Fast button component with theming

class Button : UIElement {
    [string]$Text = "Button"
    [scriptblock]$OnClick = {}
    [bool]$IsDefault = $false
    
    # Cached rendering
    hidden [string]$_cachedRender = ""
    hidden [ThemeManager]$Theme
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    # Cached theme colors
    hidden [hashtable]$_colors = @{}
    
    Button() : base() {
        $this.IsFocusable = $true
        $this.Height = 3  # Default button height
    }
    
    Button([string]$text) : base() {
        $this.Text = $text
        $this.IsFocusable = $true
        $this.Height = 3
        if ($global:Logger) {
            $global:Logger.Debug("Button created with text: '$text'")
        }
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.Invalidate()  # Force initial render
    }
    
    [void] OnThemeChanged() {
        # Cache colors on theme change
        if ($this.Theme) {
            $this._colors = @{
                "button.background" = $this.Theme.GetBgColor("button.background")
                "button.foreground" = $this.Theme.GetColor("button.foreground")
                "button.focused.background" = $this.Theme.GetBgColor("button.focused.background")
                "button.focused.foreground" = $this.Theme.GetColor("button.focused.foreground")
                "border" = $this.Theme.GetColor("border")
                "border.focused" = $this.Theme.GetColor("border.focused")
                "accent" = $this.Theme.GetColor("accent")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Method to properly track text changes
    [void] SetText([string]$text) {
        if ($this.Text -ne $text) {
            $this.Text = $text
            $this._dataVersion++  # Increment on text change
            $this.Invalidate()
        }
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        # Debug logging removed for performance
        
        # Return early if Theme is not initialized
        if (-not $this.Theme) {
            $this._cachedRender = ""
            return
        }
        
        $sb = Get-PooledStringBuilder 512  # Button rendering typically needs small capacity
        
        # Determine colors based on state
        $bgColor = ""
        $fgColor = ""
        $borderColor = ""
        
        if ($this.IsFocused) {
            $bgColor = $this._colors["button.focused.background"]
            $fgColor = $this._colors["button.focused.foreground"]
            $borderColor = $this._colors["border.focused"]
        } else {
            $bgColor = $this._colors["button.background"]
            $fgColor = $this._colors["button.foreground"]
            $borderColor = $this._colors["border"]
        }
        
        # Calculate text position (centered)
        $textX = $this.X + [Math]::Max(1, [int](($this.Width - $this.Text.Length) / 2))
        $textY = $this.Y + 1  # For height=3, text should be on the middle line
        
        # Debug logging removed for performance
        
        # Draw button box
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $borderWidth = [Math]::Max(0, $this.Width - 2)
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($borderWidth) + [VT]::TR())
        } else {
            $sb.Append([VT]::TL() + [VT]::TR())
        }
        
        # Middle lines
        for ($y = $this.Y + 1; $y -lt $this.Y + $this.Height - 1; $y++) {
            # Debug logging removed for performance
            
            $sb.Append([VT]::MoveTo($this.X, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Fill line with background, but handle text line specially
            if ($y -eq $textY -and $this.Text) {
                # Draw background up to text
                $sb.Append($bgColor)
                $textStartOffset = [Math]::Max(0, ($this.Width - $this.Text.Length) / 2) - 1
                if ($textStartOffset -gt 0) {
                    $sb.Append([StringCache]::GetSpaces([int]$textStartOffset))
                }
                
                # Draw text
                $sb.Append($fgColor)
                $sb.Append($this.Text)
                
                # Fill rest of line
                $sb.Append($bgColor)
                $remainingSpace = $this.Width - 2 - [int]$textStartOffset - $this.Text.Length
                if ($remainingSpace -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($remainingSpace))
                }
            } else {
                # Non-text lines - just fill with background
                $sb.Append($bgColor)
                $paddingWidth = [Math]::Max(0, $this.Width - 2)
                if ($paddingWidth -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($paddingWidth))
                }
            }
            
            # Draw right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            $sb.Append([VT]::Reset())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        if ($borderWidth -gt 0) {
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($borderWidth) + [VT]::BR())
        } else {
            $sb.Append([VT]::BL() + [VT]::BR())
        }
        
        # Add default indicator if needed
        if ($this.IsDefault) {
            $sb.Append([VT]::MoveTo($this.X + 1, $this.Y))
            $sb.Append($this._colors["accent"])
            $sb.Append("*")
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            if ($key.Key -eq [System.ConsoleKey]::Enter -or 
                $key.Key -eq [System.ConsoleKey]::Spacebar) {
                $this.Click()
                return $true
            }
            return $false
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    [void] Click() {
        try {
            if ($this.OnClick) {
                & $this.OnClick
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Button.Click: Error executing OnClick handler - $($_.Exception.Message)")
            }
        }
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/CommandPalette.ps1
# CommandPalette.ps1 - Fast command palette overlay

class CommandPalette : Container {
    [string]$SearchText = ""
    [ListBox]$ResultsList
    [System.Collections.ArrayList]$AllCommands
    [System.Collections.ArrayList]$FilteredCommands
    [scriptblock]$OnCommandSelected = {}
    [bool]$IsVisible = $false
    [EventBus]$EventBus
    [ThemeManager]$Theme
    
    # Layout
    hidden [int]$PaletteWidth = 60
    hidden [int]$PaletteHeight = 20
    hidden [int]$MaxResults = 15
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    CommandPalette() : base() {
        $this.AllCommands = [System.Collections.ArrayList]::new()
        $this.FilteredCommands = [System.Collections.ArrayList]::new()
        $this.DrawBackground = $true
        
        # Create results list
        $this.ResultsList = [ListBox]::new()
        $this.ResultsList.ShowBorder = $false
        $this.ResultsList.ShowScrollbar = $true
        $this.ResultsList.ItemRenderer = {
            param($cmd)
            $name = $cmd.Name.PadRight(20)
            $desc = if ($cmd.Description.Length -gt 35) {
                $cmd.Description.Substring(0, 32) + "..."
            } else {
                $cmd.Description
            }
            return "$name $desc"
        }
        $this.AddChild($this.ResultsList)
    }
    
    [void] OnInitialize() {
        # Get services
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Subscribe to command registration events
        if ($this.EventBus) {
            $this.EventBus.Subscribe('command.registered', {
                param($sender, $eventData)
                if ($eventData.Name -and $eventData.Description -and $eventData.Action) {
                    $this.AddCommand($eventData.Name, $eventData.Description, $eventData.Action)
                }
            }.GetNewClosure())
        }
        
        # Initialize child components
        if ($this.ResultsList) {
            $this.ResultsList.Initialize($this.ServiceContainer)
        }
        
        # Set palette background if theme is available
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        # Load default commands
        $this.LoadDefaultCommands()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'menu.background' = $this.Theme.GetBgColor("menu.background")
                'border.focused' = $this.Theme.GetColor("border.focused")
                'accent' = $this.Theme.GetColor("accent")
                'foreground' = $this.Theme.GetColor("foreground")
                'disabled' = $this.Theme.GetColor("disabled")
            }
            $this.SetBackgroundColor($this._colors['menu.background'])
        }
        $this.Invalidate()
    }
    
    [void] LoadDefaultCommands() {
        # Store reference to this palette for use in scriptblocks
        $palette = $this
        
        # Add some default commands
        $this.AddCommand("new project", "Create a new project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new project command")
            }
            
            # Publish event to switch to projects tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
            }
            
            # Create and show the dialog
            $dialog = [NewProjectDialog]::new()
            $dialog.OnCreate = {
                param($project)
                if ($global:Logger) {
                    $global:Logger.Info("Creating project: $($project.Name)")
                }
                # Add project via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    # Create proper Project object using single-parameter constructor
                    $newProject = $projectService.AddProject($project.Name)
                    
                    # Publish project created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::ProjectCreated, @{ Project = $newProject })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        $this.AddCommand("new task", "Create a new task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing new task command")
            }
            
            # Publish event to switch to tasks tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
            }
            
            # Create and show the dialog directly (same pattern as new project)
            $dialog = [NewTaskDialog]::new()
            $dialog.OnCreate = {
                param($task)
                if ($global:Logger) {
                    $global:Logger.Info("Creating task: $($task.Title)")
                }
                # Create task via service
                $taskService = $global:ServiceContainer.GetService("TaskService")
                if ($taskService) {
                    $newTask = $taskService.CreateTask($task)
                    
                    # Publish task created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TaskCreated, @{ Task = $newTask })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Don't set OnCancel - BaseDialog handles ESC and closing automatically
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit project", "Edit selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("edit task", "Edit selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing edit task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'EditTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete project", "Delete selected project", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete project command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 0 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteProject'
                    Target = 'ProjectsScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("delete task", "Delete selected task", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Executing delete task command")
            }
            
            # Publish events
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 1 })
                $palette.EventBus.Publish([EventNames]::CommandExecuted, @{ 
                    Command = 'DeleteTask'
                    Target = 'TaskScreen'
                })
            }
        }.GetNewClosure())
        
        $this.AddCommand("time entry", "Go to time entry screen", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Time entry command executed")
            }
            # Switch to time tab (tab index 2)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 2 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("quick time entry", "Quick time entry for today", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quick time entry command executed")
            }
            
            # Switch to time tab first
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 2 })
            }
            
            # Get current week Friday for time entry
            $timeService = $global:ServiceContainer.GetService("TimeTrackingService")
            $currentWeekFriday = if ($timeService) { 
                $timeService.GetCurrentWeekFriday() 
            } else { 
                # Fallback to current week's Friday
                $today = [DateTime]::Today
                $daysUntilFriday = ([int][DayOfWeek]::Friday - [int]$today.DayOfWeek + 7) % 7
                if ($daysUntilFriday -eq 0 -and $today.DayOfWeek -ne [DayOfWeek]::Friday) {
                    $daysUntilFriday = 7
                }
                $today.AddDays($daysUntilFriday)
            }
            
            # Create and show quick time entry dialog
            $dialog = [QuickTimeEntryDialog]::new($currentWeekFriday)
            $dialog.OnSave = {
                param($timeEntry)
                if ($global:Logger) {
                    $global:Logger.Info("Creating time entry: $($timeEntry.Hours) hours for project $($timeEntry.ProjectId)")
                }
                # Create time entry via service
                $timeService = $global:ServiceContainer.GetService("TimeTrackingService")
                if ($timeService) {
                    $timeService.AddTimeEntry($timeEntry)
                    
                    # Publish time entry created event
                    $eventBus = $global:ServiceContainer.GetService('EventBus')
                    if ($eventBus) {
                        $eventBus.Publish([EventNames]::TimeEntryUpdated, @{ TimeEntry = $timeEntry })
                    }
                }
                # Close dialog
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            # Push dialog to screen manager
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure())
        
        $this.AddCommand("search", "Search in files", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Search command executed")
            }
            # TODO: Implement search
        }.GetNewClosure())
        
        $this.AddCommand("files", "Open file browser", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Files command executed")
            }
            # Switch to files tab (tab index 3 - Projects, Tasks, Time, Files)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 3 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("text editor", "Open text editor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Text editor command executed")
            }
            # Switch to editor tab (tab index 4 - Projects, Tasks, Time, Files, Editor)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("editor", "Open text editor tab", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Editor tab command executed")
            }
            # Switch to editor tab
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 4 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("settings", "Open settings", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Settings command executed")
            }
            # Switch to settings tab (tab index 5 - Projects, Tasks, Time, Files, Editor, Settings)
            if ($palette.EventBus) {
                $palette.EventBus.Publish([EventNames]::TabChanged, @{ TabIndex = 5 })
            }
        }.GetNewClosure())
        
        $this.AddCommand("eventbus monitor", "Open EventBus monitor", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: EventBus monitor command executed")
            }
            # Open EventBus monitor dialog
            $monitor = [EventBusMonitor]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($monitor)
            }
        }.GetNewClosure())
        
        $this.AddCommand("reload", "Reload configuration", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Reload command executed")
            }
            # TODO: Implement reload
        }.GetNewClosure())
        
        $this.AddCommand("theme dark", "Switch to dark theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Dark theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        
        $this.AddCommand("theme light", "Switch to light theme", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Light theme command executed")
            }
            # TODO: Implement theme switching
        }.GetNewClosure())
        $this.AddCommand("quit", "Exit application (Ctrl+Q)", {
            if ($global:Logger) {
                $global:Logger.Debug("CommandPalette: Quit command executed")
            }
            if ($global:ScreenManager) {
                $screen = $global:ScreenManager.GetActiveScreen()
                if ($screen) { 
                    $screen.Active = $false 
                }
            }
        }.GetNewClosure())
    }
    
    [void] AddCommand([string]$name, [string]$description, [scriptblock]$action) {
        $this.AllCommands.Add(@{
            Name = $name
            Description = $description
            Action = $action
        })
    }
    
    [void] Show() {
        $this.IsVisible = $true
        $this.SearchText = ""
        $this.UpdateFilter()
        $this.Invalidate()
        
        # Focus on results
        $this.ResultsList.Focus()
    }
    
    [void] Hide() {
        $this.IsVisible = $false
        $this.Invalidate()
        
        # Return focus to parent's active tab
        if ($this.Parent -and $this.Parent.GetType().Name -eq "MainScreen") {
            $activeTab = $this.Parent.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                $activeTab.Content.Focus()
            }
        }
    }
    
    [void] UpdateFilter() {
        $this.FilteredCommands.Clear()
        
        if ([string]::IsNullOrEmpty($this.SearchText)) {
            $this.FilteredCommands.AddRange($this.AllCommands)
        } else {
            # Simple fuzzy search
            $searchLower = $this.SearchText.ToLower()
            foreach ($cmd in $this.AllCommands) {
                if ($cmd.Name.ToLower().Contains($searchLower) -or 
                    $cmd.Description.ToLower().Contains($searchLower)) {
                    $this.FilteredCommands.Add($cmd)
                }
            }
        }
        
        # Update list
        $this.ResultsList.SetItems($this.FilteredCommands.ToArray())
    }
    
    [void] OnBoundsChanged() {
        # Center the palette
        $centerX = [int](($this.Width - $this.PaletteWidth) / 2)
        $centerY = [int](($this.Height - $this.PaletteHeight) / 2)
        
        # Update own bounds to be centered
        $this.X = $centerX
        $this.Y = $centerY
        $this.Width = $this.PaletteWidth
        $this.Height = $this.PaletteHeight
        
        # Layout results list (leave room for search box and border)
        $this.ResultsList.SetBounds(
            $this.X + 2,
            $this.Y + 4,
            $this.Width - 4,
            $this.Height - 6
        )
        
        # Recalculate visible items
        $this.ResultsList.VisibleItems = [Math]::Min($this.MaxResults, $this.Height - 6)
        
        ([Container]$this).OnBoundsChanged()
    }
    
    [string] OnRender() {
        if (-not $this.IsVisible) { return "" }
        
        $sb = Get-PooledStringBuilder 1024
        
        # Draw background first
        $sb.Append(([Container]$this).OnRender())
        
        # Draw border
        $borderColor = $this._colors['border.focused']
        
        # Top border with title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal(2))
        $accentColor = $this._colors['accent']
        $sb.Append($accentColor)
        $sb.Append(" Command Palette ")
        $sb.Append($borderColor)
        $sb.Append([StringCache]::GetVTHorizontal($this.Width - 19) + [VT]::TR())
        
        # Sides
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        
        # Search box
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 2))
        $foregroundColor = $this._colors['foreground']
        $sb.Append($foregroundColor)
        $sb.Append("Search: ")
        $sb.Append($accentColor)
        $sb.Append($this.SearchText)
        $sb.Append("_")
        
        # Separator
        $sb.Append([VT]::MoveTo($this.X + 1, $this.Y + 3))
        $sb.Append($borderColor)
        $sb.Append([StringCache]::GetVTHorizontal($this.Width - 2))
        
        # Help text
        $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + $this.Height - 2))
        $disabledColor = $this._colors['disabled']
        $sb.Append($disabledColor)
        $sb.Append("[Enter] Select  [Esc] Cancel")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsVisible) { return $false }
        
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($global:Logger) {
                    $global:Logger.Debug("CommandPalette: Escape pressed, hiding palette")
                }
                try {
                    $this.Hide()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("CommandPalette: Error hiding palette: $_")
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.ResultsList.GetSelectedItem()
                if ($selected) {
                    if ($global:Logger) {
                        $global:Logger.Debug("CommandPalette: Executing command '$($selected.Name)'")
                    }
                    $this.Hide()
                    if ($selected.Action) {
                        try {
                            # Execute in the context of the CommandPalette
                            $selected.Action.Invoke()
                        } catch {
                            if ($global:Logger) {
                                $global:Logger.Error("CommandPalette: Error executing command '$($selected.Name)': $_")
                            }
                        }
                    }
                    if ($this.OnCommandSelected) {
                        & $this.OnCommandSelected $selected
                    }
                }
                return $true
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.SearchText.Length -gt 0) {
                    $this.SearchText = $this.SearchText.Substring(0, $this.SearchText.Length - 1)
                    $this.UpdateFilter()
                    $this.Invalidate()
                }
                return $true
            }
            default {
                # Let list handle navigation
                if ($this.ResultsList.HandleInput($key)) {
                    return $true
                }
                
                # Add character to search
                if ($key.KeyChar -and [char]::IsLetterOrDigit($key.KeyChar) -or $key.KeyChar -eq ' ') {
                    $this.SearchText += $key.KeyChar
                    $this.UpdateFilter()
                    $this.Invalidate()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Components/DataGrid.ps1
# DataGrid.ps1 - Fast data grid component for tabular display with full grid lines
# Optimized for performance with caching and pooled string builders

class DataGrid : UIElement {
    [System.Collections.ArrayList]$Items
    [hashtable[]]$Columns = @()
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowHeader = $true
    [bool]$ShowBorder = $true
    [bool]$ShowGridLines = $true  # New property for grid lines
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_colors = @{}
    hidden [hashtable]$_columnWidths = @{}
    hidden [string]$_cachedHeader = ""
    hidden [string]$_cachedSeparator = ""
    hidden [string[]]$_cachedHeaders = @()        # Pre-built header strings
    hidden [int[]]$_cachedColumnWidths = @()      # Pre-calculated widths
    hidden [string]$_cachedBorders = ""           # Pre-built border strings
    hidden [bool]$_layoutCacheValid = $false
    hidden [int]$_lastWidth = 0
    hidden [int]$_dataVersion = 0                 # Version-based change detection
    hidden [int]$_lastRenderedVersion = -1
    
    DataGrid() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Cache all colors used by DataGrid
        $this._colors['border'] = $this.Theme.GetColor('border')
        $this._colors['border.focused'] = $this.Theme.GetColor('border.focused')
        $this._colors['accent'] = $this.Theme.GetColor('accent')
        $this._colors['header.foreground'] = $this.Theme.GetColor('header.foreground')
        $this._colors['header.background'] = $this.Theme.GetBgColor('header.background')
        $this._colors['background'] = $this.Theme.GetBgColor('background')
        $this._colors['foreground'] = $this.Theme.GetColor('foreground')
        $this._colors['selection'] = $this.Theme.GetBgColor('selection')
        $this._colors['scrollbar'] = $this.Theme.GetColor('scrollbar')
        
        $this._dataVersion++  # Increment for theme change
        $this._layoutCacheValid = $false
        $this.Invalidate()
    }
    
    # Set the columns for the grid
    [void] SetColumns([hashtable[]]$columns) {
        $this.Columns = $columns
        $this._layoutCacheValid = $false
        $this._dataVersion++  # Increment on any data change
        $this.Invalidate()
    }
    
    # Set data items
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = if ($this.Items.Count -gt 0) { 0 } else { -1 }
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on any data change
        $this.Invalidate()
    }
    
    # Get selected item
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    # Select specific index
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    # Calculate column widths with auto-sizing
    hidden [void] CalculateColumnWidths([int]$availableWidth) {
        if ($this._layoutCacheValid -and $this._lastWidth -eq $availableWidth) {
            return
        }
        
        $this._columnWidths.Clear()
        $totalFixed = 0
        $flexCount = 0
        
        # First pass: calculate fixed widths and count flex columns
        foreach ($col in $this.Columns) {
            if ($col.Width -and $col.Width -gt 0) {
                $this._columnWidths[$col.Name] = $col.Width
                $totalFixed += $col.Width
            } else {
                $flexCount++
            }
        }
        
        # Add space for separators if grid lines are shown
        if ($this.ShowGridLines -and $this.Columns.Count -gt 1) {
            $totalFixed += ($this.Columns.Count - 1)  # Vertical separators
        }
        
        # Second pass: distribute remaining width to flex columns
        if ($flexCount -gt 0 -and $availableWidth -gt $totalFixed) {
            $flexWidth = [Math]::Floor(($availableWidth - $totalFixed) / $flexCount)
            foreach ($col in $this.Columns) {
                if (-not $col.Width -or $col.Width -eq 0) {
                    $this._columnWidths[$col.Name] = [Math]::Max(5, $flexWidth)  # Min width of 5
                }
            }
        }
        
        $this._lastWidth = $availableWidth
        $this._layoutCacheValid = $true
    }
    
    # Build cached header string
    hidden [void] BuildCachedHeader([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedHeader) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $header = if ($col.Header) { $col.Header } else { $col.Name }
                $text = if ($header.Length -gt $width) {
                    $header.Substring(0, $width - 1) + "‚Ä¶"
                } else {
                    $header.PadRight($width)
                }
                $sb.Append($text)
                $x += $width
                
                # Add separator after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("‚îÇ")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append([StringCache]::GetSpaces($contentWidth - $x))
        }
        
        $this._cachedHeader = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Build cached separator line
    hidden [void] BuildCachedSeparator([int]$contentWidth) {
        if ($this._layoutCacheValid -and $this._cachedSeparator) {
            return
        }
        
        $sb = Get-PooledStringBuilder 256
        $x = 0
        
        for ($i = 0; $i -lt $this.Columns.Count; $i++) {
            $col = $this.Columns[$i]
            $width = $this._columnWidths[$col.Name]
            
            if ($x + $width -gt $contentWidth) {
                $width = $contentWidth - $x
            }
            
            if ($width -gt 0) {
                $sb.Append([StringCache]::GetHorizontalLine($width))
                $x += $width
                
                # Add intersection after column (except last)
                if ($this.ShowGridLines -and $i -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                    $sb.Append("‚îº")
                    $x++
                }
            }
            
            if ($x -ge $contentWidth) { break }
        }
        
        # Fill remaining space
        if ($x -lt $contentWidth) {
            $sb.Append([StringCache]::GetHorizontalLine($contentWidth - $x))
        }
        
        $this._cachedSeparator = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    # Ensure selected item is visible
    hidden [void] EnsureVisible() {
        if ($this.Items.Count -eq 0) { return }
        
        $contentHeight = $this.Height - 2  # Account for borders
        if ($this.ShowHeader) { 
            $contentHeight -= 2  # Header + separator line
        }
        
        # Account for row separators
        if ($this.ShowGridLines) {
            $contentHeight = [Math]::Floor($contentHeight / 2)  # Each row takes 2 lines with separator
        }
        
        # Scroll up if selected is above visible area
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        }
        # Scroll down if selected is below visible area
        elseif ($this.SelectedIndex -ge ($this.ScrollOffset + $contentHeight)) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        # Ensure scroll offset is valid
        $maxScroll = [Math]::Max(0, $this.Items.Count - $contentHeight)
        $this.ScrollOffset = [Math]::Max(0, [Math]::Min($this.ScrollOffset, $maxScroll))
    }
    
    [string] OnRender() {
        # Return empty if Theme is not initialized
        if (-not $this.Theme) {
            return ""
        }
        
        $sb = Get-PooledStringBuilder 4096  # Larger size for grid with separators
        
        # Calculate content area
        $contentX = $this.X + 1
        $contentY = $this.Y + 1
        $contentWidth = $this.Width - 2
        $contentHeight = $this.Height - 2
        
        # Draw border if enabled
        if ($this.ShowBorder -and $this.Theme) {
            $borderColor = if ($this.IsFocused) { 
                $this._colors['border.focused'] 
            } else { 
                $this._colors['border'] 
            }
            
            # Top border with title
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL())
            
            if ($this.Title) {
                $titleText = " " + $this.Title + " "  # Avoid string interpolation overhead
                $titleLen = $titleText.Length
                $borderLen = $this.Width - 2
                $leftPad = [int](($borderLen - $titleLen) / 2)
                
                if ($leftPad -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($leftPad))
                }
                $sb.Append($this._colors['accent'])
                $sb.Append($titleText)
                $sb.Append($borderColor)
                $remainingBorder = [Math]::Max(0, $borderLen - $leftPad - $titleLen)
                if ($remainingBorder -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($remainingBorder))
                }
            } else {
                $topBorderWidth = [Math]::Max(0, $this.Width - 2)
                if ($topBorderWidth -gt 0) {
                    $sb.Append([StringCache]::GetVTHorizontal($topBorderWidth))
                }
            }
            
            $sb.Append([VT]::TR())
            
            # Side borders
            for ($i = 1; $i -lt $this.Height - 1; $i++) {
                $sb.Append([VT]::MoveTo($this.X, $this.Y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $i))
                $sb.Append([VT]::V())
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
            $sb.Append([VT]::BL())
            $bottomBorderWidth = [Math]::Max(0, $this.Width - 2)
            if ($bottomBorderWidth -gt 0) {
                $sb.Append([StringCache]::GetVTHorizontal($bottomBorderWidth))
            }
            $sb.Append([VT]::BR())
            $sb.Append([VT]::Reset())
        } else {
            $contentX = $this.X
            $contentY = $this.Y
            $contentWidth = $this.Width
            $contentHeight = $this.Height
        }
        
        # Calculate column widths
        $this.CalculateColumnWidths($contentWidth)
        
        # Clear content area
        $bgColor = $this._colors['background']
        for ($y = 0; $y -lt $contentHeight; $y++) {
            $sb.Append([VT]::MoveTo($contentX, $contentY + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
        }
        
        $currentY = $contentY
        $dataStartY = $currentY
        
        # Render header if enabled
        if ($this.ShowHeader -and $this.Columns.Count -gt 0) {
            # Build cached header
            $this.BuildCachedHeader($contentWidth)
            
            # Render header
            $sb.Append([VT]::MoveTo($contentX, $currentY))
            $sb.Append($this._colors['header.background'])
            $sb.Append($this._colors['header.foreground'])
            $sb.Append($this._cachedHeader)
            $sb.Append([VT]::Reset())
            $currentY++
            
            # Render header separator line
            if ($this.ShowGridLines) {
                $this.BuildCachedSeparator($contentWidth)
                $sb.Append([VT]::MoveTo($contentX, $currentY))
                $sb.Append($this._colors['border'])
                $sb.Append($this._cachedSeparator)
                $sb.Append([VT]::Reset())
                $currentY++
            }
            
            $dataStartY = $currentY
            $contentHeight = $this.Height - 2 - ($currentY - $contentY)
        }
        
        # Calculate visible rows (accounting for separators) - optimization: only render visible rows
        $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
        $maxVisibleRows = [Math]::Floor($contentHeight / $rowHeight)
        
        # Optimization: Skip off-screen rows entirely - zero overhead bounds checking
        $startRow = $this.ScrollOffset
        $endRow = [Math]::Min($startRow + $maxVisibleRows, $this.Items.Count)
        $visibleRows = $endRow - $startRow
        
        # Render data rows (only visible ones)
        for ($i = 0; $i -lt $visibleRows; $i++) {
            $itemIndex = $startRow + $i
            if ($itemIndex -ge $this.Items.Count) { break }
            
            $item = $this.Items[$itemIndex]
            $isSelected = ($itemIndex -eq $this.SelectedIndex)
            $rowY = $currentY + ($i * $rowHeight)
            
            # Render data row
            $sb.Append([VT]::MoveTo($contentX, $rowY))
            
            if ($isSelected) {
                $sb.Append($this._colors['selection'])
                $sb.Append($this._colors['foreground'])
            } else {
                $sb.Append($this._colors['background'])
                $sb.Append($this._colors['foreground'])
            }
            
            # Render columns
            $x = 0
            for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                $col = $this.Columns[$j]
                $width = $this._columnWidths[$col.Name]
                
                if ($x + $width -gt $contentWidth) {
                    $width = $contentWidth - $x
                }
                
                if ($width -gt 0) {
                    # Get value using property name or custom getter
                    $value = ""
                    if ($col.Getter) {
                        $value = & $col.Getter $item
                    } elseif ($col.Name -and $item.PSObject.Properties[$col.Name]) {
                        $value = $item.($col.Name)
                    }
                    
                    # Apply formatter if provided
                    if ($col.Formatter) {
                        $value = & $col.Formatter $value
                    }
                    
                    # Convert to string and truncate if needed
                    $text = $value.ToString()
                    if ($text.Length -gt $width) {
                        $text = $text.Substring(0, $width - 1) + "‚Ä¶"
                    } else {
                        $text = $text.PadRight($width)
                    }
                    
                    $sb.Append($text)
                    $x += $width
                    
                    # Add vertical separator after column (except last)
                    if ($this.ShowGridLines -and $j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                        if ($isSelected) {
                            # Keep selection colors for separator
                            $sb.Append("‚îÇ")
                        } else {
                            $sb.Append($this._colors['border'])
                            $sb.Append("‚îÇ")
                            $sb.Append($this._colors['foreground'])
                        }
                        $x++
                    }
                }
                
                if ($x -ge $contentWidth) { break }
            }
            
            # Fill remaining row space
            if ($x -lt $contentWidth) {
                $sb.Append([StringCache]::GetSpaces($contentWidth - $x))
            }
            
            # Render row separator (except after last visible row)
            if ($this.ShowGridLines -and $i -lt $visibleRows - 1) {
                $sb.Append([VT]::MoveTo($contentX, $rowY + 1))
                $sb.Append($this._colors['border'])
                
                $x = 0
                for ($j = 0; $j -lt $this.Columns.Count; $j++) {
                    $col = $this.Columns[$j]
                    $width = $this._columnWidths[$col.Name]
                    
                    if ($x + $width -gt $contentWidth) {
                        $width = $contentWidth - $x
                    }
                    
                    if ($width -gt 0) {
                        $sb.Append([StringCache]::GetHorizontalLine($width))
                        $x += $width
                        
                        # Add intersection
                        if ($j -lt $this.Columns.Count - 1 -and $x -lt $contentWidth) {
                            $sb.Append("‚îº")
                            $x++
                        }
                    }
                    
                    if ($x -ge $contentWidth) { break }
                }
                
                # Fill remaining separator
                if ($x -lt $contentWidth) {
                    $sb.Append([StringCache]::GetHorizontalLine($contentWidth - $x))
                }
                $sb.Append([VT]::Reset())
            }
        }
        
        # Show scroll indicator
        if ($this.Items.Count -gt $maxVisibleRows) {
            $scrollBarX = $this.X + $this.Width - 1
            $scrollBarHeight = $contentHeight
            $scrollThumbSize = [Math]::Max(1, [int]($scrollBarHeight * $maxVisibleRows / $this.Items.Count))
            $scrollThumbPos = [int]($this.ScrollOffset * ($scrollBarHeight - $scrollThumbSize) / ($this.Items.Count - $maxVisibleRows))
            
            $sb.Append($this._colors['scrollbar'])
            for ($i = 0; $i -lt $scrollBarHeight; $i++) {
                $sb.Append([VT]::MoveTo($scrollBarX, $dataStartY + $i))
                if ($i -ge $scrollThumbPos -and $i -lt ($scrollThumbPos + $scrollThumbSize)) {
                    $sb.Append("‚ñà")
                } else {
                    $sb.Append("‚îÇ")
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if (-not $this.IsFocused -or $this.Items.Count -eq 0) { return $false }
        
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    $this.EnsureVisible()
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $rowHeight = if ($this.ShowGridLines) { 2 } else { 1 }
                $pageSize = [Math]::Floor(($this.Height - 2 - (if ($this.ShowHeader) { 2 } else { 0 })) / $rowHeight)
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $this.EnsureVisible()
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = $this.Items.Count - 1
                $this.EnsureVisible()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._dataVersion++  # Increment for focus change
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._dataVersion++  # Increment for focus change
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        # Invalidate layout cache when bounds change
        if ($this.Width -ne $this._lastWidth) {
            $this._layoutCacheValid = $false
        }
        ([UIElement]$this).OnBoundsChanged()
    }
}


####\Components/DockPanel.ps1
# DockPanel.ps1 - Dock-based layout container
# Allows children to be docked to Top, Bottom, Left, Right, or Fill remaining space

enum DockPosition {
    Top
    Bottom
    Left
    Right
    Fill
}

class DockPanel : Container {
    [bool]$LastChildFill = $true
    [int]$DockSpacing = 0
    
    # Layout caching for performance
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastChildCount = 0
    
    # Available content area after docking
    hidden [int]$_contentX = 0
    hidden [int]$_contentY = 0  
    hidden [int]$_contentWidth = 0
    hidden [int]$_contentHeight = 0
    
    DockPanel() : base() {
        # DockPanel manages its own layout
    }
    
    [void] SetChildDock([UIElement]$child, [DockPosition]$position) {
        # Add custom property to track dock position
        $child | Add-Member -MemberType NoteProperty -Name "DockPosition" -Value $position -Force
        $this.InvalidateLayout()
    }
    
    [void] SetChildHeight([UIElement]$child, [int]$height) {
        # Add custom property to track fixed height
        $child | Add-Member -MemberType NoteProperty -Name "FixedHeight" -Value $height -Force
        $child.Height = $height
        $this.InvalidateLayout()
    }
    
    [void] SetChildWidth([UIElement]$child, [int]$width) {
        # Add custom property to track fixed width
        $child | Add-Member -MemberType NoteProperty -Name "FixedWidth" -Value $width -Force
        $child.Width = $width
        $this.InvalidateLayout()
    }
    
    [DockPosition] GetChildDock([UIElement]$child) {
        if ($child.PSObject.Properties["DockPosition"]) {
            return $child.DockPosition
        }
        return [DockPosition]::Fill
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        ([Container]$this).OnBoundsChanged()
    }
    
    [void] AddChild([UIElement]$child) {
        ([Container]$this).AddChild($child)
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        ([Container]$this).RemoveChild($child)
        $this.InvalidateLayout()
    }
    
    [void] UpdateLayout() {
        # Check if layout needs updating
        if (-not $this._layoutInvalid -and 
            $this.Width -eq $this._lastWidth -and 
            $this.Height -eq $this._lastHeight -and 
            $this.Children.Count -eq $this._lastChildCount) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Recalculating layout for $($this.Children.Count) children")
        }
        
        # Initialize available area (full container minus any padding)
        $availableX = $this.X
        $availableY = $this.Y
        $availableWidth = $this.Width
        $availableHeight = $this.Height
        
        # Group children by dock position
        $topChildren = @()
        $bottomChildren = @()
        $leftChildren = @()
        $rightChildren = @()
        $fillChild = $null
        
        foreach ($child in $this.Children) {
            if (-not $child.Visible) { continue }
            
            $dock = $this.GetChildDock($child)
            switch ($dock) {
                ([DockPosition]::Top) { $topChildren += $child }
                ([DockPosition]::Bottom) { $bottomChildren += $child }
                ([DockPosition]::Left) { $leftChildren += $child }
                ([DockPosition]::Right) { $rightChildren += $child }
                ([DockPosition]::Fill) { $fillChild = $child }
            }
        }
        
        # Process docked children in order: Top, Bottom, Left, Right
        
        # Top docked children
        foreach ($child in $topChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $child.SetBounds($availableX, $availableY, $availableWidth, $childHeight)
            $availableY += $childHeight + $this.DockSpacing
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Bottom docked children
        foreach ($child in $bottomChildren) {
            $childHeight = if ($child.PSObject.Properties["FixedHeight"]) { $child.FixedHeight } else { $child.Height }
            $childY = $availableY + $availableHeight - $childHeight
            $child.SetBounds($availableX, $childY, $availableWidth, $childHeight)
            $availableHeight -= $childHeight + $this.DockSpacing
        }
        
        # Left docked children  
        foreach ($child in $leftChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $child.SetBounds($availableX, $availableY, $childWidth, $availableHeight)
            $availableX += $childWidth + $this.DockSpacing
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Right docked children
        foreach ($child in $rightChildren) {
            $childWidth = if ($child.PSObject.Properties["FixedWidth"]) { $child.FixedWidth } else { $child.Width }
            $childX = $availableX + $availableWidth - $childWidth
            $child.SetBounds($childX, $availableY, $childWidth, $availableHeight)
            $availableWidth -= $childWidth + $this.DockSpacing
        }
        
        # Fill remaining space with fill child (if LastChildFill is enabled and we have one)
        if ($this.LastChildFill -and $fillChild) {
            # Ensure minimum size
            $fillWidth = [Math]::Max(0, $availableWidth)
            $fillHeight = [Math]::Max(0, $availableHeight)
            $fillChild.SetBounds($availableX, $availableY, $fillWidth, $fillHeight)
        }
        
        # Cache current state
        $this._contentX = $availableX
        $this._contentY = $availableY
        $this._contentWidth = $availableWidth
        $this._contentHeight = $availableHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
        
        if ($global:Logger) {
            $global:Logger.Debug("DockPanel.UpdateLayout: Layout complete. Content area: ($availableX,$availableY) ${availableWidth}x$availableHeight")
        }
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering - render all visible children
        $sb = Get-PooledStringBuilder 2048
        
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child first
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [hashtable] GetContentArea() {
        $this.UpdateLayout()
        return @{
            X = $this._contentX
            Y = $this._contentY
            Width = $this._contentWidth
            Height = $this._contentHeight
        }
    }
    
    # Convenience methods for setting dock positions
    [void] DockTop([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Top) }
    [void] DockBottom([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Bottom) }
    [void] DockLeft([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Left) }
    [void] DockRight([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Right) }
    [void] DockFill([UIElement]$child) { $this.SetChildDock($child, [DockPosition]::Fill) }
}


####\Components/FastFileTree.ps1
# FastFileTree.ps1 - High-performance file system browser based on ALCAR patterns
# Fast string-based rendering with directory caching and lazy loading

class FileSystemNode {
    [string]$Name
    [string]$FullPath
    [bool]$IsDirectory
    [long]$Size
    [datetime]$LastModified
    [bool]$IsExpanded = $false
    [System.Collections.ArrayList]$Children
    [FileSystemNode]$Parent
    [int]$Level = 0
    [bool]$IsLoaded = $false
    [bool]$HasChildren = $false
    
    FileSystemNode([string]$fullPath) {
        $this.FullPath = $fullPath
        $this.Name = Split-Path $fullPath -Leaf
        $this.Children = [System.Collections.ArrayList]::new()
        
        if (Test-Path $fullPath) {
            $item = Get-Item $fullPath -ErrorAction SilentlyContinue
            if ($item) {
                $this.IsDirectory = $item.PSIsContainer
                $this.Size = if (-not $this.IsDirectory -and $item.Length) { $item.Length } else { 0 }
                $this.LastModified = $item.LastWriteTime
                
                # Check if directory has children without loading them
                if ($this.IsDirectory) {
                    try {
                        $hasItems = Get-ChildItem $fullPath -Force -ErrorAction Stop | Select-Object -First 1
                        $this.HasChildren = $hasItems -ne $null
                    } catch {
                        $this.HasChildren = $false
                    }
                }
            }
        }
    }
    
    [void] LoadChildren() {
        if ($this.IsLoaded -or -not $this.IsDirectory) {
            return
        }
        
        try {
            $items = Get-ChildItem $this.FullPath -Force -ErrorAction Stop | Sort-Object @{Expression={$_.PSIsContainer}; Descending=$true}, Name
            
            $this.Children.Clear()
            foreach ($item in $items) {
                $child = [FileSystemNode]::new($item.FullName)
                $child.Parent = $this
                $child.Level = $this.Level + 1
                $this.Children.Add($child) | Out-Null
            }
            
            $this.IsLoaded = $true
            $this.HasChildren = $this.Children.Count -gt 0
            
        } catch {
            # Access denied or other error - mark as loaded but empty
            $this.IsLoaded = $true
            $this.HasChildren = $false
        }
    }
    
    [string] GetIcon() {
        if ($this.IsDirectory) {
            if ($this.IsExpanded) { 
                return "üìÇ" 
            } else { 
                return "üìÅ" 
            }
        }
        
        # File type icons based on extension
        $ext = [System.IO.Path]::GetExtension($this.Name).ToLower()
        switch ($ext) {
            ".ps1" { return "üìú" }
            ".txt" { return "üìÑ" }
            ".log" { return "üìã" }
            ".json" { return "üìã" }
            ".xml" { return "üìã" }
            ".md" { return "üìù" }
            ".zip" { return "üì¶" }
            ".exe" { return "‚öôÔ∏è" }
            ".dll" { return "üîß" }
            ".png" { return "üñºÔ∏è" }
            ".jpg" { return "üñºÔ∏è" }
            ".gif" { return "üñºÔ∏è" }
            default { return "üìÑ" }
        }
        return "üìÑ"  # Fallback
    }
    
    [string] GetSizeString() {
        if ($this.IsDirectory) {
            return ""
        }
        
        if ($this.Size -lt 1KB) {
            return "$($this.Size) B"
        } elseif ($this.Size -lt 1MB) {
            return "$([math]::Round($this.Size / 1KB, 1)) KB"
        } elseif ($this.Size -lt 1GB) {
            return "$([math]::Round($this.Size / 1MB, 1)) MB"
        } else {
            return "$([math]::Round($this.Size / 1GB, 2)) GB"
        }
    }
}

class FastFileTree : UIElement {
    [string]$RootPath = ""
    [FileSystemNode]$RootNode
    [System.Collections.ArrayList]$_flatView
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = "File Browser"
    [bool]$ShowSize = $true
    [bool]$ShowModified = $false
    [string]$Filter = "*"
    
    # Events
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnFileSelected = {}
    [scriptblock]$OnDirectoryChanged = {}
    
    # Visual settings
    [int]$IndentSize = 2
    [string]$ExpandedIcon = "‚ñº"
    [string]$CollapsedIcon = "‚ñ∂"
    
    hidden [ThemeManager]$Theme
    hidden [int]$_lastSelectedIndex = -1
    hidden [System.Collections.Generic.HashSet[string]]$_expandedPaths
    hidden [hashtable]$_colors = @{}
    
    FastFileTree() : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        
        # Default to current directory
        $this.RootPath = $PWD.Path
    }
    
    FastFileTree([string]$rootPath) : base() {
        $this._flatView = [System.Collections.ArrayList]::new()
        $this._expandedPaths = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
        $this.RootPath = $rootPath
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        
        $this.LoadDirectory($this.RootPath)
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selection' = $this.Theme.GetBgColor("selection")
                'normal' = $this.Theme.GetColor("normal")
                'directory' = $this.Theme.GetColor("directory")
                'file' = $this.Theme.GetColor("file")
                'border.focused' = $this.Theme.GetColor("border.focused")
                'foreground' = $this.Theme.GetColor("foreground")
                'background' = $this.Theme.GetBgColor("background")
            }
        }
        $this.Invalidate()
    }
    
    
    # Public API
    [void] LoadDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        try {
            $this.RootPath = Resolve-Path $path
            $this.RootNode = [FileSystemNode]::new($this.RootPath)
            $this.RootNode.IsExpanded = $true
            $this.RootNode.LoadChildren()
            
            # Auto-expand remembered paths
            $this.RestoreExpandedState()
            
            $this.RebuildFlatView()
            $this.SelectedIndex = 0
            $this.ScrollOffset = 0
            $this.Invalidate()
            
            # Fire directory changed event
            if ($this.OnDirectoryChanged) {
                & $this.OnDirectoryChanged $this.RootPath
            }
            
        } catch {
            # Handle errors - could show in status or log
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Error("FastFileTree: Failed to load directory '$path': $($_.Exception.Message)")
            }
        }
    }
    
    [void] NavigateUp() {
        $parentPath = Split-Path $this.RootPath -Parent
        if ($parentPath -and (Test-Path $parentPath)) {
            $this.LoadDirectory($parentPath)
        }
    }
    
    [void] NavigateToSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory) {
            $this.LoadDirectory($selected.FullPath)
        }
    }
    
    [FileSystemNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] ExpandSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and -not $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] CollapseSelected() {
        $selected = $this.GetSelectedNode()
        if ($selected -and $selected.IsDirectory -and $selected.IsExpanded) {
            $this.ToggleExpanded($selected)
        }
    }
    
    [void] ToggleExpanded([FileSystemNode]$node) {
        if (-not $node.IsDirectory) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        
        if ($node.IsExpanded) {
            $node.LoadChildren()
            $this._expandedPaths.Add($node.FullPath) | Out-Null
        } else {
            $this._expandedPaths.Remove($node.FullPath) | Out-Null
        }
        
        $this.RebuildFlatView()
        
        # Try to keep selection on the same node
        $this.SetSelectedNode($node)
        $this.Invalidate()
    }
    
    [void] SetSelectedNode([FileSystemNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].FullPath -eq $node.FullPath) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex) {
                if ($this.OnSelectionChanged) {
                    & $this.OnSelectionChanged
                }
            }
            
            $this.Invalidate()
        }
    }
    
    [void] RefreshCurrent() {
        # Save current selection
        $selectedPath = $null
        $selected = $this.GetSelectedNode()
        if ($selected) {
            $selectedPath = $selected.FullPath
        }
        
        # Reload directory
        $this.LoadDirectory($this.RootPath)
        
        # Restore selection if possible
        if ($selectedPath) {
            for ($i = 0; $i -lt $this._flatView.Count; $i++) {
                if ($this._flatView[$i].FullPath -eq $selectedPath) {
                    $this.SelectIndex($i)
                    break
                }
            }
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        if ($this.RootNode) {
            $this.AddNodeToFlatView($this.RootNode)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([FileSystemNode]$node) {
        # Apply filter for non-directories
        if (-not $node.IsDirectory -and $this.Filter -ne "*") {
            if (-not ($node.Name -like $this.Filter)) {
                return
            }
        }
        
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] RestoreExpandedState() {
        if ($this.RootNode) {
            $this.RestoreExpandedStateRecursive($this.RootNode)
        }
    }
    
    [void] RestoreExpandedStateRecursive([FileSystemNode]$node) {
        if ($this._expandedPaths.Contains($node.FullPath)) {
            $node.IsExpanded = $true
            $node.LoadChildren()
        }
        
        foreach ($child in $node.Children) {
            $this.RestoreExpandedStateRecursive($child)
        }
    }
    
    [void] EnsureVisible() {
        # Calculate visible lines based on current dimensions
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        $borderReduction = $effectiveShowBorder ? 2 : 0
        $titleReduction = ($this.Title -and $this.Height -gt $borderReduction) ? 1 : 0
        $visibleLines = [Math]::Max(0, $this.Height - $borderReduction - $titleReduction)
        
        if ($visibleLines -gt 0) {
            if ($this.SelectedIndex -lt $this.ScrollOffset) {
                $this.ScrollOffset = $this.SelectedIndex
            } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
                $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
            }
            
            $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
        }
    }
    
    # Rendering
    [string] OnRender() {
        return $this.BuildRenderString()
    }
    
    [string] BuildRenderString() {
        # Validate dimensions before rendering
        if ($this.Width -le 0 -or $this.Height -le 0) {
            return ""
        }
        
        # Disable border if dimensions are too small
        $effectiveShowBorder = $this.ShowBorder -and $this.Width -ge 3 -and $this.Height -ge 2
        
        # Use StringBuilder pool if available, otherwise create new
        $sb = $null
        if (Get-Command -Name 'Get-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            $sb = Get-PooledStringBuilder 4096  # File trees can be quite large
        } else {
            $sb = [System.Text.StringBuilder]::new(4096)
        }
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selection']
        $normalColor = $this._colors['normal']
        $directoryColor = if ($this._colors['directory']) { $this._colors['directory'] } else { $normalColor }
        $fileColor = if ($this._colors['file']) { $this._colors['file'] } else { $normalColor }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area with proper bounds checking
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($effectiveShowBorder ? 2 : 0)
        
        # Ensure content width is never negative
        if ($contentWidth -lt 0) {
            $contentWidth = 0
        }
        
        if ($effectiveShowBorder) {
            # Top border - safe to render since we validated Width >= 3
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title -and $contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                if ($titleText.Length -gt $contentWidth) {
                    $titleText = "..." + $titleText.Substring($titleText.Length - $contentWidth + 3)
                }
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title -and $this.Width -gt 0) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title) - $($this.RootPath)"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render file/directory entries
        $visibleLines = $contentHeight - ($effectiveShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
            
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                }
                
                # Build display line
                $line = ""
                
                # Indentation
                $line += [StringCache]::GetSpaces($node.Level * $this.IndentSize)
                
                # Expand/collapse icon for directories
                if ($node.IsDirectory -and $node.HasChildren) {
                    $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
                } else {
                    $line += "  "  # Space for alignment
                }
                
                # File/directory icon
                $line += $node.GetIcon() + " "
                
                # Name
                $line += $node.Name
                
                # Size (for files, if enabled)
                if ($this.ShowSize -and -not $node.IsDirectory) {
                    $sizeStr = $node.GetSizeString()
                    if ($sizeStr) {
                        $line += " ($sizeStr)"
                    }
                }
                
                # Pad and truncate to fit
                $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
                
                # Apply appropriate color and render line
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                if ($i -eq $this.SelectedIndex) {
                    # Selected item - use selection colors
                    $sb.Append($selectedBg)
                    $foregroundColor = $this._colors['foreground']
                    $sb.Append($foregroundColor)
                } else {
                    # Normal item - directory or file color with normal background
                    $normalBg = $this._colors['background']
                    $sb.Append($normalBg)
                    $color = if ($node.IsDirectory) { $directoryColor } else { $fileColor }
                    $sb.Append($color)
                }
                $sb.Append($line)
            }
            
            # Side borders
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            if ($contentWidth -gt 0) {
                $sb.Append([VT]::MoveTo($this.X + ($effectiveShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append([StringCache]::GetSpaces($contentWidth))
            }
            
            if ($effectiveShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($effectiveShowBorder) {
            # Bottom border - safe to render since we validated Width >= 3
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        if (Get-Command -Name 'Return-PooledStringBuilder' -ErrorAction SilentlyContinue) {
            Return-PooledStringBuilder $sb  # Return to pool for reuse
        }
        return $result
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $selected = $this.GetSelectedNode()
                if ($selected) {
                    if ($selected.IsDirectory) {
                        if ($selected.HasChildren) {
                            $this.ToggleExpanded($selected)
                        } else {
                            $this.LoadDirectory($selected.FullPath)
                        }
                    } else {
                        # Fire file selected event
                        if ($this.OnFileSelected) {
                            & $this.OnFileSelected $selected
                        }
                    }
                }
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                $selected = $this.GetSelectedNode()
                if ($selected -and $selected.IsDirectory -and $selected.HasChildren) {
                    $this.ToggleExpanded($selected)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Backspace) {
                $this.NavigateUp()
                $handled = $true
            }
            ([System.ConsoleKey]::F5) {
                $this.RefreshCurrent()
                $handled = $true
            }
        }
        
        # Handle character keys for quick navigation
        if (-not $handled -and $key.KeyChar -ge 'A' -and $key.KeyChar -le 'z') {
            $this.QuickNavigate($key.KeyChar)
            $handled = $true
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] QuickNavigate([char]$char) {
        $startIndex = ($this.SelectedIndex + 1) % $this._flatView.Count
        
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            $index = ($startIndex + $i) % $this._flatView.Count
            $node = $this._flatView[$index]
            
            if ($node.Name.Length -gt 0 -and [char]::ToLower($node.Name[0]) -eq [char]::ToLower($char)) {
                $this.SelectIndex($index)
                break
            }
        }
    }
    
    [void] OnGotFocus() {
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this.Invalidate()
    }
}


####\Components/GridPanel.ps1
# GridPanel.ps1 - Fast grid layout component for PRAXIS

class GridPanel : Container {
    [int]$Columns = 2
    [int]$Rows = 0  # Auto-calculated if 0
    [int]$CellSpacing = 1
    [int]$MinCellWidth = 5
    [int]$MinCellHeight = 2
    [bool]$ShowBorder = $false
    [bool]$AutoSize = $true  # Auto-calculate rows based on children
    
    # Cached layout calculations
    hidden [int]$_cachedCellWidth = 0
    hidden [int]$_cachedCellHeight = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastColumns = 0
    hidden [int]$_lastChildCount = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    GridPanel() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    GridPanel([int]$columns) : base() {
        $this.Columns = [Math]::Max(1, $columns)
        $this.DrawBackground = $false
    }
    
    [void] SetGridSize([int]$columns, [int]$rows) {
        $this.Columns = [Math]::Max(1, $columns)
        $this.Rows = [Math]::Max(0, $rows)
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] AddChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).AddChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] RemoveChild([UIElement]$child) {
        # Call base implementation
        ([Container]$this).RemoveChild($child)
        # Invalidate layout when children change
        $this.InvalidateLayout()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastHeight -eq $this.Height -and
            $this._lastColumns -eq $this.Columns -and
            $this._lastChildCount -eq $this.Children.Count) {
            return  # Layout is still valid
        }
        
        $visibleChildren = @($this.Children | Where-Object { $_.Visible })
        if ($visibleChildren.Count -eq 0) {
            $this._layoutInvalid = $false
            return
        }
        
        # Calculate grid dimensions
        $cols = $this.Columns
        $actualRows = if ($this.AutoSize) {
            [Math]::Ceiling($visibleChildren.Count / $cols)
        } else {
            [Math]::Max(1, $this.Rows)
        }
        
        # Calculate cell dimensions
        $totalSpacingWidth = ($cols - 1) * $this.CellSpacing
        $totalSpacingHeight = ($actualRows - 1) * $this.CellSpacing
        
        $cellWidth = [Math]::Max($this.MinCellWidth, 
            [int](($this.Width - $totalSpacingWidth) / $cols))
        $cellHeight = [Math]::Max($this.MinCellHeight, 
            [int](($this.Height - $totalSpacingHeight) / $actualRows))
        
        # Position children in grid
        for ($i = 0; $i -lt $visibleChildren.Count; $i++) {
            $child = $visibleChildren[$i]
            $col = $i % $cols
            $row = [int]($i / $cols)
            
            # Calculate position
            $childX = $this.X + ($col * ($cellWidth + $this.CellSpacing))
            $childY = $this.Y + ($row * ($cellHeight + $this.CellSpacing))
            
            # Set child bounds
            $child.SetBounds($childX, $childY, $cellWidth, $cellHeight)
        }
        
        # Cache the layout
        $this._cachedCellWidth = $cellWidth
        $this._cachedCellHeight = $cellHeight
        $this._lastWidth = $this.Width
        $this._lastHeight = $this.Height
        $this._lastColumns = $this.Columns
        $this._lastChildCount = $this.Children.Count
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 2048
        
        # Render all visible children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        # Optional: render grid borders
        if ($this.ShowBorder -and $this._cachedCellWidth -gt 0) {
            $borderColor = $this._colors['border']
            $sb.Append($borderColor)
            
            # Draw grid lines (simplified - just basic grid)
            $cols = $this.Columns
            $actualRows = if ($this.AutoSize) {
                [Math]::Ceiling($this.Children.Count / $cols)
            } else {
                $this.Rows
            }
            
            # Vertical lines
            for ($col = 1; $col -lt $cols; $col++) {
                $lineX = $this.X + ($col * ($this._cachedCellWidth + $this.CellSpacing)) - 1
                for ($y = 0; $y -lt $this.Height; $y++) {
                    $sb.Append([VT]::MoveTo($lineX, $this.Y + $y))
                    $sb.Append("‚îÇ")
                }
            }
            
            # Horizontal lines
            for ($row = 1; $row -lt $actualRows; $row++) {
                $lineY = $this.Y + ($row * ($this._cachedCellHeight + $this.CellSpacing)) - 1
                $sb.Append([VT]::MoveTo($this.X, $lineY))
                $sb.Append([StringCache]::GetHorizontalLine($this.Width))
            }
            
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused child
        foreach ($child in $this.Children) {
            if ($child.IsFocused -and $child.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods
    [int] GetCellWidth() { return $this._cachedCellWidth }
    [int] GetCellHeight() { return $this._cachedCellHeight }
    
    # Get child at grid position
    [UIElement] GetChildAt([int]$col, [int]$row) {
        $index = ($row * $this.Columns) + $col
        if ($index -ge 0 -and $index -lt $this.Children.Count) {
            return $this.Children[$index]
        }
        return $null
    }
    
    # Focus management with grid navigation
    [void] FocusCell([int]$col, [int]$row) {
        $child = $this.GetChildAt($col, $row)
        if ($child -and $child.IsFocusable) {
            $child.Focus()
        }
    }
}


####\Components/HorizontalSplit.ps1
# HorizontalSplit.ps1 - Fast horizontal layout component for PRAXIS

class HorizontalSplit : Container {
    [UIElement]$LeftPane
    [UIElement]$RightPane
    [int]$SplitRatio = 50  # Percentage for left pane (0-100)
    [int]$MinPaneWidth = 5
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedLeftWidth = 0
    hidden [int]$_cachedRightWidth = 0
    hidden [int]$_cachedRightX = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastWidth = 0
    hidden [int]$_lastSplitRatio = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    HorizontalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    [void] SetLeftPane([UIElement]$pane) {
        if ($this.LeftPane) {
            $this.RemoveChild($this.LeftPane)
        }
        $this.LeftPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetRightPane([UIElement]$pane) {
        if ($this.RightPane) {
            $this.RemoveChild($this.RightPane)
        }
        $this.RightPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastWidth -eq $this.Width -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalWidth = $this.Width
        $leftWidth = [int](($totalWidth * $this.SplitRatio) / 100)
        $leftWidth = [Math]::Max($this.MinPaneWidth, [Math]::Min($leftWidth, $totalWidth - $this.MinPaneWidth))
        $rightWidth = $totalWidth - $leftWidth
        $rightX = $this.X + $leftWidth
        
        # Update left pane
        if ($this.LeftPane) {
            $this.LeftPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        }
        
        # Update right pane
        if ($this.RightPane) {
            $this.RightPane.SetBounds($rightX, $this.Y, $rightWidth, $this.Height)
        }
        
        # Cache the layout
        $this._cachedLeftWidth = $leftWidth
        $this._cachedRightWidth = $rightWidth
        $this._cachedRightX = $rightX
        $this._lastWidth = $this.Width
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 1024
        
        # Render children
        if ($this.LeftPane -and $this.LeftPane.Visible) {
            $sb.Append($this.LeftPane.Render())
        }
        
        if ($this.RightPane -and $this.RightPane.Visible) {
            $sb.Append($this.RightPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedLeftWidth -gt 0) {
            $borderColor = $this._colors['border']
            for ($y = 0; $y -lt $this.Height; $y++) {
                $sb.Append([VT]::MoveTo($this._cachedRightX - 1, $this.Y + $y))
                $sb.Append($borderColor)
                $sb.Append("‚îÇ")
            }
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.LeftPane -and $this.LeftPane.IsFocused) {
            if ($this.LeftPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.RightPane -and $this.RightPane.IsFocused) {
            if ($this.RightPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetLeftFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetRightFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetLeftPane() { return $this.LeftPane }
    [UIElement] GetRightPane() { return $this.RightPane }
    
    # Focus management
    [void] FocusLeftPane() {
        if ($this.LeftPane -and $this.LeftPane.IsFocusable) {
            $this.LeftPane.Focus()
        }
    }
    
    [void] FocusRightPane() {
        if ($this.RightPane -and $this.RightPane.IsFocusable) {
            $this.RightPane.Focus()
        }
    }
}


####\Components/ListBox.ps1
# ListBox.ps1 - Fast list box component with selection and scrolling

class ListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [int]$VisibleItems = 10
    [bool]$ShowBorder = $true
    [bool]$ShowScrollbar = $true
    
    # Display properties
    [scriptblock]$ItemRenderer = { param($item) $item.ToString() }
    [string]$Title = ""
    
    # Callback for selection changes
    [scriptblock]$OnSelectionChanged = {}
    
    # Cached rendering
    hidden [string]$_cachedItems = ""
    hidden [bool]$_itemsCacheInvalid = $true
    hidden [ThemeManager]$Theme
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedRender = ""
    
    # Cached theme colors
    hidden [hashtable]$_colors = @{}
    
    ListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        # Cache colors on theme change
        if ($this.Theme) {
            $this._colors = @{
                "accent" = $this.Theme.GetColor("accent")
                "foreground" = $this.Theme.GetColor("foreground")
                "selection.bg" = $this.Theme.GetBgColor("selection")
                "selection.fg" = $this.Theme.GetColor("menu.selected.foreground")
                "border" = $this.Theme.GetColor("border")
                "border.focused" = $this.Theme.GetColor("border.focused")
                "scrollbar" = $this.Theme.GetColor("scrollbar")
                "scrollbar.thumb" = $this.Theme.GetColor("scrollbar.thumb")
                "disabled" = $this.Theme.GetColor("disabled")
                "background" = $this.Theme.GetBgColor("background")
            }
        }
        $this._dataVersion++  # Increment for theme change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] SetItems([array]$items) {
        $oldIndex = $this.SelectedIndex
        $this.Items.Clear()
        $this.Items.AddRange($items)
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on any data change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
        
        # Trigger callback if we have items and the selection changed
        if ($this.Items.Count -gt 0 -and ($oldIndex -ne 0 -or $this.Items.Count -eq 1) -and $this.OnSelectionChanged) {
            try {
                & $this.OnSelectionChanged
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("ListBox.SetItems: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                }
            }
        }
    }
    
    [void] AddItem([object]$item) {
        $this.Items.Add($item)
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this.Items.Count) {
            return $this.Items[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible($index)
            $this._dataVersion++  # Increment on selection change
            $this._itemsCacheInvalid = $true
            $this.Invalidate()
            
            # Trigger callback if selection actually changed
            if ($oldIndex -ne $index -and $this.OnSelectionChanged) {
                try {
                    & $this.OnSelectionChanged
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ListBox.SelectIndex: Error executing OnSelectionChanged handler - $($_.Exception.Message)")
                    }
                }
            }
        }
    }
    
    [void] EnsureVisible([int]$index) {
        # Adjust scroll to keep selected item visible
        $visibleEnd = $this.ScrollOffset + $this.VisibleItems - 1
        
        if ($index -lt $this.ScrollOffset) {
            $this.ScrollOffset = $index
        } elseif ($index -gt $visibleEnd) {
            $this.ScrollOffset = $index - $this.VisibleItems + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # Recalculate visible items based on height
        $contentHeight = $this.Height
        if ($this.ShowBorder) { $contentHeight -= 2 }
        if ($this.Title) { $contentHeight -= 1 }
        
        $this.VisibleItems = [Math]::Max(1, $contentHeight)
        $this._itemsCacheInvalid = $true
    }
    
    [string] OnRender() {
        if ($this._itemsCacheInvalid) {
            $this.RebuildItemsCache()
        }
        return $this._cachedItems
    }
    
    [void] RebuildItemsCache() {
        $sb = Get-PooledStringBuilder 2048  # ListBox can have many items
        
        $contentX = $this.X
        $contentY = $this.Y
        $contentWidth = $this.Width
        
        # Draw border if enabled
        if ($this.ShowBorder) {
            $this.DrawBorder($sb)
            $contentX++
            $contentY++
            $contentWidth -= 2
        }
        
        # Draw title if present
        if ($this.Title) {
            $sb.Append([VT]::MoveTo($contentX, $contentY))
            $sb.Append($this._colors["accent"])
            $titleText = $this.Title
            if ($titleText.Length -gt $contentWidth) {
                $titleText = $titleText.Substring(0, $contentWidth - 3) + "..."
            }
            $sb.Append($titleText)
            $sb.Append($this._colors["foreground"])
            $contentY++
        }
        
        # Draw items
        $endIndex = [Math]::Min($this.ScrollOffset + $this.VisibleItems, $this.Items.Count)
        $itemY = $contentY
        
        for ($i = $this.ScrollOffset; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $text = & $this.ItemRenderer $item
            
            # Truncate if too long
            if ($text.Length -gt $contentWidth - 2) {
                $text = $text.Substring(0, $contentWidth - 5) + "..."
            }
            
            $sb.Append([VT]::MoveTo($contentX, $itemY))
            
            # Selection highlighting
            if ($i -eq $this.SelectedIndex) {
                if ($this.IsFocused) {
                    $sb.Append($this._colors["selection.bg"])
                    $sb.Append($this._colors["selection.fg"])
                } else {
                    $sb.Append($this._colors["disabled"])
                }
                $sb.Append("> ")
            } else {
                $sb.Append("  ")
            }
            
            $sb.Append($text)
            
            # Clear to end of line if selected
            if ($i -eq $this.SelectedIndex) {
                $remainingSpace = $contentWidth - $text.Length - 2
                if ($remainingSpace -gt 0) {
                    $sb.Append([StringCache]::GetSpaces($remainingSpace))
                }
                $sb.Append([VT]::Reset())
            }
            
            $itemY++
        }
        
        # Clear any remaining empty lines in the visible area
        $remainingLines = $this.VisibleItems - ($endIndex - $this.ScrollOffset)
        if ($remainingLines -gt 0) {
            $bgColor = $this._colors["background"]
            $clearLine = [StringCache]::GetSpaces($contentWidth)
            
            for ($i = 0; $i -lt $remainingLines; $i++) {
                $sb.Append([VT]::MoveTo($contentX, $itemY))
                $sb.Append($bgColor)
                $sb.Append($clearLine)
                $sb.Append([VT]::Reset())
                $itemY++
            }
        }
        
        # Draw scrollbar if enabled and needed
        if ($this.ShowScrollbar -and $this.Items.Count -gt $this.VisibleItems) {
            $this.DrawScrollbar($sb)
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedItems = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._itemsCacheInvalid = $false
    }
    
    [void] DrawBorder([System.Text.StringBuilder]$sb) {
        $borderColor = if ($this.IsFocused) { 
            $this._colors["border.focused"] 
        } else { 
            $this._colors["border"] 
        }
        
        # Top border
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
        
        # Side borders
        for ($y = 1; $y -lt $this.Height - 1; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append([VT]::V())
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $this.Y + $y))
            $sb.Append([VT]::V())
        }
        
        # Bottom border
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $this.Height - 1))
        $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        $sb.Append([VT]::Reset())
    }
    
    [void] DrawScrollbar([System.Text.StringBuilder]$sb) {
        $scrollbarX = $this.X + $this.Width - 1
        if ($this.ShowBorder) { $scrollbarX-- }
        
        $scrollbarY = $this.Y + 1
        if ($this.ShowBorder) { $scrollbarY++ }
        if ($this.Title) { $scrollbarY++ }
        
        $scrollbarHeight = $this.VisibleItems
        
        # Calculate thumb position and size
        $thumbSize = [Math]::Max(1, [int]($scrollbarHeight * $this.VisibleItems / $this.Items.Count))
        $thumbPos = [int]($scrollbarY + ($scrollbarHeight - $thumbSize) * $this.ScrollOffset / ($this.Items.Count - $this.VisibleItems))
        
        # Draw scrollbar track and thumb
        for ($y = $scrollbarY; $y -lt $scrollbarY + $scrollbarHeight; $y++) {
            $sb.Append([VT]::MoveTo($scrollbarX, $y))
            
            if ($y -ge $thumbPos -and $y -lt $thumbPos + $thumbSize) {
                $sb.Append($this._colors["accent"])
                $sb.Append("‚ñà")
            } else {
                $sb.Append($this._colors["border"])
                $sb.Append("‚îÇ")
            }
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $false
            
            switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectIndex($this.SelectedIndex - 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectIndex($this.SelectedIndex + 1)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $newIndex = [Math]::Max(0, $this.SelectedIndex - $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $newIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $this.VisibleItems)
                $this.SelectIndex($newIndex)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectIndex(0)
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectIndex($this.Items.Count - 1)
                $handled = $true
            }
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ListBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Focus handling
    [void] OnGotFocus() {
        $this._dataVersion++  # Increment for focus change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._dataVersion++  # Increment for focus change
        $this._itemsCacheInvalid = $true
        $this.Invalidate()
    }
}


####\Components/MultiSelectListBox.ps1
# MultiSelectListBox.ps1 - ListBox with multiple selection support
# Supports checkboxes, range selection, and bulk operations

class MultiSelectListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    
    # Multi-selection settings
    [System.Collections.Generic.HashSet[int]]$SelectedIndices
    [bool]$ShowCheckboxes = $true
    [bool]$AllowRangeSelection = $true
    [bool]$AllowToggleAll = $true
    
    # Visual indicators
    [char]$CheckedIcon = [char]0x2611    # ‚òë
    [char]$UncheckedIcon = [char]0x2610  # ‚òê
    [char]$PartialIcon = [char]0x2612    # ‚òí
    
    # Selection state tracking
    hidden [int]$_lastSelectedIndex = -1  # For range selection
    hidden [bool]$_allSelected = $false
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [hashtable]$_colors = @{}
    
    MultiSelectListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this.SelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'checkbox' = $this.Theme.GetColor("checkbox")
                'checkbox.selected' = $this.Theme.GetColor("checkbox.selected")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        $this.SelectedIndices.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._lastSelectedIndex = -1
        $this._allSelected = $false
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $indexToRemove = -1
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if ($this.Items[$i] -eq $item) {
                $indexToRemove = $i
                break
            }
        }
        
        if ($indexToRemove -ge 0) {
            $this.RemoveItemAt($indexToRemove)
        }
    }
    
    [void] RemoveItemAt([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.Items.RemoveAt($index)
            
            # Update selected indices
            $newSelectedIndices = [System.Collections.Generic.HashSet[int]]::new()
            foreach ($selectedIndex in $this.SelectedIndices) {
                if ($selectedIndex -lt $index) {
                    $newSelectedIndices.Add($selectedIndex) | Out-Null
                } elseif ($selectedIndex -gt $index) {
                    $newSelectedIndices.Add($selectedIndex - 1) | Out-Null
                }
                # Skip the removed index
            }
            $this.SelectedIndices = $newSelectedIndices
            
            # Update current selection
            if ($this.SelectedIndex -eq $index) {
                $this.SelectedIndex = [Math]::Min($index, $this.Items.Count - 1)
            } elseif ($this.SelectedIndex -gt $index) {
                $this.SelectedIndex--
            }
            
            $this.EnsureSelectionValid()
            $this.UpdateAllSelectedState()
            $this.Invalidate()
        }
    }
    
    # Selection management
    [bool] IsSelected([int]$index) {
        return $this.SelectedIndices.Contains($index)
    }
    
    [void] SetSelected([int]$index, [bool]$selected) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($selected) {
                $this.SelectedIndices.Add($index) | Out-Null
            } else {
                $this.SelectedIndices.Remove($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] ToggleSelected([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            if ($this.IsSelected($index)) {
                $this.SelectedIndices.Remove($index) | Out-Null
            } else {
                $this.SelectedIndices.Add($index) | Out-Null
            }
            $this.UpdateAllSelectedState()
            $this.FireSelectionChanged()
        }
    }
    
    [void] SelectRange([int]$startIndex, [int]$endIndex) {
        if (-not $this.AllowRangeSelection) {
            return
        }
        
        $start = [Math]::Min($startIndex, $endIndex)
        $end = [Math]::Max($startIndex, $endIndex)
        
        for ($i = $start; $i -le $end -and $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [void] SelectAll() {
        $this.SelectedIndices.Clear()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            $this.SelectedIndices.Add($i) | Out-Null
        }
        $this._allSelected = $true
        $this.FireSelectionChanged()
    }
    
    [void] SelectNone() {
        $this.SelectedIndices.Clear()
        $this._allSelected = $false
        $this.FireSelectionChanged()
    }
    
    [void] InvertSelection() {
        $newSelected = [System.Collections.Generic.HashSet[int]]::new()
        for ($i = 0; $i -lt $this.Items.Count; $i++) {
            if (-not $this.IsSelected($i)) {
                $newSelected.Add($i) | Out-Null
            }
        }
        $this.SelectedIndices = $newSelected
        $this.UpdateAllSelectedState()
        $this.FireSelectionChanged()
    }
    
    [System.Collections.ArrayList] GetSelectedItems() {
        $selectedItems = [System.Collections.ArrayList]::new()
        foreach ($index in $this.SelectedIndices) {
            if ($index -ge 0 -and $index -lt $this.Items.Count) {
                $selectedItems.Add($this.Items[$index]) | Out-Null
            }
        }
        return $selectedItems
    }
    
    [System.Collections.Generic.List[int]] GetSelectedIndicesList() {
        $result = [System.Collections.Generic.List[int]]::new()
        $sortedIndices = $this.SelectedIndices | Sort-Object
        foreach ($index in $sortedIndices) {
            $result.Add($index)
        }
        return $result
    }
    
    [int] GetSelectedCount() {
        return $this.SelectedIndices.Count
    }
    
    # Navigation
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Items.Count) {
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            $this.Invalidate()
        }
    }
    
    # Internal methods
    [void] UpdateAllSelectedState() {
        $this._allSelected = ($this.SelectedIndices.Count -eq $this.Items.Count -and $this.Items.Count -gt 0)
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this.Items.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this.Items.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [void] FireSelectionChanged() {
        if ($this.OnSelectionChanged) {
            & $this.OnSelectionChanged
        }
        $this.Invalidate()
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 2048  # MultiSelectListBox with items and checkboxes
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $checkboxColor = if ($this._colors['checkbox']) { $this._colors['checkbox'] } else { $normalColor }
        $selectedCheckboxColor = if ($this._colors['checkbox.selected']) { $this._colors['checkbox.selected'] } else { "`e[38;2;0;255;0m" }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title with selection info
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                
                $selectionInfo = ""
                if ($this.SelectedIndices.Count -gt 0) {
                    $selectionInfo = " ($($this.SelectedIndices.Count) selected)"
                }
                $titleText = "$($this.Title)$selectionInfo"
                $titleLine = $titleText.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this.Items.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $item = $this.Items[$i]
            $y = $contentY + ($i - $startIndex)
            $isCurrentSelection = ($i -eq $this.SelectedIndex)
            $isSelected = $this.IsSelected($i)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for current item
            if ($isCurrentSelection) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Checkbox
            if ($this.ShowCheckboxes) {
                $checkboxIcon = if ($isSelected) { $this.CheckedIcon } else { $this.UncheckedIcon }
                $checkboxColorToUse = if ($isSelected) { $selectedCheckboxColor } else { $checkboxColor }
                
                $line += "$checkboxIcon "
            }
            
            # Item content
            $itemText = if ($this.ItemRenderer) {
                & $this.ItemRenderer $item
            } else {
                if ($item -eq $null) {
                    "<null>"
                } else {
                    $item.ToString()
                }
            }
            
            $line += $itemText
            
            # Adjust content width for checkbox
            $availableWidth = if ($this.ShowCheckboxes) { $contentWidth - 2 } else { $contentWidth }
            
            # Truncate if too long
            if ($line.Length -gt $availableWidth) {
                $line = $line.Substring(0, $availableWidth - 3) + "..."
            }
            
            # Pad to full width
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            # Side borders
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldSelectedIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    
                    # Shift+Up for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                    
                    # Shift+Down for range selection
                    if (($key.Modifiers -band [System.ConsoleModifiers]::Shift) -and $this.AllowRangeSelection) {
                        if ($this._lastSelectedIndex -ge 0) {
                            $this.SelectRange($this._lastSelectedIndex, $this.SelectedIndex)
                        } else {
                            $this.SetSelected($this.SelectedIndex, $true)
                        }
                    }
                    
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3
                $this.SelectedIndex = [Math]::Min($this.Items.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this.Items.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Spacebar) {
                # Toggle selection of current item
                $this.ToggleSelected($this.SelectedIndex)
                $this._lastSelectedIndex = $this.SelectedIndex
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                # Toggle selection and move down
                $this.ToggleSelected($this.SelectedIndex)
                if ($this.SelectedIndex -lt $this.Items.Count - 1) {
                    $this.SelectedIndex++
                }
                $this._lastSelectedIndex = $this.SelectedIndex - 1
                $handled = $true
            }
        }
        
        # Keyboard shortcuts
        if (($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            switch ($key.Key) {
                ([System.ConsoleKey]::A) {
                    if ($this.AllowToggleAll) {
                        if ($this._allSelected) {
                            $this.SelectNone()
                        } else {
                            $this.SelectAll()
                        }
                    }
                    $handled = $true
                }
                ([System.ConsoleKey]::I) {
                    $this.InvertSelection()
                    $handled = $true
                }
                ([System.ConsoleKey]::D) {
                    $this.SelectNone()
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Update last selected index for range operations
            if (-not ($key.Modifiers -band [System.ConsoleModifiers]::Shift)) {
                $this._lastSelectedIndex = $this.SelectedIndex
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/ProgressBar.ps1
# ProgressBar.ps1 - Progress visualization component based on AxiomPhoenix patterns
# Fast string-based rendering with percentage and status text display

class ProgressBar : UIElement {
    [int]$Value = 0                    # Current progress (0-100)
    [int]$Maximum = 100               # Maximum value (default 100 for percentages)
    [string]$StatusText = ""          # Optional status text
    [bool]$ShowPercentage = $true     # Show percentage text
    [bool]$ShowBorder = $true         # Show border around progress bar
    [string]$Title = ""               # Optional title
    
    # Visual customization
    [char]$FilledChar = [char]0x2588  # ‚ñà (full block)
    [char]$EmptyChar = [char]0x2591   # ‚ñë (light shade)
    [string]$ProgressColor = ""       # Color for filled portion
    [string]$CompleteColor = ""       # Color when 100% complete
    [string]$TextColor = ""           # Color for percentage text
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_lastValue = -1      # For change detection
    hidden [string]$_lastStatusText = ""
    hidden [hashtable]$_colors = @{}  # Cached color ANSI sequences
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    ProgressBar() : base() {
        $this.Height = 5  # Default height (border + bar + percentage + status + border)
        $this.Width = 40  # Default width
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        # Cache theme colors
        if ($this.Theme) {
            # Cache all color ANSI sequences
            $this._colors["progress.active"] = $this.Theme.GetColor("progress.active")
            $this._colors["progress.complete"] = $this.Theme.GetColor("progress.complete")
            $this._colors["progress.text"] = $this.Theme.GetColor("progress.text")
            $this._colors["border"] = $this.Theme.GetColor("border")
            $this._colors["title"] = $this.Theme.GetColor("title")
            $this._colors["normal"] = $this.Theme.GetColor("normal")
            
            # Set default colors if not already set
            if ([string]::IsNullOrEmpty($this.ProgressColor)) {
                $this.ProgressColor = $this._colors["progress.active"]
            }
            if ([string]::IsNullOrEmpty($this.CompleteColor)) {
                $this.CompleteColor = $this._colors["progress.complete"]
            }
            if ([string]::IsNullOrEmpty($this.TextColor)) {
                $this.TextColor = $this._colors["progress.text"]
            }
        }
        
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [void] SetProgress([int]$value) {
        $this.SetProgress($value, $this.StatusText)
    }
    
    [void] SetProgress([int]$value, [string]$statusText) {
        # Clamp value to valid range
        $this.Value = [Math]::Max(0, [Math]::Min($this.Maximum, $value))
        $this.StatusText = $statusText
        
        # Only invalidate if something actually changed
        if ($this.Value -ne $this._lastValue -or $this.StatusText -ne $this._lastStatusText) {
            $this._lastValue = $this.Value
            $this._lastStatusText = $this.StatusText
            $this._dataVersion++  # Increment on progress change
            $this.Invalidate()
        }
    }
    
    [int] GetPercentage() {
        if ($this.Maximum -eq 0) {
            return 0
        }
        return [int](($this.Value * 100) / $this.Maximum)
    }
    
    [bool] IsComplete() {
        return $this.Value -ge $this.Maximum
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 512  # ProgressBar is relatively simple
        
        # Colors from cache
        $borderColor = if ($this._colors.ContainsKey("border")) { $this._colors["border"] } else { "" }
        $titleColor = if ($this._colors.ContainsKey("title")) { $this._colors["title"] } else { "" }
        $normalColor = if ($this._colors.ContainsKey("normal")) { $this._colors["normal"] } else { "" }
        
        # Determine progress color based on completion
        $currentProgressColor = if ($this.IsComplete()) { 
            if ([string]::IsNullOrEmpty($this.CompleteColor)) { $this.ProgressColor } else { $this.CompleteColor }
        } else { 
            $this.ProgressColor 
        }
        
        # Calculate dimensions
        $contentY = $this.Y
        $contentHeight = $this.Height
        $barWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($barWidth).Substring(0, $barWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Calculate bar dimensions
        $percentage = $this.GetPercentage()
        $filledWidth = if ($barWidth -gt 0) { [Math]::Floor($barWidth * $percentage / 100) } else { 0 }
        $emptyWidth = $barWidth - $filledWidth
        
        # Render progress bar
        $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
        
        # Filled portion
        if ($filledWidth -gt 0) {
            $sb.Append($currentProgressColor)
            $sb.Append([StringCache]::GetRepeatedChar($this.FilledChar, $filledWidth))
        }
        
        # Empty portion  
        if ($emptyWidth -gt 0) {
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetRepeatedChar($this.EmptyChar, $emptyWidth))
        }
        
        $contentY++
        $contentHeight--
        
        # Percentage text (centered)
        if ($this.ShowPercentage) {
            $percentText = "$percentage%"
            $textX = $this.X + ($this.Width - $percentText.Length) / 2
            $sb.Append([VT]::MoveTo([int]$textX, $contentY))
            $sb.Append($this.TextColor)
            $sb.Append($percentText)
            $contentY++
            $contentHeight--
        }
        
        # Status text (left-aligned, truncated if needed)
        if ($this.StatusText -and $contentHeight -gt ($this.ShowBorder ? 1 : 0)) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($normalColor)
            
            $statusWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
            if ($this.StatusText.Length -gt $statusWidth) {
                $truncated = $this.StatusText.Substring(0, $statusWidth - 3) + "..."
                $sb.Append($truncated)
            } else {
                $paddedStatus = $this.StatusText.PadRight($statusWidth).Substring(0, $statusWidth)
                $sb.Append($paddedStatus)
            }
            $contentY++
            $contentHeight--
        }
        
        # Side borders for remaining height
        if ($this.ShowBorder) {
            while ($contentHeight -gt 1) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
                $sb.Append($borderColor)
                $sb.Append([VT]::V())
                
                $contentY++
                $contentHeight--
            }
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    # Animation helper method (for future use)
    [void] AnimateTo([int]$targetValue, [int]$durationMs = 1000) {
        # Basic animation - could be enhanced with timer/events
        $startValue = $this.Value
        $steps = [Math]::Max(1, $durationMs / 50)  # 50ms per step
        $increment = ($targetValue - $startValue) / $steps
        
        for ($i = 0; $i -lt $steps; $i++) {
            $currentValue = $startValue + ($increment * ($i + 1))
            $this.SetProgress([int]$currentValue)
            Start-Sleep -Milliseconds 50
        }
        
        # Ensure we reach the exact target
        $this.SetProgress($targetValue)
    }
    
    # No input handling needed for progress bar
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        return $false
    }
}


####\Components/RangerFileTree.ps1
# RangerFileTree.ps1 - Ranger-style 3-pane file browser
# Left: Parent directory, Center: Current directory, Right: Preview/child

class RangerFileTree : Container {
    [string]$CurrentPath
    [FileSystemNode]$ParentNode
    [FileSystemNode]$CurrentNode
    [FileSystemNode]$PreviewNode
    
    # Three panes
    [FastFileTree]$ParentPane
    [FastFileTree]$CurrentPane
    [FastFileTree]$PreviewPane
    
    # Layout
    [double]$LeftPaneWidth = 0.25
    [double]$CenterPaneWidth = 0.35
    [double]$RightPaneWidth = 0.40
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    hidden [ThemeManager]$Theme
    
    RangerFileTree() : base() {
        $this.CurrentPath = (Get-Location).Path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    RangerFileTree([string]$path) : base() {
        $this.CurrentPath = $path
        $this.IsFocusable = $true
        $this.CreatePanes()
    }
    
    [void] CreatePanes() {
        # Create parent pane
        $this.ParentPane = [FastFileTree]::new()
        $this.ParentPane.ShowBorder = $true
        $this.ParentPane.Title = "Parent"
        $this.ParentPane.ShowSize = $false
        $this.AddChild($this.ParentPane)
        
        # Create current pane
        $this.CurrentPane = [FastFileTree]::new()
        $this.CurrentPane.ShowBorder = $true
        $this.CurrentPane.Title = "Current"
        $this.CurrentPane.ShowSize = $true
        $this.AddChild($this.CurrentPane)
        
        # Create preview pane
        $this.PreviewPane = [FastFileTree]::new()
        $this.PreviewPane.ShowBorder = $true
        $this.PreviewPane.Title = "Preview"
        $this.PreviewPane.ShowSize = $true
        $this.AddChild($this.PreviewPane)
        
        # Set up event handlers
        $ranger = $this
        $this.CurrentPane.OnSelectionChanged = {
            $ranger.UpdatePreviewPane()
        }.GetNewClosure()
        
        $this.CurrentPane.OnFileSelected = {
            param($node)
            if ($node.IsDirectory) {
                $ranger.NavigateToDirectory($node.FullPath)
            } else {
                if ($ranger.OnFileSelected) {
                    & $ranger.OnFileSelected $node
                }
            }
        }.GetNewClosure()
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnInitialize: Starting initialization")
            $global:Logger.Debug("  IsFocusable: $($this.IsFocusable)")
            $global:Logger.Debug("  CurrentPath: $($this.CurrentPath)")
        }
        
        # Initialize theme
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        
        # Initialize child panes
        $this.ParentPane.ServiceContainer = $this.ServiceContainer
        $this.ParentPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  ParentPane initialized, IsFocusable=$($this.ParentPane.IsFocusable)")
        }
        
        $this.CurrentPane.ServiceContainer = $this.ServiceContainer
        $this.CurrentPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  CurrentPane initialized, IsFocusable=$($this.CurrentPane.IsFocusable)")
        }
        
        $this.PreviewPane.ServiceContainer = $this.ServiceContainer
        $this.PreviewPane.OnInitialize()
        if ($global:Logger) {
            $global:Logger.Debug("  PreviewPane initialized, IsFocusable=$($this.PreviewPane.IsFocusable)")
        }
        
        # Load initial directory
        $this.NavigateToDirectory($this.CurrentPath)
        
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnInitialize: Completed")
        }
    }
    
    [void] NavigateToDirectory([string]$path) {
        if (-not (Test-Path $path -PathType Container)) {
            return
        }
        
        $this.CurrentPath = Resolve-Path $path
        
        # Update parent pane
        $parentPath = Split-Path $this.CurrentPath -Parent
        if ($parentPath) {
            $this.ParentPane.LoadDirectory($parentPath)
            # Select current directory in parent
            $currentName = Split-Path $this.CurrentPath -Leaf
            for ($i = 0; $i -lt $this.ParentPane._flatView.Count; $i++) {
                if ($this.ParentPane._flatView[$i].Name -eq $currentName) {
                    $this.ParentPane.SelectIndex($i)
                    break
                }
            }
        } else {
            # At root, show drives or root
            $this.ParentPane.Title = "Drives"
            $this.ParentPane._flatView.Clear()
            $this.ParentPane.Invalidate()
        }
        
        # Update current pane
        $this.CurrentPane.LoadDirectory($this.CurrentPath)
        $this.CurrentPane.Title = Split-Path $this.CurrentPath -Leaf
        if ($this.CurrentPane._flatView.Count -gt 0) {
            $this.CurrentPane.SelectIndex(0)
            if ($global:Logger) {
                $global:Logger.Debug("RangerFileTree: Selected first item in current pane")
            }
        } else {
            if ($global:Logger) {
                $global:Logger.Warning("RangerFileTree: No items in current directory")
            }
        }
        
        # Update preview pane
        $this.UpdatePreviewPane()
    }
    
    [void] UpdatePreviewPane() {
        $selected = $this.CurrentPane.GetSelectedNode()
        if (-not $selected) {
            $this.PreviewPane.Title = "Preview"
            $this.PreviewPane._flatView.Clear()
            $this.PreviewPane.Invalidate()
            return
        }
        
        if ($selected.IsDirectory) {
            # Show directory contents
            $this.PreviewPane.LoadDirectory($selected.FullPath)
            $this.PreviewPane.Title = $selected.Name
        } else {
            # Show file preview
            $this.PreviewPane.Title = "File: $($selected.Name)"
            $this.PreviewPane._flatView.Clear()
            
            # Could add file preview logic here (first N lines, file info, etc.)
            # For now, just show file info
            $info = [FileSystemNode]::new($selected.FullPath)
            $info.Name = "Size: $($selected.GetSizeString())"
            $this.PreviewPane._flatView.Add($info) | Out-Null
            
            $info2 = [FileSystemNode]::new($selected.FullPath)
            $info2.Name = "Modified: $($selected.LastModified.ToString('yyyy-MM-dd HH:mm'))"
            $this.PreviewPane._flatView.Add($info2) | Out-Null
            
            $this.PreviewPane.Invalidate()
        }
    }
    
    [void] OnBoundsChanged() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Calculate pane widths
        $totalWidth = $this.Width
        if ($totalWidth -le 0) {
            if ($global:Logger) {
                $global:Logger.Warning("RangerFileTree: Invalid width $totalWidth")
            }
            return
        }
        
        $leftWidth = [int]($totalWidth * $this.LeftPaneWidth)
        $centerWidth = [int]($totalWidth * $this.CenterPaneWidth)
        $rightWidth = $totalWidth - $leftWidth - $centerWidth
        
        if ($global:Logger) {
            $global:Logger.Debug("  Pane widths: left=$leftWidth, center=$centerWidth, right=$rightWidth")
        }
        
        # Position panes
        $this.ParentPane.SetBounds($this.X, $this.Y, $leftWidth, $this.Height)
        $this.CurrentPane.SetBounds($this.X + $leftWidth, $this.Y, $centerWidth, $this.Height)
        $this.PreviewPane.SetBounds($this.X + $leftWidth + $centerWidth, $this.Y, $rightWidth, $this.Height)
    }
    
    [string] OnRender() {
        # Debug rendering to ensure we're actually drawing
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnRender: Rendering with IsFocused=$($this.IsFocused)")
        }
        
        # Let base Container render children
        return ([Container]$this).OnRender()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)' Modifiers=$($key.Modifiers)")
            $global:Logger.Debug("  IsFocused: $($this.IsFocused)")
            $global:Logger.Debug("  CurrentPane IsFocused: $($this.CurrentPane.IsFocused)")
        }
        
        # Handle vim-style navigation keys
        if (-not $key.Modifiers) {
            switch ($key.KeyChar) {
                'h' {
                    # Navigate to parent directory (left)
                    $parentPath = Split-Path $this.CurrentPath -Parent
                    if ($parentPath) {
                        $this.NavigateToDirectory($parentPath)
                    }
                    return $true
                }
                'l' {
                    # Navigate into selected directory or open file (right)
                    $selected = $this.CurrentPane.GetSelectedNode()
                    if ($selected) {
                        if ($selected.IsDirectory) {
                            $this.NavigateToDirectory($selected.FullPath)
                        } else {
                            # Open file
                            if ($this.OnFileSelected) {
                                & $this.OnFileSelected $selected
                            }
                        }
                    }
                    return $true
                }
                'j' {
                    # Move down - create a synthetic down arrow key
                    $downKey = New-Object System.ConsoleKeyInfo -ArgumentList ([char]0, [System.ConsoleKey]::DownArrow, $false, $false, $false)
                    return $this.CurrentPane.HandleInput($downKey)
                }
                'k' {
                    # Move up - create a synthetic up arrow key
                    $upKey = New-Object System.ConsoleKeyInfo -ArgumentList ([char]0, [System.ConsoleKey]::UpArrow, $false, $false, $false)
                    return $this.CurrentPane.HandleInput($upKey)
                }
                '.' {
                    # Toggle hidden files
                    # TODO: Implement hidden file toggle
                    return $true
                }
            }
        }
        
        # Also handle arrow keys for compatibility
        switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                # Navigate to parent directory
                $parentPath = Split-Path $this.CurrentPath -Parent
                if ($parentPath) {
                    $this.NavigateToDirectory($parentPath)
                }
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                # Navigate into selected directory
                $selected = $this.CurrentPane.GetSelectedNode()
                if ($selected -and $selected.IsDirectory) {
                    $this.NavigateToDirectory($selected.FullPath)
                }
                return $true
            }
        }
        
        # Let current pane handle other input
        return $this.CurrentPane.HandleInput($key)
    }
    
    [void] OnGotFocus() {
        ([UIElement]$this).OnGotFocus()
        # Don't automatically focus child pane - we'll handle input and delegate as needed
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.OnGotFocus: Got focus")
        }
    }
    
    [void] Focus() {
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.Focus: Setting focus")
        }
        
        # Call base Focus to set IsFocused = true
        ([UIElement]$this).Focus()
        
        # Don't focus child panes - we'll handle the input routing ourselves
        if ($global:Logger) {
            $global:Logger.Debug("RangerFileTree.Focus: IsFocused = $($this.IsFocused)")
        }
    }
}


####\Components/SearchableListBox.ps1
# SearchableListBox.ps1 - ListBox with built-in search/filter functionality
# High-performance search with real-time filtering

class SearchableListBox : UIElement {
    [System.Collections.ArrayList]$Items
    [System.Collections.ArrayList]$_filteredItems
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [string]$SearchQuery = ""
    [bool]$ShowSearchBox = $true
    [bool]$CaseSensitive = $false
    [bool]$UseRegex = $false
    [scriptblock]$ItemRenderer = $null
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnItemActivated = {}
    
    # Search configuration
    [int]$MinSearchLength = 0  # Start filtering immediately
    [bool]$SearchInDescription = $false
    [scriptblock]$SearchFilter = $null  # Custom filter function
    
    # Visual settings
    [string]$SearchPrompt = "Search: "
    [string]$NoResultsText = "No items found"
    [string]$SearchIcon = "üîç"  # Search icon
    [char[]]$ExcludedSearchKeys = @('n', 'e', 'd')  # Keys that should not trigger search mode
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [int]$_searchBoxHeight = 3
    hidden [bool]$_searchMode = $false
    hidden [int]$_lastFilteredCount = -1
    hidden [System.Collections.Generic.HashSet[string]]$_highlightCache
    hidden [hashtable]$_colors = @{}
    
    SearchableListBox() : base() {
        $this.Items = [System.Collections.ArrayList]::new()
        $this._filteredItems = [System.Collections.ArrayList]::new()
        $this._highlightCache = [System.Collections.Generic.HashSet[string]]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.ApplyFilter()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'background' = $this.Theme.GetBgColor("background")
                'search' = $this.Theme.GetColor("search")
                'highlight' = $this.Theme.GetColor("highlight")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API
    [void] SetItems($items) {
        $this.Items.Clear()
        if ($items) {
            foreach ($item in $items) {
                $this.Items.Add($item) | Out-Null
            }
        }
        $this.ApplyFilter()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this.Invalidate()
    }
    
    [void] AddItem($item) {
        $this.Items.Add($item) | Out-Null
        $this.ApplyFilter()
        $this.Invalidate()
    }
    
    [void] RemoveItem($item) {
        $this.Items.Remove($item) | Out-Null
        $this.ApplyFilter()
        $this.EnsureSelectionValid()
        $this.Invalidate()
    }
    
    [object] GetSelectedItem() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._filteredItems.Count) {
            return $this._filteredItems[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._filteredItems.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] SetSearchQuery([string]$query) {
        if ($this.SearchQuery -ne $query) {
            $this.SearchQuery = $query
            $this.ApplyFilter()
            $this.SelectedIndex = 0  # Reset to top when search changes
            $this.ScrollOffset = 0
            $this.Invalidate()
        }
    }
    
    [void] ClearSearch() {
        $this.SetSearchQuery("")
    }
    
    [void] EnterSearchMode() {
        $this._searchMode = $true
        $this.Invalidate()
    }
    
    [void] ExitSearchMode() {
        $this._searchMode = $false
        $this.Invalidate()
    }
    
    [void] ToggleSearchMode() {
        $this._searchMode = -not $this._searchMode
        $this.Invalidate()
    }
    
    # Internal methods
    [void] ApplyFilter() {
        $this._filteredItems.Clear()
        $this._highlightCache.Clear()
        
        # If no search query, show all items
        if ([string]::IsNullOrEmpty($this.SearchQuery) -or $this.SearchQuery.Length -lt $this.MinSearchLength) {
            foreach ($item in $this.Items) {
                $this._filteredItems.Add($item) | Out-Null
            }
        } else {
            # Apply filtering - optimize by pre-calculating normalized query
            $normalizedQuery = if ($this.CaseSensitive) { $this.SearchQuery } else { $this.SearchQuery.ToLower() }
            foreach ($item in $this.Items) {
                if ($this.MatchesSearchOptimized($item, $this.SearchQuery, $normalizedQuery)) {
                    $this._filteredItems.Add($item) | Out-Null
                }
            }
        }
        
        $this._lastFilteredCount = $this._filteredItems.Count
        $this.EnsureSelectionValid()
    }
    
    # Optimized version that avoids repeated ToLower() calls
    [bool] MatchesSearchOptimized($item, [string]$query, [string]$normalizedQuery) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity using pre-normalized query
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $normalizedQuery  # Use pre-normalized query
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                return $false
            }
        } else {
            return $searchText.Contains($query)
        }
    }

    [bool] MatchesSearch($item, [string]$query) {
        # Custom filter takes precedence
        if ($this.SearchFilter) {
            try {
                return & $this.SearchFilter $item $query
            } catch {
                # Fall back to default behavior on error
            }
        }
        
        # Get searchable text from item
        $searchText = $this.GetSearchableText($item)
        
        if ([string]::IsNullOrEmpty($searchText)) {
            return $false
        }
        
        # Apply case sensitivity
        if (-not $this.CaseSensitive) {
            $searchText = $searchText.ToLower()
            $query = $query.ToLower()
        }
        
        # Apply search logic
        if ($this.UseRegex) {
            try {
                return $searchText -match $query
            } catch {
                # Invalid regex, fall back to simple contains
                return $searchText -like "*$query*"
            }
        } else {
            # Simple contains search
            return $searchText -like "*$query*"
        }
    }
    
    [string] GetSearchableText($item) {
        if ($item -eq $null) {
            return ""
        }
        
        # If item has a specific string representation method
        if ($item.PSObject.Methods['ToString'] -and $item.ToString() -ne $item.GetType().FullName) {
            return $item.ToString()
        }
        
        # If it's a hashtable or PSObject, try common text properties
        if ($item -is [hashtable]) {
            $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
            foreach ($prop in $textProps) {
                if ($item.ContainsKey($prop) -and $item[$prop]) {
                    return $item[$prop].ToString()
                }
            }
            # Fall back to all values if SearchInDescription is enabled
            if ($this.SearchInDescription) {
                return ($item.Values -join ' ')
            }
        }
        
        # Try common properties for objects
        $textProps = @('Name', 'Title', 'Text', 'Description', 'Label')
        foreach ($prop in $textProps) {
            $value = $item.PSObject.Properties[$prop]
            if ($value -and $value.Value) {
                return $value.Value.ToString()
            }
        }
        
        # Fall back to string conversion
        return $item.ToString()
    }
    
    [void] EnsureSelectionValid() {
        if ($this.SelectedIndex -ge $this._filteredItems.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
        }
        if ($this.SelectedIndex -lt 0 -and $this._filteredItems.Count -gt 0) {
            $this.SelectedIndex = 0
        }
    }
    
    [void] EnsureVisible() {
        $contentHeight = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        if ($this.ShowSearchBox) {
            $contentHeight -= $this._searchBoxHeight
        }
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $contentHeight) {
            $this.ScrollOffset = $this.SelectedIndex - $contentHeight + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    # Rendering
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 2048  # SearchableListBox with search box and items
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $bgColor = $this._colors['background']
        $searchColor = if ($this._colors['search']) { $this._colors['search'] } else { $normalColor }
        $highlightColor = if ($this._colors['highlight']) { $this._colors['highlight'] } else { "`e[38;2;255;255;0m" }
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = [Math]::Max(1, $this.Width - ($this.ShowBorder ? 2 : 0))
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = if ($contentWidth -le 0) { "" } else { $titleText.PadRight($contentWidth).Substring(0, $contentWidth) }
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = "$($this.Title)"
                if ($this._filteredItems.Count -ne $this.Items.Count) {
                    $titleText += " ($($this._filteredItems.Count)/$($this.Items.Count))"
                }
                $titleLine = if ($this.Width -le 0) { "" } else { $titleText.PadRight($this.Width).Substring(0, $this.Width) }
                $sb.Append($titleLine)
                $contentY++
                $contentHeight--
            }
        }
        
        # Search box
        if ($this.ShowSearchBox) {
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($searchColor)
            
            $searchText = "$($this.SearchIcon) $($this.SearchPrompt)$($this.SearchQuery)"
            if ($this._searchMode) {
                $searchText += "|"  # Cursor indicator
            }
            
            $searchLine = if ($contentWidth -le 0) { "" } else { $searchText.PadRight($contentWidth).Substring(0, $contentWidth) }
            $sb.Append($searchLine)
            $contentY++
            $contentHeight--
            
            # Search box separator
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $contentY))
            $sb.Append($borderColor)
            $sb.Append([StringCache]::GetVTHorizontal($contentWidth))
            $contentY++
            $contentHeight--
            
            # Side borders for search area
            if ($this.ShowBorder) {
                for ($y = $contentY - 2; $y -lt $contentY; $y++) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # List content
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._filteredItems.Count)
        
        if ($this._filteredItems.Count -eq 0) {
            # Fill all empty lines first
            for ($i = 0; $i -lt $visibleLines; $i++) {
                $y = $contentY + $i
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                $sb.Append($normalColor)
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($contentWidth))
                
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
            
            # No results message centered in the content area
            if ($visibleLines -gt 0) {
                $noResultsY = $contentY + [int]($visibleLines / 2)
                $messageX = $this.X + ($this.ShowBorder ? 1 : 0) + [Math]::Max(0, [int](($contentWidth - $this.NoResultsText.Length) / 2))
                $sb.Append([VT]::MoveTo($messageX, $noResultsY))
                $sb.Append($normalColor)
                $sb.Append($bgColor)
                $sb.Append($this.NoResultsText)
            }
        } else {
            # Render items
            for ($i = $startIndex; $i -lt $endIndex; $i++) {
                $item = $this._filteredItems[$i]
                $y = $contentY + ($i - $startIndex)
                
                $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
                
                # Background for selected item
                if ($i -eq $this.SelectedIndex) {
                    $sb.Append($selectedBg)
                } else {
                    $sb.Append($normalColor)
                    $sb.Append($bgColor)
                }
                
                # Get display text
                $displayText = if ($this.ItemRenderer) {
                    & $this.ItemRenderer $item
                } else {
                    $this.GetSearchableText($item)
                }
                
                # Highlight search terms
                if (-not [string]::IsNullOrEmpty($this.SearchQuery) -and $displayText) {
                    $displayText = $this.HighlightSearchTerms($displayText, $highlightColor, $normalColor)
                }
                
                # Pad and truncate to fit
                if ($displayText.Length -gt $contentWidth) {
                    $displayText = $displayText.Substring(0, $contentWidth - 3) + "..."
                }
                $displayLine = if ($contentWidth -le 0) { "" } else { $displayText.PadRight($contentWidth).Substring(0, $contentWidth) }
                $sb.Append($displayLine)
                
                # Side borders
                if ($this.ShowBorder) {
                    $sb.Append([VT]::MoveTo($this.X, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                    
                    $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                    $sb.Append($currentBorderColor)
                    $sb.Append([VT]::V())
                }
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [string] HighlightSearchTerms([string]$text, [string]$highlightColor, [string]$normalColor) {
        if ([string]::IsNullOrEmpty($this.SearchQuery)) {
            return $text
        }
        
        # Simple highlighting - replace matches with colored versions
        try {
            $query = $this.SearchQuery
            if (-not $this.CaseSensitive) {
                # Case-insensitive replacement
                return [regex]::Replace($text, [regex]::Escape($query), "$highlightColor`$0$normalColor", [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
            } else {
                return $text.Replace($query, "$highlightColor$query$normalColor")
            }
        } catch {
            # If highlighting fails, return original text
            return $text
        }
    }
    
    # Input handling
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        # Search mode input
        if ($this._searchMode) {
            switch ($key.Key) {
                ([System.ConsoleKey]::Escape) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    $this.ExitSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Backspace) {
                    if ($this.SearchQuery.Length -gt 0) {
                        $this.SetSearchQuery($this.SearchQuery.Substring(0, $this.SearchQuery.Length - 1))
                    }
                    $handled = $true
                }
                default {
                    if ($key.KeyChar -ge 32 -and $key.KeyChar -lt 127) {  # Printable characters
                        $this.SetSearchQuery($this.SearchQuery + $key.KeyChar)
                        $handled = $true
                    }
                }
            }
        } else {
            # Normal navigation mode
            switch ($key.Key) {
                ([System.ConsoleKey]::UpArrow) {
                    if ($this.SelectedIndex -gt 0) {
                        $this.SelectedIndex--
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::DownArrow) {
                    if ($this.SelectedIndex -lt $this._filteredItems.Count - 1) {
                        $this.SelectedIndex++
                        $handled = $true
                    }
                }
                ([System.ConsoleKey]::PageUp) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::PageDown) {
                    $pageSize = $this.Height - 5
                    $this.SelectedIndex = [Math]::Min($this._filteredItems.Count - 1, $this.SelectedIndex + $pageSize)
                    $handled = $true
                }
                ([System.ConsoleKey]::Home) {
                    $this.SelectedIndex = 0
                    $handled = $true
                }
                ([System.ConsoleKey]::End) {
                    $this.SelectedIndex = [Math]::Max(0, $this._filteredItems.Count - 1)
                    $handled = $true
                }
                ([System.ConsoleKey]::F3) {
                    $this.ToggleSearchMode()
                    $handled = $true
                }
                ([System.ConsoleKey]::Enter) {
                    if ($this.OnItemActivated -and $this._filteredItems.Count -gt 0 -and $this.SelectedIndex -ge 0) {
                        & $this.OnItemActivated $this.GetSelectedItem()
                    }
                    $handled = $true
                }
            }
            
            # Character-based search activation (exclude shortcut keys)
            if (-not $handled -and $key.KeyChar -ge 32 -and $key.KeyChar -lt 127 -and $key.KeyChar -notin $this.ExcludedSearchKeys) {
                $this.SetSearchQuery([string]$key.KeyChar)
                $this.EnterSearchMode()
                $handled = $true
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._searchMode = $false  # Exit search mode when losing focus
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/TabContainer.ps1
# TabContainer.ps1 - Fast tab-based screen switching
# Core component for PRAXIS multi-screen management

class TabContainer : Container {
    [System.Collections.Generic.List[TabItem]]$Tabs
    [int]$ActiveTabIndex = 0
    [int]$TabBarHeight = 2
    
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_tabCache = @{}
    hidden [string]$_cachedTabBar = ""
    hidden [bool]$_tabBarInvalid = $true
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TabContainer() : base() {
        $this.Tabs = [System.Collections.Generic.List[TabItem]]::new()
    }
    
    [void] OnInitialize() {
        $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
        $this.Theme.Subscribe({ $this.OnThemeChanged() })
        $this.OnThemeChanged()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'tab.background' = $this.Theme.GetBgColor("tab.background")
                'tab.active.background' = $this.Theme.GetBgColor("tab.active.background")
                'tab.active.foreground' = $this.Theme.GetColor("tab.active.foreground")
                'tab.active.accent' = $this.Theme.GetColor("tab.active.accent")
                'tab.foreground' = $this.Theme.GetColor("tab.foreground")
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Propagate to all tabs
        foreach ($tab in $this.Tabs) {
            if ($tab.Content -and $tab.Content -is [Screen]) {
                $tab.Content.OnThemeChanged()
            }
        }
    }
    
    # Add a new tab
    [void] AddTab([string]$title, [UIElement]$content) {
        $tab = [TabItem]::new()
        $tab.Title = $title
        $tab.Content = $content
        $tab.ShortcutKey = $this.Tabs.Count + 1  # 1-9 shortcuts
        
        # Initialize the content if it's a Screen
        if ($content -is [Screen] -and $global:ServiceContainer) {
            $content.Initialize($global:ServiceContainer)
            # Tab content should draw their own background
            $content.DrawBackground = $true
        }
        
        $this.Tabs.Add($tab)
        $this._dataVersion++  # Increment on tab change
        $this._tabBarInvalid = $true
        
        # Set as active if first tab
        if ($this.Tabs.Count -eq 1) {
            # Force activation of first tab by temporarily setting ActiveTabIndex to -1
            $oldIndex = $this.ActiveTabIndex
            $this.ActiveTabIndex = -1
            $this.ActivateTab(0)
            # If ActivateTab failed, restore the index
            if ($this.ActiveTabIndex -eq -1) {
                $this.ActiveTabIndex = $oldIndex
            }
        } else {
            # Position but don't add to children yet
            $this.PositionContent($content, $false)
        }
        
        $this.Invalidate()
    }
    
    # Switch to a specific tab
    [void] ActivateTab([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Tabs.Count) { return }
        
        # Don't switch if already on this tab
        if ($index -eq $this.ActiveTabIndex) { return }
        
        $this._dataVersion++  # Increment on tab activation change
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.ActivateTab: Switching from tab $($this.ActiveTabIndex) to tab $index")
        }
        
        # Store old content reference
        $oldContent = $null
        
        # Deactivate current
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $oldTab = $this.Tabs[$this.ActiveTabIndex]
            if ($oldTab.Content) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Removing old tab content: $($oldTab.Title)")
                }
                $oldContent = $oldTab.Content
                $this.RemoveChild($oldTab.Content)
            }
        }
        
        # Activate new
        $this.ActiveTabIndex = $index
        $newTab = $this.Tabs[$index]
        if ($newTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Adding new tab content: $($newTab.Title)")
                $global:Logger.Debug("TabContainer: Content type: $($newTab.Content.GetType().Name)")
                $global:Logger.Debug("TabContainer: Container bounds: X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
            }
            $this.PositionContent($newTab.Content, $true)
            $this.AddChild($newTab.Content)
            if ($newTab.Content -is [Screen]) {
                # Tab content should draw its own background to clear old content
                $newTab.Content.DrawBackground = $true
                $newTab.Content.SetBackgroundColor([VT]::Reset())
                $newTab.Content.OnActivated()
            }
            # Force the new content to invalidate
            $newTab.Content.Invalidate()
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: New content bounds: X=$($newTab.Content.X) Y=$($newTab.Content.Y) W=$($newTab.Content.Width) H=$($newTab.Content.Height)")
            }
        }
        
        # Now safely deactivate old content after UI tree is updated
        if ($oldContent -and $oldContent -is [Screen]) {
            $oldContent.OnDeactivated()
        }
        
        $this._tabBarInvalid = $true
        $this.Invalidate()
        
        # Force parent to redraw completely to clear any artifacts
        if ($this.Parent) {
            $this.Parent.Invalidate()
        }
    }
    
    # Position content below tab bar
    hidden [void] PositionContent([UIElement]$content, [bool]$isActive) {
        # Only set bounds if we have valid dimensions
        if ($this.Width -gt 0 -and $this.Height -gt $this.TabBarHeight) {
            $content.SetBounds(
                $this.X,
                $this.Y + $this.TabBarHeight,
                $this.Width,
                $this.Height - $this.TabBarHeight
            )
        }
    }
    
    # Layout management
    [void] OnBoundsChanged() {
        # Update tab bar cache
        $this._tabBarInvalid = $true
        
        # Update active content bounds
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            $activeTab = $this.Tabs[$this.ActiveTabIndex]
            if ($activeTab.Content) {
                $this.PositionContent($activeTab.Content, $true)
            }
        }
    }
    
    # Render the tab container
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: tabBarInvalid=$($this._tabBarInvalid), Children.Count=$($this.Children.Count)")
        }
        
        $sb = Get-PooledStringBuilder 2048
        
        # Render tab bar
        if ($this._tabBarInvalid) {
            $this.RebuildTabBar()
        }
        $sb.Append($this._cachedTabBar)
        
        # Render active content (base class handles children)
        $baseRender = ([Container]$this).OnRender()
        $sb.Append($baseRender)
        
        if ($global:Logger) {
            $global:Logger.Debug("TabContainer.OnRender: Children.Count = $($this.Children.Count), baseRender.Length = $($baseRender.Length)")
            if ($this.Children.Count -gt 0) {
                $global:Logger.Debug("TabContainer.OnRender: First child type = $($this.Children[0].GetType().Name)")
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    # Build the tab bar
    hidden [void] RebuildTabBar() {
        $sb = Get-PooledStringBuilder 1024
        
        # Tab bar background
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($this._colors['tab.background'])
        $sb.Append([StringCache]::GetSpaces($this.Width))
        
        # Draw tabs
        $x = $this.X + 1
        for ($i = 0; $i -lt $this.Tabs.Count; $i++) {
            $tab = $this.Tabs[$i]
            $title = $tab.Title
            
            # Add shortcut hint if applicable
            if ($tab.ShortcutKey -ge 1 -and $tab.ShortcutKey -le 9) {
                $title = "$($tab.ShortcutKey):$title"
            }
            
            # Calculate tab width
            $tabWidth = $title.Length + 4  # Padding
            
            # Don't draw if it would overflow
            if (($x + $tabWidth) -gt ($this.X + $this.Width - 1)) {
                break
            }
            
            $sb.Append([VT]::MoveTo($x, $this.Y))
            
            # Tab styling
            if ($i -eq $this.ActiveTabIndex) {
                # Active tab
                $sb.Append($this._colors['tab.active.background'])
                $sb.Append($this._colors['tab.active.foreground'])
                $sb.Append(" $title ")
                
                # Bottom accent line
                $sb.Append([VT]::MoveTo($x, $this.Y + 1))
                $sb.Append($this._colors['tab.active.accent'])
                $sb.Append([StringCache]::GetHorizontalLine($tabWidth - 2))
            } else {
                # Inactive tab
                $sb.Append($this._colors['tab.background'])
                $sb.Append($this._colors['tab.foreground'])
                $sb.Append(" $title ")
            }
            
            $x += $tabWidth + 1
        }
        
        # Reset and draw separator line
        $sb.Append([VT]::Reset())
        $sb.Append([VT]::MoveTo($this.X, $this.Y + 1))
        $sb.Append($this._colors['border'])
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        $sb.Append([VT]::Reset())
        
        $this._cachedTabBar = $sb.ToString()
        Return-PooledStringBuilder $sb
        $this._tabBarInvalid = $false
    }
    
    # Handle keyboard input
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Debug logging removed for performance
        
        # Check TabContainer shortcuts FIRST before passing to children
        
        # Number keys for quick tab switching
        if ($key.KeyChar -ge '1' -and $key.KeyChar -le '9') {
            $tabIndex = [int]$key.KeyChar - [int][char]'1'
            if ($tabIndex -lt $this.Tabs.Count) {
                if ($global:Logger) {
                    $global:Logger.Debug("TabContainer: Switching to tab $($tabIndex + 1)")
                }
                $this.ActivateTab($tabIndex)
                return $true
            }
        }
        
        # Ctrl+Tab / Ctrl+Shift+Tab for cycling
        if ($key.Key -eq [System.ConsoleKey]::Tab -and 
            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
            if ($key.Modifiers -band [System.ConsoleModifiers]::Shift) {
                $this.PreviousTab()
            } else {
                $this.NextTab()
            }
            return $true
        }
        
        # Alt+Left/Right for navigation
        if ($key.Modifiers -band [System.ConsoleModifiers]::Alt) {
            if ($key.Key -eq [System.ConsoleKey]::LeftArrow) {
                $this.PreviousTab()
                return $true
            } elseif ($key.Key -eq [System.ConsoleKey]::RightArrow) {
                $this.NextTab()
                return $true
            }
        }
        
        # Route to active tab's content if tab switching didn't handle it
        $activeTab = $this.GetActiveTab()
        if ($activeTab -and $activeTab.Content) {
            if ($global:Logger) {
                $global:Logger.Debug("TabContainer: Routing input to active tab content: $($activeTab.Content.GetType().Name)")
            }
            if ($activeTab.Content.HandleInput($key)) {
                return $true
            }
        }
        
        # No one handled it
        return $false
    }
    
    # Navigation helpers
    [void] NextTab() {
        if ($this.Tabs.Count -gt 0) {
            $next = ($this.ActiveTabIndex + 1) % $this.Tabs.Count
            $this.ActivateTab($next)
        }
    }
    
    [void] PreviousTab() {
        if ($this.Tabs.Count -gt 0) {
            $prev = $this.ActiveTabIndex - 1
            if ($prev -lt 0) { $prev = $this.Tabs.Count - 1 }
            $this.ActivateTab($prev)
        }
    }
    
    # Get active tab
    [TabItem] GetActiveTab() {
        if ($this.ActiveTabIndex -ge 0 -and $this.ActiveTabIndex -lt $this.Tabs.Count) {
            return $this.Tabs[$this.ActiveTabIndex]
        }
        return $null
    }
}

# Tab item class
class TabItem {
    [string]$Title = "Tab"
    [UIElement]$Content = $null
    [int]$ShortcutKey = 0
}


####\Components/TextBox.ps1
# TextBox.ps1 - Fast text input component
# Adapted from AxiomPhoenix with string-based rendering

class TextBox : UIElement {
    [string]$Text = ""
    [string]$Placeholder = ""
    [int]$MaxLength = 100
    [int]$CursorPosition = 0
    [bool]$ShowBorder = $true
    [bool]$ShowCursor = $true
    [scriptblock]$OnChange = {}
    [scriptblock]$OnSubmit = {}
    
    hidden [int]$_scrollOffset = 0
    hidden [string]$_cachedRender = ""
    hidden [bool]$_needsRender = $true
    hidden [ThemeManager]$Theme
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TextBox() : base() {
        $this.IsFocusable = $true
        $this.Width = 20
        $this.Height = 3  # Border + content + border
    }
    
    [void] OnInitialize() {
        if ($this.ServiceContainer) {
            $this.Theme = $this.ServiceContainer.GetService("ThemeManager")
            if ($this.Theme) {
                $this.Theme.Subscribe({ $this.OnThemeChanged() })
                $this.OnThemeChanged()
            }
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'input.focused.border' = $this.Theme.GetColor("input.focused.border")
                'input.border' = $this.Theme.GetColor("input.border")
                'input.background' = $this.Theme.GetBgColor("input.background")
                'input.foreground' = $this.Theme.GetColor("input.foreground")
                'input.placeholder' = $this.Theme.GetColor("input.placeholder")
            }
        }
        $this._dataVersion++  # Increment for theme change
        $this._needsRender = $true
        $this.Invalidate()
    }
    
    [string] OnRender() {
        if (-not $this._needsRender) {
            return $this._cachedRender
        }
        
        $sb = Get-PooledStringBuilder 512  # TextBox typically needs moderate capacity
        
        # Colors based on focus state
        $borderColor = if ($this.IsFocused) {
            $this._colors['input.focused.border']
        } else {
            $this._colors['input.border']
        }
        $bgColor = $this._colors['input.background']
        $fgColor = $this._colors['input.foreground']
        $placeholderColor = $this._colors['input.placeholder']
        
        # Content area
        $contentY = $this.Y + 1
        $contentStartX = $this.X + 1
        $contentWidth = $this.Width - 2
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            
            # Middle line with content
            $sb.Append([VT]::MoveTo($this.X, $contentY))
            $sb.Append([VT]::V())
            
            # Clear content area
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            # Right border
            $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $contentY))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            # Bottom border
            $sb.Append([VT]::MoveTo($this.X, $this.Y + 2))
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        } else {
            # Just clear the content area
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
            $contentY = $this.Y
            $contentStartX = $this.X
            $contentWidth = $this.Width
        }
        
        # Render text or placeholder
        $sb.Append([VT]::MoveTo($contentStartX, $contentY))
        
        if ($this.Text.Length -eq 0 -and -not [string]::IsNullOrEmpty($this.Placeholder)) {
            # Show placeholder
            $sb.Append($placeholderColor)
            $placeholderText = if ($this.Placeholder.Length -gt $contentWidth) {
                $this.Placeholder.Substring(0, $contentWidth)
            } else {
                $this.Placeholder
            }
            $sb.Append($placeholderText)
        } else {
            # Calculate scroll offset to keep cursor in view
            if ($this.CursorPosition -lt $this._scrollOffset) {
                $this._scrollOffset = $this.CursorPosition
            } elseif ($this.CursorPosition -ge ($this._scrollOffset + $contentWidth)) {
                $this._scrollOffset = $this.CursorPosition - $contentWidth + 1
            }
            
            # Draw visible portion of text
            $sb.Append($fgColor)
            if ($this.Text.Length -gt $this._scrollOffset) {
                $len = [Math]::Min($contentWidth, $this.Text.Length - $this._scrollOffset)
                $visibleText = $this.Text.Substring($this._scrollOffset, $len)
                $sb.Append($visibleText)
            }
            
            # Draw cursor if focused
            if ($this.IsFocused -and $this.ShowCursor) {
                $cursorScreenPos = $this.CursorPosition - $this._scrollOffset
                if ($cursorScreenPos -ge 0 -and $cursorScreenPos -lt $contentWidth) {
                    $cursorX = $contentStartX + $cursorScreenPos
                    $sb.Append([VT]::MoveTo($cursorX, $contentY))
                    
                    # Reverse video for cursor
                    $charUnderCursor = if ($this.CursorPosition -lt $this.Text.Length) {
                        $this.Text[$this.CursorPosition]
                    } else {
                        ' '
                    }
                    
                    $sb.Append($bgColor)  # Swap colors for cursor
                    if ($this._colors['input.foreground']) {
                        # Create a background color from foreground color
                        $sb.Append("`e[48;2;255;255;255m")  # White background for cursor
                    }
                    $sb.Append($charUnderCursor)
                }
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
        $this._needsRender = $false
        return $this._cachedRender
    }
    
    [void] OnGotFocus() {
        $this.ShowCursor = $true
        $this._dataVersion++  # Increment for focus change
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnGotFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [void] OnLostFocus() {
        $this.ShowCursor = $false
        $this._dataVersion++  # Increment for focus change
        $this._needsRender = $true
        $this.Invalidate()
        if ($global:Logger) {
            $global:Logger.Debug("TextBox.OnLostFocus: ShowCursor=$($this.ShowCursor)")
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        try {
            $handled = $true
            $oldText = $this.Text
            
            switch ($key.Key) {
            ([System.ConsoleKey]::LeftArrow) {
                if ($this.CursorPosition -gt 0) {
                    $this.CursorPosition--
                    $this._dataVersion++  # Increment for cursor move
                }
            }
            ([System.ConsoleKey]::RightArrow) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.CursorPosition++
                    $this._dataVersion++  # Increment for cursor move
                }
            }
            ([System.ConsoleKey]::Home) {
                $this.CursorPosition = 0
                $this._dataVersion++  # Increment for cursor move
            }
            ([System.ConsoleKey]::End) {
                $this.CursorPosition = $this.Text.Length
                $this._dataVersion++  # Increment for cursor move
            }
            ([System.ConsoleKey]::Backspace) {
                if ($this.CursorPosition -gt 0) {
                    $this.Text = $this.Text.Remove($this.CursorPosition - 1, 1)
                    $this.CursorPosition--
                }
            }
            ([System.ConsoleKey]::Delete) {
                if ($this.CursorPosition -lt $this.Text.Length) {
                    $this.Text = $this.Text.Remove($this.CursorPosition, 1)
                }
            }
            ([System.ConsoleKey]::Enter) {
                try {
                    if ($this.OnSubmit) {
                        & $this.OnSubmit $this.Text
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("TextBox.HandleInput: Error executing OnSubmit handler - $($_.Exception.Message)")
                    }
                }
            }
            ([System.ConsoleKey]::Tab) {
                # Don't handle Tab - let parent handle focus navigation
                $handled = $false
            }
            ([System.ConsoleKey]::Escape) {
                # Don't handle Escape - let parent handle it
                $handled = $false
            }
            default {
                if ($key.KeyChar -and -not [char]::IsControl($key.KeyChar)) {
                    if ($this.Text.Length -lt $this.MaxLength) {
                        $this.Text = $this.Text.Insert($this.CursorPosition, $key.KeyChar)
                        $this.CursorPosition++
                    }
                } else {
                    $handled = $false
                }
            }
        }
        
            if ($handled) {
                # Increment version if text was modified
                if ($oldText -ne $this.Text) {
                    $this._dataVersion++
                }
                
                # Call OnChange if text was modified
                if ($oldText -ne $this.Text -and $this.OnChange) {
                    try {
                        & $this.OnChange $this.Text
                    } catch {
                        if ($global:Logger) {
                            $global:Logger.Error("TextBox.HandleInput: Error executing OnChange handler - $($_.Exception.Message)")
                        }
                    }
                }
                $this._needsRender = $true
                $this.Invalidate()
            }
            
            return $handled
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TextBox.HandleInput: Error processing input - $($_.Exception.Message)")
            }
            return $false
        }
    }
    
    # Helper methods
    [void] SetText([string]$text) {
        if ($text.Length -le $this.MaxLength) {
            $this.Text = $text
            $this.CursorPosition = $text.Length
            $this._dataVersion++  # Increment on text change
            $this._needsRender = $true
            $this.Invalidate()
        }
    }
    
    [void] Clear() {
        $this.Text = ""
        $this.CursorPosition = 0
        $this._scrollOffset = 0
        $this._needsRender = $true
        $this.Invalidate()
    }
}


####\Components/TreeView.ps1
# TreeView.ps1 - Hierarchical tree view component based on ALCAR patterns
# Fast string-based rendering with expand/collapse functionality

class TreeNode {
    [string]$Id
    [object]$Data
    [TreeNode]$Parent
    [System.Collections.ArrayList]$Children
    [bool]$IsExpanded = $true
    [int]$Level = 0
    [string]$DisplayText
    
    TreeNode() {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
    }
    
    TreeNode([string]$displayText) {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
        $this.DisplayText = $displayText
    }
    
    TreeNode([string]$displayText, [object]$data) {
        $this.Children = [System.Collections.ArrayList]::new()
        $this.Id = [System.Guid]::NewGuid().ToString()
        $this.DisplayText = $displayText
        $this.Data = $data
    }
    
    [void] AddChild([TreeNode]$child) {
        $child.Parent = $this
        $this.Children.Add($child) | Out-Null
        $this.UpdateLevels()
    }
    
    [void] RemoveChild([TreeNode]$child) {
        $this.Children.Remove($child)
        $child.Parent = $null
    }
    
    [void] UpdateLevels() {
        # Recursively update all child levels
        foreach ($child in $this.Children) {
            $child.Level = $this.Level + 1
            $child.UpdateLevels()
        }
    }
    
    [bool] HasChildren() {
        return $this.Children.Count -gt 0
    }
}

class TreeView : UIElement {
    [System.Collections.ArrayList]$Nodes
    [System.Collections.ArrayList]$_flatView  # Flattened display view
    [int]$SelectedIndex = 0
    [int]$ScrollOffset = 0
    [bool]$ShowBorder = $true
    [string]$Title = ""
    [scriptblock]$OnSelectionChanged = {}
    [scriptblock]$OnNodeExpanded = {}
    [scriptblock]$OnNodeCollapsed = {}
    
    # Visual settings
    [string]$ExpandedIcon = "‚ñº"
    [string]$CollapsedIcon = "‚ñ∂"
    [string]$LeafIcon = "‚Ä¢"
    [int]$IndentSize = 2
    
    hidden [ThemeManager]$Theme
    hidden [string]$_cachedRender = ""
    hidden [hashtable]$_colors = @{}
    
    # Version-based change detection
    hidden [int]$_dataVersion = 0
    hidden [int]$_lastRenderedVersion = -1
    hidden [string]$_cachedVersionRender = ""
    
    TreeView() : base() {
        $this.Nodes = [System.Collections.ArrayList]::new()
        $this._flatView = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true
    }
    
    [void] Initialize([ServiceContainer]$services) {
        $this.Theme = $services.GetService("ThemeManager")
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
        $this.RebuildFlatView()
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
                'title' = $this.Theme.GetColor("title")
                'selected' = $this.Theme.GetBgColor("selected")
                'normal' = $this.Theme.GetColor("normal")
                'border.focused' = $this.Theme.GetColor("border.focused")
            }
        }
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] Invalidate() {
        $this._cachedRender = ""
        ([UIElement]$this).Invalidate()
    }
    
    # Public API methods
    [TreeNode] AddRootNode([string]$displayText) {
        $node = [TreeNode]::new($displayText)
        $node.Level = 0
        $this.Nodes.Add($node) | Out-Null
        $this._dataVersion++  # Increment on data change
        $this.RebuildFlatView()
        return $node
    }
    
    [TreeNode] AddRootNode([string]$displayText, [object]$data) {
        $node = [TreeNode]::new($displayText, $data)
        $node.Level = 0
        $this.Nodes.Add($node) | Out-Null
        $this._dataVersion++  # Increment on data change
        $this.RebuildFlatView()
        return $node
    }
    
    [void] Clear() {
        $this.Nodes.Clear()
        $this._flatView.Clear()
        $this.SelectedIndex = 0
        $this.ScrollOffset = 0
        $this._dataVersion++  # Increment on data change
        $this.Invalidate()
    }
    
    [TreeNode] GetSelectedNode() {
        if ($this.SelectedIndex -ge 0 -and $this.SelectedIndex -lt $this._flatView.Count) {
            return $this._flatView[$this.SelectedIndex]
        }
        return $null
    }
    
    [void] SetSelectedNode([TreeNode]$node) {
        for ($i = 0; $i -lt $this._flatView.Count; $i++) {
            if ($this._flatView[$i].Id -eq $node.Id) {
                $this.SelectIndex($i)
                break
            }
        }
    }
    
    [void] SelectIndex([int]$index) {
        if ($index -ge 0 -and $index -lt $this._flatView.Count) {
            $oldIndex = $this.SelectedIndex
            $this.SelectedIndex = $index
            $this.EnsureVisible()
            
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
            
            $this.Invalidate()
        }
    }
    
    [void] ToggleExpanded([TreeNode]$node) {
        if (-not $node.HasChildren()) {
            return
        }
        
        $node.IsExpanded = -not $node.IsExpanded
        $this.RebuildFlatView()
        
        # Fire events
        if ($node.IsExpanded -and $this.OnNodeExpanded) {
            & $this.OnNodeExpanded $node
        } elseif (-not $node.IsExpanded -and $this.OnNodeCollapsed) {
            & $this.OnNodeCollapsed $node
        }
        
        # Maintain selection on the same node
        $this.SetSelectedNode($node)
    }
    
    [void] ExpandAll() {
        $this.SetAllExpanded($true)
    }
    
    [void] CollapseAll() {
        $this.SetAllExpanded($false)
    }
    
    [void] SetAllExpanded([bool]$expanded) {
        foreach ($node in $this.Nodes) {
            $this.SetNodeExpanded($node, $expanded)
        }
        $this.RebuildFlatView()
        $this.Invalidate()
    }
    
    [void] SetNodeExpanded([TreeNode]$node, [bool]$expanded) {
        if ($node.HasChildren()) {
            $node.IsExpanded = $expanded
        }
        foreach ($child in $node.Children) {
            $this.SetNodeExpanded($child, $expanded)
        }
    }
    
    # Internal methods
    [void] RebuildFlatView() {
        $this._flatView.Clear()
        foreach ($node in $this.Nodes) {
            $this.AddNodeToFlatView($node)
        }
        
        # Ensure selection is valid
        if ($this.SelectedIndex -ge $this._flatView.Count) {
            $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
        }
    }
    
    [void] AddNodeToFlatView([TreeNode]$node) {
        $this._flatView.Add($node) | Out-Null
        
        if ($node.IsExpanded) {
            foreach ($child in $node.Children) {
                $this.AddNodeToFlatView($child)
            }
        }
    }
    
    [void] EnsureVisible() {
        $visibleLines = $this.Height - ($this.ShowBorder ? 2 : 0) - ($this.Title ? 1 : 0)
        
        if ($this.SelectedIndex -lt $this.ScrollOffset) {
            $this.ScrollOffset = $this.SelectedIndex
        } elseif ($this.SelectedIndex -ge $this.ScrollOffset + $visibleLines) {
            $this.ScrollOffset = $this.SelectedIndex - $visibleLines + 1
        }
        
        $this.ScrollOffset = [Math]::Max(0, $this.ScrollOffset)
    }
    
    [string] OnRender() {
        if ([string]::IsNullOrEmpty($this._cachedRender)) {
            $this.RebuildCache()
        }
        return $this._cachedRender
    }
    
    [void] RebuildCache() {
        $sb = Get-PooledStringBuilder 4096  # TreeView can have many nodes
        
        # Colors from cache
        $borderColor = $this._colors['border']
        $titleColor = $this._colors['title']
        $selectedBg = $this._colors['selected']
        $normalColor = $this._colors['normal']
        $focusBorder = if ($this._colors['border.focused']) { $this._colors['border.focused'] } else { $borderColor }
        
        $currentBorderColor = if ($this.IsFocused) { $focusBorder } else { $borderColor }
        
        # Calculate content area
        $contentY = $this.Y
        $contentHeight = $this.Height
        $contentWidth = $this.Width - ($this.ShowBorder ? 2 : 0)
        
        if ($this.ShowBorder) {
            # Top border
            $sb.Append([VT]::MoveTo($this.X, $this.Y))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::TL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::TR())
            $contentY++
            $contentHeight--
            
            # Title
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X + 1, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($contentWidth).Substring(0, $contentWidth)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        } else {
            # Title without border
            if ($this.Title) {
                $sb.Append([VT]::MoveTo($this.X, $contentY))
                $sb.Append($titleColor)
                $titleText = $this.Title.PadRight($this.Width).Substring(0, $this.Width)
                $sb.Append($titleText)
                $contentY++
                $contentHeight--
            }
        }
        
        # Render tree nodes
        $visibleLines = $contentHeight - ($this.ShowBorder ? 1 : 0)  # Reserve bottom border
        $startIndex = $this.ScrollOffset
        $endIndex = [Math]::Min($startIndex + $visibleLines, $this._flatView.Count)
        
        for ($i = $startIndex; $i -lt $endIndex; $i++) {
            $node = $this._flatView[$i]
            $y = $contentY + ($i - $startIndex)
            
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            
            # Background for selected item
            if ($i -eq $this.SelectedIndex) {
                $sb.Append($selectedBg)
            } else {
                $sb.Append($normalColor)
            }
            
            # Build display line
            $line = ""
            
            # Indentation
            $line += [StringCache]::GetSpaces($node.Level * $this.IndentSize)
            
            # Tree icon
            if ($node.HasChildren()) {
                $line += if ($node.IsExpanded) { $this.ExpandedIcon + " " } else { $this.CollapsedIcon + " " }
            } else {
                $line += $this.LeafIcon + " "
            }
            
            # Node text
            $line += $node.DisplayText
            
            # Pad and truncate to fit
            $line = $line.PadRight($contentWidth).Substring(0, $contentWidth)
            $sb.Append($line)
            
            if ($this.ShowBorder) {
                # Side borders
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        # Fill empty lines
        for ($i = $endIndex - $startIndex; $i -lt $visibleLines; $i++) {
            $y = $contentY + $i
            $sb.Append([VT]::MoveTo($this.X + ($this.ShowBorder ? 1 : 0), $y))
            $sb.Append($normalColor)
            $sb.Append([StringCache]::GetSpaces($contentWidth))
            
            if ($this.ShowBorder) {
                $sb.Append([VT]::MoveTo($this.X, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
                
                $sb.Append([VT]::MoveTo($this.X + $this.Width - 1, $y))
                $sb.Append($currentBorderColor)
                $sb.Append([VT]::V())
            }
        }
        
        if ($this.ShowBorder) {
            # Bottom border
            $bottomY = $this.Y + $this.Height - 1
            $sb.Append([VT]::MoveTo($this.X, $bottomY))
            $sb.Append($currentBorderColor)
            $sb.Append([VT]::BL() + [StringCache]::GetVTHorizontal($this.Width - 2) + [VT]::BR())
        }
        
        $sb.Append([VT]::Reset())
        $this._cachedRender = $sb.ToString()
        Return-PooledStringBuilder $sb  # Return to pool for reuse
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        $handled = $false
        $oldIndex = $this.SelectedIndex
        
        switch ($key.Key) {
            ([System.ConsoleKey]::UpArrow) {
                if ($this.SelectedIndex -gt 0) {
                    $this.SelectedIndex--
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::DownArrow) {
                if ($this.SelectedIndex -lt $this._flatView.Count - 1) {
                    $this.SelectedIndex++
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::PageUp) {
                $pageSize = $this.Height - 3  # Approximate visible lines
                $this.SelectedIndex = [Math]::Max(0, $this.SelectedIndex - $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::PageDown) {
                $pageSize = $this.Height - 3  # Approximate visible lines
                $this.SelectedIndex = [Math]::Min($this._flatView.Count - 1, $this.SelectedIndex + $pageSize)
                $handled = $true
            }
            ([System.ConsoleKey]::Home) {
                $this.SelectedIndex = 0
                $handled = $true
            }
            ([System.ConsoleKey]::End) {
                $this.SelectedIndex = [Math]::Max(0, $this._flatView.Count - 1)
                $handled = $true
            }
            ([System.ConsoleKey]::Enter) {
                $node = $this.GetSelectedNode()
                if ($node -and $node.HasChildren()) {
                    $this.ToggleExpanded($node)
                    $handled = $true
                }
            }
            ([System.ConsoleKey]::Spacebar) {
                $node = $this.GetSelectedNode()
                if ($node -and $node.HasChildren()) {
                    $this.ToggleExpanded($node)
                    $handled = $true
                }
            }
        }
        
        if ($handled) {
            $this.EnsureVisible()
            $this.Invalidate()
            
            # Fire selection changed event
            if ($oldIndex -ne $this.SelectedIndex -and $this.OnSelectionChanged) {
                & $this.OnSelectionChanged
            }
        }
        
        return $handled
    }
    
    [void] OnGotFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
    
    [void] OnLostFocus() {
        $this._cachedRender = ""
        $this.Invalidate()
    }
}


####\Components/VerticalSplit.ps1
# VerticalSplit.ps1 - Fast vertical layout component for PRAXIS

class VerticalSplit : Container {
    [UIElement]$TopPane
    [UIElement]$BottomPane
    [int]$SplitRatio = 50  # Percentage for top pane (0-100)
    [int]$MinPaneHeight = 3
    [bool]$ShowBorder = $false
    [bool]$Resizable = $false  # Future: allow dragging the split
    
    # Cached layout calculations
    hidden [int]$_cachedTopHeight = 0
    hidden [int]$_cachedBottomHeight = 0
    hidden [int]$_cachedBottomY = 0
    hidden [bool]$_layoutInvalid = $true
    hidden [int]$_lastHeight = 0
    hidden [int]$_lastSplitRatio = 0
    hidden [hashtable]$_colors = @{}
    hidden [ThemeManager]$Theme
    
    VerticalSplit() : base() {
        $this.DrawBackground = $false
    }
    
    [void] OnInitialize() {
        ([Container]$this).OnInitialize()
        $this.Theme = $this.ServiceContainer.GetService('ThemeManager')
        if ($this.Theme) {
            $this.Theme.Subscribe({ $this.OnThemeChanged() })
            $this.OnThemeChanged()
        }
    }
    
    [void] OnThemeChanged() {
        if ($this.Theme) {
            $this._colors = @{
                'border' = $this.Theme.GetColor("border")
            }
        }
        $this.Invalidate()
    }
    
    [void] SetTopPane([UIElement]$pane) {
        if ($this.TopPane) {
            $this.RemoveChild($this.TopPane)
        }
        $this.TopPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetBottomPane([UIElement]$pane) {
        if ($this.BottomPane) {
            $this.RemoveChild($this.BottomPane)
        }
        $this.BottomPane = $pane
        if ($pane) {
            $this.AddChild($pane)
        }
        $this.InvalidateLayout()
    }
    
    [void] SetSplitRatio([int]$ratio) {
        $this.SplitRatio = [Math]::Max(10, [Math]::Min(90, $ratio))
        $this.InvalidateLayout()
    }
    
    [void] InvalidateLayout() {
        $this._layoutInvalid = $true
        $this.Invalidate()
    }
    
    [void] OnBoundsChanged() {
        $this.InvalidateLayout()
        $this.UpdateLayout()
    }
    
    [void] UpdateLayout() {
        if (-not $this._layoutInvalid -and 
            $this._lastHeight -eq $this.Height -and 
            $this._lastSplitRatio -eq $this.SplitRatio) {
            return  # Layout is still valid
        }
        
        # Calculate pane dimensions
        $totalHeight = $this.Height
        $topHeight = [int](($totalHeight * $this.SplitRatio) / 100)
        $topHeight = [Math]::Max($this.MinPaneHeight, [Math]::Min($topHeight, $totalHeight - $this.MinPaneHeight))
        $bottomHeight = $totalHeight - $topHeight
        $bottomY = $this.Y + $topHeight
        
        # Update top pane
        if ($this.TopPane) {
            $this.TopPane.SetBounds($this.X, $this.Y, $this.Width, $topHeight)
        }
        
        # Update bottom pane
        if ($this.BottomPane) {
            $this.BottomPane.SetBounds($this.X, $bottomY, $this.Width, $bottomHeight)
        }
        
        # Cache the layout
        $this._cachedTopHeight = $topHeight
        $this._cachedBottomHeight = $bottomHeight
        $this._cachedBottomY = $bottomY
        $this._lastHeight = $this.Height
        $this._lastSplitRatio = $this.SplitRatio
        $this._layoutInvalid = $false
    }
    
    [string] OnRender() {
        # Update layout before rendering
        $this.UpdateLayout()
        
        # Use fast string-based rendering
        $sb = Get-PooledStringBuilder 1024
        
        # Render children
        if ($this.TopPane -and $this.TopPane.Visible) {
            $sb.Append($this.TopPane.Render())
        }
        
        if ($this.BottomPane -and $this.BottomPane.Visible) {
            $sb.Append($this.BottomPane.Render())
        }
        
        # Optional: render split border
        if ($this.ShowBorder -and $this._cachedTopHeight -gt 0) {
            $borderColor = $this._colors['border']
            $sb.Append([VT]::MoveTo($this.X, $this._cachedBottomY - 1))
            $sb.Append($borderColor)
            $sb.Append([StringCache]::GetHorizontalLine($this.Width))
            $sb.Append([VT]::Reset())
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Route input to focused pane
        if ($this.TopPane -and $this.TopPane.IsFocused) {
            if ($this.TopPane.HandleInput($key)) {
                return $true
            }
        }
        
        if ($this.BottomPane -and $this.BottomPane.IsFocused) {
            if ($this.BottomPane.HandleInput($key)) {
                return $true
            }
        }
        
        # Let base Container handle other input (Tab navigation, etc.)
        return ([Container]$this).HandleInput($key)
    }
    
    # Helper methods for common split ratios
    [void] SetEqualSplit() { $this.SetSplitRatio(50) }
    [void] SetTopFavoredSplit() { $this.SetSplitRatio(70) }
    [void] SetBottomFavoredSplit() { $this.SetSplitRatio(30) }
    
    # Get pane by position
    [UIElement] GetTopPane() { return $this.TopPane }
    [UIElement] GetBottomPane() { return $this.BottomPane }
    
    # Focus management
    [void] FocusTopPane() {
        if ($this.TopPane -and $this.TopPane.IsFocusable) {
            $this.TopPane.Focus()
        }
    }
    
    [void] FocusBottomPane() {
        if ($this.BottomPane -and $this.BottomPane.IsFocusable) {
            $this.BottomPane.Focus()
        }
    }
}


####\Core/DocumentBuffer.ps1
# DocumentBuffer.ps1 - Model class for text editor content
# Implements Buffer/View separation - this class knows nothing about UI

class DocumentBuffer {
    # Text content storage (Phase 1: ArrayList, Phase 3: Gap Buffer)
    hidden [System.Collections.ArrayList]$Lines
    
    # Command-based undo/redo system
    hidden [System.Collections.ArrayList]$_undoStack
    hidden [System.Collections.ArrayList]$_redoStack
    hidden [int]$_maxUndoHistory = 1000
    
    # File state
    [string]$FilePath = ""
    [bool]$IsModified = $false
    [datetime]$LastModified = [datetime]::MinValue
    
    # Change tracking for render optimization
    hidden [System.Collections.Generic.HashSet[int]]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Events for UI updates
    [scriptblock]$OnContentChanged = {}
    [scriptblock]$OnModifiedStateChanged = {}
    
    DocumentBuffer() {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null  # Always have at least one empty line
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
    }
    
    DocumentBuffer([string]$filePath) {
        $this.Lines = [System.Collections.ArrayList]::new()
        $this._undoStack = [System.Collections.ArrayList]::new()
        $this._redoStack = [System.Collections.ArrayList]::new()
        $this._dirtyLines = [System.Collections.Generic.HashSet[int]]::new()
        $this.FilePath = $filePath
        $this.LoadFromFile($filePath)
    }
    
    # --- Public API for TextEditorScreen ---
    
    [string] GetLine([int]$index) {
        if ($index -lt 0 -or $index -ge $this.Lines.Count) {
            return ""
        }
        return $this.Lines[$index]
    }
    
    [int] GetLineCount() {
        return $this.Lines.Count
    }
    
    [bool] IsLineDirty([int]$line) {
        return $this._allLinesDirty -or $this._dirtyLines.Contains($line)
    }
    
    [void] ClearDirtyLines() {
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
    }
    
    [void] ExecuteCommand([object]$command) {
        $command.Execute($this)
        $this.AddToUndoStack($command)
        $this.SetModified($true)
        $this.NotifyContentChanged()
    }
    
    [bool] CanUndo() {
        return $this._undoStack.Count -gt 0
    }
    
    [bool] CanRedo() {
        return $this._redoStack.Count -gt 0
    }
    
    [void] ClearUndoHistory() {
        $this._undoStack.Clear()
        $this._redoStack.Clear()
    }
    
    [void] Undo() {
        if ($this._undoStack.Count -eq 0) { return }
        
        try {
            $command = $this._undoStack[$this._undoStack.Count - 1]
            $this._undoStack.RemoveAt($this._undoStack.Count - 1)
            $command.Undo($this)
            $this._redoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this._allLinesDirty = $true  # Mark all lines dirty after undo
            $this.NotifyContentChanged()
        } catch {
            # If undo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Undo failed: $($_.Exception.Message)")
            }
            # Don't add the failed command to redo stack
        }
    }
    
    [void] Redo() {
        if ($this._redoStack.Count -eq 0) { return }
        
        try {
            $command = $this._redoStack[$this._redoStack.Count - 1]
            $this._redoStack.RemoveAt($this._redoStack.Count - 1)
            $command.Execute($this)
            $this._undoStack.Add($command) | Out-Null
            $this.SetModified($true)
            $this._allLinesDirty = $true  # Mark all lines dirty after redo
            $this.NotifyContentChanged()
        } catch {
            # If redo fails, clear the problematic command from the stack
            if ($global:Logger) {
                $global:Logger.Error("Redo failed: $($_.Exception.Message)")
            }
            # Don't add the failed command to undo stack
        }
    }
    
    [void] LoadFromFile([string]$filePath) {
        if (-not (Test-Path $filePath)) {
            # File doesn't exist, start with empty content
            $this.Lines.Clear()
            $this.Lines.Add("") | Out-Null
            $this.SetModified($false)
            return
        }
        
        try {
            $content = Get-Content $filePath -Raw
            if ($content) {
                $lineArray = $content -split "`r?`n"
                $this.Lines.Clear()
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
                # Ensure we always have at least one line
                if ($this.Lines.Count -eq 0) {
                    $this.Lines.Add("") | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.SetModified($false)
            $this.LastModified = (Get-Item $filePath).LastWriteTime
            $this._allLinesDirty = $true
        } catch {
            throw "Failed to load file '$filePath': $($_.Exception.Message)"
        }
    }
    
    [void] SaveToFile([string]$filePath = "") {
        if ([string]::IsNullOrEmpty($filePath)) {
            $saveFilePath = $this.FilePath
        } else {
            $saveFilePath = $filePath
        }
        if ([string]::IsNullOrEmpty($saveFilePath)) {
            throw "No file path specified for save"
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $saveFilePath -Value $content -NoNewline
            $this.FilePath = $saveFilePath
            $this.SetModified($false)
            $this.LastModified = [datetime]::Now
        } catch {
            throw "Failed to save file '$saveFilePath': $($_.Exception.Message)"
        }
    }
    
    # --- Internal Text Manipulation Methods (Called by Commands) ---
    
    [void] InsertTextAt([int]$line, [int]$col, [string]$text) {
        if ($line -lt 0) { return }
        $this.EnsureLineExists($line)
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $this.Lines[$line] = $currentLine.Insert($col, $text)
        $this._dirtyLines.Add($line) | Out-Null
    }
    
    [void] DeleteTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $line -ge $this.Lines.Count) { return }
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $length = [Math]::Min($length, $currentLine.Length - $col)
        if ($length -gt 0) {
            $this.Lines[$line] = $currentLine.Remove($col, $length)
            $this._dirtyLines.Add($line) | Out-Null
        }
    }
    
    [void] InsertNewlineAt([int]$line, [int]$col) {
        if ($line -lt 0) { return }
        $this.EnsureLineExists($line)
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        
        $leftPart = $currentLine.Substring(0, $col)
        $rightPart = $currentLine.Substring($col)
        
        $this.Lines[$line] = $leftPart
        $this.Lines.Insert($line + 1, $rightPart)
        
        # Mark affected lines as dirty
        $this._dirtyLines.Add($line) | Out-Null
        $this._dirtyLines.Add($line + 1) | Out-Null
        # All lines after the insert point shift, so mark all dirty
        $this._allLinesDirty = $true
    }
    
    [void] JoinLinesAt([int]$line, [string]$separator = "") {
        if ($line -lt 0 -or $line -ge $this.Lines.Count -or $line + 1 -ge $this.Lines.Count) {
            return  # Can't join if invalid line or no next line
        }
        
        $currentLine = $this.Lines[$line]
        $nextLine = $this.Lines[$line + 1]
        $this.Lines[$line] = $currentLine + $separator + $nextLine
        $this.Lines.RemoveAt($line + 1)
        
        # Mark affected line as dirty
        $this._dirtyLines.Add($line) | Out-Null
        # All lines after the removal shift, so mark all dirty
        $this._allLinesDirty = $true
    }
    
    [string] GetTextAt([int]$line, [int]$col, [int]$length) {
        if ($line -lt 0 -or $line -ge $this.Lines.Count) { return "" }
        $currentLine = $this.Lines[$line]
        $col = [Math]::Max(0, [Math]::Min($col, $currentLine.Length))
        $length = [Math]::Min($length, $currentLine.Length - $col)
        if ($length -le 0) {
            return ""
        }
        return $currentLine.Substring($col, $length)
    }
    
    # --- Private Helper Methods ---
    
    hidden [void] EnsureLineExists([int]$line) {
        while ($this.Lines.Count -le $line) {
            $this.Lines.Add("") | Out-Null
        }
    }
    
    hidden [void] AddToUndoStack([object]$command) {
        $this._undoStack.Add($command) | Out-Null
        if ($this._undoStack.Count -gt $this._maxUndoHistory) {
            $this._undoStack.RemoveAt(0)
        }
        # A new action clears the redo stack
        $this._redoStack.Clear()
    }
    
    hidden [void] SetModified([bool]$modified) {
        if ($this.IsModified -ne $modified) {
            $this.IsModified = $modified
            if ($this.OnModifiedStateChanged) {
                & $this.OnModifiedStateChanged $modified
            }
        }
    }
    
    hidden [void] NotifyContentChanged() {
        if ($this.OnContentChanged) {
            & $this.OnContentChanged
        }
    }
}


####\Core/EditorCommands.ps1
# EditorCommands.ps1 - Command Pattern implementation for text editor
# Provides robust undo/redo system using Command Pattern design

# Base interface for all editor commands
class IEditorCommand {
    [void] Execute([object]$buffer) { 
        throw "Execute method must be implemented by derived classes"
    }
    [void] Undo([object]$buffer) { 
        throw "Undo method must be implemented by derived classes"
    }
    [string] GetDescription() {
        return $this.GetType().Name
    }
}

# Command for inserting text at a specific position
class InsertTextCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$Text
    
    InsertTextCommand([int]$line, [int]$col, [string]$text) {
        $this.Line = $line
        $this.Col = $col
        $this.Text = $text
    }
    
    [void] Execute([object]$buffer) {
        $buffer.InsertTextAt($this.Line, $this.Col, $this.Text)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.DeleteTextAt($this.Line, $this.Col, $this.Text.Length)
    }
    
    [string] GetDescription() {
        return "Insert '$($this.Text)' at ($($this.Line),$($this.Col))"
    }
}

# Command for deleting text at a specific position
class DeleteTextCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$DeletedText  # Stores the text that was deleted for undo
    [int]$Length
    
    DeleteTextCommand([int]$line, [int]$col, [string]$deletedText) {
        $this.Line = $line
        $this.Col = $col
        $this.DeletedText = $deletedText
        $this.Length = $deletedText.Length
    }
    
    [void] Execute([object]$buffer) {
        $buffer.DeleteTextAt($this.Line, $this.Col, $this.Length)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.InsertTextAt($this.Line, $this.Col, $this.DeletedText)
    }
    
    [string] GetDescription() {
        return "Delete '$($this.DeletedText)' at ($($this.Line),$($this.Col))"
    }
}

# Command for inserting a new line
class InsertNewlineCommand : IEditorCommand {
    [int]$Line
    [int]$Col
    [string]$SplitRightText = ""  # Text moved to new line when splitting
    
    InsertNewlineCommand([int]$line, [int]$col, [string]$splitRightText = "") {
        $this.Line = $line
        $this.Col = $col
        $this.SplitRightText = $splitRightText
    }
    
    [void] Execute([object]$buffer) {
        $buffer.InsertNewlineAt($this.Line, $this.Col)
    }
    
    [void] Undo([object]$buffer) {
        $buffer.JoinLinesAt($this.Line, $this.SplitRightText)
    }
    
    [string] GetDescription() {
        return "Insert newline at ($($this.Line),$($this.Col))"
    }
}

# Command for joining two lines (opposite of newline)
class JoinLinesCommand : IEditorCommand {
    [int]$Line
    [string]$JoinedText  # Text from the next line that was joined
    
    JoinLinesCommand([int]$line, [string]$joinedText) {
        $this.Line = $line
        $this.JoinedText = $joinedText
    }
    
    [void] Execute([object]$buffer) {
        $buffer.JoinLinesAt($this.Line, "")
    }
    
    [void] Undo([object]$buffer) {
        # Find the split position and insert newline
        $currentLine = $buffer.GetLine($this.Line)
        $splitPos = $currentLine.Length - $this.JoinedText.Length
        $buffer.InsertNewlineAt($this.Line, $splitPos)
    }
    
    [string] GetDescription() {
        return "Join lines at $($this.Line)"
    }
}

# Composite command for grouping multiple commands into one undo unit
class CompositeCommand : IEditorCommand {
    [System.Collections.ArrayList]$Commands
    [string]$Description
    
    CompositeCommand([string]$description) {
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.Description = $description
    }
    
    [void] AddCommand([object]$command) {
        $this.Commands.Add($command) | Out-Null
    }
    
    [void] Execute([object]$buffer) {
        foreach ($command in $this.Commands) {
            $command.Execute($buffer)
        }
    }
    
    [void] Undo([object]$buffer) {
        # Undo in reverse order
        for ($i = $this.Commands.Count - 1; $i -ge 0; $i--) {
            $this.Commands[$i].Undo($buffer)
        }
    }
    
    [string] GetDescription() {
        return $this.Description
    }
}


####\Core/IEditorCommand.ps1
# IEditorCommand.ps1 - Interface for editor commands
# Separate interface to avoid circular dependencies

# Base interface for all editor commands
class IEditorCommand {
    [void] Execute([DocumentBuffer]$buffer) { 
        throw "Execute method must be implemented by derived classes"
    }
    [void] Undo([DocumentBuffer]$buffer) { 
        throw "Undo method must be implemented by derived classes"
    }
    [string] GetDescription() {
        return $this.GetType().Name
    }
}


####\Core/ScreenManager.ps1
# ScreenManager.ps1 - Manages screen lifecycle and rendering
# Optimized for minimal overhead

class ScreenManager {
    hidden [System.Collections.Generic.Stack[Screen]]$_screenStack
    hidden [Screen]$_activeScreen = $null
    hidden [bool]$_needsRender = $true
    hidden [System.ConsoleKeyInfo]$_lastKey
    hidden [ServiceContainer]$_services
    hidden [ShortcutManager]$_shortcutManager
    hidden [bool]$_exitRequested = $false
    
    # Performance tracking
    hidden [System.Diagnostics.Stopwatch]$_renderTimer
    hidden [int]$_frameCount = 0
    hidden [double]$_lastFPS = 0
    
    # Double buffering
    hidden [string]$_lastContent = ""
    
    ScreenManager([ServiceContainer]$services) {
        $this._screenStack = [System.Collections.Generic.Stack[Screen]]::new()
        $this._services = $services
        $this._renderTimer = [System.Diagnostics.Stopwatch]::new()
        
        # Get ShortcutManager if available
        $this._shortcutManager = $services.GetService('ShortcutManager')
    }
    
    # Push a new screen
    [void] Push([Screen]$screen) {
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Push: Pushing screen $($screen.GetType().Name)")
        }
        
        # Deactivate current
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
            $this._activeScreen.OnDeactivated()
        }
        
        try {
            # Initialize and activate new screen
            $screen.Initialize($this._services)
            
            # Ensure we have valid console dimensions
            $width = [Math]::Max([Console]::WindowWidth, 80)
            $height = [Math]::Max([Console]::WindowHeight, 24)
            $screen.SetBounds(0, 0, $width, $height)
            
            if ($global:Logger) {
                $global:Logger.Debug("ScreenManager.Push: Set screen bounds to (0,0,$width,$height)")
            }
            
            $this._screenStack.Push($screen)
            $this._activeScreen = $screen
            $this._activeScreen.Active = $true
            $this._activeScreen.OnActivated()
            
            # Clear last content to force redraw on screen change
            $this._lastContent = ""
            $this._needsRender = $true
            
            if ($global:Logger) {
                $global:Logger.Info("ScreenManager.Push: Successfully pushed $($screen.GetType().Name), Active=$($this._activeScreen.Active)")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ScreenManager.Push: Error pushing screen - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
            throw
        }
    }
    
    # Pop current screen
    [Screen] Pop() {
        if ($this._screenStack.Count -eq 0) { return $null }
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Pop: Stack count before pop = $($this._screenStack.Count)")
        }
        
        $popped = $this._screenStack.Pop()
        if ($popped) {
            $popped.Active = $false
            $popped.OnDeactivated()
        }
        
        # Activate previous screen if any
        if ($this._screenStack.Count -gt 0) {
            $this._activeScreen = $this._screenStack.Peek()
            if ($this._activeScreen) {
                if ($global:Logger) {
                    $global:Logger.Debug("ScreenManager.Pop: Activating previous screen: $($this._activeScreen.GetType().Name)")
                }
                try {
                    $this._activeScreen.Active = $true
                    $this._activeScreen.OnActivated()
                } catch {
                    if ($global:Logger) {
                        $global:Logger.Error("ScreenManager.Pop: Error activating previous screen - $_")
                        $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
                    }
                }
            } else {
                if ($global:Logger) {
                    $global:Logger.Error("ScreenManager.Pop: Previous screen is null!")
                }
            }
        } else {
            $this._activeScreen = $null
        }
        
        # Clear last content to force redraw
        $this._lastContent = ""
        $this._needsRender = $true
        return $popped
    }
    
    # Replace current screen
    [void] Replace([Screen]$screen) {
        if ($this._screenStack.Count -gt 0) {
            $this.Pop() | Out-Null
        }
        $this.Push($screen)
    }
    
    # Get active screen
    [Screen] GetActiveScreen() {
        return $this._activeScreen
    }
    
    # Main run loop
    [void] Run() {
        # Initial setup
        [Console]::CursorVisible = $false
        [Console]::Clear()
        
        if ($global:Logger) {
            $global:Logger.Info("ScreenManager.Run: Starting main loop")
            if ($this._activeScreen) {
                $global:Logger.Info("Active screen: $($this._activeScreen.GetType().Name)")
                $global:Logger.Info("Active screen.Active: $($this._activeScreen.Active)")
            } else {
                $global:Logger.Info("Active screen: null")
            }
            $global:Logger.Flush()
        }
        
        # Track window size
        $lastWidth = [Console]::WindowWidth
        $lastHeight = [Console]::WindowHeight
        
        # Set needsRender to true to ensure first frame renders
        $this._needsRender = $true
        
        try {
            while ($this._activeScreen -and $this._activeScreen.Active -and -not $this._exitRequested) {
                if ($global:Logger -and $this._frameCount % 100 -eq 0) {
                    $global:Logger.Debug("ScreenManager: In main loop iteration, activeScreen = " + $(if ($this._activeScreen) { $this._activeScreen.GetType().Name } else { "null" }))
                    $global:Logger.Debug("ScreenManager: needsRender = $($this._needsRender), frameCount = $($this._frameCount)")
                }
                
                # Check for window resize
                $currentWidth = [Console]::WindowWidth
                $currentHeight = [Console]::WindowHeight
                if ($currentWidth -ne $lastWidth -or $currentHeight -ne $lastHeight) {
                    $lastWidth = $currentWidth
                    $lastHeight = $currentHeight
                    
                    # Update screen bounds
                    if ($this._activeScreen) {
                        $this._activeScreen.SetBounds(0, 0, $currentWidth, $currentHeight)
                        $this._needsRender = $true
                        
                        if ($global:Logger) {
                            $global:Logger.Debug("ScreenManager: Window resized to ${currentWidth}x${currentHeight}")
                        }
                    }
                }
                
                # Handle terminal resize
                if ([Console]::WindowWidth -ne $this._activeScreen.Width -or 
                    [Console]::WindowHeight -ne $this._activeScreen.Height) {
                    $this.HandleResize()
                }
                
                # Render if needed
                if ($this._needsRender -or $this._activeScreen._cacheInvalid) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ScreenManager: Rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                    $this.Render()
                } else {
                    # Log occasionally why we're not rendering
                    if ($this._frameCount % 100 -eq 0 -and $global:Logger) {
                        $global:Logger.Debug("ScreenManager: Not rendering (needsRender=$($this._needsRender), cacheInvalid=$($this._activeScreen._cacheInvalid))")
                    }
                }
                
                # Handle input
                try {
                    # Check if running in test mode
                    if ($env:PRAXIS_TEST_MODE) {
                        if ($global:Logger) {
                            $global:Logger.Debug("Running in test mode - skipping input")
                        }
                        Start-Sleep -Milliseconds 100
                        continue
                    }
                    
                    if ([Console]::KeyAvailable) {
                        $key = [Console]::ReadKey($true)
                        $this._lastKey = $key
                        $handled = $false
                        
                        # Log key press for debugging
                        if ($global:Logger) {
                            $global:Logger.Debug("Key pressed: $($key.Key) Char: '$($key.KeyChar)' Modifiers: $($key.Modifiers)")
                        }
                        
                        # PARENT-DELEGATED INPUT MODEL - Simple routing only
                        $handled = $false
                        
                        # 1. Check ShortcutManager for global shortcuts first
                        if ($this._shortcutManager) {
                            # Get the actual active screen (e.g., ProjectsScreen within MainScreen's TabContainer)
                            $currentScreenType = ""
                            if ($this._activeScreen) {
                                if ($this._activeScreen.GetType().Name -eq "MainScreen" -and $this._activeScreen.TabContainer) {
                                    $activeTab = $this._activeScreen.TabContainer.GetActiveTab()
                                    if ($activeTab -and $activeTab.Content) {
                                        $currentScreenType = $activeTab.Content.GetType().Name
                                    }
                                } else {
                                    $currentScreenType = $this._activeScreen.GetType().Name
                                }
                            }
                            
                            $currentContext = if ($this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) { "CommandPalette" } else { "" }
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($key.Key) Char='$($key.KeyChar)' ScreenType=$currentScreenType Context=$currentContext")
                            }
                            
                            $handled = $this._shortcutManager.HandleKeyPress($key, $currentScreenType, $currentContext)
                            
                            if ($global:Logger) {
                                $global:Logger.Debug("ShortcutManager handled=$handled")
                            }
                        }
                        
                        # 2. Command Palette override (when visible) - only if not handled by shortcuts
                        if (-not $handled -and $this._activeScreen -and $this._activeScreen.CommandPalette -and $this._activeScreen.CommandPalette.IsVisible) {
                            $handled = $this._activeScreen.CommandPalette.HandleInput($key)
                            if ($global:Logger) {
                                $global:Logger.Debug("Key routed to CommandPalette")
                            }
                        }
                        # 3. Fallback to hardcoded shortcuts if ShortcutManager not available
                        elseif (-not $this._shortcutManager) {
                            if ($key.KeyChar -eq '/' -or $key.KeyChar -eq ':') {
                                # Show command palette
                                if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
                                    $this._activeScreen.CommandPalette.Show()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Command palette opened")
                                    }
                                }
                            } 
                            elseif ($key.Key -eq [System.ConsoleKey]::Tab) {
                                # Handle Tab navigation via parent delegation
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                            elseif ($key.Modifiers -band [System.ConsoleModifiers]::Control) {
                                # Ctrl+Q for quit
                                if ($key.Key -eq [System.ConsoleKey]::Q) {
                                    $this.RequestExit()
                                    $handled = $true
                                    if ($global:Logger) {
                                        $global:Logger.Debug("Key handled: Quit application")
                                    }
                                }
                            }
                            # Ctrl+Arrows for focus navigation
                            elseif ($key.Key -eq [System.ConsoleKey]::RightArrow -or $key.Key -eq [System.ConsoleKey]::LeftArrow) {
                                if ($this._activeScreen) {
                                    $handled = $this.HandleTabNavigation($key)
                                }
                            }
                        }
                        
                        # 4. Tab navigation (if not handled above)
                        if (-not $handled -and $key.Key -eq [System.ConsoleKey]::Tab -and $this._activeScreen) {
                            $handled = $this.HandleTabNavigation($key)
                        }
                        
                        # 5. If not handled by global shortcuts, let screen handle it
                        if (-not $handled -and $this._activeScreen) {
                            try {
                                $handled = $this._activeScreen.HandleInput($key)
                                if ($handled -and $global:Logger) {
                                    $global:Logger.Debug("Key handled by screen: $($this._activeScreen.GetType().Name)")
                                }
                            } catch {
                                if ($global:Logger) {
                                    $global:Logger.LogException($_.Exception, "Error in screen input handling")
                                }
                            }
                        }
                        
                        if ($handled) {
                            $this._needsRender = $true
                        }
                        
                        # Emergency exit (Ctrl+Esc)
                        if ($key.Key -eq [System.ConsoleKey]::Escape -and 
                            ($key.Modifiers -band [System.ConsoleModifiers]::Control)) {
                            break  # Ctrl+Esc to exit
                        }
                    } else {
                        # Small sleep to prevent CPU spinning
                        Start-Sleep -Milliseconds 10
                    }
                } catch {
                    if ($global:Logger) {
                        $global:Logger.LogException($_.Exception, "Error in input handling")
                    }
                    
                    # In non-interactive mode, just sleep
                    Start-Sleep -Milliseconds 50
                    
                    # Check if we should exit (for testing)
                    if ($env:PRAXIS_TEST_MODE) {
                        break
                    }
                }
            }
        } finally {
            # Cleanup
            [Console]::CursorVisible = $true
            [Console]::Clear()
            [Console]::SetCursorPosition(0, 0)
        }
    }
    
    # Render current screen
    hidden [void] Render() {
        $this._renderTimer.Restart()
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Render: Starting render")
        }
        
        # Get rendered content
        $content = $this._activeScreen.Render()
        
        if ($global:Logger) {
            $global:Logger.Debug("ScreenManager.Render: Content length = $($content.Length)")
        }
        
        # Always write to console
        [Console]::CursorVisible = $false
        [Console]::SetCursorPosition(0, 0)
        [Console]::Write($content)
        
        $this._renderTimer.Stop()
        $this._frameCount++
        
        # Update FPS every second
        if ($this._frameCount % 60 -eq 0) {
            $this._lastFPS = 1000.0 / $this._renderTimer.ElapsedMilliseconds
        }
        
        $this._needsRender = $false
    }
    
    # Handle terminal resize
    hidden [void] HandleResize() {
        $newWidth = [Console]::WindowWidth
        $newHeight = [Console]::WindowHeight
        
        # Update all screens in stack
        foreach ($screen in $this._screenStack) {
            $screen.SetBounds(0, 0, $newWidth, $newHeight)
        }
        
        # Clear and force full redraw
        [Console]::Clear()
        $this._lastContent = ""  # Force full redraw on next render
        $this._needsRender = $true
    }
    
    # Request render on next frame
    [void] RequestRender() {
        $this._needsRender = $true
    }
    
    # Parent-delegated Tab navigation
    [bool] HandleTabNavigation([System.ConsoleKeyInfo]$key) {
        # Find the deepest focused element
        $focused = $this.FindDeepestFocusedElement($this._activeScreen)
        if ($global:Logger) {
            $global:Logger.Debug("HandleTabNavigation: Focused element = " + $(if ($focused) { $focused.GetType().Name } else { "null" }))
        }
        
        if (-not $focused) {
            # No focus, try to focus first focusable element
            if ($global:Logger) {
                $global:Logger.Debug("HandleTabNavigation: No focused element, focusing first")
            }
            $this._activeScreen.FocusFirst()
            return $true
        }
        
        # Ask the parent to handle navigation
        if ($focused.Parent) {
            $isReverse = ($key.Modifiers -band [System.ConsoleModifiers]::Shift) -or 
                         ($key.Key -eq [System.ConsoleKey]::LeftArrow)
            
            if ($global:Logger) {
                $global:Logger.Debug("HandleTabNavigation: Parent = $($focused.Parent.GetType().Name), Reverse = $isReverse")
            }
            
            if ($isReverse) {
                $focused.Parent.FocusPreviousChild($focused)
            } else {
                $focused.Parent.FocusNextChild($focused)
            }
            
            if ($global:Logger) {
                $direction = if ($isReverse) { "reverse" } else { "forward" }
                $global:Logger.Debug("Tab navigation: $direction via parent delegation")
            }
            return $true
        }
        
        return $false
    }
    
    # Find the deepest focused element in the tree
    [UIElement] FindDeepestFocusedElement([UIElement]$root) {
        if (-not $root) { return $null }
        
        if ($root.IsFocused) {
            # Check if any child is focused (go deeper)
            foreach ($child in $root.Children) {
                $deeper = $this.FindDeepestFocusedElement($child)
                if ($deeper) { return $deeper }
            }
            return $root
        }
        
        # Not focused, check children
        foreach ($child in $root.Children) {
            $found = $this.FindDeepestFocusedElement($child)
            if ($found) { return $found }
        }
        
        return $null
    }
    
    # Get current FPS
    [double] GetFPS() {
        return $this._lastFPS
    }
    
    # Request application exit
    [void] RequestExit() {
        $this._exitRequested = $true
        if ($this._activeScreen) {
            $this._activeScreen.Active = $false
        }
    }
    
    # Show command palette
    [void] ShowCommandPalette() {
        if ($this._activeScreen -and $this._activeScreen.CommandPalette) {
            $this._activeScreen.CommandPalette.Show()
        }
    }
}

# Global screen manager instance
$global:ScreenManager = $null


####\Core/ServiceContainer.ps1
# ServiceContainer.ps1 - Lightweight dependency injection
# Simplified from AxiomPhoenix for PRAXIS

class ServiceContainer {
    hidden [hashtable]$_services = @{}
    hidden [hashtable]$_factories = @{}
    
    # Register a service instance
    [void] Register([string]$name, [object]$instance) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $instance) {
            throw "Service instance cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._services[$name] = $instance
    }
    
    # Register a factory for lazy initialization
    [void] RegisterFactory([string]$name, [scriptblock]$factory, [bool]$singleton = $true) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        if ($null -eq $factory) {
            throw "Factory cannot be null"
        }
        if ($this._services.ContainsKey($name) -or $this._factories.ContainsKey($name)) {
            throw "Service '$name' is already registered"
        }
        
        $this._factories[$name] = @{
            Factory = $factory
            Singleton = $singleton
            Instance = $null
        }
    }
    
    # Get a service by name
    [object] GetService([string]$name) {
        if ([string]::IsNullOrWhiteSpace($name)) {
            throw "Service name cannot be empty"
        }
        
        # Check eager instances first
        if ($this._services.ContainsKey($name)) {
            return $this._services[$name]
        }
        
        # Check factories
        if ($this._factories.ContainsKey($name)) {
            $factory = $this._factories[$name]
            
            # Return cached singleton if available
            if ($factory.Singleton -and $null -ne $factory.Instance) {
                return $factory.Instance
            }
            
            # Create new instance
            $instance = & $factory.Factory $this
            
            # Cache if singleton
            if ($factory.Singleton) {
                $factory.Instance = $instance
            }
            
            return $instance
        }
        
        throw "Service '$name' not found. Available: $($this.GetServiceNames() -join ', ')"
    }
    
    # Get all registered service names
    [string[]] GetServiceNames() {
        $names = @()
        $names += $this._services.Keys
        $names += $this._factories.Keys
        return $names | Sort-Object
    }
    
    # Cleanup all services
    [void] Cleanup() {
        # Dispose any IDisposable services
        $allInstances = @()
        $allInstances += $this._services.Values
        $allInstances += $this._factories.Values | Where-Object { $_.Instance } | ForEach-Object { $_.Instance }
        
        foreach ($instance in $allInstances) {
            if ($instance -is [System.IDisposable]) {
                try {
                    $instance.Dispose()
                } catch {
                    # Ignore disposal errors
                }
            }
        }
        
        $this._services.Clear()
        $this._factories.Clear()
    }
}

# Global service container instance
$global:ServiceContainer = [ServiceContainer]::new()


####\Core/StringBuilderPool.ps1
# StringBuilderPool.ps1 - Pool for reusing StringBuilder instances to reduce memory allocations

class StringBuilderPool {
    static [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]$Pool = [System.Collections.Concurrent.ConcurrentQueue[System.Text.StringBuilder]]::new()
    static [int]$MaxPoolSize = 50
    static [int]$MaxCapacity = 16384  # 16KB max capacity before discarding
    static [int]$CreatedCount = 0
    static [int]$ReusedCount = 0
    
    # Get a StringBuilder from the pool or create new one
    static [System.Text.StringBuilder] Get() {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()  # Clear but keep capacity
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new()
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Get a StringBuilder with initial capacity
    static [System.Text.StringBuilder] Get([int]$initialCapacity) {
        $sb = $null
        if ([StringBuilderPool]::Pool.TryDequeue([ref]$sb)) {
            $sb.Clear()
            if ($sb.Capacity -lt $initialCapacity) {
                $sb.Capacity = $initialCapacity
            }
            [StringBuilderPool]::ReusedCount++
        } else {
            $sb = [System.Text.StringBuilder]::new($initialCapacity)
            [StringBuilderPool]::CreatedCount++
        }
        return $sb
    }
    
    # Return StringBuilder to pool for reuse
    static [void] Return([System.Text.StringBuilder]$sb) {
        if (-not $sb) { return }
        
        # Don't pool if too large (prevents memory bloat)
        if ($sb.Capacity -gt [StringBuilderPool]::MaxCapacity) {
            return
        }
        
        # Don't pool if we're at max capacity
        if ([StringBuilderPool]::Pool.Count -ge [StringBuilderPool]::MaxPoolSize) {
            return
        }
        
        $sb.Clear()
        [StringBuilderPool]::Pool.Enqueue($sb)
    }
    
    # Get pool statistics for debugging
    static [hashtable] GetStats() {
        return @{
            PoolSize = [StringBuilderPool]::Pool.Count
            MaxPoolSize = [StringBuilderPool]::MaxPoolSize
            Created = [StringBuilderPool]::CreatedCount
            Reused = [StringBuilderPool]::ReusedCount
            ReuseRate = if ([StringBuilderPool]::CreatedCount -eq 0) { 0 } else { 
                [Math]::Round(([StringBuilderPool]::ReusedCount / ([StringBuilderPool]::CreatedCount + [StringBuilderPool]::ReusedCount)) * 100, 2)
            }
        }
    }
    
    # Clear the pool (useful for testing or cleanup)
    static [void] Clear() {
        while ([StringBuilderPool]::Pool.TryDequeue([ref]$null)) {
            # Empty the queue
        }
    }
}

# Global helper functions for easier access
function Get-PooledStringBuilder {
    param([int]$initialCapacity = 256)
    
    if ($initialCapacity -gt 0) {
        return [StringBuilderPool]::Get($initialCapacity)
    } else {
        return [StringBuilderPool]::Get()
    }
}

function Return-PooledStringBuilder {
    param([System.Text.StringBuilder]$StringBuilder)
    [StringBuilderPool]::Return($StringBuilder)
}

function Get-StringBuilderPoolStats {
    return [StringBuilderPool]::GetStats()
}


####\Core/StringCache.ps1
# StringCache.ps1 - Pre-cached strings for common rendering patterns
# Optimizes string multiplication operations that allocate frequently

class StringCache {
    # Cache for space strings of various lengths
    static [hashtable]$Spaces = @{}
    
    # Cache for horizontal line strings
    static [hashtable]$HLines = @{}
    
    # Cache for VT100 horizontal sequences (populated later)
    static [hashtable]$VTHorizontal = @{}
    
    # Maximum cached length
    static [int]$MaxCacheLength = 200
    
    # Initialize the cache with common sizes
    static [void] Initialize() {
        # Pre-populate common sizes for spaces
        for ($i = 1; $i -le [StringCache]::MaxCacheLength; $i++) {
            [StringCache]::Spaces[$i] = " " * $i
        }
        
        # Pre-populate common sizes for horizontal lines
        for ($i = 1; $i -le [StringCache]::MaxCacheLength; $i++) {
            [StringCache]::HLines[$i] = "‚îÄ" * $i
        }
        
        # VT100 horizontal sequences will be populated after VT is loaded
    }
    
    # Get spaces of specified width
    static [string] GetSpaces([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength) {
            return [StringCache]::Spaces[$width]
        }
        # For larger widths, build dynamically
        return " " * $width
    }
    
    # Get horizontal lines of specified width
    static [string] GetHorizontalLine([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength) {
            return [StringCache]::HLines[$width]
        }
        # For larger widths, build dynamically
        return "‚îÄ" * $width
    }
    
    # Get VT100 horizontal sequence of specified width
    static [string] GetVTHorizontal([int]$width) {
        if ($width -le 0) { return "" }
        if ($width -le [StringCache]::MaxCacheLength -and [StringCache]::VTHorizontal.ContainsKey($width)) {
            return [StringCache]::VTHorizontal[$width]
        }
        # For larger widths, build dynamically using fallback
        return "‚îÄ" * $width
    }
    
    # Get repeated character string
    static [string] GetRepeatedChar([char]$char, [int]$count) {
        if ($count -le 0) { return "" }
        if ($char -eq ' ' -and $count -le [StringCache]::MaxCacheLength) {
            return [StringCache]::Spaces[$count]
        }
        if ($char -eq '‚îÄ' -and $count -le [StringCache]::MaxCacheLength) {
            return [StringCache]::HLines[$count]
        }
        # For other characters or large counts, build dynamically
        return [string]$char * $count
    }
}

# Initialize the cache on module load
[StringCache]::Initialize()


####\Core/VT100.ps1
# VT100/ANSI Core for BOLT-AXIOM with True Color Support

class VT {
    # Cursor movement (ANSI uses 1-based coordinates)
    static [string] MoveTo([int]$x, [int]$y) { return "`e[$($y + 1);$($x + 1)H" }
    static [string] SavePos() { return "`e[s" }
    static [string] RestorePos() { return "`e[u" }
    static [string] Hide() { return "`e[?25l" }
    static [string] Show() { return "`e[?25h" }
    
    # Screen control
    static [string] Clear() { return "`e[H`e[2J" }  # Clear screen and home
    static [string] ClearLine() { return "`e[K" }
    static [string] Home() { return "`e[H" }      # Just home position
    static [string] ClearToEnd() { return "`e[J" }  # Clear from cursor to end
    
    # Basic styles
    static [string] Reset() { return "`e[0m" }
    static [string] Bold() { return "`e[1m" }
    static [string] Dim() { return "`e[2m" }
    
    # 24-bit True Color
    static [string] RGB([int]$r, [int]$g, [int]$b) { 
        return "`e[38;2;$r;$g;$($b)m" 
    }
    static [string] RGBBG([int]$r, [int]$g, [int]$b) { 
        return "`e[48;2;$r;$g;$($b)m" 
    }
    
    # Wireframe color palette (true color)
    static [string] Border() { return [VT]::RGB(0, 255, 255) }      # Cyan
    static [string] BorderDim() { return [VT]::RGB(0, 128, 128) }   # Dark cyan
    static [string] BorderActive() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Text() { return [VT]::RGB(192, 192, 192) }      # Light gray
    static [string] TextDim() { return [VT]::RGB(128, 128, 128) }   # Gray
    static [string] TextBright() { return [VT]::RGB(255, 255, 255) } # White
    static [string] Accent() { return [VT]::RGB(0, 255, 0) }        # Green
    static [string] Warning() { return [VT]::RGB(255, 255, 0) }     # Yellow
    static [string] Error() { return [VT]::RGB(255, 0, 0) }         # Red
    static [string] Selected() { return [VT]::RGB(255, 255, 255) + [VT]::RGBBG(0, 64, 128) } # White on dark blue
    
    # Box drawing - single lines for speed
    static [string] TL() { return "‚îå" }     # Top left
    static [string] TR() { return "‚îê" }     # Top right
    static [string] BL() { return "‚îî" }     # Bottom left
    static [string] BR() { return "‚îò" }     # Bottom right
    static [string] H() { return "‚îÄ" }      # Horizontal
    static [string] V() { return "‚îÇ" }      # Vertical
    static [string] Cross() { return "‚îº" }  # Cross
    static [string] T() { return "‚î¨" }      # T down
    static [string] B() { return "‚î¥" }      # T up
    static [string] L() { return "‚îú" }      # T right
    static [string] R() { return "‚î§" }      # T left
    
    # Double lines for emphasis
    static [string] DTL() { return "‚ïî" }
    static [string] DTR() { return "‚ïó" }
    static [string] DBL() { return "‚ïö" }
    static [string] DBR() { return "‚ïù" }
    static [string] DH() { return "‚ïê" }
    static [string] DV() { return "‚ïë" }
}

# Layout measurement helpers
class Measure {
    static [int] TextWidth([string]$text) {
        # Remove ANSI sequences for accurate measurement
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        return $clean.Length
    }
    
    static [string] Truncate([string]$text, [int]$maxWidth) {
        $clean = $text -replace '\x1b\[[0-9;]*m', ''
        if ($clean.Length -le $maxWidth) { return $text }
        return $clean.Substring(0, $maxWidth - 3) + "..."
    }
    
    static [string] Pad([string]$text, [int]$width, [string]$align = "Left") {
        $textWidth = [Measure]::TextWidth($text)
        if ($textWidth -ge $width) { return [Measure]::Truncate($text, $width) }
        
        $padding = $width - $textWidth
        switch ($align) {
            "Left" { return $text + [StringCache]::GetSpaces($padding) }
            "Right" { return [StringCache]::GetSpaces($padding) + $text }
            "Center" { 
                $left = [int]($padding / 2)
                $right = $padding - $left
                return [StringCache]::GetSpaces($left) + $text + [StringCache]::GetSpaces($right)
            }
        }
        return $text
    }
}


####\Models/BaseAction.ps1
# BaseAction.ps1 - Base class for Visual Macro Factory actions
# Defines the contract for all macro actions with explicit data dependencies

class BaseAction {
    [string]$Name
    [string]$Description
    [string]$Category
    [string]$Icon = "‚öôÔ∏è"
    
    # Declares what variables this action NEEDS from the Macro Context
    # Format: @{ Name="fieldName"; Type="Field"; Description="Field to analyze" }
    [hashtable[]]$Consumes = @()
    
    # Declares what variables this action CREATES  
    # Format: @{ Name="outputDb"; Type="Database"; Description="Result database" }
    [hashtable[]]$Produces = @()
    
    # Whether this action can accept custom IDEA@ commands
    [bool]$AllowsCustomCommands = $false
    
    BaseAction() {
        # Override in derived classes
    }
    
    # Generates the final IDEAScript code using the provided context
    [string] RenderScript([hashtable]$macroContext) {
        throw "RenderScript must be implemented by derived class: $($this.GetType().Name)"
    }
    
    # Get display text for UI lists
    [string] GetDisplayText() {
        return "$($this.Icon) $($this.Name)"
    }
    
    # Get detailed description with requirements
    [string] GetDetailedDescription() {
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine($this.Description)
        
        if ($this.Consumes.Count -gt 0) {
            $sb.AppendLine("`nRequires:")
            foreach ($req in $this.Consumes) {
                $sb.AppendLine("  ‚Ä¢ $($req.Name) ($($req.Type)): $($req.Description)")
            }
        }
        
        if ($this.Produces.Count -gt 0) {
            $sb.AppendLine("`nProduces:")
            foreach ($prod in $this.Produces) {
                $sb.AppendLine("  ‚Ä¢ $($prod.Name) ($($prod.Type)): $($prod.Description)")
            }
        }
        
        return $sb.ToString()
    }
    
    # Validate that required context variables are available
    [bool] ValidateContext([hashtable]$macroContext) {
        foreach ($requirement in $this.Consumes) {
            if (-not $macroContext.ContainsKey($requirement.Name)) {
                return $false
            }
        }
        return $true
    }
    
    # Get list of missing context variables
    [string[]] GetMissingContext([hashtable]$macroContext) {
        $missing = @()
        foreach ($requirement in $this.Consumes) {
            if (-not $macroContext.ContainsKey($requirement.Name)) {
                $missing += $requirement.Name
            }
        }
        return $missing
    }
}


####\Models/Command.ps1
# Command.ps1 - Model for storing reusable command strings
# Used in Command Library for quick access and clipboard copying

class Command : BaseModel {
    [string]$Title = ""
    [string]$Description = ""
    [string[]]$Tags = @()
    [string]$Group = ""
    [string]$CommandText = ""  # REQUIRED - the actual command to copy
    [datetime]$Created = [datetime]::Now
    [datetime]$LastUsed = [datetime]::MinValue
    [int]$UseCount = 0
    
    Command() : base() {
        # Base constructor handles Id generation
    }
    
    Command([string]$commandText) : base() {
        $this.CommandText = $commandText
    }
    
    Command([string]$title, [string]$commandText) : base() {
        $this.Title = $title
        $this.CommandText = $commandText
    }
    
    # Validation - CommandText is required
    [bool] IsValid() {
        return -not [string]::IsNullOrWhiteSpace($this.CommandText)
    }
    
    # Update usage statistics when command is used
    [void] RecordUsage() {
        $this.LastUsed = [datetime]::Now
        $this.UseCount++
    }
    
    # Get display text for lists
    [string] GetDisplayText() {
        $displayText = ""
        
        # Add group prefix if present
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $displayText += "[$($this.Group)] "
        }
        
        # Add title or truncated command text
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $displayText += $this.Title
        } else {
            # Use first 50 chars of command text as fallback
            $commandPreview = $this.CommandText
            if ($commandPreview.Length -gt 50) {
                $commandPreview = $commandPreview.Substring(0, 47) + "..."
            }
            $displayText += $commandPreview
        }
        
        return $displayText
    }
    
    # Get searchable text for filtering
    [string] GetSearchableText() {
        $searchText = @()
        
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $searchText += $this.Title
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Description)) {
            $searchText += $this.Description
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $searchText += $this.Group
        }
        
        if ($this.Tags -and $this.Tags.Count -gt 0) {
            $searchText += ($this.Tags -join " ")
        }
        
        # Always include command text in search
        $searchText += $this.CommandText
        
        return ($searchText -join " ")
    }
    
    # Get detailed text for display in dialogs
    [string] GetDetailText() {
        $details = @()
        
        if (-not [string]::IsNullOrWhiteSpace($this.Title)) {
            $details += "Title: $($this.Title)"
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Description)) {
            $details += "Description: $($this.Description)"
        }
        
        if (-not [string]::IsNullOrWhiteSpace($this.Group)) {
            $details += "Group: $($this.Group)"
        }
        
        if ($this.Tags -and $this.Tags.Count -gt 0) {
            $details += "Tags: $($this.Tags -join ', ')"
        }
        
        $details += "Command: $($this.CommandText)"
        
        if ($this.UseCount -gt 0) {
            $details += "Used: $($this.UseCount) times, last: $($this.LastUsed.ToString('yyyy-MM-dd HH:mm'))"
        }
        
        return ($details -join "`n")
    }
    
    # Convert to hashtable for JSON serialization
    [hashtable] ToHashtable() {
        return @{
            Id = $this.Id
            Title = $this.Title
            Description = $this.Description
            Tags = $this.Tags
            Group = $this.Group
            CommandText = $this.CommandText
            Created = $this.Created.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK")
            LastUsed = if ($this.LastUsed -eq [datetime]::MinValue) { $null } else { $this.LastUsed.ToString("yyyy-MM-ddTHH:mm:ss.fffffffK") }
            UseCount = $this.UseCount
        }
    }
    
    # Create from hashtable (for JSON deserialization)
    static [Command] FromHashtable([hashtable]$data) {
        $command = [Command]::new()
        
        $command.Id = $data.Id
        $command.Title = $data.Title ?? ""
        $command.Description = $data.Description ?? ""
        $command.Tags = $data.Tags ?? @()
        $command.Group = $data.Group ?? ""  
        $command.CommandText = $data.CommandText ?? ""
        $command.UseCount = $data.UseCount ?? 0
        
        if ($data.Created) {
            $command.Created = [datetime]::Parse($data.Created)
        }
        
        if ($data.LastUsed) {
            $command.LastUsed = [datetime]::Parse($data.LastUsed)
        } else {
            $command.LastUsed = [datetime]::MinValue
        }
        
        return $command
    }
}


####\Models/Project.ps1
# Project Model - Enhanced project definition based on PMC pattern

class Project : BaseModel {
    [string]$FullProjectName
    [string]$Nickname
    [string]$ID1
    [string]$ID2
    [DateTime]$DateAssigned
    [DateTime]$BFDate
    [DateTime]$DateDue
    [string]$Note
    [string]$CAAPath
    [string]$RequestPath
    [string]$T2020Path
    [decimal]$CumulativeHrs
    [DateTime]$ClosedDate
    
    # Audit Information
    [string]$AuditType
    [string]$AuditProgram
    [string]$AuditCase
    [DateTime]$AuditStartDate
    [DateTime]$AuditPeriodFrom
    [DateTime]$AuditPeriodTo
    
    # Additional Audit Periods
    [DateTime]$AuditPeriod1Start
    [DateTime]$AuditPeriod1End
    [DateTime]$AuditPeriod2Start
    [DateTime]$AuditPeriod2End
    [DateTime]$AuditPeriod3Start
    [DateTime]$AuditPeriod3End
    [DateTime]$AuditPeriod4Start
    [DateTime]$AuditPeriod4End
    [DateTime]$AuditPeriod5Start
    [DateTime]$AuditPeriod5End
    
    # Client Information
    [string]$ClientID  # TPNum
    [string]$Address
    [string]$City
    [string]$Province
    [string]$PostalCode
    [string]$Country
    [string]$ShipToAddress
    
    # Auditor Information
    [string]$AuditorName
    [string]$AuditorPhone
    [string]$AuditorTL
    [string]$AuditorTLPhone
    
    # Contact Information
    [string]$Contact1Name
    [string]$Contact1Phone
    [string]$Contact1Ext
    [string]$Contact1Address
    [string]$Contact1Title
    [string]$Contact2Name
    [string]$Contact2Phone
    [string]$Contact2Ext
    [string]$Contact2Address
    [string]$Contact2Title
    
    # System Information
    [string]$AccountingSoftware1
    [string]$AccountingSoftware1Other
    [string]$AccountingSoftware1Type
    [string]$AccountingSoftware2
    [string]$AccountingSoftware2Other
    [string]$AccountingSoftware2Type
    
    # Other Information
    [DateTime]$RequestDate
    [string]$FXInfo
    [string]$Comments
    
    # Status tracking (not from Excel)
    [string]$Status = "Active"
    
    # Default constructor
    Project() : base() {
        $this.FullProjectName = ""
        $this.Nickname = ""
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Project([string]$fullName, [string]$nickname) : base() {
        $this.FullProjectName = $fullName
        $this.Nickname = $nickname
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)  # 6 weeks default
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Legacy constructor for backward compatibility
    Project([string]$name) : base() {
        $this.FullProjectName = $name
        $this.Nickname = $name
        $this.ID1 = ""
        $this.ID2 = ""
        $this.DateAssigned = [DateTime]::Now
        $this.BFDate = [DateTime]::Now
        $this.DateDue = [DateTime]::Now.AddDays(42)
        $this.Note = ""
        $this.CAAPath = ""
        $this.RequestPath = ""
        $this.T2020Path = ""
        $this.CumulativeHrs = 0
        $this.ClosedDate = [DateTime]::MinValue
        
        # Initialize new audit date fields
        $this.AuditStartDate = [DateTime]::MinValue
        $this.AuditPeriodFrom = [DateTime]::MinValue
        $this.AuditPeriodTo = [DateTime]::MinValue
        $this.AuditPeriod1Start = [DateTime]::MinValue
        $this.AuditPeriod1End = [DateTime]::MinValue
        $this.AuditPeriod2Start = [DateTime]::MinValue
        $this.AuditPeriod2End = [DateTime]::MinValue
        $this.AuditPeriod3Start = [DateTime]::MinValue
        $this.AuditPeriod3End = [DateTime]::MinValue
        $this.AuditPeriod4Start = [DateTime]::MinValue
        $this.AuditPeriod4End = [DateTime]::MinValue
        $this.AuditPeriod5Start = [DateTime]::MinValue
        $this.AuditPeriod5End = [DateTime]::MinValue
        $this.RequestDate = [DateTime]::MinValue
        
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
}


####\Models/Subtask.ps1
# Subtask.ps1 - Subtask model extending the Task system

class Subtask : BaseModel {
    [string]$ParentTaskId  # Links to parent Task.Id
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [int]$SortOrder = 0  # For ordering subtasks within parent
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    # Estimated and actual time tracking
    [int]$EstimatedMinutes = 0
    [int]$ActualMinutes = 0
    
    Subtask() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    Subtask([string]$parentTaskId) : base() {
        $this.ParentTaskId = $parentTaskId
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[‚úì]" }
            ([TaskStatus]::Cancelled) { return "[‚úó]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "‚Üì" }
            ([TaskPriority]::Medium) { return "‚Üí" }
            ([TaskPriority]::High) { return "‚Üë" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
    
    [string] GetDurationDisplay() {
        if ($this.EstimatedMinutes -eq 0) {
            return ""
        }
        
        $estimated = $this.FormatMinutes($this.EstimatedMinutes)
        if ($this.ActualMinutes -gt 0) {
            $actual = $this.FormatMinutes($this.ActualMinutes)
            return "$actual / $estimated"
        } else {
            return "~$estimated"
        }
    }
    
    [string] FormatMinutes([int]$minutes) {
        if ($minutes -lt 60) {
            return "$($minutes)m"
        } elseif ($minutes -lt 480) {  # Less than 8 hours
            $hours = [Math]::Floor($minutes / 60)
            $mins = $minutes % 60
            if ($mins -eq 0) {
                return "$($hours)h"
            } else {
                return "$($hours)h$($mins)m"
            }
        } else {
            $hours = [Math]::Round($minutes / 60.0, 1)
            return "$($hours)h"
        }
    }
    
    [bool] IsCompleted() {
        return $this.Status -eq [TaskStatus]::Completed
    }
    
    [bool] IsInProgress() {
        return $this.Status -eq [TaskStatus]::InProgress
    }
    
    [bool] IsPending() {
        return $this.Status -eq [TaskStatus]::Pending
    }
}


####\Models/Task.ps1
# Task.ps1 - Task model

enum TaskStatus {
    Pending
    InProgress
    Completed
    Cancelled
}

enum TaskPriority {
    Low
    Medium
    High
}

class Task : BaseModel {
    [string]$Title
    [string]$Description = ""
    [TaskStatus]$Status = [TaskStatus]::Pending
    [TaskPriority]$Priority = [TaskPriority]::Medium
    [int]$Progress = 0
    [string]$ProjectId = ""
    [string[]]$Tags = @()
    [DateTime]$DueDate = [DateTime]::MinValue
    
    Task() : base() {
        # BaseModel handles Id, CreatedAt, UpdatedAt, Deleted initialization
    }
    
    # Helper methods
    [bool] IsOverdue() {
        return $this.DueDate -ne [DateTime]::MinValue -and 
               $this.DueDate -lt [DateTime]::Now -and 
               $this.Status -ne [TaskStatus]::Completed -and
               $this.Status -ne [TaskStatus]::Cancelled
    }
    
    [int] GetDaysUntilDue() {
        if ($this.DueDate -eq [DateTime]::MinValue) {
            return [int]::MaxValue
        }
        return ([DateTime]$this.DueDate - [DateTime]::Now).Days
    }
    
    [string] GetStatusDisplay() {
        switch ($this.Status) {
            ([TaskStatus]::Pending) { return "[ ]" }
            ([TaskStatus]::InProgress) { return "[~]" }
            ([TaskStatus]::Completed) { return "[‚úì]" }
            ([TaskStatus]::Cancelled) { return "[‚úó]" }
        }
        return "[?]"
    }
    
    [string] GetPriorityDisplay() {
        switch ($this.Priority) {
            ([TaskPriority]::Low) { return "‚Üì" }
            ([TaskPriority]::Medium) { return "‚Üí" }
            ([TaskPriority]::High) { return "‚Üë" }
        }
        return " "
    }
    
    [void] UpdateProgress([int]$progress) {
        $this.Progress = [Math]::Max(0, [Math]::Min(100, $progress))
        $this.UpdatedAt = Get-Date
        
        # Auto-update status based on progress
        if ($this.Progress -eq 100 -and $this.Status -ne [TaskStatus]::Completed) {
            $this.Status = [TaskStatus]::Completed
        } elseif ($this.Progress -gt 0 -and $this.Progress -lt 100 -and $this.Status -eq [TaskStatus]::Pending) {
            $this.Status = [TaskStatus]::InProgress
        }
    }
}


####\Models/TimeCode.ps1
# TimeCode Model - Non-project time codes (vacation, admin, etc.)

class TimeCode : BaseModel {
    [string]$ID2               # 3-5 character code (e.g., "VAC", "SICK", "ADMIN")
    [string]$Description       # Optional description for display
    [bool]$IsActive           # Whether this code is currently in use
    [int]$DisplayOrder        # For sorting common codes to top
    
    TimeCode() : base() {
        $this.IsActive = $true
        $this.DisplayOrder = 999  # Default to bottom
    }
    
    TimeCode([string]$id2) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = ""
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    TimeCode([string]$id2, [string]$description) : base() {
        $this.ID2 = $id2.ToUpper()
        $this.Description = $description
        $this.IsActive = $true
        $this.DisplayOrder = 999
    }
    
    [string] GetDisplayName() {
        if ($this.Description) {
            return "$($this.ID2) - $($this.Description)"
        }
        return $this.ID2
    }
    
    # Static method to get common time codes
    static [TimeCode[]] GetCommonCodes() {
        return @(
            [TimeCode]::new("VAC", "Vacation"),
            [TimeCode]::new("SICK", "Sick Leave"),
            [TimeCode]::new("STAT", "Statutory Holiday"),
            [TimeCode]::new("ADMIN", "Administration"),
            [TimeCode]::new("TRAIN", "Training"),
            [TimeCode]::new("MTG", "Meetings"),
            [TimeCode]::new("PD", "Professional Development")
        )
    }
}


####\Models/TimeEntry.ps1
# TimeEntry Model - Universal time tracking for projects and non-project codes

class TimeEntry : BaseModel {
    [string]$WeekEndingFriday  # Friday date in yyyyMMdd format
    [string]$Name              # Project name or empty for non-project
    [string]$ID1               # Project ID1 or empty for non-project
    [string]$ID2               # Project ID2 or non-project code (3-5 chars)
    [decimal]$Monday
    [decimal]$Tuesday
    [decimal]$Wednesday
    [decimal]$Thursday
    [decimal]$Friday
    [decimal]$Total            # Calculated total for the week
    [string]$FiscalYear       # Format: "2024-2025" (Apr 1 2024 - Mar 31 2025)
    
    TimeEntry() : base() {
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    TimeEntry([string]$weekEndingFriday, [string]$id2) : base() {
        $this.WeekEndingFriday = $weekEndingFriday
        $this.ID2 = $id2
        $this.Name = ""
        $this.ID1 = ""
        $this.Monday = 0
        $this.Tuesday = 0
        $this.Wednesday = 0
        $this.Thursday = 0
        $this.Friday = 0
        $this.Total = 0
        $this.CalculateFiscalYear()
    }
    
    [void] CalculateTotal() {
        $this.Total = $this.Monday + $this.Tuesday + $this.Wednesday + $this.Thursday + $this.Friday
    }
    
    [void] CalculateFiscalYear() {
        if (-not $this.WeekEndingFriday) {
            $fridayDate = [DateTime]::Now
            while ($fridayDate.DayOfWeek -ne [DayOfWeek]::Friday) {
                $fridayDate = $fridayDate.AddDays(1)
            }
            $this.WeekEndingFriday = $fridayDate.ToString("yyyyMMdd")
        }
        
        $date = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        
        # Fiscal year runs April 1 - March 31
        if ($date.Month -ge 4) {
            # April through December - fiscal year starts this calendar year
            $fiscalStart = $date.Year
        } else {
            # January through March - fiscal year started last calendar year
            $fiscalStart = $date.Year - 1
        }
        
        $this.FiscalYear = "$fiscalStart-$($fiscalStart + 1)"
    }
    
    [bool] IsProjectEntry() {
        # Non-project entries have 3-5 character ID2 codes
        return $this.ID2.Length -gt 5
    }
    
    [DateTime] GetWeekStartMonday() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return $fridayDate.AddDays(-4)  # Monday is 4 days before Friday
    }
    
    [string] GetWeekDisplayString() {
        $fridayDate = [DateTime]::ParseExact($this.WeekEndingFriday, "yyyyMMdd", $null)
        return "Week ending " + $fridayDate.ToString("MM/dd/yyyy")
    }
}


####\Screens/CommandEditDialog.ps1
# CommandEditDialog.ps1 - Dialog for creating and editing commands
# Handles all CRUD operations for command library entries

class CommandEditDialog : BaseDialog {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [TextBox]$TagsBox
    [TextBox]$GroupBox
    [TextBox]$CommandBox
    [Command]$Command
    [CommandService]$CommandService
    [scriptblock]$OnSave
    
    CommandEditDialog() : base("Command Editor", 80, 25) {
        # Constructor uses BaseDialog(title, width, height)
    }
    
    [void] OnInitialize() {
        ([BaseDialog]$this).OnInitialize()
        
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        
        # Calculate positions
        $labelWidth = 12
        $fieldX = $labelWidth + 3
        $fieldWidth = $this.DialogWidth - $fieldX - 3
        $currentY = 3
        
        # Title field
        $this.CreateLabel("Title:", 2, $currentY)
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.X = $fieldX
        $this.TitleBox.Y = $currentY
        $this.TitleBox.Width = $fieldWidth
        $this.TitleBox.Placeholder = "Optional: Display name for the command"
        $this.AddChild($this.TitleBox)
        $currentY += 4
        
        # Description field
        $this.CreateLabel("Description:", 2, $currentY)
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.X = $fieldX
        $this.DescriptionBox.Y = $currentY
        $this.DescriptionBox.Width = $fieldWidth
        $this.DescriptionBox.Placeholder = "Optional: What this command does"
        $this.AddChild($this.DescriptionBox)
        $currentY += 4
        
        # Tags field
        $this.CreateLabel("Tags:", 2, $currentY)
        $this.TagsBox = [TextBox]::new()
        $this.TagsBox.X = $fieldX
        $this.TagsBox.Y = $currentY
        $this.TagsBox.Width = $fieldWidth
        $this.TagsBox.Placeholder = "Optional: Comma-separated tags (git, powershell, etc.)"
        $this.AddChild($this.TagsBox)
        $currentY += 4
        
        # Group field
        $this.CreateLabel("Group:", 2, $currentY)
        $this.GroupBox = [TextBox]::new()
        $this.GroupBox.X = $fieldX
        $this.GroupBox.Y = $currentY
        $this.GroupBox.Width = $fieldWidth
        $this.GroupBox.Placeholder = "Optional: Category/group name"
        $this.AddChild($this.GroupBox)
        $currentY += 4
        
        # Command field (required)
        $this.CreateLabel("Command:", 2, $currentY)
        $this.CommandBox = [TextBox]::new()
        $this.CommandBox.X = $fieldX
        $this.CommandBox.Y = $currentY
        $this.CommandBox.Width = $fieldWidth
        $this.CommandBox.Placeholder = "REQUIRED: The command text to copy to clipboard"
        $this.AddChild($this.CommandBox)
        $currentY += 4
        
        # Configure BaseDialog buttons
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.OnPrimary = { $this.SaveCommand() }
        $this.OnSecondary = { $this.Cancel() }
        
        # Set initial focus
        $this.TitleBox.Focus()
    }
    
    [void] CreateLabel([string]$text, [int]$x, [int]$y) {
        # Helper method to create labels - could be implemented as a simple text render
        # For now, we'll handle this in the rendering
    }
    
    [void] SetCommand([Command]$command) {
        $this.Command = $command
        
        if ($command) {
            # Editing existing command
            $this.Title = "Edit Command"
            $this.TitleBox.SetText($command.Title)
            $this.DescriptionBox.SetText($command.Description)
            $this.TagsBox.SetText(($command.Tags -join ", "))
            $this.GroupBox.SetText($command.Group)
            $this.CommandBox.SetText($command.CommandText)
        } else {
            # Creating new command
            $this.Title = "Add Command"
            $this.TitleBox.SetText("")
            $this.DescriptionBox.SetText("")
            $this.TagsBox.SetText("")
            $this.GroupBox.SetText("")
            $this.CommandBox.SetText("")
        }
    }
    
    [void] SaveCommand() {
        try {
            # Validate required field
            $commandText = $this.CommandBox.Text.Trim()
            if ([string]::IsNullOrWhiteSpace($commandText)) {
                # Show error or just return - command text is required
                if ($global:Logger) {
                    $global:Logger.Warning("Command text is required")
                }
                return
            }
            
            # Parse tags
            $tagsText = $this.TagsBox.Text.Trim()
            $tags = @()
            if (-not [string]::IsNullOrWhiteSpace($tagsText)) {
                $tags = $tagsText -split ',' | ForEach-Object { $_.Trim() } | Where-Object { $_ -ne '' }
            }
            
            if ($this.Command) {
                # Update existing command
                $this.Command.Title = $this.TitleBox.Text.Trim()
                $this.Command.Description = $this.DescriptionBox.Text.Trim()
                $this.Command.Tags = $tags
                $this.Command.Group = $this.GroupBox.Text.Trim()
                $this.Command.CommandText = $commandText
                
                $success = $this.CommandService.UpdateCommand($this.Command)
                if (-not $success) {
                    if ($global:Logger) {
                        $global:Logger.Error("Failed to update command")
                    }
                    return
                }
            } else {
                # Create new command
                $this.Command = $this.CommandService.AddCommand(
                    $this.TitleBox.Text.Trim(),
                    $this.DescriptionBox.Text.Trim(),
                    $tags,
                    $this.GroupBox.Text.Trim(),
                    $commandText
                )
            }
            
            # Call save callback
            if ($this.OnSave) {
                & $this.OnSave $this.Command
            }
            
            # Close dialog
            $this.ScreenManager.PopScreen()
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandEditDialog.SaveCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] Cancel() {
        $this.ScreenManager.PopScreen()
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Handle Ctrl+S to save
        if ($key.Key -eq [System.ConsoleKey]::S -and $key.Modifiers -band [System.ConsoleModifiers]::Control) {
            $this.SaveCommand()
            return $true
        }
        
        # Handle Escape to cancel
        if ($key.Key -eq [System.ConsoleKey]::Escape) {
            $this.Cancel()
            return $true
        }
        
        return ([BaseDialog]$this).HandleInput($key)
    }
    
    # Override OnRender to draw labels
    [string] OnRender() {
        $baseRender = ([BaseDialog]$this).OnRender()
        
        # Add labels - this is a simple approach
        # In a more sophisticated implementation, labels would be proper UI elements
        $sb = [System.Text.StringBuilder]::new()
        $sb.Append($baseRender)
        
        # Get theme colors
        $theme = $this.ServiceContainer.GetService("ThemeManager")
        if ($theme) {
            $labelColor = $theme.GetColor("foreground")
            $requiredColor = $theme.GetColor("accent")
            
            # Draw labels
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 3))
            $sb.Append($labelColor)
            $sb.Append("Title:")
            
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 7))
            $sb.Append($labelColor)
            $sb.Append("Description:")
            
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 11))
            $sb.Append($labelColor)
            $sb.Append("Tags:")
            
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 15))
            $sb.Append($labelColor)
            $sb.Append("Group:")
            
            $sb.Append([VT]::MoveTo($this.X + 2, $this.Y + 19))
            $sb.Append($requiredColor)
            $sb.Append("Command:")
            
            $sb.Append([VT]::Reset())
        }
        
        return $sb.ToString()
    }
    
    [string] GetHelpText() {
        return @"
Command Editor Help:

Ctrl+S    - Save command
Escape    - Cancel and close
Tab       - Navigate between fields

Fields:
- Title: Optional display name
- Description: Optional description  
- Tags: Optional comma-separated tags
- Group: Optional category/group
- Command: REQUIRED - text to copy to clipboard

Only the Command field is required. All others are optional.
"@
    }
}


####\Screens/CommandLibraryScreen.ps1
# CommandLibraryScreen.ps1 - Command library management screen
# Browse, search, and manage reusable command strings with clipboard copy

class CommandLibraryScreen : Screen {
    [SearchableListBox]$CommandList
    [CommandService]$CommandService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    CommandLibraryScreen() : base() {
        $this.Title = "Command Library"
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Create command list using SearchableListBox
        $this.CommandList = [SearchableListBox]::new()
        $this.CommandList.Title = "Commands"
        $this.CommandList.ShowBorder = $true
        $this.CommandList.SearchPrompt = "Search commands... (t:tag d:desc g:group +and |or)"
        
        # Set custom search filter for advanced syntax
        $this.CommandList.SearchFilter = {
            param($command, $query)
            return $this.CommandService.SearchCommands($query) -contains $command
        }.GetNewClosure()
        
        # Custom renderer for commands
        $this.CommandList.ItemRenderer = {
            param($command)
            if (-not $command) { return "" }
            
            $displayText = $command.GetDisplayText()
            
            # Add usage count if > 0
            if ($command.UseCount -gt 0) {
                $displayText += " ‚òÖ$($command.UseCount)"
            }
            
            return $displayText
        }
        
        # Handle selection changes
        $this.CommandList.OnSelectionChanged = {
            # Could update UI state here if needed
        }
        
        $this.CommandList.Initialize($this.ServiceContainer)
        $this.AddChild($this.CommandList)
        
        # Load commands
        $this.LoadCommands()
        
        # Register shortcuts
        $this.RegisterShortcuts()
        
        # Set initial focus to command list
        if ($this.CommandList) {
            $this.CommandList.Focus()
        }
    }
    
    [void] LoadCommands() {
        $commands = $this.CommandService.GetAllCommands()
        $this.CommandList.SetItems($commands)
    }
    
    [void] FilterCommands() {
        # Apply any active search filter
        # SearchableListBox handles its own filtering, so this is just for refresh
        $this.CommandList.Invalidate()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.new"
            Name = "New Command"
            Description = "Create a new command"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.NewCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.edit"
            Name = "Edit Command"
            Description = "Edit the selected command"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.EditCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.delete"
            Name = "Delete Command"
            Description = "Delete the selected command"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.DeleteCommand() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "commands.copy"
            Name = "Copy Command"
            Description = "Copy selected command to clipboard"
            Key = [System.ConsoleKey]::Enter
            Scope = [ShortcutScope]::Screen
            ScreenType = "CommandLibraryScreen"
            Priority = 50
            Action = { $screen.CopySelectedCommand() }.GetNewClosure()
        })
    }
    
    [void] NewCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.NewCommand: Called via shortcut")
        }
        try {
            $screen = [CommandEditDialog]::new()
            $screen.Initialize($this.ServiceContainer)
            
            $screen.SetCommand($null)  # New command
            $screen.OnSave = {
                param($command)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($screen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.NewCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] EditCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.EditCommand: Called via shortcut")
        }
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if (-not $selectedCommand) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen.EditCommand: No command selected")
            }
            return 
        }
        
        try {
            $screen = [CommandEditDialog]::new()
            $screen.Initialize($this.ServiceContainer)
            
            $screen.SetCommand($selectedCommand)
            $screen.OnSave = {
                param($command)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($screen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.EditCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] DeleteCommand() {
        if ($global:Logger) {
            $global:Logger.Info("CommandLibraryScreen.DeleteCommand: Called via shortcut")
        }
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if (-not $selectedCommand) { 
            if ($global:Logger) {
                $global:Logger.Warning("CommandLibraryScreen.DeleteCommand: No command selected")
            }
            return 
        }
        
        try {
            # Show confirmation dialog
            $confirmScreen = [ConfirmationDialog]::new()
            $confirmScreen.Initialize($this.ServiceContainer)
            $confirmScreen.SetTitle("Delete Command")
            $confirmScreen.SetMessage("Are you sure you want to delete this command?`n`n$($selectedCommand.GetDisplayText())")
            $confirmScreen.OnConfirm = {
                $this.CommandService.DeleteCommand($selectedCommand.Id)
                $this.LoadCommands()
                $this.FilterCommands()
            }
            
            $global:ScreenManager.Push($confirmScreen)
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("CommandLibraryScreen.DeleteCommand: $($_.Exception.Message)")
            }
        }
    }
    
    [void] CopySelectedCommand() {
        $selectedCommand = $this.CommandList.GetSelectedItem()
        if ($selectedCommand) {
            try {
                $this.CommandService.CopyToClipboard($selectedCommand.Id)
                
                # Show brief confirmation (could be a toast notification)
                if ($global:Logger) {
                    $global:Logger.Info("Copied to clipboard: $($selectedCommand.GetDisplayText())")
                }
                
                # Refresh the list to show updated usage count
                $this.LoadCommands()
                $this.FilterCommands()
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("Failed to copy command: $($_.Exception.Message)")
                }
            }
        }
    }
    
    # Search help removed - SearchableListBox should handle this
    
    # HandleInput removed - using ShortcutManager instead
    
    [void] OnBoundsChanged() {
        if ($this.Width -le 0 -or $this.Height -le 0) { return }
        
        # CommandLibraryScreen has a single CommandList that takes the full area
        if ($this.CommandList) {
            $this.CommandList.SetBounds(0, 0, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Set focus when screen becomes active
        if ($this.CommandList) {
            $this.CommandList.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Route to ShortcutManager for screen-specific shortcuts
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if ($shortcutManager) {
            return $shortcutManager.HandleKeyPress($keyInfo, $this.GetType().Name, "")
        }
        return $false
    }
    
    [string] GetHelpText() {
        return @"
Command Library Help:

Enter         - Copy selected command to clipboard
n             - Add new command
e             - Edit selected command  
d             - Delete selected command
Escape        - Return to main menu
Tab           - Navigate between elements

Search supports advanced syntax:
  t:tag d:desc g:group +and |or
"@
    }
}


####\Screens/ConfirmationDialog.ps1
# ConfirmationDialog.ps1 - Generic confirmation dialog using BaseDialog

class ConfirmationDialog : BaseDialog {
    [string]$Message
    [string]$ConfirmText = "Yes"
    [string]$CancelText = "No"
    
    ConfirmationDialog() : base("Confirm") {
        $this.Message = "Are you sure?"
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    ConfirmationDialog([string]$message) : base("Confirm") {
        $this.Message = $message
        # Set button texts before initialization
        $this.PrimaryButtonText = $this.ConfirmText
        $this.SecondaryButtonText = $this.CancelText
    }
    
    [void] InitializeContent() {
        # Base dialog handles button creation, we just need to update button texts if needed
        if ($this.PrimaryButton -and $this.ConfirmText -ne "Yes") {
            $this.PrimaryButton.Text = $this.ConfirmText
        }
        
        if ($this.SecondaryButton -and $this.CancelText -ne "No") {
            $this.SecondaryButton.Text = $this.CancelText
        }
        
        # No additional content controls needed for simple confirmation
        # The message is rendered directly in the dialog
    }
    
    [void] OnActivated() {
        ([BaseDialog]$this).OnActivated()
        # Override to focus on cancel button by default (safer)
        if ($this.SecondaryButton) {
            $this.SecondaryButton.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on message
        $messageLines = $this.Message -split "`n"
        $maxLineLength = ($messageLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $this.DialogWidth = [Math]::Max(40, $maxLineLength + 8)
        $this.DialogHeight = 10 + $messageLines.Count
        
        # Let base class handle the rest
        ([BaseDialog]$this).OnBoundsChanged()
    }
    
    # Override HandleScreenInput to add Y/N shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Y/N shortcuts specific to confirmation dialog
        switch ($key.Key) {
            ([System.ConsoleKey]::Y) {
                if ($key.KeyChar -eq 'Y' -or $key.KeyChar -eq 'y') {
                    $this.HandlePrimaryAction()
                    return $true
                }
            }
            ([System.ConsoleKey]::N) {
                if ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n') {
                    $this.HandleSecondaryAction()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render the base dialog (overlay, box, title, buttons)
        $baseRender = ([BaseDialog]$this).OnRender()
        $sb.Append($baseRender)
        
        # Add our custom content - the message and hint
        if ($this._dialogBounds -and $this._dialogBounds.Count -gt 0) {
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Draw warning icon in title
            $title = " ‚ö† Confirm "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($this.Theme.GetColor("warning"))
            $sb.Append($title)
            
            # Draw message
            $messageLines = $this.Message -split "`n"
            $messageY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $messageLines) {
                $lineX = $x + [int](($w - $line.Length) / 2)
                $sb.Append([VT]::MoveTo($lineX, $messageY))
                $sb.Append($line)
                $messageY++
            }
            
            # Draw hint
            $hint = "[Y/N] or use Tab to select"
            $hintX = $x + [int](($w - $hint.Length) / 2)
            $sb.Append([VT]::MoveTo($hintX, $y + $h - 2))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append($hint)
        }
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/DashboardScreen.ps1
# DashboardScreen.ps1 - Ultra-complex dashboard to stress-test layout system
# Layout: Main HorizontalSplit -> Left: Project overview, Right: VerticalSplit -> Top: Task metrics, Bottom: GridPanel with action buttons

class DashboardScreen : Screen {
    # Main layout structure
    [HorizontalSplit]$MainLayout
    [VerticalSplit]$RightLayout
    [GridPanel]$ActionGrid
    [HorizontalSplit]$TopRightLayout
    [VerticalSplit]$MetricsLayout
    
    # Left pane components (Project Overview)
    [ListBox]$ProjectList
    [ListBox]$RecentActivity
    [VerticalSplit]$LeftLayout
    
    # Top-right pane components (Task Metrics & Charts)
    [ListBox]$TaskList
    [ListBox]$PriorityBreakdown
    [ListBox]$StatusChart
    [GridPanel]$MetricBoxes
    
    # Bottom-right pane (Action buttons)
    [Button]$NewProjectBtn
    [Button]$NewTaskBtn
    [Button]$ExportBtn
    [Button]$SettingsBtn
    [Button]$RefreshBtn
    [Button]$HelpBtn
    [Button]$ReportsBtn
    [Button]$ArchiveBtn
    
    # Services
    [ProjectService]$ProjectService
    [TaskService]$TaskService
    [EventBus]$EventBus
    
    # Data for complex displays
    hidden [array]$_projectStats
    hidden [array]$_taskMetrics
    hidden [array]$_recentActivities
    hidden [bool]$_isLoading = $false
    hidden [hashtable]$_loadingProgress = @{
        Projects = 0
        Tasks = 0
        Activity = 0
        Metrics = 0
    }
    
    DashboardScreen() : base() {
        $this.Title = "PRAXIS Dashboard"
    }
    
    [void] OnInitialize() {
        Write-Host "Initializing ultra-complex dashboard..."
        
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.TaskService = $global:ServiceContainer.GetService("TaskService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to data loading events for background updates
        $this.SetupEventHandlers()
        
        # Create the incredibly complex nested layout structure
        $this.BuildMasterLayout()
        $this.BuildLeftPane()
        $this.BuildRightPane()
        
        # Show initial loading state
        $this.ShowLoadingState()
        
        # Start background data loading (non-blocking)
        $this.StartBackgroundDataLoad()
        
        Write-Host "Dashboard initialized with maximum complexity!"
    }
    
    [void] BuildMasterLayout() {
        Write-Host "Building master layout structure..."
        
        # Main horizontal split: 40% left (projects), 60% right (tasks & actions)
        $this.MainLayout = [HorizontalSplit]::new()
        $this.MainLayout.SetSplitRatio(40)
        $this.MainLayout.ShowBorder = $false
        $this.MainLayout.Initialize($global:ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Left side: Vertical split for project list + recent activity
        $this.LeftLayout = [VerticalSplit]::new()
        $this.LeftLayout.SetSplitRatio(65)  # 65% project list, 35% recent activity
        $this.LeftLayout.ShowBorder = $false
        $this.LeftLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetLeftPane($this.LeftLayout)
        
        # Right side: Vertical split for task metrics + action buttons
        $this.RightLayout = [VerticalSplit]::new()
        $this.RightLayout.SetSplitRatio(75)  # 75% metrics, 25% buttons
        $this.RightLayout.ShowBorder = $false
        $this.RightLayout.Initialize($global:ServiceContainer)
        $this.MainLayout.SetRightPane($this.RightLayout)
    }
    
    [void] BuildLeftPane() {
        Write-Host "Building left pane with project overview..."
        
        # Top-left: Project List with statistics
        $this.ProjectList = [ListBox]::new()
        $this.ProjectList.Title = "üìä Project Overview"
        $this.ProjectList.ShowBorder = $true
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "‚úÖ" } else { "üöß" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { "üî• OVERDUE" } elseif ($daysLeft -lt 7) { "‚ö†Ô∏è  DUE SOON" } elseif ($daysLeft -lt 30) { "üìÖ $daysLeft days" } else { "üìà $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        $this.ProjectList.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetTopPane($this.ProjectList)
        
        # Bottom-left: Recent Activity Feed
        $this.RecentActivity = [ListBox]::new()
        $this.RecentActivity.Title = "üìà Recent Activity"
        $this.RecentActivity.ShowBorder = $true
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "üÜï" }
                "TaskCompleted" { "‚úÖ" }
                "TaskCreated" { "üìù" }
                "ProjectUpdated" { "üìù" }
                default { "‚ÑπÔ∏è" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
        $this.RecentActivity.Initialize($global:ServiceContainer)
        $this.LeftLayout.SetBottomPane($this.RecentActivity)
    }
    
    [void] BuildRightPane() {
        Write-Host "Building right pane with metrics and controls..."
        
        # Top-right: Another horizontal split for task metrics
        $this.TopRightLayout = [HorizontalSplit]::new()
        $this.TopRightLayout.SetSplitRatio(50)  # Equal split for metrics
        $this.TopRightLayout.ShowBorder = $false
        $this.TopRightLayout.Initialize($global:ServiceContainer)
        
        # Nested vertical split in the left side of top-right
        $this.MetricsLayout = [VerticalSplit]::new()
        $this.MetricsLayout.SetSplitRatio(50)
        $this.MetricsLayout.ShowBorder = $false
        $this.MetricsLayout.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetLeftPane($this.MetricsLayout)
        
        # Task List (top of metrics)
        $this.TaskList = [ListBox]::new()
        $this.TaskList.Title = "üéØ Active Tasks"
        $this.TaskList.ShowBorder = $true
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "üî¥" }
                "Medium" { "üü°" }
                "Low" { "üü¢" }
                default { "‚ö™" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "‚ö°" }
                "Done" { "‚úÖ" }
                "Blocked" { "üö´" }
                default { "üìã" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        $this.TaskList.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetTopPane($this.TaskList)
        
        # Priority Breakdown (bottom of metrics)
        $this.PriorityBreakdown = [ListBox]::new()
        $this.PriorityBreakdown.Title = "üìä Priority Distribution"
        $this.PriorityBreakdown.ShowBorder = $true
        $this.PriorityBreakdown.Initialize($global:ServiceContainer)
        $this.MetricsLayout.SetBottomPane($this.PriorityBreakdown)
        
        # Status Chart (right side of top-right)
        $this.StatusChart = [ListBox]::new()
        $this.StatusChart.Title = "üìà Status Overview"
        $this.StatusChart.ShowBorder = $true
        $this.StatusChart.Initialize($global:ServiceContainer)
        $this.TopRightLayout.SetRightPane($this.StatusChart)
        
        # Set the complex top layout
        $this.RightLayout.SetTopPane($this.TopRightLayout)
        
        # Bottom-right: Action button grid (4x2 = 8 buttons)
        $this.ActionGrid = [GridPanel]::new(4)  # 4 columns
        $this.ActionGrid.ShowBorder = $true
        $this.ActionGrid.CellSpacing = 1
        $this.ActionGrid.Initialize($global:ServiceContainer)
        
        # Create all the action buttons with cool icons and actions
        $this.CreateActionButtons()
        
        $this.RightLayout.SetBottomPane($this.ActionGrid)
    }
    
    [void] CreateActionButtons() {
        Write-Host "Creating interactive action buttons..."
        
        # Capture $this reference for use in button handlers
        $dashboardRef = $this
        
        # Button 1: New Project
        $this.NewProjectBtn = [Button]::new("üÜï New Project")
        $this.NewProjectBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Project button clicked")
            }
            # Create new project dialog
            $dialog = [NewProjectDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewProjectBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewProjectBtn)
        
        # Button 2: New Task
        $this.NewTaskBtn = [Button]::new("üìù New Task")
        $this.NewTaskBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: New Task button clicked")
            }
            # Create new task dialog
            $dialog = [NewTaskDialog]::new()
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }.GetNewClosure()
        $this.NewTaskBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.NewTaskBtn)
        
        # Button 3: Export Data
        $this.ExportBtn = [Button]::new("üì§ Export")
        $this.ExportBtn.OnClick = { 
            Write-Host "Dashboard: Exporting data..."
            # TODO: Implement export functionality
        }.GetNewClosure()
        $this.ExportBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ExportBtn)
        
        # Button 4: Settings
        $this.SettingsBtn = [Button]::new("‚öôÔ∏è  Settings")
        $this.SettingsBtn.OnClick = { 
            Write-Host "Dashboard: Opening settings..."
            # TODO: Switch to settings screen
        }.GetNewClosure()
        $this.SettingsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.SettingsBtn)
        
        # Button 5: Refresh Data
        $this.RefreshBtn = [Button]::new("üîÑ Refresh")
        $this.RefreshBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Refresh button clicked - reloading all data")
            }
            $dashboardRef.ShowLoadingState()
            $dashboardRef.StartBackgroundDataLoad()
        }.GetNewClosure()
        $this.RefreshBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.RefreshBtn)
        
        # Button 6: Help
        $this.HelpBtn = [Button]::new("‚ùì Help")
        $helpBtnRef = $this.HelpBtn
        $this.HelpBtn.OnClick = { 
            if ($global:Logger) {
                $global:Logger.Info("Dashboard: Help button clicked")
            }
            # Change button text to show it was clicked
            $helpBtnRef.Text = "‚úÖ Clicked!"
            $helpBtnRef.Invalidate()
            # TODO: Show help dialog
        }.GetNewClosure()
        $this.HelpBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.HelpBtn)
        
        # Button 7: Reports
        $this.ReportsBtn = [Button]::new("üìä Reports")
        $this.ReportsBtn.OnClick = { 
            Write-Host "Dashboard: Generating reports..."
            # TODO: Generate analytics reports
        }.GetNewClosure()
        $this.ReportsBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ReportsBtn)
        
        # Button 8: Archive
        $this.ArchiveBtn = [Button]::new("üì¶ Archive")
        $this.ArchiveBtn.OnClick = { 
            Write-Host "Dashboard: Managing archives..."
            # TODO: Archive management
        }.GetNewClosure()
        $this.ArchiveBtn.Initialize($global:ServiceContainer)
        $this.ActionGrid.AddChild($this.ArchiveBtn)
    }
    
    [void] LoadAllData() {
        Write-Host "Loading complex dashboard data..."
        
        # Load project data with statistics
        $projects = @()
        if ($this.ProjectService) {
            $allProjects = $this.ProjectService.GetAllProjects()
            $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
        }
        
        # Add some demo projects if empty
        if ($projects.Count -eq 0) {
            $projects = @(
                @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
            )
        }
        
        $this.ProjectList.SetItems($projects)
        
        # Load task data with complex metrics
        $tasks = @()
        if ($this.TaskService) {
            $allTasks = $this.TaskService.GetAllTasks()
            $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
        }
        
        # Add demo tasks if empty
        if ($tasks.Count -eq 0) {
            $tasks = @(
                @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
            )
        }
        
        $this.TaskList.SetItems($tasks)
        
        # Generate priority breakdown with visual charts
        $priorityStats = @(
            "üî¥ High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
            "üü° Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
            "üü¢ Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
            ""
            "Progress Overview:"
            "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë 60% Complete"
            "Active: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count) tasks"
            "Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count) tasks"
        )
        $this.PriorityBreakdown.SetItems($priorityStats)
        
        # Create status chart with ASCII visualization
        $completedTasks = if ($this.TaskService) { 
            @($this.TaskService.GetAllTasks() | Where-Object { $_.Status -eq "Done" }).Count
        } else { 8 }
        
        $totalTasks = $completedTasks + $tasks.Count
        $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
        
        $statusData = @(
            "üìä Project Health Dashboard"
            ""
            "Completion Rate: $completionRate%"
            "[$('‚ñà' * [int]($completionRate/10))$('‚ñë' * (10 - [int]($completionRate/10)))]"
            ""
            "‚úÖ Completed: $completedTasks"
            "‚ö° In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
            "üìã Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
            "üö´ Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            ""
            "üéØ Productivity Score: $(Get-Random -Minimum 75 -Maximum 98)%"
        )
        $this.StatusChart.SetItems($statusData)
        
        # Create realistic recent activity feed
        $this.LoadRecentActivity()
        
        Write-Host "Dashboard data loaded successfully!"
    }
    
    [void] LoadRecentActivity() {
        $activities = @(
            @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
            @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
            @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
            @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
            @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            @{ Type = "TaskCreated"; Message = "Created performance task"; Time = "1 day ago" }
            @{ Type = "ProjectCreated"; Message = "Initialized Testing Framework"; Time = "2 days ago" }
        )
        
        $this.RecentActivity.SetItems($activities)
    }
    
    [void] SetupEventHandlers() {
        # Subscribe to background data loading completion events
        $dashboardRef = $this
        
        $this.EventBus.Subscribe('dashboard.data.projects.loaded', {
            param($sender, $data)
            if ($data.Projects) {
                $dashboardRef.ProjectList.SetItems($data.Projects)
                $dashboardRef._loadingProgress.Projects = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.tasks.loaded', {
            param($sender, $data)
            if ($data.Tasks) {
                $dashboardRef.TaskList.SetItems($data.Tasks)
                $dashboardRef._loadingProgress.Tasks = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.activity.loaded', {
            param($sender, $data)
            if ($data.Activities) {
                $dashboardRef.RecentActivity.SetItems($data.Activities)
                $dashboardRef._loadingProgress.Activity = 100
                $dashboardRef.UpdateLoadingStatus()
            }
        }.GetNewClosure())
        
        $this.EventBus.Subscribe('dashboard.data.metrics.loaded', {
            param($sender, $data)
            if ($data.PriorityStats) {
                $dashboardRef.PriorityBreakdown.SetItems($data.PriorityStats)
            }
            if ($data.StatusData) {
                $dashboardRef.StatusChart.SetItems($data.StatusData)
            }
            $dashboardRef._loadingProgress.Metrics = 100
            $dashboardRef.UpdateLoadingStatus()
        }.GetNewClosure())
    }
    
    [void] ShowLoadingState() {
        # Display loading indicators in each component
        $loadingProjects = @(
            "‚è≥ Loading project data...",
            "   Please wait..."
        )
        $this.ProjectList.SetItems($loadingProjects)
        
        $loadingTasks = @(
            "‚è≥ Loading task list...",
            "   Fetching from database..."
        )
        $this.TaskList.SetItems($loadingTasks)
        
        $loadingActivity = @(
            "‚è≥ Loading recent activity...",
            "   Analyzing events..."
        )
        $this.RecentActivity.SetItems($loadingActivity)
        
        $loadingMetrics = @(
            "‚è≥ Calculating metrics...",
            "   Processing data..."
        )
        $this.PriorityBreakdown.SetItems($loadingMetrics)
        $this.StatusChart.SetItems($loadingMetrics)
    }
    
    [void] StartBackgroundDataLoad() {
        if ($this._isLoading) {
            Write-Host "Data loading already in progress"
            return
        }
        
        $this._isLoading = $true
        $this._loadingProgress = @{
            Projects = 0
            Tasks = 0
            Activity = 0
            Metrics = 0
        }
        
        # Use PowerShell jobs for true background loading
        $projService = $this.ProjectService
        $taskSvc = $this.TaskService
        $evtBus = $this.EventBus
        
        # Load projects in background
        $projectJob = Start-Job -ScriptBlock {
            param($service, $evtBus)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 800
            
            $projects = @()
            if ($service) {
                $allProjects = $service.GetAllProjects()
                $projects = $allProjects | Where-Object { -not $_.Deleted } | Sort-Object DateDue
            }
            
            if ($projects.Count -eq 0) {
                $projects = @(
                    @{ Nickname = "PRAXIS Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(30) }
                    @{ Nickname = "Dashboard System"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(7) }
                    @{ Nickname = "Layout Components"; ClosedDate = [DateTime]::Now; DateDue = [DateTime]::Now.AddDays(-5) }
                    @{ Nickname = "Testing Framework"; ClosedDate = [DateTime]::MinValue; DateDue = [DateTime]::Now.AddDays(45) }
                )
            }
            
            # Process projects
            foreach ($project in $projects) {
                $project.ClosedDate = if ($project.ClosedDate) { $project.ClosedDate } else { [DateTime]::MinValue }
                $project.DateDue = if ($project.DateDue) { $project.DateDue } else { [DateTime]::Now.AddDays(30) }
            }
            
            return $projects
        } -ArgumentList $projService, $evtBus
        
        # Load tasks in background
        $taskJob = Start-Job -ScriptBlock {
            param($service)
            
            # Simulate loading delay
            Start-Sleep -Milliseconds 1200
            
            $tasks = @()
            if ($service) {
                $allTasks = $service.GetAllTasks()
                $tasks = $allTasks | Where-Object { $_.Status -ne "Done" } | Sort-Object Priority, Title
            }
            
            if ($tasks.Count -eq 0) {
                $tasks = @(
                    @{ Title = "Implement HorizontalSplit"; Priority = "High"; Status = "Done"; Progress = 100 }
                    @{ Title = "Create Dashboard Screen"; Priority = "High"; Status = "InProgress"; Progress = 75 }
                    @{ Title = "Add visual styling"; Priority = "Medium"; Status = "InProgress"; Progress = 25 }
                    @{ Title = "Fix layout bugs"; Priority = "High"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Write documentation"; Priority = "Low"; Status = "Pending"; Progress = 0 }
                    @{ Title = "Performance optimization"; Priority = "Medium"; Status = "Blocked"; Progress = 10 }
                )
            }
            
            return $tasks
        } -ArgumentList $taskSvc
        
        # Monitor jobs and publish events when complete
        $monitorJob = Start-Job -ScriptBlock {
            param($projectJob, $taskJob, $evtBus)
            
            # Wait for project job
            $projects = Receive-Job -Job $projectJob -Wait
            $evtBus.Publish('dashboard.data.projects.loaded', @{ Projects = $projects })
            
            # Wait for task job
            $tasks = Receive-Job -Job $taskJob -Wait
            $evtBus.Publish('dashboard.data.tasks.loaded', @{ Tasks = $tasks })
            
            # Generate metrics based on loaded data
            Start-Sleep -Milliseconds 500
            
            $priorityStats = @(
                "üî¥ High Priority: $(@($tasks | Where-Object { $_.Priority -eq 'High' }).Count) tasks"
                "üü° Medium Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Medium' }).Count) tasks"
                "üü¢ Low Priority: $(@($tasks | Where-Object { $_.Priority -eq 'Low' }).Count) tasks"
                ""
                "Progress Overview:"
                "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë 60% Complete"
            )
            
            $completedTasks = @($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $totalTasks = $tasks.Count + $completedTasks
            $completionRate = if ($totalTasks -gt 0) { [int](($completedTasks / $totalTasks) * 100) } else { 0 }
            
            $statusData = @(
                "üìä Project Health Dashboard"
                ""
                "Completion Rate: $completionRate%"
                "[$('‚ñà' * [int]($completionRate/10))$('‚ñë' * (10 - [int]($completionRate/10)))]"
                ""
                "‚úÖ Completed: $completedTasks"
                "‚ö° In Progress: $(@($tasks | Where-Object { $_.Status -eq 'InProgress' }).Count)"
                "üìã Pending: $(@($tasks | Where-Object { $_.Status -eq 'Pending' }).Count)"
                "üö´ Blocked: $(@($tasks | Where-Object { $_.Status -eq 'Blocked' }).Count)"
            )
            
            $evtBus.Publish('dashboard.data.metrics.loaded', @{ 
                PriorityStats = $priorityStats
                StatusData = $statusData 
            })
            
            # Load activity data
            Start-Sleep -Milliseconds 300
            $activities = @(
                @{ Type = "TaskCompleted"; Message = "Completed 'Layout Components'"; Time = "2 min ago" }
                @{ Type = "ProjectCreated"; Message = "Started 'Dashboard System'"; Time = "15 min ago" }
                @{ Type = "TaskCreated"; Message = "Added 'Fix layout bugs'"; Time = "1 hour ago" }
                @{ Type = "ProjectUpdated"; Message = "Updated PRAXIS Framework"; Time = "2 hours ago" }
                @{ Type = "TaskCompleted"; Message = "Finished HorizontalSplit tests"; Time = "4 hours ago" }
            )
            
            $evtBus.Publish('dashboard.data.activity.loaded', @{ Activities = $activities })
            
            # Clean up jobs
            Remove-Job -Job $projectJob -Force
            Remove-Job -Job $taskJob -Force
            
        } -ArgumentList $projectJob, $taskJob, $evtBus
        
        # Set up item renderers that will be used when data loads
        $this.ProjectList.ItemRenderer = {
            param($project)
            $status = if ($project.ClosedDate -ne [DateTime]::MinValue) { "‚úÖ" } else { "üöß" }
            $daysLeft = ($project.DateDue - [DateTime]::Now).Days
            $urgency = if ($daysLeft -lt 0) { "üî• OVERDUE" } elseif ($daysLeft -lt 7) { "‚ö†Ô∏è  DUE SOON" } elseif ($daysLeft -lt 30) { "üìÖ $daysLeft days" } else { "üìà $daysLeft days" }
            return "$status $($project.Nickname) - $urgency"
        }
        
        $this.TaskList.ItemRenderer = {
            param($task)
            $priority = switch ($task.Priority) {
                "High" { "üî¥" }
                "Medium" { "üü°" }
                "Low" { "üü¢" }
                default { "‚ö™" }
            }
            $status = switch ($task.Status) {
                "InProgress" { "‚ö°" }
                "Done" { "‚úÖ" }
                "Blocked" { "üö´" }
                default { "üìã" }
            }
            return "$priority $status $($task.Title) [$($task.Progress)%]"
        }
        
        $this.RecentActivity.ItemRenderer = {
            param($activity)
            $icon = switch ($activity.Type) {
                "ProjectCreated" { "üÜï" }
                "TaskCompleted" { "‚úÖ" }
                "TaskCreated" { "üìù" }
                "ProjectUpdated" { "üìù" }
                default { "‚ÑπÔ∏è" }
            }
            return "$icon $($activity.Message) - $($activity.Time)"
        }
    }
    
    [void] UpdateLoadingStatus() {
        # Check if all data has loaded
        $totalProgress = ($this._loadingProgress.Projects + $this._loadingProgress.Tasks + 
                         $this._loadingProgress.Activity + $this._loadingProgress.Metrics) / 4
        
        if ($totalProgress -eq 100) {
            $this._isLoading = $false
            Write-Host "Dashboard data fully loaded!"
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Set initial focus to ProjectList
        if ($this.ProjectList) {
            $this.ProjectList.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # Update the main layout to fill the entire screen
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Handle dashboard-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::F5) {
                $this.ShowLoadingState()
                $this.StartBackgroundDataLoad()
                Write-Host "Dashboard refresh started!"
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.ShowLoadingState()
                    $this.StartBackgroundDataLoad()
                    Write-Host "Dashboard data reload started!"
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        return $false
    }
    
}


####\Screens/EditProjectDialog.ps1
# EditProjectDialog.ps1 - Dialog for editing existing projects

class EditProjectDialog : BaseDialog {
    [Project]$Project
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$ID1Box
    [TextBox]$ID2Box
    [TextBox]$NoteBox
    [TextBox]$CAAPathBox
    [TextBox]$RequestPathBox
    [TextBox]$T2020PathBox
    [TextBox]$DueDateBox
    
    EditProjectDialog([Project]$project) : base("Edit Project") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 22
    }
    
    [void] InitializeContent() {
        # Create all project input fields with current values
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Text = $this.Project.FullProjectName
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Text = $this.Project.Nickname
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [TextBox]::new()
        $this.ID1Box.Text = $this.Project.ID1
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [TextBox]::new()
        $this.ID2Box.Text = $this.Project.ID2
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NoteBox = [TextBox]::new()
        $this.NoteBox.Text = $this.Project.Note
        $this.NoteBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NoteBox, 5)
        
        $this.CAAPathBox = [TextBox]::new()
        $this.CAAPathBox.Text = $this.Project.CAAPath
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [TextBox]::new()
        $this.RequestPathBox.Text = $this.Project.RequestPath
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [TextBox]::new()
        $this.T2020PathBox.Text = $this.Project.T2020Path
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Text = $this.Project.DateDue.ToString("MM/dd/yyyy")
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action (Save)
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = $dialog.Project.DateDue
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Keep original date if parsing fails
                    }
                }
                
                # Update project properties
                $dialog.Project.FullProjectName = $dialog.NameBox.Text
                $dialog.Project.Nickname = $dialog.NicknameBox.Text
                $dialog.Project.ID1 = $dialog.ID1Box.Text
                $dialog.Project.ID2 = $dialog.ID2Box.Text
                $dialog.Project.Note = $dialog.NoteBox.Text
                $dialog.Project.CAAPath = $dialog.CAAPathBox.Text
                $dialog.Project.RequestPath = $dialog.RequestPathBox.Text
                $dialog.Project.T2020Path = $dialog.T2020PathBox.Text
                $dialog.Project.DateDue = $dueDate
                $dialog.Project.UpdatedAt = [DateTime]::Now
                
                # Save via service
                $projectService = $global:ServiceContainer.GetService("ProjectService")
                if ($projectService) {
                    $projectService.SaveProject($dialog.Project)
                }
                
                # Publish event if EventBus available
                if ($dialog.EventBus) {
                    $dialog.EventBus.Publish([EventNames]::ProjectUpdated, @{ 
                        Project = $dialog.Project 
                    })
                    
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'EditProjectDialog'
                        Action = 'Save'
                        Data = $dialog.Project
                    })
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action (Cancel)
        $this.OnSecondary = {
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'EditProjectDialog'
                    Action = 'Cancel'
                })
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields (same as NewProjectDialog)
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 2)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 2)
        $currentY += 2
        
        $this.NoteBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
    }
}


####\Screens/EditTaskDialog.ps1
# EditTaskDialog.ps1 - Dialog for editing existing tasks

class EditTaskDialog : Screen {
    [Task]$Task
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$StatusList
    [ListBox]$PriorityList
    [TextBox]$ProgressBox
    [Button]$SaveButton
    [Button]$CancelButton
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    EditTaskDialog([Task]$task) : base() {
        $this.Title = "Edit Task"
        $this.Task = $task
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Text = $this.Task.Title
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.TitleBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.TitleBox)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Text = $this.Task.Description
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.DescriptionBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.DescriptionBox)
        
        # Create status list
        $this.StatusList = [ListBox]::new()
        $this.StatusList.Title = "Status"
        $this.StatusList.ShowBorder = $true
        $this.StatusList.Initialize($global:ServiceContainer)
        $this.StatusList.SetItems(@(
            @{Name="Pending"; Value=[TaskStatus]::Pending},
            @{Name="In Progress"; Value=[TaskStatus]::InProgress},
            @{Name="Completed"; Value=[TaskStatus]::Completed},
            @{Name="Cancelled"; Value=[TaskStatus]::Cancelled}
        ))
        $this.StatusList.ItemRenderer = { param($item) $item.Name }
        # Select current status
        for ($i = 0; $i -lt $this.StatusList.Items.Count; $i++) {
            if ($this.StatusList.Items[$i].Value -eq $this.Task.Status) {
                $this.StatusList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.StatusList)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.Initialize($global:ServiceContainer)
        $this.PriorityList.SetItems(@(
            @{Name="Low"; Value=[TaskPriority]::Low},
            @{Name="Medium"; Value=[TaskPriority]::Medium},
            @{Name="High"; Value=[TaskPriority]::High}
        ))
        $this.PriorityList.ItemRenderer = { param($item) $item.Name }
        # Select current priority
        for ($i = 0; $i -lt $this.PriorityList.Items.Count; $i++) {
            if ($this.PriorityList.Items[$i].Value -eq $this.Task.Priority) {
                $this.PriorityList.SelectIndex($i)
                break
            }
        }
        $this.AddChild($this.PriorityList)
        
        # Create progress textbox
        $this.ProgressBox = [TextBox]::new()
        $this.ProgressBox.Text = $this.Task.Progress.ToString()
        $this.ProgressBox.Placeholder = "0-100"
        $this.ProgressBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProgressBox)
        
        # Create buttons
        $this.SaveButton = [Button]::new("Save")
        # Capture dialog reference
        $dialog = $this
        $this.SaveButton.OnClick = {
            if ($dialog.TitleBox.Text.Trim()) {
                $selectedStatus = $dialog.StatusList.GetSelectedItem()
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $progress = 0
                if ([int]::TryParse($dialog.ProgressBox.Text, [ref]$progress)) {
                    $progress = [Math]::Max(0, [Math]::Min(100, $progress))
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave @{
                        Title = $dialog.TitleBox.Text
                        Description = $dialog.DescriptionBox.Text
                        Status = if ($selectedStatus) { $selectedStatus.Value } else { $dialog.Task.Status }
                        Priority = if ($selectedPriority) { $selectedPriority.Value } else { $dialog.Task.Priority }
                        Progress = $progress
                    }
                }
            }
        }.GetNewClosure()
        $this.SaveButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SaveButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                if ($this.OnCancel) {
                    & $this.OnCancel
                }
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $focused = $this.FindFocused()
                if ($focused -eq $this.SaveButton) {
                    & $this.SaveButton.OnClick
                } elseif ($focused -eq $this.CancelButton) {
                    & $this.CancelButton.OnClick
                }
                return $true
            }
        }
        
        # Let base class handle other keys (like Tab navigation)
        return ([Screen]$this).HandleInput($key)
    }
    
    [void] OnBoundsChanged() {
        # Dialog dimensions
        $dialogWidth = 65
        $dialogHeight = 22
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.TitleBox.SetBounds($centerX + 2, $centerY + 2, $dialogWidth - 4, 3)
        $this.DescriptionBox.SetBounds($centerX + 2, $centerY + 6, $dialogWidth - 4, 3)
        
        $this.StatusList.SetBounds($centerX + 2, $centerY + 10, 20, 6)
        $this.PriorityList.SetBounds($centerX + 24, $centerY + 10, 20, 5)
        $this.ProgressBox.SetBounds($centerX + 46, $centerY + 10, 16, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + 17
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 12
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on title box
        $this.TitleBox.Focus()
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " Edit Task "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw labels
            $sb.Append([VT]::MoveTo($x + 2, $y + 1))
            $sb.Append($this.Theme.GetColor("foreground"))
            $sb.Append("Title:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 5))
            $sb.Append("Description:")
            
            $sb.Append([VT]::MoveTo($x + 2, $y + 9))
            $sb.Append("Status:")
            
            $sb.Append([VT]::MoveTo($x + 24, $y + 9))
            $sb.Append("Priority:")
            
            $sb.Append([VT]::MoveTo($x + 46, $y + 9))
            $sb.Append("Progress (%):")
            
            # Draw task info
            $sb.Append([VT]::MoveTo($x + 2, $y + 16))
            $sb.Append($this.Theme.GetColor("disabled"))
            $sb.Append("Created: " + $this.Task.CreatedAt.ToString("yyyy-MM-dd HH:mm"))
            if ($this.Task.DueDate -ne [DateTime]::MinValue) {
                $sb.Append(" | Due: " + $this.Task.DueDate.ToString("yyyy-MM-dd"))
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/EventBusMonitor.ps1
# EventBusMonitor.ps1 - Dialog for monitoring EventBus activity

class EventBusMonitor : Screen {
    [TextBox]$InfoDisplay
    [Button]$RefreshButton
    [Button]$ToggleHistoryButton
    [Button]$ToggleDebugButton
    [Button]$ClearHistoryButton
    [Button]$CloseButton
    [EventBus]$EventBus
    hidden [System.Timers.Timer]$RefreshTimer
    
    EventBusMonitor() : base() {
        $this.Title = "EventBus Monitor"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create info display
        $this.InfoDisplay = [TextBox]::new()
        $this.InfoDisplay.ReadOnly = $true
        $this.InfoDisplay.ShowBorder = $true
        $this.InfoDisplay.Text = "Loading EventBus information..."
        $this.InfoDisplay.Initialize($global:ServiceContainer)
        $this.AddChild($this.InfoDisplay)
        
        # Create buttons
        $this.RefreshButton = [Button]::new("Refresh")
        $this.RefreshButton.OnClick = { $this.RefreshInfo() }
        $this.RefreshButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.RefreshButton)
        
        $this.ToggleHistoryButton = [Button]::new("Toggle History")
        $this.ToggleHistoryButton.OnClick = { $this.ToggleHistory() }
        $this.ToggleHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleHistoryButton)
        
        $this.ToggleDebugButton = [Button]::new("Toggle Debug")
        $this.ToggleDebugButton.OnClick = { $this.ToggleDebug() }
        $this.ToggleDebugButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ToggleDebugButton)
        
        $this.ClearHistoryButton = [Button]::new("Clear History")
        $this.ClearHistoryButton.OnClick = { $this.ClearHistory() }
        $this.ClearHistoryButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ClearHistoryButton)
        
        $this.CloseButton = [Button]::new("Close")
        $this.CloseButton.IsDefault = $true
        $this.CloseButton.OnClick = { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        $this.CloseButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CloseButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        })
        $this.BindKey('r', { $this.RefreshInfo() })
        $this.BindKey('h', { $this.ToggleHistory() })
        $this.BindKey('d', { $this.ToggleDebug() })
        $this.BindKey('c', { $this.ClearHistory() })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        
        # Initial refresh
        $this.RefreshInfo()
        
        # Focus on close button
        $this.CloseButton.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout components
        $padding = 2
        $buttonHeight = 3
        $buttonWidth = 20
        $buttonSpacing = 2
        
        # Info display takes most of the space
        $this.InfoDisplay.SetBounds(
            $this.X + $padding,
            $this.Y + $padding,
            $this.Width - ($padding * 2),
            $this.Height - $buttonHeight - ($padding * 3)
        )
        
        # Buttons at the bottom
        $totalButtonWidth = ($buttonWidth * 5) + ($buttonSpacing * 4)
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - $padding
        
        $this.RefreshButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleHistoryButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, $buttonHeight)
        $this.ToggleDebugButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 2, $buttonY, $buttonWidth, $buttonHeight)
        $this.ClearHistoryButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 3, $buttonY, $buttonWidth, $buttonHeight)
        $this.CloseButton.SetBounds($buttonStartX + ($buttonWidth + $buttonSpacing) * 4, $buttonY, $buttonWidth, $buttonHeight)
    }
    
    [void] RefreshInfo() {
        if (-not $this.EventBus) { return }
        
        $report = $this.EventBus.GetDebugReport()
        
        # Add recent history if enabled
        if ($this.EventBus.EnableHistory) {
            $history = $this.EventBus.GetEventHistory()
            if ($history.Count -gt 0) {
                $report += "`n`nRecent Events:`n"
                $recent = $history | Select-Object -Last 10
                foreach ($event in $recent) {
                    $report += "  $($event.Timestamp.ToString('HH:mm:ss')) - $($event.EventName)`n"
                }
            }
        }
        
        # Add keyboard shortcuts
        $report += "`n`nKeyboard Shortcuts:`n"
        $report += "  [R] Refresh  [H] Toggle History  [D] Toggle Debug`n"
        $report += "  [C] Clear History  [Esc] Close"
        
        $this.InfoDisplay.Text = $report
        $this.InfoDisplay.Invalidate()
    }
    
    [void] ToggleHistory() {
        if ($this.EventBus) {
            $this.EventBus.EnableHistory = -not $this.EventBus.EnableHistory
            $this.RefreshInfo()
        }
    }
    
    [void] ToggleDebug() {
        if ($this.EventBus) {
            $this.EventBus.EnableDebugLogging = -not $this.EventBus.EnableDebugLogging
            $this.RefreshInfo()
        }
    }
    
    [void] ClearHistory() {
        if ($this.EventBus) {
            $this.EventBus.ClearHistory()
            $this.RefreshInfo()
        }
    }
    
    [void] FocusNext() {
        $focusableChildren = @($this.RefreshButton, $this.ToggleHistoryButton, 
                              $this.ToggleDebugButton, $this.ClearHistoryButton, 
                              $this.CloseButton)
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        # Move to next
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ExcelImportScreen.ps1
# ExcelImportScreen.ps1 - Excel import screen using PRAXIS patterns

class ExcelImportScreen : Screen {
    [FastFileTree]$FileTree
    [ListBox]$PreviewList
    [Button]$ImportButton
    [Button]$BackButton
    [ProgressBar]$ImportProgress
    [string]$SelectedFile
    [hashtable]$ImportedData
    [string]$StatusMessage = "Select an Excel file to import (SVI-CAS worksheet)"
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$StatusBarHeight = 1
    hidden [int]$ProgressHeight = 3
    
    ExcelImportScreen() : base() {
        $this.Title = "Excel Import"
    }
    
    [void] OnInitialize() {
        # Create file tree for Excel file selection
        $this.FileTree = [FastFileTree]::new()
        $this.FileTree.ShowBorder = $true
        $this.FileTree.Title = "Select Excel File"
        $this.FileTree.FileExtensions = @('.xlsx', '.xlsm', '.xls')
        $this.FileTree.ShowSize = $true
        $this.AddChild($this.FileTree)
        
        # Start with current directory
        $this.FileTree.LoadDirectory((Get-Location).Path)
        
        # Create preview list
        $this.PreviewList = [ListBox]::new()
        $this.PreviewList.Title = "Import Preview"
        $this.PreviewList.ShowBorder = $true
        $this.AddChild($this.PreviewList)
        
        # Create progress bar (initially hidden)
        $this.ImportProgress = [ProgressBar]::new()
        $this.ImportProgress.IsVisible = $false
        $this.AddChild($this.ImportProgress)
        
        # Create buttons
        $screen = $this  # Capture reference for closures
        
        $this.ImportButton = [Button]::new("Import")
        $this.ImportButton.IsEnabled = $false
        $this.ImportButton.OnClick = { $screen.StartImport() }.GetNewClosure()
        $this.AddChild($this.ImportButton)
        
        $this.BackButton = [Button]::new("Back")
        $this.BackButton.OnClick = { 
            $screen.ServiceContainer.GetService('ScreenManager').PopScreen() 
        }.GetNewClosure()
        $this.AddChild($this.BackButton)
        
        # Set up file selection handler
        $this.FileTree.OnFileSelected = {
            param($filePath)
            if ($filePath -match '\.xls[xm]?$') {
                $screen.SelectedFile = $filePath
                $screen.StatusMessage = "Selected: $(Split-Path $filePath -Leaf)"
                $screen.ImportButton.IsEnabled = $true
                $screen.PreviewFile()
                $screen.Invalidate()
            }
        }.GetNewClosure()
        
        # Key bindings
        $this.AddKeyBinding([ConsoleKey]::Escape, { 
            $this.ServiceContainer.GetService('ScreenManager').PopScreen() 
        })
        $this.AddKeyBinding([ConsoleKey]::I, { 
            if ($this.ImportButton.IsEnabled) { $this.StartImport() } 
        })
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.FileTree) { return }
        
        # Calculate layout
        $fileTreeHeight = [Math]::Floor(($this.Height - $this.StatusBarHeight - $this.ButtonHeight - 2) * 0.5)
        $previewHeight = $this.Height - $fileTreeHeight - $this.StatusBarHeight - $this.ButtonHeight - 2
        
        # Position file tree at top
        $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $fileTreeHeight)
        
        # Position preview list below file tree
        $previewY = $this.Y + $fileTreeHeight + 1
        $this.PreviewList.SetBounds($this.X, $previewY, $this.Width, $previewHeight)
        
        # Position progress bar over preview area when visible
        if ($this.ImportProgress.IsVisible) {
            $progressY = $previewY + [Math]::Floor($previewHeight / 2) - 1
            $this.ImportProgress.SetBounds($this.X + 4, $progressY, $this.Width - 8, $this.ProgressHeight)
        }
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - $this.StatusBarHeight
        $buttonWidth = 12
        $this.ImportButton.SetBounds($this.X + $this.Width - ($buttonWidth * 2) - 4, $buttonY, $buttonWidth, 3)
        $this.BackButton.SetBounds($this.X + $this.Width - $buttonWidth - 2, $buttonY, $buttonWidth, 3)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus on file tree
        if ($this.FileTree) {
            $this.FileTree.Focus()
        }
    }
    
    [void] PreviewFile() {
        if (-not $this.SelectedFile) { return }
        
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("File: $(Split-Path $this.SelectedFile -Leaf)")
        $this.PreviewList.AddItem("Path: $($this.SelectedFile)")
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("This will import data from the 'SVI-CAS' worksheet")
        $this.PreviewList.AddItem("Press 'Import' to continue...")
    }
    
    [void] StartImport() {
        if (-not $this.SelectedFile) { return }
        
        $this.ImportButton.IsEnabled = $false
        $this.ImportProgress.IsVisible = $true
        $this.ImportProgress.Value = 0
        $this.StatusMessage = "Importing from Excel..."
        $this.OnBoundsChanged()  # Reposition progress bar
        $this.Invalidate()
        
        try {
            # Get Excel import service
            $excelService = $this.ServiceContainer.GetService('ExcelImportService')
            if (-not $excelService) {
                throw "Excel import service not available"
            }
            
            # Import data
            $this.ImportProgress.Value = 20
            $this.StatusMessage = "Reading Excel file..."
            $this.Invalidate()
            
            $this.ImportedData = $excelService.ImportFromExcel($this.SelectedFile)
            
            $this.ImportProgress.Value = 50
            $this.StatusMessage = "Processing data..."
            $this.Invalidate()
            
            # Display preview
            $this.ShowImportPreview()
            
            $this.ImportProgress.Value = 80
            $this.StatusMessage = "Creating project..."
            $this.Invalidate()
            
            # Create project from imported data
            $project = $excelService.CreateProjectFromImport($this.ImportedData)
            
            # Save project
            $projectService = $this.ServiceContainer.GetService('ProjectService')
            $projectService.CreateProject($project)
            
            $this.ImportProgress.Value = 100
            $this.StatusMessage = "Import completed successfully! Project ID2: $($project.ID2)"
            $this.Invalidate()
            
            # Show success and return to projects screen after delay
            Start-Sleep -Seconds 2
            $screenManager = $this.ServiceContainer.GetService('ScreenManager')
            $screenManager.PopScreen()
            
            # Fire event to refresh projects list
            $eventBus = $this.ServiceContainer.GetService('EventBus')
            if ($eventBus) {
                $eventBus.Publish([EventNames]::ProjectCreated, $this, @{ Project = $project })
            }
        }
        catch {
            $this.StatusMessage = "Import failed: $_"
            $this.ImportProgress.IsVisible = $false
            $this.ImportButton.IsEnabled = $true
            $this.OnBoundsChanged()  # Reset layout
            $this.Invalidate()
        }
    }
    
    [void] ShowImportPreview() {
        $this.PreviewList.ClearItems()
        $this.PreviewList.AddItem("=== IMPORTED DATA PREVIEW ===")
        $this.PreviewList.AddItem("")
        
        # Core project info
        if ($this.ImportedData.CASCase) {
            $this.PreviewList.AddItem("ID2 (CAS Case#): $($this.ImportedData.CASCase)")
        }
        if ($this.ImportedData.TPName) {
            $this.PreviewList.AddItem("TP Name: $($this.ImportedData.TPName)")
        }
        if ($this.ImportedData.TPNum) {
            $this.PreviewList.AddItem("TP Number: $($this.ImportedData.TPNum)")
        }
        if ($this.ImportedData.AuditType) {
            $this.PreviewList.AddItem("Audit Type: $($this.ImportedData.AuditType)")
        }
        
        # Address
        if ($this.ImportedData.Address -or $this.ImportedData.City) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("ADDRESS:")
            if ($this.ImportedData.Address) {
                $this.PreviewList.AddItem("  $($this.ImportedData.Address)")
            }
            if ($this.ImportedData.City -or $this.ImportedData.Province) {
                $this.PreviewList.AddItem("  $($this.ImportedData.City), $($this.ImportedData.Province) $($this.ImportedData.PostalCode)")
            }
        }
        
        # Auditor info
        if ($this.ImportedData.AuditorName) {
            $this.PreviewList.AddItem("")
            $this.PreviewList.AddItem("AUDITOR:")
            $this.PreviewList.AddItem("  $($this.ImportedData.AuditorName) - $($this.ImportedData.AuditorPhone)")
            if ($this.ImportedData.AuditorTL) {
                $this.PreviewList.AddItem("  Team Lead: $($this.ImportedData.AuditorTL)")
            }
        }
        
        $this.PreviewList.AddItem("")
        $this.PreviewList.AddItem("Press 'Import' to create project...")
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base screen first
        $null = $sb.Append(([Screen]$this).OnRender())
        
        # Render status bar at bottom
        $statusY = $this.Y + $this.Height - 1
        $null = $sb.Append($this.VT.MoveTo($this.X, $statusY))
        $null = $sb.Append($this.ThemeManager.GetCached('StatusBar'))
        $null = $sb.Append(' ' * $this.Width)  # Clear line
        $null = $sb.Append($this.VT.MoveTo($this.X + 2, $statusY))
        $null = $sb.Append($this.StatusMessage)
        $null = $sb.Append($this.VT.Reset)
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/FileBrowserScreen.ps1
# FileBrowserScreen - File browser using FastFileTree component
# Proper PRAXIS architecture implementation

class FileBrowserScreen : Screen {
    [RangerFileTree]$FileTree
    [scriptblock]$FileSelectedCallback = $null  # Callback for file selection
    
    FileBrowserScreen() : base() {
        $this.Title = "File Browser - [h/‚Üê]Back [j/‚Üì]Down [k/‚Üë]Up [l/‚Üí]Enter [.]Hidden"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnInitialize: Starting initialization")
        }
        
        # Create and configure the ranger-style file tree
        $this.FileTree = [RangerFileTree]::new()
        $this.FileTree.CurrentPath = (Get-Location).Path
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen: Created RangerFileTree with path: $($this.FileTree.CurrentPath)")
            $global:Logger.Debug("FileBrowserScreen: FileTree IsFocusable: $($this.FileTree.IsFocusable)")
        }
        
        # Add the file tree as a child component BEFORE initializing
        # This ensures Parent is set correctly
        $this.AddChild($this.FileTree)
        
        # Initialize the FileTree with the service container
        $this.FileTree.Initialize($this.ServiceContainer)
        
        # Set up event handlers
        $screen = $this  # Capture reference for closures
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($screen.FileSelectedCallback) {
                & $screen.FileSelectedCallback $node.FullPath
            } else {
                # Default behavior: open text editor for files
                $screen.OpenFileInEditor($node.FullPath)
            }
        }.GetNewClosure()
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnInitialize: Completed, Children.Count=$($this.Children.Count)")
        }
    }
    
    [void] OnBoundsChanged() {
        # Call base implementation
        ([Screen]$this).OnBoundsChanged()
        
        # Set the file tree to fill the entire screen
        if ($this.FileTree -and $this.Width -gt 0 -and $this.Height -gt 0) {
            $this.FileTree.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
            
            if ($global:Logger) {
                $global:Logger.Debug("FileBrowserScreen.OnBoundsChanged: Set FileTree bounds to ($($this.X),$($this.Y),$($this.Width),$($this.Height))")
            }
        } elseif ($global:Logger) {
            $global:Logger.Warning("FileBrowserScreen.OnBoundsChanged: Invalid bounds - FileTree=$($this.FileTree -ne $null), Width=$($this.Width), Height=$($this.Height)")
        }
    }
    
    [void] OpenFileInEditor([string]$filePath) {
        if (-not $filePath -or -not (Test-Path $filePath)) {
            return
        }
        
        $item = Get-Item $filePath -ErrorAction SilentlyContinue
        if ($item -and -not $item.PSIsContainer) {
            # It's a file, open in text editor
            try {
                $editorType = [type]"TextEditorScreen"
                if ($editorType) {
                    $editor = $editorType::new($filePath)
                    
                    # Get screen manager and push the editor
                    $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Push($editor)
                }
            } catch {
                # TextEditorScreen not available
                if ($global:Logger) {
                    $global:Logger.Info("TextEditor not available for file: $filePath")
                }
            }
        }
    }
    
    # Override OnActivated to ensure FileTree gets focus
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.OnActivated: Screen activated")
            $global:Logger.Debug("  Children.Count = $($this.Children.Count)")
        }
        
        # Use FocusFirst to focus the first focusable child (should be FileTree)
        $this.FocusFirst()
        
        if ($global:Logger) {
            # Check what got focused
            $focusedChild = $this.FindFocusedChild()
            if ($focusedChild) {
                $global:Logger.Debug("  Focused child: $($focusedChild.GetType().Name)")
                $global:Logger.Debug("  Focused child IsFocused: $($focusedChild.IsFocused)")
            } else {
                $global:Logger.Debug("  No focused child found after FocusFirst()!")
                # Try direct focus as fallback
                if ($this.FileTree) {
                    $global:Logger.Debug("  Attempting direct FileTree.Focus()")
                    $this.FileTree.Focus()
                    # Check again
                    $focusedChild = $this.FindFocusedChild()
                    if ($focusedChild) {
                        $global:Logger.Debug("  After direct focus: Found $($focusedChild.GetType().Name)")
                    } else {
                        $global:Logger.Debug("  Still no focused child!")
                    }
                }
            }
        }
    }
    
    # Override HandleInput to debug input routing
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("FileBrowserScreen.HandleInput: Key=$($key.Key) Char='$($key.KeyChar)'")
            $global:Logger.Debug("  FileTree.IsFocused = $($this.FileTree.IsFocused)")
        }
        
        # Call base implementation
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/FilePickerDialog.ps1
# FilePickerDialog.ps1 - File selection dialog using FastFileTree
# Modal dialog for selecting files or directories

class FilePickerDialog : Screen {
    [FastFileTree]$FileTree
    [Button]$SelectButton
    [Button]$CancelButton
    [TextBox]$PathBox
    
    # Configuration
    [string]$InitialPath = ""
    [string]$Filter = "*"
    [bool]$AllowDirectories = $false
    [bool]$AllowFiles = $true
    [bool]$MustExist = $true
    [string]$DialogTitle = "Select File"
    
    # Results
    [string]$SelectedPath = ""
    [bool]$DialogResult = $false
    
    # Events
    [scriptblock]$OnFileSelected = {}
    
    # Layout
    hidden [int]$_treeHeight = 20
    hidden [int]$_dialogWidth = 80
    hidden [int]$_dialogHeight = 25
    
    FilePickerDialog() : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $PWD.Path
    }
    
    FilePickerDialog([string]$initialPath) : base() {
        $this.Title = "File Picker"
        $this.DrawBackground = $true
        $this.InitialPath = $initialPath
    }
    
    [void] OnInitialize() {
        # Calculate dialog position (centered)
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        # Path input box at top
        $this.PathBox = [TextBox]::new()
        $this.PathBox.Placeholder = "Enter path or navigate below"
        $this.PathBox.Text = $this.InitialPath
        $this.PathBox.SetBounds([int]$centerX + 2, [int]$centerY + 2, $this._dialogWidth - 4, 3)
        $this.PathBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.PathBox)
        
        # File tree in the middle
        $this.FileTree = [FastFileTree]::new($this.InitialPath)
        $this.FileTree.Title = $this.DialogTitle
        $this.FileTree.Filter = $this.Filter
        $this.FileTree.ShowBorder = $true
        $this.FileTree.SetBounds([int]$centerX + 2, [int]$centerY + 6, $this._dialogWidth - 4, $this._treeHeight)
        $this.FileTree.Initialize($global:ServiceContainer)
        
        # Set up events
        $dialogRef = $this
        $this.FileTree.OnSelectionChanged = {
            $selected = $dialogRef.FileTree.GetSelectedNode()
            if ($selected) {
                $dialogRef.PathBox.Text = $selected.FullPath
                $dialogRef.UpdateButtonStates()
            }
        }.GetNewClosure()
        
        $this.FileTree.OnFileSelected = {
            param($node)
            if ($dialogRef.IsValidSelection($node)) {
                $dialogRef.SelectedPath = $node.FullPath
                $dialogRef.DialogResult = $true
                $dialogRef.Active = $false
            }
        }.GetNewClosure()
        
        $this.AddChild($this.FileTree)
        
        # Buttons at bottom
        $buttonY = [int]$centerY + 6 + $this._treeHeight + 1
        $buttonWidth = 15
        $buttonSpacing = 2
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = [int]$centerX + (($this._dialogWidth - $totalButtonWidth) / 2)
        
        $this.SelectButton = [Button]::new("Select")
        $this.SelectButton.IsDefault = $true
        $this.SelectButton.SetBounds($buttonStartX, $buttonY, $buttonWidth, 3)
        $this.SelectButton.OnClick = {
            $dialogRef.SelectFile()
        }.GetNewClosure()
        $this.SelectButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.SelectButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.SetBounds($buttonStartX + $buttonWidth + $buttonSpacing, $buttonY, $buttonWidth, 3)
        $this.CancelButton.OnClick = {
            $dialogRef.SelectedPath = ""
            $dialogRef.DialogResult = $false
            $dialogRef.Active = $false
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.FileTree.Focus()
        
        # Update button states
        $this.UpdateButtonStates()
    }
    
    [void] UpdateButtonStates() {
        $selected = $this.FileTree.GetSelectedNode()
        $isValid = $this.IsValidSelection($selected)
        
        # Enable/disable select button based on selection
        # Note: Button doesn't have Enabled property in current implementation
        # This is a placeholder for when we add that functionality
        
        # Update button text to reflect what will happen
        if ($selected) {
            if ($selected.IsDirectory) {
                $this.SelectButton.Text = if ($this.AllowDirectories) { "Select Folder" } else { "Enter" }
            } else {
                $this.SelectButton.Text = "Select File"
            }
        } else {
            $this.SelectButton.Text = "Select"
        }
        $this.SelectButton.Invalidate()
    }
    
    [bool] IsValidSelection([FileSystemNode]$node) {
        if ($node -eq $null) {
            return $false
        }
        
        # Check if selection type is allowed
        if ($node.IsDirectory -and -not $this.AllowDirectories) {
            return $false
        }
        
        if (-not $node.IsDirectory -and -not $this.AllowFiles) {
            return $false
        }
        
        # Check if file exists (if required)
        if ($this.MustExist -and -not (Test-Path $node.FullPath)) {
            return $false
        }
        
        return $true
    }
    
    [void] SelectFile() {
        $selected = $this.FileTree.GetSelectedNode()
        
        if ($selected -and $this.IsValidSelection($selected)) {
            $this.SelectedPath = $selected.FullPath
            $this.DialogResult = $true
            
            # Fire event
            if ($this.OnFileSelected) {
                & $this.OnFileSelected $selected.FullPath
            }
            
            $this.Active = $false
        } elseif ($selected -and $selected.IsDirectory -and -not $this.AllowDirectories) {
            # Navigate into directory instead of selecting it
            $this.FileTree.NavigateToSelected()
            $this.PathBox.Text = $this.FileTree.RootPath
        } else {
            # Try to use path from text box
            $pathFromBox = $this.PathBox.Text.Trim()
            if ($pathFromBox -and (Test-Path $pathFromBox)) {
                $this.SelectedPath = $pathFromBox
                $this.DialogResult = $true
                
                if ($this.OnFileSelected) {
                    & $this.OnFileSelected $pathFromBox
                }
                
                $this.Active = $false
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Dialog is positioned manually in OnInitialize
        # This could be enhanced to support resizing
    }
    
    [string] OnRender() {
        # Draw dark overlay background
        $sb = Get-PooledStringBuilder 2048
        
        # Semi-transparent background overlay
        $overlayColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.overlay") } else { "`e[48;2;0;0;0m" }
        
        for ($y = 0; $y -lt [Console]::WindowHeight; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayColor)
            $sb.Append([StringCache]::GetSpaces([Console]::WindowWidth))
        }
        
        # Dialog border
        $centerX = ([Console]::WindowWidth - $this._dialogWidth) / 2
        $centerY = ([Console]::WindowHeight - $this._dialogHeight) / 2
        
        $borderColor = if ($this.Theme) { $this.Theme.GetColor("dialog.border") } else { "`e[38;2;100;100;100m" }
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("dialog.background") } else { "`e[48;2;40;40;40m" }
        
        # Draw dialog background
        for ($y = 0; $y -lt $this._dialogHeight; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this._dialogWidth))
        }
        
        # Draw border
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY))
        $sb.Append($borderColor)
        $sb.Append([VT]::TL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::TR())
        
        for ($y = 1; $y -lt $this._dialogHeight - 1; $y++) {
            $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
            
            $sb.Append([VT]::MoveTo([int]$centerX + $this._dialogWidth - 1, [int]$centerY + $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::V())
        }
        
        $sb.Append([VT]::MoveTo([int]$centerX, [int]$centerY + $this._dialogHeight - 1))
        $sb.Append($borderColor)
        $sb.Append([VT]::BL() + ([VT]::H() * ($this._dialogWidth - 2)) + [VT]::BR())
        
        # Title
        if ($this.DialogTitle) {
            $sb.Append([VT]::MoveTo([int]$centerX + 2, [int]$centerY))
            $titleColor = if ($this.Theme) { $this.Theme.GetColor("dialog.title") } else { "`e[38;2;255;255;255m" }
            $sb.Append($titleColor)
            $sb.Append(" $($this.DialogTitle) ")
        }
        
        $sb.Append([VT]::Reset())
        
        # Render children on top
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Escape) {
                $this.SelectedPath = ""
                $this.DialogResult = $false
                $this.Active = $false
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                if ($this.PathBox.IsFocused) {
                    # Try to navigate to path in text box
                    $path = $this.PathBox.Text.Trim()
                    if ($path -and (Test-Path $path)) {
                        if (Test-Path $path -PathType Container) {
                            $this.FileTree.LoadDirectory($path)
                            $this.FileTree.Focus()
                        } else {
                            # It's a file, select it
                            $this.SelectedPath = $path
                            $this.DialogResult = $true
                            $this.Active = $false
                        }
                    }
                    return $true
                }
                # Let other controls handle Enter
                break
            }
            ([System.ConsoleKey]::Tab) {
                # Cycle focus between controls
                if ($this.PathBox.IsFocused) {
                    $this.FileTree.Focus()
                } elseif ($this.FileTree.IsFocused) {
                    $this.SelectButton.Focus()
                } elseif ($this.SelectButton.IsFocused) {
                    $this.CancelButton.Focus()
                } else {
                    $this.PathBox.Focus()
                }
                return $true
            }
        }
        
        # Let base Screen handle other input
        return ([Screen]$this).HandleInput($key)
    }
}


####\Screens/MainScreen.ps1
# MainScreen.ps1 - Main screen with tab container

class MainScreen : Screen {
    [TabContainer]$TabContainer
    [CommandPalette]$CommandPalette
    [EventBus]$EventBus
    hidden [string]$TabChangedSubscription
    
    MainScreen() : base() {
        $this.Title = "PRAXIS"
    }
    
    [void] OnInitialize() {
        # Get EventBus
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to tab change events  
        if ($this.EventBus) {
            # Use string directly to avoid potential class loading issues
            $this.TabChangedSubscription = $this.EventBus.Subscribe('navigation.tabChanged', {
                param($sender, $eventData)
                if ($eventData.TabIndex -ne $null -and $this.TabContainer) {
                    $this.TabContainer.ActivateTab($eventData.TabIndex)
                    $this.RequestRender()
                }
            }.GetNewClosure())
        }
        
        # Create tab container
        $this.TabContainer = [TabContainer]::new()
        $this.TabContainer.Initialize($global:ServiceContainer)
        $this.AddChild($this.TabContainer)
        
        # Add real screens as tabs
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Adding tabs to TabContainer")
        }
        
        $projectsScreen = [ProjectsScreen]::new()
        $this.TabContainer.AddTab("Projects", $projectsScreen)
        
        $taskScreen = [TaskScreen]::new()
        $this.TabContainer.AddTab("Tasks", $taskScreen)
        
        $timeEntryScreen = [TimeEntryScreen]::new()
        $this.TabContainer.AddTab("Time", $timeEntryScreen)
        
        $fileBrowserScreen = [FileBrowserScreen]::new()
        $this.TabContainer.AddTab("Files", $fileBrowserScreen)
        
        $textEditorScreen = [TextEditorScreenNew]::new()
        $this.TabContainer.AddTab("Editor", $textEditorScreen)
        
        $commandLibraryScreen = [CommandLibraryScreen]::new()
        $this.TabContainer.AddTab("Commands", $commandLibraryScreen)
        
        $macroFactoryScreen = [VisualMacroFactoryScreen]::new()
        $this.TabContainer.AddTab("Macro Factory", $macroFactoryScreen)
        
        $settingsScreen = [SettingsScreen]::new()
        $this.TabContainer.AddTab("Settings", $settingsScreen)
        
        if ($global:Logger) {
            $global:Logger.Debug("MainScreen: Added $($this.TabContainer.Tabs.Count) tabs")
        }
        
        # Create command palette (overlay)
        $this.CommandPalette = [CommandPalette]::new()
        $this.CommandPalette.Initialize($global:ServiceContainer)
        $this.AddChild($this.CommandPalette)
        
        # Ensure bounds are set if we already have them
        if ($this.Width -gt 0 -and $this.Height -gt 0) {
            $this.OnBoundsChanged()
        }
        
        # Key bindings now handled by GetShortcutBindings() method
    }
    
    
    [void] OnBoundsChanged() {
        if ($this.TabContainer) {
            $this.TabContainer.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
        if ($this.CommandPalette) {
            # Command palette uses full screen for centering
            $this.CommandPalette.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] OnActivated() {
        # Call base to trigger render
        ([Screen]$this).OnActivated()
        
        # Make sure bounds are set
        if ($this.Width -eq 0 -or $this.Height -eq 0) {
            $this.SetBounds(0, 0, [Console]::WindowWidth, [Console]::WindowHeight)
        }
        
        # Activate the active tab's content screen
        if ($this.TabContainer) {
            $activeTab = $this.TabContainer.GetActiveTab()
            if ($activeTab -and $activeTab.Content) {
                # Screens are not focusable - call OnActivated instead
                if ($activeTab.Content -is [Screen]) {
                    $activeTab.Content.OnActivated()
                } else {
                    $activeTab.Content.Focus()
                }
            }
        }
    }
    
    # Override to handle global shortcuts
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Global shortcuts
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Q) {
                # Only handle Q for quit if Ctrl is pressed
                # This prevents conflict with child screens using 'q'
                if ($keyInfo.Modifiers -eq [System.ConsoleModifiers]::Control) {
                    $this.Active = $false  # Exit the main loop
                    return $true
                }
            }
            # Remove Escape handling - let child screens handle it
        }
        
        # Let TabContainer handle tab switching shortcuts (numbers, Ctrl+Tab, etc)
        # This is safe because TabContainer is not focusable, so it won't be in the normal input chain
        if ($this.TabContainer) {
            return $this.TabContainer.HandleInput($keyInfo)
        }
        
        return $false
    }
}


####\Screens/NewProjectDialog.ps1
# NewProjectDialog.ps1 - Dialog for creating new projects (refactored to use BaseDialog)

class NewProjectDialog : BaseDialog {
    [TextBox]$NameBox
    [TextBox]$NicknameBox
    [TextBox]$ID1Box
    [TextBox]$ID2Box
    [TextBox]$NotesBox
    [TextBox]$CAAPathBox
    [TextBox]$RequestPathBox
    [TextBox]$T2020PathBox
    [TextBox]$DueDateBox
    
    NewProjectDialog() : base("New Project") {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 22
    }
    
    [void] InitializeContent() {
        # Create all project input fields
        $this.NameBox = [TextBox]::new()
        $this.NameBox.Placeholder = "Enter full project name..."
        $this.AddContentControl($this.NameBox, 1)
        
        $this.NicknameBox = [TextBox]::new()
        $this.NicknameBox.Placeholder = "Enter project nickname..."
        $this.AddContentControl($this.NicknameBox, 2)
        
        $this.ID1Box = [TextBox]::new()
        $this.ID1Box.Placeholder = "Enter ID1..."
        $this.AddContentControl($this.ID1Box, 3)
        
        $this.ID2Box = [TextBox]::new()
        $this.ID2Box.Placeholder = "Enter ID2..."
        $this.AddContentControl($this.ID2Box, 4)
        
        $this.NotesBox = [TextBox]::new()
        $this.NotesBox.Placeholder = "Enter notes..."
        $this.AddContentControl($this.NotesBox, 5)
        
        $this.CAAPathBox = [TextBox]::new()
        $this.CAAPathBox.Placeholder = "Enter CAA path..."
        $this.AddContentControl($this.CAAPathBox, 6)
        
        $this.RequestPathBox = [TextBox]::new()
        $this.RequestPathBox.Placeholder = "Enter request path..."
        $this.AddContentControl($this.RequestPathBox, 7)
        
        $this.T2020PathBox = [TextBox]::new()
        $this.T2020PathBox.Placeholder = "Enter T2020 path..."
        $this.AddContentControl($this.T2020PathBox, 8)
        
        $this.DueDateBox = [TextBox]::new()
        $this.DueDateBox.Placeholder = "Enter due date (MM/DD/YYYY)..."
        $this.DueDateBox.Text = ([DateTime]::Now.AddDays(42)).ToString("MM/dd/yyyy")
        $this.AddContentControl($this.DueDateBox, 9)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.NameBox.Text.Trim()) {
                # Parse due date
                $dueDate = [DateTime]::Now.AddDays(42)
                if ($dialog.DueDateBox.Text.Trim()) {
                    try {
                        $dueDate = [DateTime]::Parse($dialog.DueDateBox.Text)
                    } catch {
                        # Use default if parsing fails
                        $dueDate = [DateTime]::Now.AddDays(42)
                    }
                }
                
                $projectData = @{
                    FullProjectName = $dialog.NameBox.Text
                    Nickname = if ($dialog.NicknameBox.Text.Trim()) { $dialog.NicknameBox.Text } else { $dialog.NameBox.Text }
                    ID1 = $dialog.ID1Box.Text
                    ID2 = $dialog.ID2Box.Text
                    Note = $dialog.NotesBox.Text
                    CAAPath = $dialog.CAAPathBox.Text
                    RequestPath = $dialog.RequestPathBox.Text
                    T2020Path = $dialog.T2020PathBox.Text
                    DateDue = $dueDate
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create project via service
                    $projectService = $global:ServiceContainer.GetService("ProjectService")
                    if ($projectService) {
                        # Create project with full data
                        $newProject = $projectService.AddProject($projectData.FullProjectName, $projectData.Nickname)
                        
                        # Update additional properties
                        $newProject.ID1 = $projectData.ID1
                        $newProject.ID2 = $projectData.ID2
                        $newProject.Note = $projectData.Note
                        $newProject.CAAPath = $projectData.CAAPath
                        $newProject.RequestPath = $projectData.RequestPath
                        $newProject.T2020Path = $projectData.T2020Path
                        $newProject.DateDue = $projectData.DateDue
                        
                        # Save the updated project
                        $projectService.SaveProject($newProject)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::ProjectCreated, @{ 
                            Project = $newProject 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewProjectDialog'
                        Action = 'Create'
                        Data = $projectData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $projectData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewProjectDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for all project fields
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        $currentY = $dialogY + 2
        
        $this.NameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.NicknameBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        # Split ID fields horizontally
        $halfWidth = [int](($controlWidth - 2) / 2)
        $this.ID1Box.SetBounds($dialogX + $this.DialogPadding, $currentY, $halfWidth, 2)
        $this.ID2Box.SetBounds($dialogX + $this.DialogPadding + $halfWidth + 2, $currentY, $halfWidth, 2)
        $currentY += 2
        
        $this.NotesBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.CAAPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.RequestPathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.T2020PathBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
        $currentY += 2
        
        $this.DueDateBox.SetBounds($dialogX + $this.DialogPadding, $currentY, $controlWidth, 2)
    }
}


####\Screens/NewTaskDialog.ps1
# NewTaskDialog.ps1 - Dialog for creating new tasks (refactored to use BaseDialog)

class NewTaskDialog : BaseDialog {
    [TextBox]$TitleBox
    [TextBox]$DescriptionBox
    [ListBox]$PriorityList
    
    NewTaskDialog() : base("New Task", 50, 18) {
        $this.PrimaryButtonText = "Create"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create title textbox
        $this.TitleBox = [TextBox]::new()
        $this.TitleBox.Placeholder = "Enter task title..."
        $this.AddContentControl($this.TitleBox, 1)
        
        # Create description textbox
        $this.DescriptionBox = [TextBox]::new()
        $this.DescriptionBox.Placeholder = "Enter description (optional)..."
        $this.AddContentControl($this.DescriptionBox, 2)
        
        # Create priority list
        $this.PriorityList = [ListBox]::new()
        $this.PriorityList.Title = "Priority"
        $this.PriorityList.ShowBorder = $true
        $this.PriorityList.SetItems(@("Low", "Medium", "High"))
        $this.PriorityList.SelectIndex(1)  # Default to Medium
        $this.AddContentControl($this.PriorityList, 3)
        
        # Set up primary action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.TitleBox.Text.Trim()) {
                # Get selected priority
                $selectedPriority = $dialog.PriorityList.GetSelectedItem()
                $priority = switch ($selectedPriority) {
                    "Low" { [TaskPriority]::Low }
                    "High" { [TaskPriority]::High }
                    default { [TaskPriority]::Medium }
                }
                
                $taskData = @{
                    Title = $dialog.TitleBox.Text.Trim()
                    Description = $dialog.DescriptionBox.Text.Trim()
                    Priority = $priority
                }
                
                # Use EventBus if available
                if ($dialog.EventBus) {
                    # Create task via service
                    $taskService = $global:ServiceContainer.GetService("TaskService")
                    if ($taskService) {
                        $newTask = $taskService.CreateTask($taskData)
                        
                        # Publish event
                        $dialog.EventBus.Publish([EventNames]::TaskCreated, @{ 
                            Task = $newTask 
                        })
                    }
                    
                    # Publish dialog closed event
                    $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                        Dialog = 'NewTaskDialog'
                        Action = 'Create'
                        Data = $taskData
                    })
                } else {
                    # Legacy callback support
                    if ($dialog.OnCreate -and $dialog.OnCreate.GetType().Name -eq 'ScriptBlock') {
                        & $dialog.OnCreate $taskData
                    }
                }
            }
        }.GetNewClosure()
        
        # Set up secondary action
        $this.OnSecondary = {
            # Publish dialog closed event
            if ($dialog.EventBus) {
                $dialog.EventBus.Publish([EventNames]::DialogClosed, @{ 
                    Dialog = 'NewTaskDialog'
                    Action = 'Cancel'
                })
            } else {
                # Legacy callback support
                if ($dialog.OnCancel -and $dialog.OnCancel.GetType().Name -eq 'ScriptBlock') {
                    & $dialog.OnCancel
                }
            }
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom positioning for task dialog controls
        $controlWidth = $this.DialogWidth - ($this.DialogPadding * 2)
        
        # Title box
        $this.TitleBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 2, 
            $controlWidth, 
            3
        )
        
        # Description box
        $this.DescriptionBox.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 6, 
            $controlWidth, 
            3
        )
        
        # Priority list
        $this.PriorityList.SetBounds(
            $dialogX + $this.DialogPadding, 
            $dialogY + 10, 
            $controlWidth, 
            5
        )
    }
}


####\Screens/NumberInputDialog.ps1
# NumberInputDialog.ps1 - Simple dialog for numeric input

class NumberInputDialog : Screen {
    [string]$Prompt
    [decimal]$DefaultValue
    [decimal]$MinValue
    [decimal]$MaxValue
    [bool]$AllowDecimals
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    NumberInputDialog([string]$prompt) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = 0
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    NumberInputDialog([string]$prompt, [decimal]$defaultValue) : base() {
        $this.Title = "Number Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.MinValue = [decimal]::MinValue
        $this.MaxValue = [decimal]::MaxValue
        $this.AllowDecimals = $true
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue.ToString()
        $this.InputBox.Placeholder = if ($this.AllowDecimals) { "0.00" } else { "0" }
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            $value = [decimal]0
            if ([decimal]::TryParse($dialog.InputBox.Text, [ref]$value)) {
                # Validate range
                if ($value -lt $dialog.MinValue) {
                    $value = $dialog.MinValue
                } elseif ($value -gt $dialog.MaxValue) {
                    $value = $dialog.MaxValue
                }
                
                # Round if no decimals allowed
                if (-not $dialog.AllowDecimals) {
                    $value = [Math]::Round($value)
                }
                
                if ($dialog.OnSubmit) {
                    & $dialog.OnSubmit $value
                }
            }
            # If parse fails, don't submit
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box
        $this.InputBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 11 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
            
            # Draw constraints if any
            $constraintY = $y + 2 + $promptLines.Count + 4
            $sb.Append([VT]::MoveTo($x + 2, $constraintY))
            $sb.Append($this.Theme.GetColor("disabled"))
            $constraints = @()
            if ($this.MinValue -ne [decimal]::MinValue) {
                $constraints += "Min: $($this.MinValue)"
            }
            if ($this.MaxValue -ne [decimal]::MaxValue) {
                $constraints += "Max: $($this.MaxValue)"
            }
            if (-not $this.AllowDecimals) {
                $constraints += "Integers only"
            }
            if ($constraints.Count -gt 0) {
                $sb.Append($constraints -join " | ")
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/ProjectDetailScreen.ps1
# ProjectDetailScreen - Detailed project view with time tracking information
# Redesigned to follow PRAXIS architecture standards using DockPanel and components

class ProjectDetailScreen : Screen {
    [Project]$Project = $null
    [System.Collections.ArrayList]$TimeEntries
    
    # PRAXIS Architecture Components
    [DockPanel]$MainLayout
    [ListBox]$ProjectInfoPanel
    [DataGrid]$WeeklySummaryGrid  
    [DataGrid]$TimeEntriesGrid
    
    # Services
    [ThemeManager]$ThemeManager
    [EventBus]$EventBus
    
    ProjectDetailScreen() : base() {
        $this.Title = "Project Details"
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    ProjectDetailScreen([Project]$project) : base() {
        $this.Title = "Project Details - $($project.Nickname)"
        $this.Project = $project
        $this.TimeEntries = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services through proper dependency injection
        $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Load time entries if we have a project
        if ($this.Project) {
            $this.LoadTimeEntries()
        }
        
        # Create main DockPanel layout
        $this.MainLayout = [DockPanel]::new()
        $this.MainLayout.Initialize($this.ServiceContainer)
        $this.AddChild($this.MainLayout)
        
        # Create project info panel (top section)
        $this.CreateProjectInfoPanel()
        
        # Create weekly summary grid (middle section)
        $this.CreateWeeklySummaryGrid()
        
        # Create time entries grid (fill remaining space)
        $this.CreateTimeEntriesGrid()
        
        # Update title
        if ($this.Project) {
            $this.Title = "Project Details - $($this.Project.Nickname)"
        }
        
        # Populate data
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
    }
    
    [void] CreateProjectInfoPanel() {
        $this.ProjectInfoPanel = [ListBox]::new()
        $this.ProjectInfoPanel.Initialize($this.ServiceContainer)
        $this.ProjectInfoPanel.ShowBorder = $true
        $this.ProjectInfoPanel.Title = "Project Information"
        $this.ProjectInfoPanel.IsFocusable = $false  # Read-only display
        
        # Dock to top with a specific height
        $this.MainLayout.SetChildDock($this.ProjectInfoPanel, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.ProjectInfoPanel, 35)  # Allow plenty of space for all fields
        $this.MainLayout.AddChild($this.ProjectInfoPanel)
    }
    
    [void] CreateWeeklySummaryGrid() {
        $this.WeeklySummaryGrid = [DataGrid]::new()
        $this.WeeklySummaryGrid.Initialize($this.ServiceContainer)
        $this.WeeklySummaryGrid.ShowHeader = $true
        $this.WeeklySummaryGrid.ShowBorder = $true
        $this.WeeklySummaryGrid.Title = "Weekly Hours Summary"
        $this.WeeklySummaryGrid.IsFocusable = $false  # Read-only display
        
        # Set up columns for weekly summary
        $columns = @(
            @{ Name = "WeekOf"; Header = "Week of"; Width = 12; Getter = { param($item) $item.WeekOf } }
            @{ Name = "Monday"; Header = "Mon"; Width = 7; Getter = { param($item) $item.Monday.ToString("F1") } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 7; Getter = { param($item) $item.Tuesday.ToString("F1") } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 7; Getter = { param($item) $item.Wednesday.ToString("F1") } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 7; Getter = { param($item) $item.Thursday.ToString("F1") } }
            @{ Name = "Friday"; Header = "Fri"; Width = 7; Getter = { param($item) $item.Friday.ToString("F1") } }
            @{ Name = "Total"; Header = "Total"; Width = 8; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.WeeklySummaryGrid.SetColumns($columns)
        
        # Dock to top (after project info) with a specific height
        $this.MainLayout.SetChildDock($this.WeeklySummaryGrid, [DockPosition]::Top)
        $this.MainLayout.SetChildHeight($this.WeeklySummaryGrid, 8)  # Weekly summary doesn't need much space
        $this.MainLayout.AddChild($this.WeeklySummaryGrid)
    }
    
    [void] CreateTimeEntriesGrid() {
        $this.TimeEntriesGrid = [DataGrid]::new()
        $this.TimeEntriesGrid.Initialize($this.ServiceContainer)
        $this.TimeEntriesGrid.ShowHeader = $true
        $this.TimeEntriesGrid.ShowBorder = $true
        $this.TimeEntriesGrid.Title = "Time Entries - [A]dd [E]dit [D]elete [R]efresh"
        $this.TimeEntriesGrid.IsFocusable = $true  # Interactive
        
        # Set up columns for time entries
        $screen = $this  # Capture reference for closure
        $columns = @(
            @{ Name = "Date"; Header = "Date"; Width = 12; Getter = { param($item) $screen.FormatDate($item.Date) }.GetNewClosure() }
            @{ Name = "Hours"; Header = "Hours"; Width = 8; Getter = { param($item) [double]::Parse($item.Total).ToString("F2") } }
            @{ Name = "Description"; Header = "Description"; Width = 40; Getter = { param($item) if ($item.Description) { $item.Description } else { "No description" } } }
        )
        $this.TimeEntriesGrid.SetColumns($columns)
        
        # Set up selection changed handler
        $screen = $this  # Capture reference for closure
        $this.TimeEntriesGrid.OnSelectionChanged = {
            # Handle selection changes if needed
        }.GetNewClosure()
        
        # Fill remaining space
        $this.MainLayout.SetChildDock($this.TimeEntriesGrid, [DockPosition]::Fill)
        $this.MainLayout.AddChild($this.TimeEntriesGrid)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus the time entries grid which is the main interactive component
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [void] OnBoundsChanged() {
        # DockPanel handles layout automatically
        if ($this.MainLayout) {
            $this.MainLayout.SetBounds($this.X, $this.Y, $this.Width, $this.Height)
        }
    }
    
    [void] LoadTimeEntries() {
        # This would load time entries from the tracker system
        # For now, creating sample data based on the tracker.txt structure
        $this.TimeEntries.Clear()
        
        # Sample time entries (in production, this would load from actual data)
        $sampleEntries = @(
            @{
                Date = "20241201"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = "8.00"
                TueHours = ""
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "8.00"
                Description = "Initial project setup and requirements gathering"
            },
            @{
                Date = "20241202"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = "6.50"
                WedHours = ""
                ThuHours = ""
                FriHours = ""
                Total = "6.50"
                Description = "Development work on core features"
            },
            @{
                Date = "20241203"
                Nickname = $this.Project.Nickname
                ID1 = "CLIENT1"
                ID2 = "V000123456S"
                MonHours = ""
                TueHours = ""
                WedHours = "7.25"
                ThuHours = ""
                FriHours = ""
                Total = "7.25"
                Description = "Testing and bug fixes"
            }
        )
        
        foreach ($entry in $sampleEntries) {
            $this.TimeEntries.Add([PSCustomObject]$entry) | Out-Null
        }
    }
    
    [void] PopulateProjectInfo() {
        if (-not $this.Project -or -not $this.ProjectInfoPanel) {
            return
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: Project type = $($this.Project.GetType().Name)")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: AuditType = '$($this.Project.AuditType)'")
            $global:Logger.Debug("ProjectDetailScreen.PopulateProjectInfo: ClientID = '$($this.Project.ClientID)'")
        }
        
        $infoItems = [System.Collections.ArrayList]::new()
        
        # === BASIC PROJECT INFORMATION ===
        $infoItems.Add("=== PROJECT IDENTIFICATION ===") | Out-Null
        $infoItems.Add("Nickname: $($this.Project.Nickname)") | Out-Null
        $infoItems.Add("Full Name: $($this.Project.FullProjectName)") | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectDetailScreen: Showing $($infoItems.Count) items so far")
        }
        
        # IDs
        if ($this.Project.ID1) {
            $infoItems.Add("Client Code (ID1): $($this.Project.ID1)") | Out-Null
        }
        if ($this.Project.ID2) {
            $infoItems.Add("CAS Case# (ID2): $($this.Project.ID2)") | Out-Null
        }
        if ($this.Project.ClientID) {
            $infoItems.Add("Client ID: $($this.Project.ClientID)") | Out-Null
        }
        
        # === AUDIT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDIT INFORMATION ===") | Out-Null
        if ($this.Project.AuditType) {
            $infoItems.Add("Audit Type: $($this.Project.AuditType)") | Out-Null
        }
        if ($this.Project.AuditProgram) {
            $infoItems.Add("Audit Program: $($this.Project.AuditProgram)") | Out-Null
        }
        if ($this.Project.AuditCase) {
            $infoItems.Add("Audit Case: $($this.Project.AuditCase)") | Out-Null
        }
        
        # Audit Dates
        if ($this.Project.AuditStartDate -and $this.Project.AuditStartDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Start Date: $($this.FormatDate($this.Project.AuditStartDate))") | Out-Null
        }
        if ($this.Project.AuditPeriodFrom -and $this.Project.AuditPeriodFrom -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period From: $($this.FormatDate($this.Project.AuditPeriodFrom))") | Out-Null
        }
        if ($this.Project.AuditPeriodTo -and $this.Project.AuditPeriodTo -ne [DateTime]::MinValue) {
            $infoItems.Add("Audit Period To: $($this.FormatDate($this.Project.AuditPeriodTo))") | Out-Null
        }
        
        # Additional Audit Periods
        $hasAuditPeriods = $false
        for ($i = 1; $i -le 5; $i++) {
            $startProp = "AuditPeriod${i}Start"
            $endProp = "AuditPeriod${i}End"
            if ($this.Project.$startProp -ne [DateTime]::MinValue -or $this.Project.$endProp -ne [DateTime]::MinValue) {
                if (-not $hasAuditPeriods) {
                    $infoItems.Add("Additional Audit Periods:") | Out-Null
                    $hasAuditPeriods = $true
                }
                $start = if ($this.Project.$startProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$startProp) } else { "N/A" }
                $end = if ($this.Project.$endProp -ne [DateTime]::MinValue) { $this.FormatDate($this.Project.$endProp) } else { "N/A" }
                $infoItems.Add("  Period ${i}: $start to $end") | Out-Null
            }
        }
        
        # === PROJECT DATES ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== PROJECT DATES ===") | Out-Null
        if ($this.Project.RequestDate -and $this.Project.RequestDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Data Requested: $($this.FormatDate($this.Project.RequestDate))") | Out-Null
        }
        if ($this.Project.DateAssigned) {
            $infoItems.Add("Date Assigned: $($this.FormatDate($this.Project.DateAssigned))") | Out-Null
        }
        if ($this.Project.BFDate -and $this.Project.BFDate -ne [DateTime]::MinValue) {
            $infoItems.Add("BF Date: $($this.FormatDate($this.Project.BFDate))") | Out-Null
        }
        if ($this.Project.DateDue) {
            $infoItems.Add("Due Date: $($this.FormatDate($this.Project.DateDue))") | Out-Null
        }
        if ($this.Project.ClosedDate -and $this.Project.ClosedDate -ne [DateTime]::MinValue) {
            $infoItems.Add("Completed: $($this.FormatDate($this.Project.ClosedDate))") | Out-Null
        }
        
        # === CLIENT LOCATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CLIENT LOCATION ===") | Out-Null
        if ($this.Project.Address) {
            $infoItems.Add("Address: $($this.Project.Address)") | Out-Null
        }
        if ($this.Project.City -or $this.Project.Province -or $this.Project.PostalCode) {
            $location = @()
            if ($this.Project.City) { $location += $this.Project.City }
            if ($this.Project.Province) { $location += $this.Project.Province }
            if ($this.Project.PostalCode) { $location += $this.Project.PostalCode }
            $infoItems.Add("City/Prov/Postal: $($location -join ', ')") | Out-Null
        }
        if ($this.Project.Country) {
            $infoItems.Add("Country: $($this.Project.Country)") | Out-Null
        }
        if ($this.Project.ShipToAddress) {
            $infoItems.Add("Ship To Address: $($this.Project.ShipToAddress)") | Out-Null
        }
        
        # === AUDITOR INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== AUDITOR INFORMATION ===") | Out-Null
        if ($this.Project.AuditorName) {
            $infoItems.Add("Auditor: $($this.Project.AuditorName)") | Out-Null
        }
        if ($this.Project.AuditorPhone) {
            $infoItems.Add("Auditor Phone: $($this.Project.AuditorPhone)") | Out-Null
        }
        if ($this.Project.AuditorTL) {
            $infoItems.Add("Team Lead: $($this.Project.AuditorTL)") | Out-Null
        }
        if ($this.Project.AuditorTLPhone) {
            $infoItems.Add("Team Lead Phone: $($this.Project.AuditorTLPhone)") | Out-Null
        }
        
        # === CONTACT INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== CONTACT INFORMATION ===") | Out-Null
        # Contact 1
        if ($this.Project.Contact1Name) {
            $infoItems.Add("Contact 1:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact1Name)") | Out-Null
            if ($this.Project.Contact1Title) { $infoItems.Add("  Title: $($this.Project.Contact1Title)") | Out-Null }
            if ($this.Project.Contact1Phone) { 
                $phone = $this.Project.Contact1Phone
                if ($this.Project.Contact1Ext) { $phone += " x$($this.Project.Contact1Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact1Address) { $infoItems.Add("  Address: $($this.Project.Contact1Address)") | Out-Null }
        }
        # Contact 2
        if ($this.Project.Contact2Name) {
            $infoItems.Add("Contact 2:") | Out-Null
            $infoItems.Add("  Name: $($this.Project.Contact2Name)") | Out-Null
            if ($this.Project.Contact2Title) { $infoItems.Add("  Title: $($this.Project.Contact2Title)") | Out-Null }
            if ($this.Project.Contact2Phone) { 
                $phone = $this.Project.Contact2Phone
                if ($this.Project.Contact2Ext) { $phone += " x$($this.Project.Contact2Ext)" }
                $infoItems.Add("  Phone: $phone") | Out-Null 
            }
            if ($this.Project.Contact2Address) { $infoItems.Add("  Address: $($this.Project.Contact2Address)") | Out-Null }
        }
        
        # === SYSTEM INFORMATION ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== SYSTEM INFORMATION ===") | Out-Null
        if ($this.Project.AccountingSoftware1) {
            $sw1 = $this.Project.AccountingSoftware1
            if ($this.Project.AccountingSoftware1Other) { $sw1 += " ($($this.Project.AccountingSoftware1Other))" }
            if ($this.Project.AccountingSoftware1Type) { $sw1 += " - $($this.Project.AccountingSoftware1Type)" }
            $infoItems.Add("Accounting Software 1: $sw1") | Out-Null
        }
        if ($this.Project.AccountingSoftware2) {
            $sw2 = $this.Project.AccountingSoftware2
            if ($this.Project.AccountingSoftware2Other) { $sw2 += " ($($this.Project.AccountingSoftware2Other))" }
            if ($this.Project.AccountingSoftware2Type) { $sw2 += " - $($this.Project.AccountingSoftware2Type)" }
            $infoItems.Add("Accounting Software 2: $sw2") | Out-Null
        }
        
        # === STATUS AND TOTALS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== STATUS AND HOURS ===") | Out-Null
        $status = if ($this.Project.Status) { $this.Project.Status } else { "Active" }
        $infoItems.Add("Status: $status") | Out-Null
        
        # Show cumulative hours from Excel import
        if ($this.Project.CumulativeHrs -gt 0) {
            $infoItems.Add("Cumulative Hours (from import): $($this.Project.CumulativeHrs.ToString('F2'))") | Out-Null
        }
        
        $totalHours = $this.CalculateTotalHours()
        $infoItems.Add("Total Hours (tracked): $($totalHours.ToString('F2'))") | Out-Null
        
        # === FILE PATHS ===
        $infoItems.Add("") | Out-Null
        $infoItems.Add("=== FILE PATHS ===") | Out-Null
        if ($this.Project.CAAPath) {
            $infoItems.Add("CAA Path: $($this.Project.CAAPath)") | Out-Null
        }
        if ($this.Project.RequestPath) {
            $infoItems.Add("Request Path: $($this.Project.RequestPath)") | Out-Null
        }
        if ($this.Project.T2020Path) {
            $infoItems.Add("T2020 Path: $($this.Project.T2020Path)") | Out-Null
        }
        
        # === ADDITIONAL INFORMATION ===
        if ($this.Project.FXInfo -or $this.Project.Comments -or $this.Project.Note) {
            $infoItems.Add("") | Out-Null
            $infoItems.Add("=== ADDITIONAL INFORMATION ===") | Out-Null
            
            if ($this.Project.FXInfo) {
                $infoItems.Add("FX Info: $($this.Project.FXInfo)") | Out-Null
            }
            if ($this.Project.Comments) {
                $infoItems.Add("Comments: $($this.Project.Comments)") | Out-Null
            }
            if ($this.Project.Note) {
                $infoItems.Add("Notes: $($this.Project.Note)") | Out-Null
            }
        }
        
        $this.ProjectInfoPanel.SetItems($infoItems)
    }
    
    [void] PopulateWeeklySummary() {
        if (-not $this.WeeklySummaryGrid) {
            return
        }
        
        $weeklyData = $this.CalculateWeeklySummary()
        $this.WeeklySummaryGrid.SetItems($weeklyData)
    }
    
    [void] PopulateTimeEntries() {
        if (-not $this.TimeEntriesGrid) {
            return
        }
        
        # Sort entries by date (most recent first)
        $sortedEntries = $this.TimeEntries | Sort-Object { [DateTime]::ParseExact($_.Date, "yyyyMMdd", $null) } -Descending
        $this.TimeEntriesGrid.SetItems($sortedEntries)
    }
    
    [string] FormatDate([string]$dateStr) {
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Not set"
        }
        
        try {
            if ($dateStr.Length -eq 8) {
                # YYYYMMDD format
                $date = [DateTime]::ParseExact($dateStr, "yyyyMMdd", $null)
                return $date.ToString("MM/dd/yyyy")
            } else {
                # Try parsing as DateTime
                $date = [DateTime]::Parse($dateStr)
                return $date.ToString("MM/dd/yyyy")
            }
        } catch {
            return $dateStr
        }
    }
    
    [string] FormatDate([DateTime]$date) {
        if ($date -eq [DateTime]::MinValue) {
            return "Not set"
        }
        return $date.ToString("MM/dd/yyyy")
    }
    
    [double] CalculateTotalHours() {
        $total = 0.0
        foreach ($entry in $this.TimeEntries) {
            try {
                $hours = [double]::Parse($entry.Total)
                $total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        return $total
    }
    
    [System.Collections.ArrayList] CalculateWeeklySummary() {
        $weeks = @{}
        
        foreach ($entry in $this.TimeEntries) {
            try {
                $entryDate = [DateTime]::ParseExact($entry.Date, "yyyyMMdd", $null)
                $monday = $entryDate.AddDays(-([int]$entryDate.DayOfWeek - 1))
                $weekKey = $monday.ToString("MM/dd/yyyy")
                
                if (-not $weeks.ContainsKey($weekKey)) {
                    $weeks[$weekKey] = @{
                        WeekOf = $weekKey
                        Monday = 0.0
                        Tuesday = 0.0
                        Wednesday = 0.0
                        Thursday = 0.0
                        Friday = 0.0
                        Total = 0.0
                    }
                }
                
                # Add hours to appropriate day
                $dayOfWeek = $entryDate.DayOfWeek.ToString()
                $hours = [double]::Parse($entry.Total)
                
                switch ($dayOfWeek) {
                    "Monday" { $weeks[$weekKey].Monday += $hours }
                    "Tuesday" { $weeks[$weekKey].Tuesday += $hours }
                    "Wednesday" { $weeks[$weekKey].Wednesday += $hours }
                    "Thursday" { $weeks[$weekKey].Thursday += $hours }
                    "Friday" { $weeks[$weekKey].Friday += $hours }
                }
                
                $weeks[$weekKey].Total += $hours
            } catch {
                # Skip invalid entries
            }
        }
        
        $weeklyData = [System.Collections.ArrayList]::new()
        foreach ($week in $weeks.Values) {
            $weeklyData.Add([PSCustomObject]$week) | Out-Null
        }
        
        # Sort by week date (most recent first) and ensure ArrayList type
        $sortedData = $weeklyData | Sort-Object { [DateTime]::Parse($_.WeekOf) } -Descending
        $result = [System.Collections.ArrayList]::new()
        foreach ($item in $sortedData) {
            $result.Add($item) | Out-Null
        }
        return $result
    }
    
    [void] AddTimeEntry() {
        if (-not $this.Project) {
            return
        }
        
        # Create time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project)
        
        # Set up callback for when entry is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Add to local time entries collection
            $screen.TimeEntries.Add($timeEntryData) | Out-Null
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] EditSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.EditTimeEntry($selected)
    }
    
    [void] EditTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $this.Project -or -not $timeEntry) {
            return
        }
        
        # Create edit time entry dialog
        $dialog = [TimeEntryDialog]::new($this.Project, $timeEntry)
        
        # Set up callback for when entry is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($timeEntryData)
            
            # Find and replace in local collection
            for ($i = 0; $i -lt $screen.TimeEntries.Count; $i++) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries[$i] = $timeEntryData
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] DeleteSelectedTimeEntry() {
        $selected = $this.TimeEntriesGrid.GetSelectedItem()
        if (-not $selected) {
            return
        }
        
        $this.DeleteTimeEntry($selected)
    }
    
    [void] DeleteTimeEntry([PSCustomObject]$timeEntry) {
        if (-not $timeEntry) {
            return
        }
        
        # Show confirmation dialog
        $message = "Delete time entry for $($this.FormatDate($timeEntry.Date)) ($($timeEntry.Total) hours)?"
        $dialog = [ConfirmationDialog]::new($message)
        
        $screen = $this  # Capture reference for closure
        $dialog.OnConfirm = {
            # Remove from local collection
            for ($i = $screen.TimeEntries.Count - 1; $i -ge 0; $i--) {
                if ($screen.TimeEntries[$i].Date -eq $timeEntry.Date -and
                    $screen.TimeEntries[$i].Description -eq $timeEntry.Description) {
                    $screen.TimeEntries.RemoveAt($i)
                    break
                }
            }
            
            # Refresh all displays
            $screen.PopulateTimeEntries()
            $screen.PopulateWeeklySummary()
            $screen.PopulateProjectInfo()  # Update total hours
            
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            # Close dialog using proper service access
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # Show dialog using proper service access
        $screenManager = $this.ServiceContainer.GetService("ScreenManager")
        if ($screenManager) {
            $screenManager.Push($dialog)
        }
    }
    
    [void] RefreshData() {
        # Reload time entries
        $this.LoadTimeEntries()
        
        # Refresh all displays
        $this.PopulateProjectInfo()
        $this.PopulateWeeklySummary()
        $this.PopulateTimeEntries()
        
        # Focus the time entries grid
        if ($this.TimeEntriesGrid) {
            $this.TimeEntriesGrid.Focus()
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle character shortcuts
        if ($keyInfo.KeyChar) {
            switch ($keyInfo.KeyChar) {
                'r' {
                    # Refresh/reload data
                    $this.RefreshData()
                    return $true
                }
                'a' {
                    # Add new time entry
                    $this.AddTimeEntry()
                    return $true
                }
                'e' {
                    # Edit selected time entry
                    $this.EditSelectedTimeEntry()
                    return $true
                }
                'd' {
                    # Delete selected time entry
                    $this.DeleteSelectedTimeEntry()
                    return $true
                }
            }
        }
        
        # Handle ESC to go back
        if ($keyInfo.Key -eq [System.ConsoleKey]::Escape) {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
            return $true
        }
        
        # Let base class handle other input (like tab switching and navigation)
        return $false
    }
}


####\Screens/ProjectsScreen.ps1
# ProjectsScreen.ps1 - Project management screen using DataGrid component

class ProjectsScreen : Screen {
    [DataGrid]$ProjectGrid
    # Buttons removed - using keyboard shortcuts only
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout - buttons removed
    
    ProjectsScreen() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to project created events with explicit closure
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe('project.created', {
                param($sender, $eventData)
                $screen.RefreshProjects()
                # Select the new project if provided
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe('command.executed', {
                param($sender, $eventData)
                if ($eventData.Target -eq 'ProjectsScreen') {
                    switch ($eventData.Command) {
                        'EditProject' { $screen.EditProject() }
                        'DeleteProject' { $screen.DeleteProject() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe('project.updated', {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe('project.deleted', {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create DataGrid with columns
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Projects"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowGridLines = $true
        
        # Define columns with proper formatting
        $columns = @(
            @{
                Name = "Status"
                Header = "Sts"
                Width = 3
                Getter = {
                    param($project)
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[‚úì]" } else { "[ ]" }
                }
            },
            @{
                Name = "FullProjectName"
                Header = "Project Name"
                Width = 0  # Flexible width - will auto-size
            },
            @{
                Name = "ID1"
                Header = "ID1"
                Width = 5
            },
            @{
                Name = "ID2"
                Header = "ID2"
                Width = 9
            },
            @{
                Name = "DateAssigned"
                Header = "Assigned"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            },
            @{
                Name = "DateDue"
                Header = "Due"
                Width = 10
                Formatter = {
                    param($value)
                    if ($value -is [DateTime] -and $value -ne [DateTime]::MinValue) {
                        $value.ToString("yyyy-MM-dd")
                    } else {
                        "          "
                    }
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Buttons removed - use keyboard shortcuts instead
        # n - New Project
        # e - Edit Project
        # d - Delete Project
        # Enter - View Details
        
        # Load projects
        $this.LoadProjects()
        
        # Register screen-specific shortcuts with ShortcutManager
        $this.RegisterShortcuts()
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if (-not $shortcutManager) { 
            if ($global:Logger) {
                $global:Logger.Warning("ProjectsScreen: ShortcutManager not found in ServiceContainer")
            }
            return 
        }
        
        # Register screen-specific shortcuts
        $screen = $this
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.new"
            Name = "New Project"
            Description = "Create a new project"
            KeyChar = 'n'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.NewProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.edit"
            Name = "Edit Project"
            Description = "Edit the selected project"
            KeyChar = 'e'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.EditProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.delete"
            Name = "Delete Project"
            Description = "Delete the selected project"
            KeyChar = 'd'
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.DeleteProject() }.GetNewClosure()
        })
        
        $shortcutManager.RegisterShortcut(@{
            Id = "projects.refresh"
            Name = "Refresh"
            Description = "Refresh the project list"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "ProjectsScreen"
            Priority = 50
            Action = { $screen.LoadProjects() }.GetNewClosure()
        })
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.RegisterShortcuts: Registered shortcuts for 'n', 'e', 'd', etc.")
        }
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnActivated: Screen activated with new focus system")
        }
        
        # Add defensive null checks
        try {
            # Focus the grid if it has items, otherwise the New button
            if ($global:Logger) {
                $projectGridNull = ($this.ProjectGrid -eq $null)
                $itemsCount = if ($this.ProjectGrid -and $this.ProjectGrid.Items) { $this.ProjectGrid.Items.Count } else { 0 }
                $global:Logger.Debug("ProjectsScreen focus check: ProjectGrid=$(!$projectGridNull), Items=$itemsCount")
            }
            
            if ($this.ProjectGrid) {
                $this.ProjectGrid.Focus()
            } else {
                if ($global:Logger) {
                    $global:Logger.Debug("ProjectsScreen: No focusable element found!")
                }
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("ProjectsScreen.OnActivated: Error during focus - $_")
                $global:Logger.Error("Stack trace: $($_.ScriptStackTrace)")
            }
        }
    }
    
    [void] OnBoundsChanged() {
        # Debug
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Grid takes full space now that buttons are removed
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $this.Height
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date
        $sorted = $activeProjects | Sort-Object DateDue
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        # Reload projects and update display
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.NewProject() called")
        }
        # Create new project dialog
        $dialog = [NewProjectDialog]::new()
        
        # EventBus will handle project creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                
                # Create nickname from name
                # Create project using single-parameter constructor
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                # Select the new project
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit project dialog
        $dialog = [EditProjectDialog]::new($selected)
        # Capture references
        $screen = $this
        $project = $selected
        $dialog.OnPrimary = {
            # Get the data from the dialog
            $projectData = @{
                FullProjectName = $dialog.NameBox.Text
                Nickname = $dialog.NicknameBox.Text
                Note = $dialog.NoteBox.Text
                DateDue = $dialog.DueDateBox.Text
            }
            
            # Update the project
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            # Save through service
            $screen.ProjectService.UpdateProject($project)
            
            # Publish project updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                # Fallback if EventBus not available
                $screen.LoadProjects()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Show confirmation dialog
            $message = "Are you sure you want to delete project '$($selected.FullProjectName)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            $dialog.OnConfirm = {
                # Delete the project
                $screen.ProjectService.DeleteProject($projectId)
                
                # Publish project deleted event
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    # Fallback if EventBus not available
                    $screen.LoadProjects()
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.ViewProjectDetails() called")
        }
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            # Create and show project detail screen
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    # Using parent-delegated focus model - Tab handled by ScreenManager/Container
    
    # Override HandleScreenInput instead of HandleInput to work with base Screen class
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("ProjectsScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Screen-specific shortcuts - only called as fallback by base Screen class
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'N' key pressed, calling NewProject")
                    }
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    if ($global:Logger) {
                        $global:Logger.Debug("ProjectsScreen: 'E' key pressed, calling EditProject")
                    }
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'V' -or $key.KeyChar -eq 'v')) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadProjects()
                    return $true
                }
            }
            ([System.ConsoleKey]::Q) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'Q' -or $key.KeyChar -eq 'q')) {
                    $this.Active = $false
                    return $true
                }
            }
        }
        
        # If no shortcut matched, return false (let base Screen handle it)
        return $false
    }
}


####\Screens/ProjectsScreenEnhanced.ps1
# ProjectsScreenEnhanced.ps1 - Project management screen with DataGrid

class ProjectsScreenEnhanced : Screen {
    [DataGrid]$ProjectGrid
    [Button]$NewButton
    [Button]$ViewButton
    [Button]$EditButton
    [Button]$DeleteButton
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    ProjectsScreenEnhanced() : base() {
        $this.Title = "Projects"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ProjectService = $global:ServiceContainer.GetService("ProjectService")
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to project created events
            $this.EventSubscriptions['ProjectCreated'] = $this.EventBus.Subscribe([EventNames]::ProjectCreated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
                if ($eventData.Project) {
                    for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                        if ($screen.ProjectGrid.Items[$i].Id -eq $eventData.Project.Id) {
                            $screen.ProjectGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to project updated events
            $this.EventSubscriptions['ProjectUpdated'] = $this.EventBus.Subscribe([EventNames]::ProjectUpdated, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
            
            # Subscribe to project deleted events
            $this.EventSubscriptions['ProjectDeleted'] = $this.EventBus.Subscribe([EventNames]::ProjectDeleted, {
                param($sender, $eventData)
                $screen.RefreshProjects()
            }.GetNewClosure())
        }
        
        # Create project data grid
        $this.ProjectGrid = [DataGrid]::new()
        $this.ProjectGrid.Title = "Project List"
        $this.ProjectGrid.ShowBorder = $true
        $this.ProjectGrid.ShowHeader = $true
        $this.ProjectGrid.IsFocusable = $true
        
        # Define columns
        $columns = @(
            @{ 
                Name = "Status"
                Header = "Status"
                Width = 8
                Getter = { 
                    param($project) 
                    if ($project.ClosedDate -ne [DateTime]::MinValue) { "[Done]" } 
                    else { "[Open]" }
                }
            }
            @{ 
                Name = "Name"
                Header = "Project Name"
                Width = 25
                Getter = { param($project) $project.Nickname }
            }
            @{ 
                Name = "ID1"
                Header = "ID1"
                Width = 10
                Getter = { 
                    param($project) 
                    if ($project.ID1) { $project.ID1 } else { "-" }
                }
            }
            @{ 
                Name = "ID2"
                Header = "ID2"
                Width = 15
                Getter = { 
                    param($project) 
                    if ($project.ID2) { $project.ID2 } else { "-" }
                }
            }
            @{ 
                Name = "Client"
                Header = "Client"
                Width = 20
                Getter = { 
                    param($project) 
                    if ($project.Name) { $project.Name } else { "-" }
                }
            }
            @{ 
                Name = "Assigned"
                Header = "Assigned"
                Width = 10
                Getter = { 
                    param($project) 
                    $project.DateAssigned.ToString("MM/dd/yy")
                }
            }
        )
        
        $this.ProjectGrid.SetColumns($columns)
        $this.ProjectGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.ProjectGrid)
        
        # Create buttons
        $screen = $this
        
        $this.NewButton = [Button]::new("New Project")
        $this.NewButton.IsDefault = $true
        $this.NewButton.OnClick = { $screen.NewProject() }.GetNewClosure()
        $this.NewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.NewButton)
        
        $this.ViewButton = [Button]::new("View Details")
        $this.ViewButton.OnClick = { $screen.ViewProjectDetails() }.GetNewClosure()
        $this.ViewButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.ViewButton)
        
        $this.EditButton = [Button]::new("Edit")
        $this.EditButton.OnClick = { $screen.EditProject() }.GetNewClosure()
        $this.EditButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.EditButton)
        
        $this.DeleteButton = [Button]::new("Delete")
        $this.DeleteButton.OnClick = { $screen.DeleteProject() }.GetNewClosure()
        $this.DeleteButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.DeleteButton)
        
        # Load projects
        $this.LoadProjects()
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Focus the grid if it has items, otherwise the New button
        if ($this.ProjectGrid -and $this.ProjectGrid.Items.Count -gt 0) {
            $this.ProjectGrid.Focus()
        } elseif ($this.NewButton) {
            $this.NewButton.Focus()
        }
    }
    
    [void] OnDeactivated() {
        ([Screen]$this).OnDeactivated()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes most space, buttons at bottom
        $buttonAreaHeight = $this.ButtonHeight + 2
        $gridHeight = $this.Height - $buttonAreaHeight
        
        # Project grid
        $this.ProjectGrid.SetBounds(
            $this.X, 
            $this.Y,
            $this.Width,
            $gridHeight
        )
        
        # Buttons (horizontally arranged)
        $maxButtonWidth = 20
        $totalButtonWidth = ($maxButtonWidth * 4) + ($this.ButtonSpacing * 3)
        
        if ($this.Width -gt $totalButtonWidth) {
            $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $this.X
            $buttonWidth = [int](($this.Width - ($this.ButtonSpacing * 3)) / 4)
        }
        
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        
        $this.NewButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.ViewButton.SetBounds(
            $buttonStartX + $buttonWidth + $this.ButtonSpacing,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.EditButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 2,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
        
        $this.DeleteButton.SetBounds(
            $buttonStartX + ($buttonWidth + $this.ButtonSpacing) * 3,
            $buttonY,
            $buttonWidth,
            $this.ButtonHeight
        )
    }
    
    [void] LoadProjects() {
        $projects = $this.ProjectService.GetAllProjects()
        
        # Filter out deleted projects
        $activeProjects = $projects | Where-Object { -not $_.Deleted }
        
        # Sort by due date (most urgent first), then by assigned date
        $sorted = $activeProjects | Sort-Object -Property @(
            @{Expression = { $_.ClosedDate -eq [DateTime]::MinValue }; Descending = $true}
            @{Expression = { ($_.DateDue - [DateTime]::Now).Days }}
            @{Expression = { $_.DateAssigned }}
        )
        
        $this.ProjectGrid.SetItems($sorted)
    }
    
    [void] RefreshProjects() {
        $this.LoadProjects()
        $this.Invalidate()
    }
    
    [void] NewProject() {
        $dialog = [NewProjectDialog]::new()
        
        if (-not $this.EventBus) {
            $screen = $this
            $dialog.OnCreate = {
                param($projectData)
                $project = $screen.ProjectService.AddProject($projectData.Name)
                $screen.LoadProjects()
                
                for ($i = 0; $i -lt $screen.ProjectGrid.Items.Count; $i++) {
                    if ($screen.ProjectGrid.Items[$i].Id -eq $project.Id) {
                        $screen.ProjectGrid.SelectIndex($i)
                        break
                    }
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $dialog = [EditProjectDialog]::new($selected)
        $screen = $this
        $project = $selected
        
        $dialog.OnSave = {
            param($projectData)
            
            $project.FullProjectName = $projectData.FullProjectName
            $project.Nickname = $projectData.Nickname
            $project.Note = $projectData.Note
            $project.DateDue = $projectData.DateDue
            
            $screen.ProjectService.UpdateProject($project)
            
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::ProjectUpdated, @{ Project = $project })
            } else {
                $screen.LoadProjects()
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }.GetNewClosure()
        
        $dialog.OnCancel = {
            if ($global:ScreenManager) {
                $global:ScreenManager.Pop()
            }
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteProject() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $message = "Are you sure you want to delete project '$($selected.Nickname)'?"
            $dialog = [ConfirmationDialog]::new($message)
            
            $screen = $this
            $projectId = $selected.Id
            
            $dialog.OnConfirm = {
                $screen.ProjectService.DeleteProject($projectId)
                
                if ($screen.EventBus) {
                    $screen.EventBus.Publish([EventNames]::ProjectDeleted, @{ ProjectId = $projectId })
                } else {
                    $screen.LoadProjects()
                }
                
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }.GetNewClosure()
            
            $dialog.OnCancel = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.Pop()
                }
            }
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
            }
        }
    }
    
    [void] ViewProjectDetails() {
        $selected = $this.ProjectGrid.GetSelectedItem()
        if ($selected) {
            $detailScreen = [ProjectDetailScreen]::new($selected)
            
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($detailScreen)
            }
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) {
                $this.ViewProjectDetails()
                return $true
            }
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers) {
                    $this.NewProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers) {
                    $this.EditProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers) {
                    $this.DeleteProject()
                    return $true
                }
            }
            ([System.ConsoleKey]::V) {
                if (-not $key.Modifiers) {
                    $this.ViewProjectDetails()
                    return $true
                }
            }
        }
        
        return $false
    }
}


####\Screens/QuickTimeEntryDialog.ps1
# QuickTimeEntryDialog - Simple time entry dialog

class QuickTimeEntryDialog : BaseDialog {
    [DateTime]$WeekFriday
    [TextBox]$ProjectBox
    [TextBox]$MondayBox
    [TextBox]$TuesdayBox
    [TextBox]$WednesdayBox
    [TextBox]$ThursdayBox
    [TextBox]$FridayBox
    [TimeTrackingService]$TimeService
    [scriptblock]$OnSave
    
    QuickTimeEntryDialog([DateTime]$weekFriday) : base("Quick Time Entry") {
        $this.WeekFriday = $weekFriday
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
        $this.DialogWidth = 70
        $this.DialogHeight = 30
    }
    
    [void] InitializeContent() {
        # Create all input fields
        $this.ProjectBox = [TextBox]::new()
        $this.ProjectBox.Placeholder = "Enter Project ID2 or Non-Project Code..."
        $this.AddContentControl($this.ProjectBox, 1)
        
        $this.MondayBox = [TextBox]::new()
        $this.MondayBox.Placeholder = "Monday Hours"
        $this.AddContentControl($this.MondayBox, 2)
        
        $this.TuesdayBox = [TextBox]::new()
        $this.TuesdayBox.Placeholder = "Tuesday Hours"
        $this.AddContentControl($this.TuesdayBox, 3)
        
        $this.WednesdayBox = [TextBox]::new()
        $this.WednesdayBox.Placeholder = "Wednesday Hours"
        $this.AddContentControl($this.WednesdayBox, 4)
        
        $this.ThursdayBox = [TextBox]::new()
        $this.ThursdayBox.Placeholder = "Thursday Hours"
        $this.AddContentControl($this.ThursdayBox, 5)
        
        $this.FridayBox = [TextBox]::new()
        $this.FridayBox.Placeholder = "Friday Hours"
        $this.AddContentControl($this.FridayBox, 6)
        
        # Set up save action
        $dialog = $this
        $this.OnPrimary = {
            if ($dialog.ProjectBox.Text.Trim()) {
                $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
                
                $data = @{
                    WeekEndingFriday = $dialog.WeekFriday.ToString("yyyyMMdd")
                    ID2 = $dialog.ProjectBox.Text.Trim().ToUpper()
                    Monday = $dialog.ParseHours($dialog.MondayBox.Text)
                    Tuesday = $dialog.ParseHours($dialog.TuesdayBox.Text)
                    Wednesday = $dialog.ParseHours($dialog.WednesdayBox.Text)
                    Thursday = $dialog.ParseHours($dialog.ThursdayBox.Text)
                    Friday = $dialog.ParseHours($dialog.FridayBox.Text)
                }
                
                if ($dialog.OnSave) {
                    & $dialog.OnSave $data
                }
                
                $dialog.CloseDialog()
            }
        }.GetNewClosure()
    }
    
    [decimal] ParseHours([string]$text) {
        if ([string]::IsNullOrWhiteSpace($text)) { return 0 }
        $hours = 0
        if ([decimal]::TryParse($text, [ref]$hours)) {
            return $hours
        }
        return 0
    }
}


####\Screens/SettingsScreen.ps1
# SettingsScreen.ps1 - Settings management screen

class SettingsScreen : Screen {
    [ListBox]$CategoryList
    [DataGrid]$SettingsGrid
    [ConfigurationService]$ConfigService
    [hashtable[]]$CurrentSettings = @()
    [string]$CurrentCategory = ""
    [EventBus]$EventBus
    
    SettingsScreen() : base() {
        $this.Title = "Settings"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.ConfigService = $global:ServiceContainer.GetService("ConfigurationService")
        if (-not $this.ConfigService) {
            $this.ConfigService = [ConfigurationService]::new()
            $global:ServiceContainer.Register("ConfigurationService", $this.ConfigService)
        }
        
        $this.EventBus = $global:ServiceContainer.GetService('EventBus')
        
        # Create category list
        $this.CategoryList = [ListBox]::new()
        $this.CategoryList.Title = "Categories"
        $this.CategoryList.ShowBorder = $true
        # Capture screen reference for callback
        $screen = $this
        $this.CategoryList.OnSelectionChanged = {
            $screen.LoadCategorySettings()
        }.GetNewClosure()
        $this.CategoryList.Initialize($global:ServiceContainer)
        $this.AddChild($this.CategoryList)
        
        # Create settings grid
        $this.SettingsGrid = [DataGrid]::new()
        $this.SettingsGrid.Title = "Settings"
        $this.SettingsGrid.ShowBorder = $true
        $this.SettingsGrid.Initialize($global:ServiceContainer)
        $this.SettingsGrid.SetColumns(@(
            @{Name="Setting"; Header="Setting"; Width=30},
            @{Name="Value"; Header="Value"; Width=20},
            @{Name="Type"; Header="Type"; Width=10}
        ))
        $this.AddChild($this.SettingsGrid)
        
        # Load categories
        $this.LoadCategories()
        
        # No more BindKey - use HandleScreenInput instead
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        switch ($key.Key) {
            ([System.ConsoleKey]::Enter) { 
                $this.EditSetting()
                return $true
            }
        }
        
        switch ($key.KeyChar) {
            'e' { $this.EditSetting(); return $true }
            'r' { $this.ResetCategory(); return $true }
            'R' { $this.ResetAll(); return $true }
            's' { $this.SaveSettings(); return $true }
        }
        
        return $false
    }
    
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        $this.CategoryList.Focus()
        # Settings are loaded automatically when selection changes
    }
    
    [void] OnBoundsChanged() {
        # Split the width between category list and settings grid
        $categoryWidth = 25
        $gridWidth = [Math]::Max(10, $this.Width - $categoryWidth)
        
        # Set bounds for category list
        $this.CategoryList.SetBounds(
            $this.X,
            $this.Y,
            $categoryWidth,
            $this.Height
        )
        
        # Set bounds for settings grid
        $this.SettingsGrid.SetBounds(
            $this.X + $categoryWidth,
            $this.Y,
            $gridWidth,
            $this.Height
        )
    }
    
    [void] LoadCategories() {
        $config = $this.ConfigService.GetAll()
        $categories = @()
        
        foreach ($key in $config.Keys | Sort-Object) {
            if ($config[$key] -is [hashtable]) {
                $categories += @{
                    Name = $key
                    DisplayName = $this.FormatCategoryName($key)
                }
            }
        }
        
        $this.CategoryList.SetItems($categories)
        $this.CategoryList.ItemRenderer = { param($cat) $cat.DisplayName }
        
        if ($categories.Count -gt 0) {
            $this.CategoryList.SelectIndex(0)
            # LoadCategorySettings is now called automatically by OnSelectionChanged
        }
    }
    
    [void] LoadCategorySettings() {
        $selected = $this.CategoryList.GetSelectedItem()
        if (-not $selected) { return }
        
        $this.CurrentCategory = $selected.Name
        $categoryConfig = $this.ConfigService.Get($this.CurrentCategory)
        
        if ($categoryConfig -is [hashtable]) {
            $settings = @()
            
            foreach ($key in $categoryConfig.Keys | Sort-Object) {
                $value = $categoryConfig[$key]
                $type = $this.GetValueType($value)
                
                $settings += @{
                    Setting = $this.FormatSettingName($key)
                    Value = $this.FormatValue($value)
                    Type = $type
                    Key = $key
                    RawValue = $value
                }
            }
            
            $this.CurrentSettings = $settings
            $this.SettingsGrid.SetItems($settings)
            $this.SettingsGrid.Title = "Settings - $($selected.DisplayName)"
        }
    }
    
    [void] EditSetting() {
        if (-not $this.SettingsGrid.IsFocused) { return }
        
        $selected = $this.SettingsGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        $path = "$($this.CurrentCategory).$($selected.Key)"
        $currentValue = $selected.RawValue
        
        # Create appropriate dialog based on type
        $dialog = $null
        
        # Special handling for theme selection
        if ($path -eq "Theme.CurrentTheme") {
            # Cycle through available themes
            $availableThemes = $this.ConfigService.Get("Theme.AvailableThemes", @("default", "matrix"))
            $currentIndex = $availableThemes.IndexOf($currentValue)
            $nextIndex = ($currentIndex + 1) % $availableThemes.Count
            $newValue = $availableThemes[$nextIndex]
            
            $this.ConfigService.Set($path, $newValue)
            
            # Apply theme immediately
            $themeManager = $global:ServiceContainer.GetService("ThemeManager")
            if ($themeManager) {
                $themeManager.SetTheme($newValue)
            }
            
            # Publish config changed event
            if ($this.EventBus) {
                $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                    Path = $path
                    OldValue = $currentValue
                    NewValue = $newValue
                    Category = $this.CurrentCategory
                })
            }
            
            $this.LoadCategorySettings()
            return
        }
        
        switch ($selected.Type) {
            "Boolean" {
                # Simple toggle
                $newValue = -not $currentValue
                $this.ConfigService.Set($path, $newValue)
                
                # Publish config changed event
                if ($this.EventBus) {
                    $this.EventBus.Publish([EventNames]::ConfigChanged, @{
                        Path = $path
                        OldValue = $currentValue
                        NewValue = $newValue
                        Category = $this.CurrentCategory
                    })
                }
                
                $this.LoadCategorySettings()
                return
            }
            "Number" {
                # TODO: Create NumberInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("Number editing not yet implemented")
                }
            }
            "String" {
                # TODO: Create TextInputDialog
                if ($global:Logger) {
                    $global:Logger.Info("String editing not yet implemented")
                }
            }
        }
    }
    
    [void] ResetCategory() {
        if (-not $this.CurrentCategory) { return }
        
        $message = "Reset all settings in '$($this.CurrentCategory)' to defaults?"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.OnConfirm = {
            $this.ConfigService.ResetSection($this.CurrentCategory)
            $this.LoadCategorySettings()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ResetAll() {
        $message = "Reset ALL settings to defaults?`n`nThis cannot be undone!"
        $dialog = [ConfirmationDialog]::new($message)
        $dialog.ConfirmText = "Reset All"
        $dialog.OnConfirm = {
            $this.ConfigService.Reset()
            $this.LoadCategories()
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] SaveSettings() {
        $this.ConfigService.Save()
        if ($global:Logger) {
            $global:Logger.Info("Settings saved")
        }
    }
    
    
    hidden [string] FormatCategoryName([string]$name) {
        # Convert PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        return $formatted.Trim()
    }
    
    hidden [string] FormatSettingName([string]$name) {
        # Convert camelCase/PascalCase to Title Case
        $formatted = $name -creplace '([A-Z])', ' $1'
        $formatted = $formatted.Substring(0,1).ToUpper() + $formatted.Substring(1)
        return $formatted.Trim()
    }
    
    hidden [string] FormatValue($value) {
        if ($value -eq $null) { return "<null>" }
        if ($value -is [bool]) { return $(if ($value) { "Yes" } else { "No" }) }
        if ($value -is [hashtable]) { return "<nested>" }
        if ($value -is [array]) { return "<array[$($value.Count)]>" }
        return $value.ToString()
    }
    
    hidden [string] GetValueType($value) {
        if ($value -eq $null) { return "Null" }
        if ($value -is [bool]) { return "Boolean" }
        if ($value -is [int] -or $value -is [long] -or $value -is [double]) { return "Number" }
        if ($value -is [string]) { return "String" }
        if ($value -is [hashtable]) { return "Object" }
        if ($value -is [array]) { return "Array" }
        return "Unknown"
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append(" [Tab]Navigate [Enter/E]Edit [R]Reset Category [Shift+R]Reset All [S]Save")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/SubtaskDialog.ps1
# SubtaskDialog - Dialog for adding/editing subtasks using BaseDialog

class SubtaskDialog : BaseDialog {
    [Task]$ParentTask = $null
    [Subtask]$Subtask = $null  # For editing existing subtasks
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$TitleTextBox
    [TextBox]$DescriptionTextBox
    [TextBox]$EstimatedTimeTextBox
    [TextBox]$ActualTimeTextBox
    [TextBox]$DueDateTextBox
    
    # Dropdowns (simplified as text for now)
    [TextBox]$PriorityTextBox
    [TextBox]$ProgressTextBox
    
    SubtaskDialog() : base("Add Subtask", 60, 24) {
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask) : base("Add Subtask - $($parentTask.Title)", 60, 24) {
        $this.ParentTask = $parentTask
        $this.PrimaryButtonText = "Add Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    SubtaskDialog([Task]$parentTask, $subtask) : base("Edit Subtask", 60, 24) {
        $this.ParentTask = $parentTask
        $this.Subtask = $subtask
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Update Subtask"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.TitleTextBox = [TextBox]::new()
        $this.TitleTextBox.Title = "Title"
        $this.TitleTextBox.ShowBorder = $true
        $this.TitleTextBox.TabIndex = 1
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Title']) {
            $this.TitleTextBox.Text = $this.Subtask.Title
        }
        $this.AddContentControl($this.TitleTextBox)
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        $this.DescriptionTextBox.TabIndex = 2
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.PSObject.Properties['Description']) {
            $this.DescriptionTextBox.Text = $this.Subtask.Description
        }
        $this.AddContentControl($this.DescriptionTextBox)
        
        $this.PriorityTextBox = [TextBox]::new()
        $this.PriorityTextBox.Title = "Priority (Low/Medium/High)"
        $this.PriorityTextBox.ShowBorder = $true
        $this.PriorityTextBox.TabIndex = 3
        
        if ($this.IsEditMode -and $this.Subtask -and $this.Subtask.Priority) {
            $this.PriorityTextBox.Text = $this.Subtask.Priority.ToString()
        } else {
            $this.PriorityTextBox.Text = "Medium"
        }
        $this.AddContentControl($this.PriorityTextBox)
        
        $this.ProgressTextBox = [TextBox]::new()
        $this.ProgressTextBox.Title = "Progress (0-100)"
        $this.ProgressTextBox.ShowBorder = $true
        $this.ProgressTextBox.TabIndex = 4
        
        if ($this.IsEditMode -and $this.Subtask) {
            $progress = if ($this.Subtask.PSObject.Properties['Progress']) { $this.Subtask.Progress } else { 0 }
            $this.ProgressTextBox.Text = $progress.ToString()
        } else {
            $this.ProgressTextBox.Text = "0"
        }
        $this.AddContentControl($this.ProgressTextBox)
        
        $this.EstimatedTimeTextBox = [TextBox]::new()
        $this.EstimatedTimeTextBox.Title = "Estimated Time (minutes)"
        $this.EstimatedTimeTextBox.ShowBorder = $true
        $this.EstimatedTimeTextBox.TabIndex = 5
        
        if ($this.IsEditMode -and $this.Subtask) {
            $estimated = if ($this.Subtask.PSObject.Properties['EstimatedMinutes']) { $this.Subtask.EstimatedMinutes } else { 0 }
            if ($estimated -gt 0) {
                $this.EstimatedTimeTextBox.Text = $estimated.ToString()
            }
        }
        $this.AddContentControl($this.EstimatedTimeTextBox)
        
        $this.ActualTimeTextBox = [TextBox]::new()
        $this.ActualTimeTextBox.Title = "Actual Time (minutes)"
        $this.ActualTimeTextBox.ShowBorder = $true
        $this.ActualTimeTextBox.TabIndex = 6
        
        if ($this.IsEditMode -and $this.Subtask) {
            $actual = if ($this.Subtask.PSObject.Properties['ActualMinutes']) { $this.Subtask.ActualMinutes } else { 0 }
            if ($actual -gt 0) {
                $this.ActualTimeTextBox.Text = $actual.ToString()
            }
        }
        $this.AddContentControl($this.ActualTimeTextBox)
        
        $this.DueDateTextBox = [TextBox]::new()
        $this.DueDateTextBox.Title = "Due Date (MM/DD/YYYY, optional)"
        $this.DueDateTextBox.ShowBorder = $true
        $this.DueDateTextBox.TabIndex = 7
        
        if ($this.IsEditMode -and $this.Subtask) {
            $dueDate = if ($this.Subtask.PSObject.Properties['DueDate']) { $this.Subtask.DueDate } else { [DateTime]::MinValue }
            if ($dueDate -ne [DateTime]::MinValue) {
                $this.DueDateTextBox.Text = $dueDate.ToString("MM/dd/yyyy")
            }
        }
        $this.AddContentControl($this.DueDateTextBox)
        
        # Set custom handlers for BaseDialog
        $dialog = $this
        $this.OnPrimary = {
            $dialog.HandleSave()
        }.GetNewClosure()
        
        $this.OnSecondary = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
            $dialog.CloseDialog()
        }.GetNewClosure()
    }
    
    [void] PositionContentControls([int]$dialogX, [int]$dialogY) {
        # Custom layout: Stack inputs vertically
        $padding = $this.DialogPadding
        $shortInputHeight = 3
        $tallInputHeight = 4
        $currentY = $dialogY + $padding
        $inputWidth = $this.DialogWidth - ($padding * 2)
        
        # Title input
        $this.TitleTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $tallInputHeight
        )
        $currentY += $tallInputHeight + 1
        
        # Priority and Progress on same row
        $halfWidth = [int](($inputWidth - 2) / 2)
        $this.PriorityTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ProgressTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Estimated and Actual time on same row
        $this.EstimatedTimeTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        
        $this.ActualTimeTextBox.SetBounds(
            $dialogX + $padding + $halfWidth + 2,
            $currentY,
            $halfWidth,
            $shortInputHeight
        )
        $currentY += $shortInputHeight + 1
        
        # Due date
        $this.DueDateTextBox.SetBounds(
            $dialogX + $padding,
            $currentY,
            $inputWidth,
            $shortInputHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create subtask data
        $subtaskData = $this.CreateSubtaskData()
        
        if ($this.OnSave) {
            & $this.OnSave $subtaskData
        }
        
        # Close dialog after successful save
        $this.CloseDialog()
    }
    
    [string] ValidateInputs() {
        # Validate title
        $title = $this.TitleTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($title)) {
            return "Title is required"
        }
        
        # Validate priority
        $priority = $this.PriorityTextBox.Text.Trim()
        if ($priority -notin @("Low", "Medium", "High")) {
            return "Priority must be Low, Medium, or High"
        }
        
        # Validate progress
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $progress = 0
        if (-not [string]::IsNullOrEmpty($progressStr)) {
            if (-not [int]::TryParse($progressStr, [ref]$progress) -or $progress -lt 0 -or $progress -gt 100) {
                return "Progress must be a number between 0 and 100"
            }
        }
        
        # Validate estimated time
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($estimatedStr)) {
            $estimated = 0
            if (-not [int]::TryParse($estimatedStr, [ref]$estimated) -or $estimated -lt 0) {
                return "Estimated time must be a positive number"
            }
        }
        
        # Validate actual time
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($actualStr)) {
            $actual = 0
            if (-not [int]::TryParse($actualStr, [ref]$actual) -or $actual -lt 0) {
                return "Actual time must be a positive number"
            }
        }
        
        # Validate due date
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        if (-not [string]::IsNullOrEmpty($dueDateStr)) {
            try {
                [DateTime]::Parse($dueDateStr) | Out-Null
            } catch {
                return "Invalid due date format. Use MM/DD/YYYY"
            }
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateSubtaskData() {
        # Parse inputs
        $title = $this.TitleTextBox.Text.Trim()
        $description = $this.DescriptionTextBox.Text.Trim()
        $priorityStr = $this.PriorityTextBox.Text.Trim()
        $progressStr = $this.ProgressTextBox.Text.Trim()
        $estimatedStr = $this.EstimatedTimeTextBox.Text.Trim()
        $actualStr = $this.ActualTimeTextBox.Text.Trim()
        $dueDateStr = $this.DueDateTextBox.Text.Trim()
        
        # Convert priority
        $priority = switch ($priorityStr) {
            "Low" { [TaskPriority]::Low }
            "High" { [TaskPriority]::High }
            default { [TaskPriority]::Medium }
        }
        
        # Parse numbers
        $progress = if ([string]::IsNullOrEmpty($progressStr)) { 0 } else { [int]::Parse($progressStr) }
        $estimated = if ([string]::IsNullOrEmpty($estimatedStr)) { 0 } else { [int]::Parse($estimatedStr) }
        $actual = if ([string]::IsNullOrEmpty($actualStr)) { 0 } else { [int]::Parse($actualStr) }
        
        # Parse due date
        $dueDate = if ([string]::IsNullOrEmpty($dueDateStr)) {
            [DateTime]::MinValue
        } else {
            [DateTime]::Parse($dueDateStr)
        }
        
        # Create subtask data object
        $subtaskData = [PSCustomObject]@{
            Id = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Id']) { $this.Subtask.Id } else { [guid]::NewGuid().ToString() }
            } else { 
                [guid]::NewGuid().ToString() 
            }
            ParentTaskId = $this.ParentTask.Id
            Title = $title
            Description = $description
            Status = if ($this.IsEditMode -and $this.Subtask) { 
                if ($this.Subtask.PSObject.Properties['Status']) { $this.Subtask.Status } else { [TaskStatus]::Pending }
            } else { 
                [TaskStatus]::Pending 
            }
            Priority = $priority
            Progress = $progress
            EstimatedMinutes = $estimated
            ActualMinutes = $actual
            DueDate = $dueDate
            IsEditMode = $this.IsEditMode
        }
        
        return $subtaskData
    }
    
    # Override HandleScreenInput to add Ctrl+Enter shortcut
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        # Let base class handle standard dialog shortcuts first
        if (([BaseDialog]$this).HandleScreenInput($key)) {
            return $true
        }
        
        # Add Ctrl+Enter shortcut for save
        if ($key.Key -eq [System.ConsoleKey]::Enter -and ($key.Modifiers -band [ConsoleModifiers]::Control)) {
            $this.HandleSave()
            return $true
        }
        
        return $false
    }
    
    # Legacy callback support
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
}


####\Screens/TaskScreen.ps1
# TaskScreen.ps1 - Task management screen using DataGrid

class TaskScreen : Screen {
    [DataGrid]$TaskGrid
    [TaskService]$TaskService
    [SubtaskService]$SubtaskService
    [ProjectService]$ProjectService
    [hashtable]$StatusColors
    [hashtable]$PriorityColors
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    hidden [bool]$ShowSubtasks = $true
    hidden [hashtable]$ProjectCache = @{}
    
    # Layout settings
    hidden [int]$StatusBarHeight = 2
    
    TaskScreen() : base() {
        $this.Title = "Tasks"
    }
    
    [void] OnInitialize() {
        # Get services using proper dependency injection
        $this.TaskService = $this.GetService("TaskService")
        if (-not $this.TaskService) {
            $this.TaskService = [TaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("TaskService", $this.TaskService)
            } else {
                $global:ServiceContainer.Register("TaskService", $this.TaskService)
            }
        }
        
        $this.SubtaskService = $this.GetService("SubtaskService")
        if (-not $this.SubtaskService) {
            $this.SubtaskService = [SubtaskService]::new()
            if ($this.ServiceContainer) {
                $this.ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            } else {
                $global:ServiceContainer.Register("SubtaskService", $this.SubtaskService)
            }
        }
        
        $this.ProjectService = $this.GetService("ProjectService")
        $this.EventBus = $this.GetService('EventBus')
        
        # Subscribe to events
        if ($this.EventBus) {
            # Capture reference to this screen instance
            $screen = $this
            
            # Subscribe to task created events
            $this.EventSubscriptions['TaskCreated'] = $this.EventBus.Subscribe('task.created', {
                param($sender, $eventData)
                $screen.LoadTasks()
                # Select the new task if provided
                if ($eventData.Task) {
                    for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                        if ($screen.TaskGrid.Items[$i].Id -eq $eventData.Task.Id) {
                            $screen.TaskGrid.SelectIndex($i)
                            break
                        }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to command events for this screen
            $this.EventSubscriptions['CommandExecuted'] = $this.EventBus.Subscribe('command.executed', {
                param($sender, $eventData)
                if ($global:Logger) {
                    $global:Logger.Debug("TaskScreen: Received CommandExecuted event - Command: $($eventData.Command), Target: $($eventData.Target)")
                }
                if ($eventData.Target -eq 'TaskScreen') {
                    switch ($eventData.Command) {
                        'NewTask' { 
                            if ($global:Logger) {
                                $global:Logger.Debug("TaskScreen: Executing NewTask command")
                            }
                            $screen.NewTask() 
                        }
                        'EditTask' { $screen.EditTask() }
                        'DeleteTask' { $screen.DeleteTask() }
                    }
                }
            }.GetNewClosure())
            
            # Subscribe to task updated events
            $this.EventSubscriptions['TaskUpdated'] = $this.EventBus.Subscribe('task.updated', {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
            
            # Subscribe to task deleted events
            $this.EventSubscriptions['TaskDeleted'] = $this.EventBus.Subscribe('task.deleted', {
                param($sender, $eventData)
                $screen.LoadTasks()
            }.GetNewClosure())
        }
        
        # Set up color mappings
        $this.StatusColors = @{
            [TaskStatus]::Pending = "foreground"
            [TaskStatus]::InProgress = "warning"
            [TaskStatus]::Completed = "success"
            [TaskStatus]::Cancelled = "disabled"
        }
        
        $this.PriorityColors = @{
            [TaskPriority]::Low = "success"
            [TaskPriority]::Medium = "warning"
            [TaskPriority]::High = "error"
        }
        
        # Create DataGrid with columns
        $this.TaskGrid = [DataGrid]::new()
        $this.TaskGrid.Title = "Tasks"
        $this.TaskGrid.ShowBorder = $true
        $this.TaskGrid.ShowGridLines = $true
        
        # Define columns
        $screen = $this
        $columns = @(
            @{
                Name = "Status"
                Header = "S"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no status shown in grid (shown in title instead)
                        return " "
                    }
                    switch ($item.Status) {
                        ([TaskStatus]::Pending) { return "P" }
                        ([TaskStatus]::InProgress) { return "W" }
                        ([TaskStatus]::Completed) { return "D" }
                        ([TaskStatus]::Cancelled) { return "X" }
                        default { return "?" }
                    }
                }
            },
            @{
                Name = "Priority"
                Header = "P"
                Width = 1
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no priority shown in grid
                        return " "
                    }
                    switch ($item.Priority) {
                        ([TaskPriority]::High) { return "H" }
                        ([TaskPriority]::Medium) { return "M" }
                        ([TaskPriority]::Low) { return "L" }
                        default { return " " }
                    }
                }
            },
            @{
                Name = "Title"
                Header = "Task"
                Width = 0  # Flexible width
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - show indented with status
                        $status = switch ($item.Status) {
                            ([TaskStatus]::Pending) { "[ ]" }
                            ([TaskStatus]::InProgress) { "[~]" }
                            ([TaskStatus]::Completed) { "[‚úì]" }
                            ([TaskStatus]::Cancelled) { "[‚úó]" }
                            default { "[?]" }
                        }
                        return "  ‚îî $status $($item.Title)"
                    } else {
                        # Main task - include subtask count if any
                        $title = $item.Title
                        if ($screen.SubtaskService) {
                            $stats = $screen.SubtaskService.GetTaskStatistics($item.Id)
                            if ($stats.Total -gt 0) {
                                $title += " [$($stats.Completed)/$($stats.Total)]"
                            }
                        }
                        return $title
                    }
                }
            },
            @{
                Name = "Project"
                Header = "Project"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no project shown
                        return ""
                    }
                    if ($item.ProjectId -and $screen.ProjectService) {
                        # Cache project lookups for performance
                        if (-not $screen.ProjectCache.ContainsKey($item.ProjectId)) {
                            $project = $screen.ProjectService.GetProject($item.ProjectId)
                            if ($project) {
                                $screen.ProjectCache[$item.ProjectId] = $project.FullProjectName
                            } else {
                                $screen.ProjectCache[$item.ProjectId] = ""
                            }
                        }
                        return $screen.ProjectCache[$item.ProjectId]
                    }
                    return ""
                }
            },
            @{
                Name = "DueDate"
                Header = "Due"
                Width = 10
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no due date in grid
                        return ""
                    }
                    if ($item.DueDate -ne [DateTime]::MinValue) {
                        return $item.DueDate.ToString("yyyy-MM-dd")
                    }
                    return ""
                }
            },
            @{
                Name = "Tags"
                Header = "Tags"
                Width = 15
                Getter = {
                    param($item)
                    if ($item.PSObject.Properties.Name -contains 'ParentTaskId') {
                        # Subtask - no tags shown
                        return ""
                    }
                    if ($item.Tags -and $item.Tags.Count -gt 0) {
                        return ($item.Tags -join ",")
                    }
                    return ""
                }
            }
        )
        
        $this.TaskGrid.SetColumns($columns)
        $this.TaskGrid.Initialize($global:ServiceContainer)
        $this.AddChild($this.TaskGrid)
        
        # Load tasks
        $this.LoadTasks()
    }
    
    
    [void] OnActivated() {
        # Call base to manage focus scope and shortcuts
        ([Screen]$this).OnActivated()
        
        # Focus the grid
        if ($this.TaskGrid -and $this.TaskGrid.Items.Count -gt 0) {
            $this.TaskGrid.Focus()
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.OnActivated: Screen activated and focused grid")
        }
    }
    
    [void] OnBoundsChanged() {
        # Layout: Grid takes all space except status bar
        $gridHeight = $this.Height - $this.StatusBarHeight
        
        # Task grid
        $this.TaskGrid.SetBounds(
            $this.X,
            $this.Y,
            $this.Width,
            $gridHeight
        )
    }
    
    [void] LoadTasks() {
        $tasks = $this.TaskService.GetAllTasks()
        
        # Clear project cache for fresh lookups
        $this.ProjectCache.Clear()
        
        # Filter out deleted tasks
        $activeTasks = $tasks | Where-Object { -not $_.Deleted }
        
        # Sort by priority (high first), then status, then due date
        $sorted = $activeTasks | Sort-Object -Property `
            @{Expression = {$_.Priority}; Descending = $true},
            @{Expression = {$_.Status}; Ascending = $true},
            @{Expression = {if ($_.DueDate -eq [DateTime]::MinValue) { [DateTime]::MaxValue } else { $_.DueDate }}; Ascending = $true}
        
        if ($this.ShowSubtasks -and $this.SubtaskService) {
            # Create combined list with tasks and their subtasks
            $combinedItems = [System.Collections.ArrayList]::new()
            
            foreach ($task in $sorted) {
                $combinedItems.Add($task) | Out-Null
                
                # Add subtasks for this task
                $subtasks = $this.SubtaskService.GetSubtasksForTask($task.Id)
                foreach ($subtask in $subtasks) {
                    $combinedItems.Add($subtask) | Out-Null
                }
            }
            
            $this.TaskGrid.SetItems($combinedItems)
        } else {
            $this.TaskGrid.SetItems($sorted)
        }
    }
    
    [void] NewTask() {
        # Create new task dialog
        $dialog = [NewTaskDialog]::new()
        
        # EventBus will handle task creation and dialog closing
        # Legacy callbacks are only set as fallback for non-EventBus scenarios
        if (-not $this.EventBus) {
            # Capture the screen reference
            $screen = $this
            $dialog.OnCreate = {
                param($taskData)
                
                $task = $screen.TaskService.CreateTask($taskData)
                $screen.LoadTasks()
                
                # Select the new task
                for ($i = 0; $i -lt $screen.TaskGrid.Items.Count; $i++) {
                    if ($screen.TaskGrid.Items[$i].Id -eq $task.Id) {
                        $screen.TaskGrid.SelectIndex($i)
                        break
                    }
                }
                
                # Don't call Pop() - BaseDialog handles that
            }.GetNewClosure()
            
            # Don't need OnCancel - BaseDialog handles ESC by default
        }
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] EditTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Edit subtask
            $this.EditSubtask($selected)
            return
        }
        
        # Create edit task dialog
        $dialog = [EditTaskDialog]::new($selected)
        # Capture references
        $screen = $this
        $task = $selected
        $dialog.OnSave = {
            param($taskData)
            
            # Update the task
            $task.Title = $taskData.Title
            $task.Description = $taskData.Description
            $task.Status = $taskData.Status
            $task.Priority = $taskData.Priority
            $task.Progress = $taskData.Progress
            $task.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.TaskService.UpdateTask($task)
            
            # Publish task updated event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskUpdated, @{ Task = $task })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # EditTaskDialog is not a BaseDialog, so we need to Pop manually
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        # EditTaskDialog is not a BaseDialog, so we need to handle cancel
        $dialog.OnCancel = {
            $screenManager = $screen.ServiceContainer.GetService("ScreenManager")
            if ($screenManager) {
                $screenManager.Pop()
            }
        }.GetNewClosure()
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] DeleteTask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Check if it's a subtask or main task
        $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
        $message = if ($isSubtask) {
            "Are you sure you want to delete this subtask?`n`n$($selected.Title)"
        } else {
            "Are you sure you want to delete this task?`n`n$($selected.Title)"
        }
        
        # Show confirmation dialog
        $dialog = [ConfirmationDialog]::new($message)
        # Capture references
        $screen = $this
        $itemId = $selected.Id
        $dialog.OnConfirm = {
            if ($isSubtask) {
                # Delete subtask
                $screen.SubtaskService.DeleteSubtask($itemId)
            } else {
                # Delete task (and all its subtasks)
                $screen.TaskService.DeleteTask($itemId)
            }
            
            # Publish task deleted event
            if ($screen.EventBus) {
                $screen.EventBus.Publish([EventNames]::TaskDeleted, @{ TaskId = $itemId })
            } else {
                # Fallback if EventBus not available
                $screen.LoadTasks()
            }
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CycleStatus() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Cycle through status values
        $newStatus = switch ($selected.Status) {
            ([TaskStatus]::Pending) { [TaskStatus]::InProgress }
            ([TaskStatus]::InProgress) { [TaskStatus]::Completed }
            ([TaskStatus]::Completed) { [TaskStatus]::Cancelled }
            ([TaskStatus]::Cancelled) { [TaskStatus]::Pending }
        }
        
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Update subtask
            $selected.Status = $newStatus
            $selected.UpdatedAt = [DateTime]::Now
            $this.SubtaskService.SaveSubtask($selected)
        } else {
            # Update task
            $this.TaskService.UpdateTaskStatus($selected.Id, $newStatus)
        }
        
        # Publish task status changed event
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TaskStatusChanged, @{ 
                TaskId = $selected.Id
                OldStatus = $selected.Status
                NewStatus = $newStatus
            })
        } else {
            # Fallback if EventBus not available
            $this.LoadTasks()
        }
    }
    
    [void] AddSubtask() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected -or -not $this.SubtaskService) { return }
        
        # Find the parent task (if selected item is a subtask, get its parent)
        $parentTask = $null
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') {
            # Selected item is a subtask, find its parent
            $parentTask = $this.TaskService.GetTask($selected.ParentTaskId)
        } else {
            # Selected item is a task
            $parentTask = $selected
        }
        
        if (-not $parentTask) { return }
        
        # Create subtask dialog
        $dialog = [SubtaskDialog]::new($parentTask)
        
        # Set up callback for when subtask is saved
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Create subtask using service
            $properties = @{
                ParentTaskId = $subtaskData.ParentTaskId
                Title = $subtaskData.Title
                Description = $subtaskData.Description
                Priority = $subtaskData.Priority
                Progress = $subtaskData.Progress
                EstimatedMinutes = $subtaskData.EstimatedMinutes
                ActualMinutes = $subtaskData.ActualMinutes
                DueDate = $subtaskData.DueDate
            }
            
            $screen.SubtaskService.CreateSubtask($properties)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] ToggleSubtaskView() {
        $this.ShowSubtasks = -not $this.ShowSubtasks
        $this.LoadTasks()
    }
    
    [void] EditSubtask([PSCustomObject]$subtask) {
        if (-not $subtask -or -not $this.SubtaskService) { return }
        
        # Get parent task for context
        $parentTask = $this.TaskService.GetTask($subtask.ParentTaskId)
        if (-not $parentTask) { return }
        
        # Create subtask dialog for editing
        $dialog = [SubtaskDialog]::new($parentTask, $subtask)
        
        # Set up callback for when subtask is updated
        $screen = $this  # Capture reference for closure
        $dialog.OnSave = {
            param($subtaskData)
            
            # Update the existing subtask
            $subtask.Title = $subtaskData.Title
            $subtask.Description = $subtaskData.Description
            $subtask.Status = $subtaskData.Status
            $subtask.Priority = $subtaskData.Priority
            $subtask.Progress = $subtaskData.Progress
            $subtask.EstimatedMinutes = $subtaskData.EstimatedMinutes
            $subtask.ActualMinutes = $subtaskData.ActualMinutes
            $subtask.DueDate = $subtaskData.DueDate
            $subtask.UpdatedAt = [DateTime]::Now
            
            # Save through service
            $screen.SubtaskService.SaveSubtask($subtask)
            $screen.LoadTasks()
            
            # Don't call Pop() - BaseDialog handles that
        }.GetNewClosure()
        
        # Don't need OnCancel - BaseDialog handles ESC by default
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [void] CyclePriority() {
        $selected = $this.TaskGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Don't cycle priority for subtasks in this view
        if ($selected.PSObject.Properties.Name -contains 'ParentTaskId') { return }
        
        $this.TaskService.CyclePriority($selected.Id)
        $this.LoadTasks()
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($global:Logger) {
            $global:Logger.Debug("TaskScreen.HandleScreenInput: Key=$($key.Key) Char='$($key.KeyChar)'")
        }
        
        # Handle screen-specific shortcuts
        switch ($key.Key) {
            ([System.ConsoleKey]::N) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'N' -or $key.KeyChar -eq 'n')) {
                    $this.NewTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::E) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'E' -or $key.KeyChar -eq 'e')) {
                    $this.EditTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Enter) {
                $this.EditTask()
                return $true
            }
            ([System.ConsoleKey]::D) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'D' -or $key.KeyChar -eq 'd')) {
                    $this.DeleteTask()
                    return $true
                }
            }
            ([System.ConsoleKey]::Delete) {
                $this.DeleteTask()
                return $true
            }
            ([System.ConsoleKey]::R) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'R' -or $key.KeyChar -eq 'r')) {
                    $this.LoadTasks()
                    return $true
                }
            }
            ([System.ConsoleKey]::F5) {
                $this.LoadTasks()
                return $true
            }
            ([System.ConsoleKey]::S) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'S' -or $key.KeyChar -eq 's')) {
                    $this.CycleStatus()
                    return $true
                }
            }
            ([System.ConsoleKey]::P) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'P' -or $key.KeyChar -eq 'p')) {
                    $this.CyclePriority()
                    return $true
                }
            }
            ([System.ConsoleKey]::A) {
                if ($key.Modifiers -band [ConsoleModifiers]::Shift -and ($key.KeyChar -eq 'A')) {
                    # Shift+A to add subtask
                    $this.AddSubtask()
                    return $true
                }
            }
            ([System.ConsoleKey]::T) {
                if (-not $key.Modifiers -and ($key.KeyChar -eq 'T' -or $key.KeyChar -eq 't')) {
                    # Toggle subtask view
                    $this.ToggleSubtaskView()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 1024
        
        # Render base (background and children)
        $sb.Append(([Container]$this).OnRender())
        
        # Render status bar
        $statusY = $this.Y + $this.Height - $this.StatusBarHeight
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($this.Theme.GetColor("border"))
        $sb.Append([StringCache]::GetHorizontalLine($this.Width))
        
        # Status text
        $sb.Append([VT]::MoveTo($this.X + 1, $statusY + 1))
        $sb.Append($this.Theme.GetColor("disabled"))
        
        $selected = $this.TaskGrid.GetSelectedItem()
        if ($selected) {
            # Show task details in status bar
            $isSubtask = $selected.PSObject.Properties.Name -contains 'ParentTaskId'
            $type = if ($isSubtask) { "Subtask" } else { "Task" }
            $status = $selected.Status.ToString()
            $priority = $selected.Priority.ToString()
            $sb.Append("${type}: $($selected.Title) | Status: $status | Priority: $priority")
        } else {
            # Show help text with letter-based shortcuts
            $sb.Append("[N]ew [E]dit [D]elete [S]tatus [P]riority [A+Shift]Subtask [T]oggle [Tab]Navigate")
        }
        
        # Add legend for status/priority letters
        $sb.Append([VT]::MoveTo($this.X + $this.Width - 35, $statusY + 1))
        $sb.Append("S: P=Pending W=Working D=Done X=Cancel")
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/TestScreen.ps1
# TestScreen.ps1 - Simple test screen to verify PRAXIS is working

class TestScreen : Screen {
    [string]$Message = "PRAXIS Test Screen"
    [int]$Counter = 0
    hidden [string]$_cachedContent = ""
    
    TestScreen() : base() {
        $this.Title = "Test"
    }
    
    [void] OnInitialize() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnInitialize: $($this.Title)")
        }
        
        # No more BindKey - use HandleScreenInput instead
        
        # Don't rebuild content here - wait until we have bounds
    }
    
    # Handle screen-specific input
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$key) {
        if ($key.Key -eq [System.ConsoleKey]::Spacebar) {
            $this.Counter++
            $this._cachedContent = ""  # Force re-render
            $this.RequestRender() 
            return $true
        }
        elseif ($key.KeyChar -eq 'q') {
            $this.Active = $false
            return $true
        }
        
        return $false
    }
    
    [void] OnThemeChanged() {
        ([Screen]$this).OnThemeChanged()
        $this._cachedContent = ""
        $this.RebuildContent()
    }
    
    [void] RebuildContent() {
        $sb = Get-PooledStringBuilder 512
        
        # Calculate absolute positions
        $absoluteCenterY = $this.Y + [int]($this.Height / 2)
        $absoluteCenterX = $this.X + [int](($this.Width - $this.Message.Length) / 2)
        
        # Title
        $sb.Append([VT]::MoveTo($absoluteCenterX, $absoluteCenterY - 2))
        $sb.Append($this.Theme.GetColor("accent"))
        $sb.Append($this.Message)
        
        # Counter
        $counterText = "Counter: $($this.Counter)"
        $counterX = $this.X + [int](($this.Width - $counterText.Length) / 2)
        $sb.Append([VT]::MoveTo($counterX, $absoluteCenterY))
        $sb.Append($this.Theme.GetColor("foreground"))
        $sb.Append($counterText)
        
        # Instructions
        $instructionText = "Press SPACE to increment, Q to quit"
        $instructionX = $this.X + [int](($this.Width - $instructionText.Length) / 2)
        $sb.Append([VT]::MoveTo($instructionX, $absoluteCenterY + 2))
        $sb.Append($this.Theme.GetColor("disabled"))
        $sb.Append($instructionText)
        
        # FPS counter (bottom right)
        if ($global:ScreenManager) {
            $fps = [Math]::Round($global:ScreenManager.GetFPS(), 1)
            $fpsText = "FPS: $fps"
            $sb.Append([VT]::MoveTo($this.X + $this.Width - $fpsText.Length - 2, $this.Y + $this.Height - 2))
            $sb.Append($this.Theme.GetColor("success"))
            $sb.Append($fpsText)
        }
        
        $sb.Append([VT]::Reset())
        
        $this._cachedContent = $sb.ToString()
        Return-PooledStringBuilder $sb
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TestScreen.OnRender: Bounds X=$($this.X) Y=$($this.Y) W=$($this.Width) H=$($this.Height)")
        }
        
        # Check if we need to rebuild
        if ([string]::IsNullOrEmpty($this._cachedContent)) {
            $this.RebuildContent()
        }
        
        # Return base background + our content
        return ([Container]$this).OnRender() + $this._cachedContent
    }
}


####\Screens/TextEditorScreen.ps1
# TextEditorScreen - Multi-line text editor screen
# Proper PRAXIS architecture implementation

class TextEditorScreen : Screen {
    # Text content and cursor state
    [System.Collections.ArrayList]$Lines
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$FilePath = ""
    [bool]$Modified = $false
    [string]$StatusMessage = ""
    
    # Undo system - line-based grouping
    hidden [System.Collections.ArrayList]$_undoStates
    hidden [int]$_maxUndoStates = 25
    hidden [int]$_currentUndoIndex = -1
    hidden [int]$_maxFileSizeForUndo = 100KB
    hidden [bool]$_undoEnabled = $true
    
    # Auto-save on focus loss
    [bool]$AutoSaveOnFocusLoss = $true
    hidden [bool]$_lastFocusState = $true
    
    # PRAXIS service integration
    hidden [object]$ThemeManager
    hidden [object]$EventBus
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    # Mode system
    [bool]$InTextMode = $true  # Start in text mode
    
    TextEditorScreen() : base() {
        $this.Title = "Text Editor"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.IsFocusable = $true  # TextEditor itself is focusable
        $this.InitializeUndoSystem()
    }
    
    TextEditorScreen([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this.FilePath = $filePath
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.IsFocusable = $true  # TextEditor itself is focusable
        $this.InitializeUndoSystem()
    }
    
    [void] InitializeUndoSystem() {
        $this._undoStates = [System.Collections.ArrayList]::new()
        # Save initial state
        $this.SaveUndoState()
    }
    
    [void] SaveUndoState() {
        if (-not $this._undoEnabled) { return }
        
        # Check file size limit
        $docSize = ($this.Lines | ForEach-Object { $_.Length } | Measure-Object -Sum).Sum
        if ($docSize -gt $this._maxFileSizeForUndo) {
            $this._undoEnabled = $false
            $this.StatusMessage = "Undo disabled - file too large"
            return
        }
        
        $state = @{
            Lines = $this.Lines.Clone()
            CursorX = $this.CursorX
            CursorY = $this.CursorY
            ScrollOffsetX = $this.ScrollOffsetX
            ScrollOffsetY = $this.ScrollOffsetY
        }
        
        # Remove any redo states if we're not at the end
        if ($this._currentUndoIndex -lt $this._undoStates.Count - 1) {
            $removeCount = $this._undoStates.Count - $this._currentUndoIndex - 1
            for ($i = 0; $i -lt $removeCount; $i++) {
                $this._undoStates.RemoveAt($this._undoStates.Count - 1)
            }
        }
        
        $this._undoStates.Add($state) | Out-Null
        $this._currentUndoIndex = $this._undoStates.Count - 1
        
        # Limit undo history
        if ($this._undoStates.Count -gt $this._maxUndoStates) {
            $this._undoStates.RemoveAt(0)
            $this._currentUndoIndex--
        }
        
        # Publish buffer state change event
        if ($this.EventBus) {
            try {
                $this.EventBus.Publish('editor.buffer.state-saved', @{
                    FilePath = $this.FilePath
                    UndoStates = $this._undoStates.Count
                    CurrentIndex = $this._currentUndoIndex
                })
            }
            catch {
                # Ignore event publishing errors to avoid disrupting editing
            }
        }
    }
    
    [void] PerformUndo() {
        if ($this._currentUndoIndex -le 0) { return }
        
        $this._currentUndoIndex--
        $state = $this._undoStates[$this._currentUndoIndex]
        
        $this.Lines = $state.Lines.Clone()
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] PerformRedo() {
        if ($this._currentUndoIndex -ge $this._undoStates.Count - 1) { return }
        
        $this._currentUndoIndex++
        $state = $this._undoStates[$this._currentUndoIndex]
        
        $this.Lines = $state.Lines.Clone()
        $this.CursorX = $state.CursorX
        $this.CursorY = $state.CursorY
        $this.ScrollOffsetX = $state.ScrollOffsetX
        $this.ScrollOffsetY = $state.ScrollOffsetY
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [bool] ShouldSaveUndoForLine() {
        # For line-based undo, save state when cursor moves to a different line
        # or if this is the very first edit
        if ($this._undoStates.Count -eq 0) { return $true }
        
        $lastState = $this._undoStates[$this._currentUndoIndex]
        return ($lastState.CursorY -ne $this.CursorY)
    }
    
    [void] OnApplicationFocusChanged([bool]$hasFocus) {
        # Called by PRAXIS framework when window focus changes
        if ($this._lastFocusState -and -not $hasFocus) {
            # Lost focus - trigger auto-save if enabled and file is modified
            if ($this.AutoSaveOnFocusLoss -and $this.Modified -and $this.FilePath) {
                $this.AutoSave()
            }
        }
        $this._lastFocusState = $hasFocus
    }
    
    [void] AutoSave() {
        try {
            $content = $this.Lines -join "`n"
            $autoSavePath = "$($this.FilePath).autosave"
            Set-Content -Path $autoSavePath -Value $content -NoNewline -ErrorAction Stop
            $this.StatusMessage = "Auto-saved on focus loss"
            if ($global:Logger) {
                $global:Logger.Debug("TextEditor: Auto-saved to $autoSavePath")
            }
        }
        catch {
            $this.StatusMessage = "Auto-save failed: $_"
            if ($global:Logger) {
                $global:Logger.Error("TextEditor: Auto-save failed: $_")
            }
        }
        $this.Invalidate()
    }
    
    [void] OnInitialize() {
        # Get PRAXIS services
        try {
            $this.ThemeManager = $this.ServiceContainer.GetService('ThemeManager')
            $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        }
        catch {
            if ($global:Logger) {
                $global:Logger.Warning("TextEditor: Could not get PRAXIS services: $_")
            }
        }
        
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        } elseif (-not $this.Lines.Count) {
            $this.Lines.Add("") | Out-Null
        }
        
        # Update title
        if ($this.FilePath) {
            $this.Title = "Text Editor - $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        
        # Subscribe to focus change events if EventBus is available
        if ($this.EventBus) {
            try {
                $this.EventBus.Subscribe('application.focus.changed', $this.OnApplicationFocusChanged.GetNewClosure())
            }
            catch {
                if ($global:Logger) {
                    $global:Logger.Warning("TextEditor: Could not subscribe to focus events: $_")
                }
            }
        }
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # TextEditor itself is the focusable element
        $this.Focus()
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw -ErrorAction Stop
            if ($content) {
                $this.Lines.Clear()
                $lineArray = $content -split "`r?`n"
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.Modified = $false
            $this.StatusMessage = "File loaded: $([System.IO.Path]::GetFileName($this.FilePath))"
            
            # Publish file loaded event
            if ($this.EventBus) {
                try {
                    $this.EventBus.Publish('editor.file.loaded', @{
                        FilePath = $this.FilePath
                        LineCount = $this.Lines.Count
                    })
                }
                catch {
                    # Ignore event publishing errors
                }
            }
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
            if (-not $this.Lines.Count) {
                $this.Lines.Add("") | Out-Null
            }
        }
        $this.Invalidate()
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            # Open file browser for save location
            $this.OpenFileBrowser()
            return
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $this.FilePath -Value $content -NoNewline -ErrorAction Stop
            $this.Modified = $false
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($this.FilePath))"
            
            # Publish file saved event
            if ($this.EventBus) {
                try {
                    $this.EventBus.Publish('editor.file.saved', @{
                        FilePath = $this.FilePath
                        LineCount = $this.Lines.Count
                    })
                }
                catch {
                    # Ignore event publishing errors
                }
            }
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
        $this.Invalidate()
    }
    
    [void] OpenFileBrowser() {
        # Open file browser for file selection
        try {
            $fileBrowserType = [type]"FileBrowserScreen"
            if ($fileBrowserType) {
                $fileBrowser = $fileBrowserType::new()
                
                # Set up callback for file selection
                $editor = $this
                $fileBrowser.FileSelectedCallback = {
                    param($filePath)
                    if ($filePath -and (Test-Path $filePath)) {
                        $item = Get-Item $filePath -ErrorAction SilentlyContinue
                        if ($item -and -not $item.PSIsContainer) {
                            # File selected - either save current content or load new file
                            if ($editor.StatusMessage -eq "SELECT_SAVE_LOCATION") {
                                # Save current content to selected file
                                $editor.FilePath = $filePath
                                $editor.SaveFile()
                            } else {
                                # Load selected file
                                $editor.FilePath = $filePath
                                $editor.LoadFile()
                            }
                        }
                    }
                    
                    # Close the file browser
                    $screenManager = $editor.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Pop() | Out-Null
                }.GetNewClosure()
                
                # Push the file browser
                $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                $screenManager.Push($fileBrowser)
            }
        } catch {
            $this.StatusMessage = "FileBrowser not available"
            $this.Invalidate()
        }
    }
    
    # Override HandleScreenInput for text editor controls
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Clear status message on input (except for certain messages)
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Error") -and $this.StatusMessage -ne "SELECT_SAVE_LOCATION") {
            $this.StatusMessage = ""
        }
        
        if ($global:Logger) {
            $global:Logger.Debug("TextEditorScreen.HandleScreenInput: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' InTextMode=$($this.InTextMode)")
        }
        
        # ESC toggles between text mode and command mode
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            $this.InTextMode = -not $this.InTextMode
            $this.StatusMessage = if ($this.InTextMode) { "TEXT MODE" } else { "COMMAND MODE" }
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: ESC pressed, InTextMode=$($this.InTextMode)")
            }
            $this.Invalidate()
            return $true
        }
        
        # In command mode, let number keys bubble up for tab switching
        if (-not $this.InTextMode -and $keyInfo.KeyChar -ge '1' -and $keyInfo.KeyChar -le '9') {
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: In command mode, not handling number key '$($keyInfo.KeyChar)'")
            }
            return $false  # Let parent handle tab switching
        }
        
        # Handle control key combinations
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::S) { 
                    $this.SaveFile()
                    return $true 
                }
                ([ConsoleKey]::O) { 
                    $this.OpenFileBrowser()
                    return $true 
                }
                ([ConsoleKey]::Z) {
                    if ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift) {
                        $this.PerformRedo()
                    } else {
                        $this.PerformUndo()
                    }
                    return $true
                }
                ([ConsoleKey]::Y) {
                    $this.PerformRedo()
                    return $true
                }
                ([ConsoleKey]::Q) { 
                    if ($this.Modified) {
                        $this.StatusMessage = "Unsaved changes! Press Ctrl+Q again to quit"
                        $this.Invalidate()
                    } else {
                        $this.Active = $false
                    }
                    return $true
                }
            }
        }
        
        # Handle regular keys
        switch ($keyInfo.Key) {
            # Navigation
            ([ConsoleKey]::UpArrow) { $this.MoveCursor(0, -1); return $true }
            ([ConsoleKey]::DownArrow) { $this.MoveCursor(0, 1); return $true }
            ([ConsoleKey]::LeftArrow) { $this.MoveCursor(-1, 0); return $true }
            ([ConsoleKey]::RightArrow) { $this.MoveCursor(1, 0); return $true }
            ([ConsoleKey]::Home) { $this.CursorX = 0; $this.EnsureCursorVisible(); $this.Invalidate(); return $true }
            ([ConsoleKey]::End) { 
                if ($this.CursorY -lt $this.Lines.Count) {
                    $this.CursorX = $this.Lines[$this.CursorY].Length
                }
                $this.EnsureCursorVisible()
                $this.Invalidate()
                return $true
            }
            ([ConsoleKey]::PageUp) { $this.PageUp(); return $true }
            ([ConsoleKey]::PageDown) { $this.PageDown(); return $true }
            
            # Editing
            ([ConsoleKey]::Enter) { $this.InsertNewline(); return $true }
            ([ConsoleKey]::Backspace) { $this.Backspace(); return $true }
            ([ConsoleKey]::Delete) { $this.Delete(); return $true }
            ([ConsoleKey]::Tab) { $this.InsertTab(); return $true }
        }
        
        # Insert printable characters only in text mode
        if ($this.InTextMode -and $keyInfo.KeyChar -and [char]::IsControl($keyInfo.KeyChar) -eq $false) {
            $this.InsertChar($keyInfo.KeyChar)
            return $true
        }
        
        # Let base class handle other input (like tab switching)
        return $false
    }
    
    # Text editor specific methods
    [void] MoveCursor([int]$dx, [int]$dy) {
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.Lines.Count - 1, $this.CursorY + $dy))
        
        if ($dx -ne 0) {
            $this.CursorX = [Math]::Max(0, $this.CursorX + $dx)
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        } else {
            # Vertical movement - try to maintain column
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        }
        
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertChar([char]$char) {
        # Save undo state if this is the first edit on this line
        if ($this.ShouldSaveUndoForLine()) {
            $this.SaveUndoState()
        }
        
        $line = $this.Lines[$this.CursorY]
        $this.Lines[$this.CursorY] = $line.Insert($this.CursorX, $char)
        $this.CursorX++
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertNewline() {
        # Always save undo state before creating a new line
        $this.SaveUndoState()
        
        $line = $this.Lines[$this.CursorY]
        $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
        $after = if ($this.CursorX -lt $line.Length) { $line.Substring($this.CursorX) } else { "" }
        
        $this.Lines[$this.CursorY] = $before
        $this.Lines.Insert($this.CursorY + 1, $after)
        
        $this.CursorY++
        $this.CursorX = 0
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Backspace() {
        if ($this.CursorX -gt 0) {
            # Save undo state if this is first edit on this line
            if ($this.ShouldSaveUndoForLine()) {
                $this.SaveUndoState()
            }
            # Delete character before cursor
            $line = $this.Lines[$this.CursorY]
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Always save undo state before joining lines
            $this.SaveUndoState()
            # Join with previous line
            $prevLine = $this.Lines[$this.CursorY - 1]
            $currentLine = $this.Lines[$this.CursorY]
            $this.CursorX = $prevLine.Length
            $this.Lines[$this.CursorY - 1] = $prevLine + $currentLine
            $this.Lines.RemoveAt($this.CursorY)
            $this.CursorY--
        }
        
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Delete() {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.CursorX -lt $line.Length) {
            # Save undo state if this is first edit on this line
            if ($this.ShouldSaveUndoForLine()) {
                $this.SaveUndoState()
            }
            # Delete character at cursor
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX, 1)
        } elseif ($this.CursorY -lt $this.Lines.Count - 1) {
            # Always save undo state before joining lines
            $this.SaveUndoState()
            # Join with next line
            $nextLine = $this.Lines[$this.CursorY + 1]
            $this.Lines[$this.CursorY] = $line + $nextLine
            $this.Lines.RemoveAt($this.CursorY + 1)
        }
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] InsertTab() {
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
    
    [void] PageUp() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] PageDown() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Min($this.Lines.Count - 1, $this.CursorY + $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] EnsureCursorVisible() {
        $editorHeight = $this.Height - 6
        $editorWidth = $this.Width - $this.LineNumberWidth
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # When bounds change, ensure cursor is still visible
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096  # Text editor can have large content
        
        # Get theme colors
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
        $lineNumColor = if ($this.Theme) { $this.Theme.GetColor("linenumber") } else { $fgColor }
        $statusBg = if ($this.Theme) { $this.Theme.GetBgColor("status") } else { $bgColor }
        $statusFg = if ($this.Theme) { $this.Theme.GetColor("status.foreground") } else { $fgColor }
        $cursorBg = if ($this.Theme) { $this.Theme.GetBgColor("cursor") } else { $fgColor }
        
        # Calculate content area
        $contentHeight = $this.Height - 3  # Reserve space for title and status
        $contentWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartX = $this.X + ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartY = $this.Y + 1
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        # Draw title
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        $titleText = $this.Title
        if ($this.Modified) { $titleText += " *" }
        $titleText = $titleText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($titleText)
        
        # Render text lines
        $endY = [Math]::Min($this.ScrollOffsetY + $contentHeight, $this.Lines.Count)
        for ($lineIdx = $this.ScrollOffsetY; $lineIdx -lt $endY; $lineIdx++) {
            $screenY = $contentStartY + ($lineIdx - $this.ScrollOffsetY)
            $line = $this.Lines[$lineIdx]
            
            # Draw line numbers if enabled
            if ($this.ShowLineNumbers) {
                $sb.Append([VT]::MoveTo($this.X, $screenY))
                $sb.Append($lineNumColor)
                $lineNum = ($lineIdx + 1).ToString().PadLeft($this.LineNumberWidth - 1) + " "
                $sb.Append($lineNum)
            }
            
            # Draw line content
            $sb.Append([VT]::MoveTo($contentStartX, $screenY))
            $sb.Append($fgColor)
            
            if ($line.Length -gt $this.ScrollOffsetX) {
                $visibleText = $line.Substring($this.ScrollOffsetX)
                if ($visibleText.Length -gt $contentWidth) {
                    $visibleText = $visibleText.Substring(0, $contentWidth)
                }
                $sb.Append($visibleText)
            }
        }
        
        # Draw cursor if this screen is focused
        if ($this.IsFocused) {
            $cursorScreenX = $contentStartX + ($this.CursorX - $this.ScrollOffsetX)
            $cursorScreenY = $contentStartY + ($this.CursorY - $this.ScrollOffsetY)
            
            # Only draw cursor if it's visible
            if ($cursorScreenX -ge $contentStartX -and $cursorScreenX -lt $contentStartX + $contentWidth -and
                $cursorScreenY -ge $contentStartY -and $cursorScreenY -lt $contentStartY + $contentHeight) {
                
                $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
                $sb.Append($cursorBg)
                
                # Get character under cursor
                $charUnderCursor = " "
                if ($this.CursorY -lt $this.Lines.Count) {
                    $line = $this.Lines[$this.CursorY]
                    if ($this.CursorX -lt $line.Length) {
                        $charUnderCursor = $line[$this.CursorX]
                    }
                }
                $sb.Append($charUnderCursor)
            }
        }
        
        # Draw status line
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        
        $statusText = ""
        if ($this.StatusMessage) {
            $statusText = $this.StatusMessage
        } else {
            $modeText = if ($this.InTextMode) { "[TEXT]" } else { "[COMMAND]" }
            $statusText = "$modeText Line $($this.CursorY + 1), Col $($this.CursorX + 1)"
            if ($this.FilePath) {
                $statusText += " | $([System.IO.Path]::GetFileName($this.FilePath))"
            }
        }
        $statusText = $statusText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($statusText)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}


####\Screens/TextEditorScreenNew.ps1
# TextEditorScreenNew.ps1 - Refactored text editor with Buffer/View architecture
# Implements the professional architecture from the upgrade plan

class TextEditorScreenNew : Screen {
    # Buffer/View separation - DocumentBuffer handles all text logic
    hidden [DocumentBuffer]$_buffer
    
    # Cursor and viewport state (UI concerns only)
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$StatusMessage = ""
    
    # Line-level render cache for performance
    hidden [hashtable]$_lineRenderCache
    hidden [hashtable]$_dirtyLines
    hidden [bool]$_allLinesDirty = $true
    
    # Selection state for block selection
    [bool]$HasSelection = $false
    [int]$SelectionStartX = 0
    [int]$SelectionStartY = 0
    [int]$SelectionEndX = 0
    [int]$SelectionEndY = 0
    [bool]$InSelectionMode = $false
    
    # PRAXIS service integration
    hidden [object]$ThemeManager
    hidden [object]$EventBus
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    [bool]$AutoSaveOnFocusLoss = $true
    
    # Clipboard system
    hidden [string]$_clipboard = ""
    
    TextEditorScreenNew() : base() {
        $this.Title = "Text Editor"
        $this._buffer = [DocumentBuffer]::new()
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        
        # Add some sample content for testing
        $this.AddSampleContent()
    }
    
    TextEditorScreenNew([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this._buffer = [DocumentBuffer]::new($filePath)
        $this.InitializeRenderCache()
        $this.SetupBufferEventHandlers()
        $this.IsFocusable = $true
        $this.UpdateTitle()
    }
    
    [void] OnInitialize() {
        # Get PRAXIS services
        $this.ThemeManager = $this.ServiceContainer.GetService("ThemeManager")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
    }
    
    hidden [void] InitializeRenderCache() {
        $this._lineRenderCache = @{}
        $this._dirtyLines = @{}
    }
    
    hidden [void] SetupBufferEventHandlers() {
        # Buffer notifies us when content changes
        $screen = $this
        $this._buffer.OnContentChanged = {
            $screen.OnBufferContentChanged()
        }.GetNewClosure()
        
        $this._buffer.OnModifiedStateChanged = {
            param($isModified)
            $screen.OnBufferModifiedStateChanged($isModified)
        }.GetNewClosure()
    }
    
    hidden [void] OnBufferContentChanged() {
        # Mark lines dirty based on buffer's dirty tracking
        for ($i = 0; $i -lt $this._buffer.GetLineCount(); $i++) {
            if ($this._buffer.IsLineDirty($i)) {
                $this._dirtyLines[$i] = $true
            }
        }
        $this.Invalidate()
    }
    
    hidden [void] OnBufferModifiedStateChanged([bool]$isModified) {
        $this.UpdateTitle()
        $this.Invalidate()
    }
    
    hidden [void] UpdateTitle() {
        $fileName = if ($this._buffer.FilePath) { 
            [System.IO.Path]::GetFileName($this._buffer.FilePath) 
        } else { 
            "Untitled" 
        }
        $modifiedIndicator = if ($this._buffer.IsModified) { "*" } else { "" }
        $this.Title = "Text Editor - $fileName$modifiedIndicator"
    }
    
    hidden [void] AddSampleContent() {
        # Add some sample content to test the editor
        $sampleLines = @(
            "Welcome to PRAXIS Text Editor!",
            "",
            "This is the new Buffer/View architecture with:",
            "‚Ä¢ Command Pattern for robust undo/redo",
            "‚Ä¢ Line-level render caching for performance", 
            "‚Ä¢ Proper Buffer/View separation",
            "",
            "Try typing text, using arrow keys, or:",
            "‚Ä¢ Ctrl+Z to undo",
            "‚Ä¢ Ctrl+Y to redo", 
            "‚Ä¢ Ctrl+S to save (when implemented)",
            "",
            "The architecture is now professional-grade!"
        )
        
        # Clear the default empty line and add sample content directly
        # This bypasses the command system intentionally so it doesn't affect undo
        $this._buffer.Lines.Clear()
        foreach ($line in $sampleLines) {
            $this._buffer.Lines.Add($line) | Out-Null
        }
        
        # Clear the undo/redo stacks since this is initial content
        $this._buffer.ClearUndoHistory()
        $this._buffer.IsModified = $false
        
        $this._allLinesDirty = $true
    }
    
    # --- Input Handling - Translates keys to commands ---
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Handle special keys first
        if ($this.HandleSpecialKeys($keyInfo)) {
            return $true
        }
        
        # Handle character insertion
        if ($keyInfo.KeyChar -and -not [char]::IsControl($keyInfo.KeyChar)) {
            $this.InsertCharacter($keyInfo.KeyChar)
            return $true
        }
        
        return $false
    }
    
    hidden [bool] HandleSpecialKeys([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Backspace) {
                $this.HandleBackspace()
                return $true
            }
            ([System.ConsoleKey]::Delete) {
                $this.HandleDelete()
                return $true
            }
            ([System.ConsoleKey]::Enter) {
                $this.HandleEnter()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                $this.HandleTab()
                return $true
            }
            ([System.ConsoleKey]::LeftArrow) {
                $this.MoveCursorLeft($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::RightArrow) {
                $this.MoveCursorRight($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::UpArrow) {
                $this.MoveCursorUp($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::DownArrow) {
                $this.MoveCursorDown($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::Home) {
                $this.MoveCursorHome($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::End) {
                $this.MoveCursorEnd($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::PageUp) {
                $this.MoveCursorPageUp($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
            ([System.ConsoleKey]::PageDown) {
                $this.MoveCursorPageDown($keyInfo.Modifiers -band [System.ConsoleModifiers]::Shift)
                return $true
            }
        }
        
        # Handle Ctrl combinations
        if ($keyInfo.Modifiers -band [System.ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([System.ConsoleKey]::S) {
                    $this.SaveFile()
                    return $true
                }
                ([System.ConsoleKey]::O) {
                    $this.OpenFile()
                    return $true
                }
                ([System.ConsoleKey]::N) {
                    $this.NewFile()
                    return $true
                }
                ([System.ConsoleKey]::Z) {
                    # EMERGENCY FIX: Disable Ctrl+Z entirely to prevent crashes
                    if ($global:Logger) {
                        $global:Logger.Debug("Ctrl+Z pressed - disabled to prevent crashes")
                    }
                    $this.StatusMessage = "Ctrl+Z disabled due to crashes"
                    return $true
                }
                ([System.ConsoleKey]::Y) {
                    # EMERGENCY FIX: Disable Ctrl+Y as well to prevent crashes
                    if ($global:Logger) {
                        $global:Logger.Debug("Ctrl+Y pressed - disabled to prevent crashes")
                    }
                    $this.StatusMessage = "Ctrl+Y disabled due to crashes"
                    return $true
                }
                ([System.ConsoleKey]::C) {
                    $this.CopySelection()
                    return $true
                }
                ([System.ConsoleKey]::X) {
                    $this.CutSelection()
                    return $true
                }
                ([System.ConsoleKey]::V) {
                    $this.PasteClipboard()
                    return $true
                }
                ([System.ConsoleKey]::A) {
                    $this.SelectAll()
                    return $true
                }
            }
        }
        
        return $false
    }
    
    # --- Text Editing Operations (Command Pattern) ---
    
    hidden [void] InsertCharacter([char]$char) {
        # EMERGENCY FIX: Bypass Command Pattern to prevent crashes
        try {
            if ($global:Logger) {
                $global:Logger.Debug("InsertCharacter: Inserting '$char' at ($($this.CursorX),$($this.CursorY))")
            }
            
            # Direct insertion without Command Pattern
            $this._buffer.InsertTextAt($this.CursorY, $this.CursorX, [string]$char)
            $this.CursorX++
            
            # Mark as modified
            $this._buffer.IsModified = $true
            
            # Mark rendering dirty
            $this._allLinesDirty = $true
            if ($this._lineRenderCache) {
                $this._lineRenderCache.Clear()
            }
            
            $this.EnsureCursorVisible()
            $this.Invalidate()
            
            if ($global:Logger) {
                $global:Logger.Debug("InsertCharacter: Successfully inserted '$char'")
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("InsertCharacter failed: $($_.Exception.Message)")
            }
            $this.StatusMessage = "Character insertion failed"
        }
    }
    
    hidden [void] HandleBackspace() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
            return
        }
        
        if ($this.CursorX -gt 0) {
            # Delete character before cursor
            $charToDelete = $this._buffer.GetTextAt($this.CursorY, $this.CursorX - 1, 1)
            $command = [DeleteTextCommand]::new($this.CursorY, $this.CursorX - 1, $charToDelete)
            $this._buffer.ExecuteCommand($command)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Join with previous line
            $prevLineLength = $this._buffer.GetLine($this.CursorY - 1).Length
            $currentLineText = $this._buffer.GetLine($this.CursorY)
            $command = [JoinLinesCommand]::new($this.CursorY - 1, $currentLineText)
            $this._buffer.ExecuteCommand($command)
            $this.CursorY--
            $this.CursorX = $prevLineLength
        }
        $this.EnsureCursorVisible()
    }
    
    hidden [void] HandleDelete() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
            return
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        if ($this.CursorX -lt $currentLine.Length) {
            # Delete character at cursor
            $charToDelete = $this._buffer.GetTextAt($this.CursorY, $this.CursorX, 1)
            $command = [DeleteTextCommand]::new($this.CursorY, $this.CursorX, $charToDelete)
            $this._buffer.ExecuteCommand($command)
        } elseif ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            # Join with next line
            $nextLineText = $this._buffer.GetLine($this.CursorY + 1)
            $command = [JoinLinesCommand]::new($this.CursorY, $nextLineText)
            $this._buffer.ExecuteCommand($command)
        }
    }
    
    hidden [void] HandleEnter() {
        if ($this.HasSelection) {
            $this.DeleteSelection()
        }
        
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $rightText = $currentLine.Substring($this.CursorX)
        $command = [InsertNewlineCommand]::new($this.CursorY, $this.CursorX, $rightText)
        $this._buffer.ExecuteCommand($command)
        $this.CursorY++
        $this.CursorX = 0
        $this.EnsureCursorVisible()
        $this.ClearSelection()
    }
    
    hidden [void] HandleTab() {
        $spaces = " " * $this.TabWidth
        $command = [InsertTextCommand]::new($this.CursorY, $this.CursorX, $spaces)
        $this._buffer.ExecuteCommand($command)
        $this.CursorX += $this.TabWidth
        $this.EnsureCursorVisible()
    }
    
    # --- File Operations ---
    
    [void] SaveFile([string]$filePath = "") {
        try {
            if ([string]::IsNullOrEmpty($filePath)) {
                $filePath = $this._buffer.FilePath
            }
            if ([string]::IsNullOrEmpty($filePath)) {
                # TODO: Open file dialog
                $this.StatusMessage = "No file path specified"
                return
            }
            
            $this._buffer.SaveToFile($filePath)
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($filePath))"
            $this.UpdateTitle()
        } catch {
            $this.StatusMessage = "Error saving file: $($_.Exception.Message)"
        }
    }
    
    [void] OpenFile([string]$filePath = "") {
        # TODO: Implement file dialog
        $this.StatusMessage = "Open file not yet implemented"
    }
    
    [void] NewFile() {
        $this._buffer = [DocumentBuffer]::new()
        $this.SetupBufferEventHandlers()
        $this.CursorX = 0
        $this.CursorY = 0
        $this.ScrollOffsetX = 0
        $this.ScrollOffsetY = 0
        $this.ClearSelection()
        $this._allLinesDirty = $true
        $this._lineRenderCache.Clear()
        $this.UpdateTitle()
        $this.StatusMessage = "New file created"
        $this.Invalidate()
    }
    
    # --- Undo/Redo ---
    
    [void] UndoEdit() {
        # EMERGENCY FIX: Disable undo entirely to prevent crashes
        # This is a temporary workaround until the root cause is found
        $this.StatusMessage = "Undo temporarily disabled due to crashes"
        
        if ($global:Logger) {
            $global:Logger.Debug("UndoEdit: Undo disabled to prevent crashes")
        }
        
        return
        
        # TODO: Investigate why undo causes immediate crashes
        # All defensive programming attempts have failed
        # The crash happens before any logging executes
        # Likely a PowerShell runtime or memory issue
    }
    
    [void] RedoEdit() {
        if ($this._buffer.CanRedo()) {
            try {
                $this._buffer.Redo()
                $this.ClearSelection()
                $this._allLinesDirty = $true
                $this._lineRenderCache.Clear()
                
                # Ensure cursor position is valid after redo
                $this.ValidateCursorPosition()
                $this.EnsureCursorVisible()
                $this.StatusMessage = "Redo"
            } catch {
                # If redo fails, log error and reset to safe state
                if ($global:Logger) {
                    $global:Logger.Error("RedoEdit failed: $($_.Exception.Message)")
                }
                $this.StatusMessage = "Redo failed"
                $this.ValidateCursorPosition()
                $this._allLinesDirty = $true
                $this._lineRenderCache.Clear()
                $this.Invalidate()
            }
        } else {
            $this.StatusMessage = "Nothing to redo"
        }
    }
    
    # --- Selection and Clipboard (Stub implementations) ---
    
    hidden [void] ClearSelection() {
        $this.HasSelection = $false
        $this.InSelectionMode = $false
    }
    
    hidden [void] DeleteSelection() {
        # TODO: Implement selection deletion
        $this.ClearSelection()
    }
    
    [void] CopySelection() {
        # TODO: Implement copy
        $this.StatusMessage = "Copy not yet implemented"
    }
    
    [void] CutSelection() {
        # TODO: Implement cut
        $this.StatusMessage = "Cut not yet implemented"
    }
    
    [void] PasteClipboard() {
        # TODO: Implement paste
        $this.StatusMessage = "Paste not yet implemented"
    }
    
    [void] SelectAll() {
        # TODO: Implement select all
        $this.StatusMessage = "Select All not yet implemented"
    }
    
    # --- Cursor Movement (Stub implementations) ---
    
    hidden [void] MoveCursorLeft([bool]$extend) {
        if ($this.CursorX -gt 0) {
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            $this.CursorY--
            $this.CursorX = $this._buffer.GetLine($this.CursorY).Length
        }
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorRight([bool]$extend) {
        $currentLine = $this._buffer.GetLine($this.CursorY)
        if ($this.CursorX -lt $currentLine.Length) {
            $this.CursorX++
        } elseif ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            $this.CursorY++
            $this.CursorX = 0
        }
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorUp([bool]$extend) {
        if ($this.CursorY -gt 0) {
            $this.CursorY--
            $prevLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Min($this.CursorX, $prevLine.Length)
        }
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorDown([bool]$extend) {
        if ($this.CursorY -lt $this._buffer.GetLineCount() - 1) {
            $this.CursorY++
            $nextLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Min($this.CursorX, $nextLine.Length)
        }
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorHome([bool]$extend) {
        $this.CursorX = 0
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorEnd([bool]$extend) {
        $this.CursorX = $this._buffer.GetLine($this.CursorY).Length
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorPageUp([bool]$extend) {
        $pageSize = $this.Height - 4
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.EnsureCursorVisible()
    }
    
    hidden [void] MoveCursorPageDown([bool]$extend) {
        $pageSize = $this.Height - 4
        $this.CursorY = [Math]::Min($this._buffer.GetLineCount() - 1, $this.CursorY + $pageSize)
        $this.EnsureCursorVisible()
    }
    
    hidden [void] ValidateCursorPosition() {
        # Ensure cursor is within valid bounds
        $lineCount = $this._buffer.GetLineCount()
        if ($lineCount -eq 0) {
            $this.CursorX = 0
            $this.CursorY = 0
            return
        }
        
        # Clamp cursor Y to valid range
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.CursorY, $lineCount - 1))
        
        # Clamp cursor X to current line length
        try {
            $currentLine = $this._buffer.GetLine($this.CursorY)
            $this.CursorX = [Math]::Max(0, [Math]::Min($this.CursorX, $currentLine.Length))
        } catch {
            # If we can't get the line, reset cursor to safe position
            $this.CursorX = 0
            $this.CursorY = 0
        }
    }
    
    hidden [void] EnsureCursorVisible() {
        # Implement viewport scrolling to keep cursor visible
        $editorHeight = $this.Height - 2  # Account for status line
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        $editorWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
        
        # Ensure scroll offsets are valid
        $this.ScrollOffsetY = [Math]::Max(0, $this.ScrollOffsetY)
        $this.ScrollOffsetX = [Math]::Max(0, $this.ScrollOffsetX)
        
        $this.Invalidate()
    }
    
    # --- Optimized Rendering with Line-Level Caching ---
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096
        
        # Render with line caching for performance
        $this.RenderWithCache($sb)
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    hidden [void] RenderWithCache([System.Text.StringBuilder]$sb) {
        # Clear the entire screen area first with background color
        $bgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("background") } else { "" }
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        # Calculate editor area
        $editorHeight = $this.Height - 1  # Reserve bottom for status
        $editorWidth = $this.Width
        $lineNumWidth = if ($this.ShowLineNumbers) { $this.LineNumberWidth } else { 0 }
        $textWidth = $editorWidth - $lineNumWidth
        
        # Render visible lines with caching
        $startLine = $this.ScrollOffsetY
        $endLine = [Math]::Min($startLine + $editorHeight, $this._buffer.GetLineCount())
        
        for ($lineIndex = $startLine; $lineIndex -lt $endLine; $lineIndex++) {
            $y = $lineIndex - $startLine
            $renderLine = ""
            
            # Check if line needs re-rendering
            if ($this._allLinesDirty -or $this._dirtyLines.ContainsKey($lineIndex) -or -not $this._lineRenderCache.ContainsKey($lineIndex)) {
                # Render line from scratch
                $renderLine = $this.RenderLine($lineIndex, $lineNumWidth, $textWidth)
                $this._lineRenderCache[$lineIndex] = $renderLine
            } else {
                # Use cached version
                $renderLine = $this._lineRenderCache[$lineIndex]
            }
            
            # Output the line
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($renderLine)
        }
        
        # Clear dirty flags
        $this._buffer.ClearDirtyLines()
        $this._dirtyLines.Clear()
        $this._allLinesDirty = $false
        
        # TODO: Render cursor (need to implement cursor positioning)
        
        # Render status line
        $statusY = $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $this.Y + $statusY))
        $statusColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("status") } else { "" }
        $statusBgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("status") } else { "" }
        $sb.Append($statusBgColor)
        $sb.Append($statusColor)
        $statusText = $this.GetStatusText()
        $sb.Append($statusText.PadRight($this.Width).Substring(0, $this.Width))
    }
    
    hidden [string] RenderLine([int]$lineNumber, [int]$lineNumberWidth, [int]$textWidth) {
        $sb = [System.Text.StringBuilder]::new()
        
        # Get colors
        $textColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("normal") } else { "" }
        $lineNumColor = if ($this.ThemeManager) { $this.ThemeManager.GetColor("linenumber") } else { $textColor }
        $bgColor = if ($this.ThemeManager) { $this.ThemeManager.GetBgColor("background") } else { "" }
        
        # Apply background color
        $sb.Append($bgColor)
        
        # Line number
        if ($this.ShowLineNumbers) {
            $sb.Append($lineNumColor)
            $lineNumText = ($lineNumber + 1).ToString().PadLeft($lineNumberWidth - 1) + " "
            $sb.Append($lineNumText)
        }
        
        # Line content with text color
        $sb.Append($textColor)
        $lineText = $this._buffer.GetLine($lineNumber)
        $visibleText = $lineText
        if ($this.ScrollOffsetX -gt 0 -and $this.ScrollOffsetX -lt $lineText.Length) {
            $visibleText = $lineText.Substring($this.ScrollOffsetX)
        } elseif ($this.ScrollOffsetX -ge $lineText.Length) {
            $visibleText = ""
        }
        
        if ($visibleText.Length -gt $textWidth) {
            $visibleText = $visibleText.Substring(0, $textWidth)
        }
        
        $sb.Append($visibleText)
        
        # Pad to full width
        $totalRendered = $lineNumberWidth + $visibleText.Length
        if ($totalRendered -lt $this.Width) {
            $sb.Append([StringCache]::GetSpaces($this.Width - $totalRendered))
        }
        
        return $sb.ToString()
    }
    
    hidden [string] GetStatusText() {
        $line = $this.CursorY + 1
        $col = $this.CursorX + 1
        $total = $this._buffer.GetLineCount()
        $modified = if ($this._buffer.IsModified) { " [Modified]" } else { "" }
        $undoStatus = ""
        if ($this._buffer.CanUndo()) {
            $undoStatus += " [Undo]"
        }
        if ($this._buffer.CanRedo()) {
            $undoStatus += " [Redo]"
        }
        
        $status = "Line $line/$total, Col $col$modified$undoStatus"
        if ($this.StatusMessage) {
            $status += " | $($this.StatusMessage)"
        }
        
        return $status
    }
}


####\Screens/TextInputDialog.ps1
# TextInputDialog.ps1 - Simple dialog for text input

class TextInputDialog : Screen {
    [string]$Prompt
    [string]$DefaultValue
    [string]$Placeholder
    [TextBox]$InputBox
    [Button]$OkButton
    [Button]$CancelButton
    [scriptblock]$OnSubmit = {}
    [scriptblock]$OnCancel = {}
    
    TextInputDialog([string]$prompt) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = ""
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    TextInputDialog([string]$prompt, [string]$defaultValue) : base() {
        $this.Title = "Input"
        $this.Prompt = $prompt
        $this.DefaultValue = $defaultValue
        $this.Placeholder = "Enter text..."
        $this.DrawBackground = $true
    }
    
    [void] OnInitialize() {
        # Create input textbox
        $this.InputBox = [TextBox]::new()
        $this.InputBox.Text = $this.DefaultValue
        $this.InputBox.Placeholder = $this.Placeholder
        $this.InputBox.Initialize($global:ServiceContainer)
        $this.AddChild($this.InputBox)
        
        # Create buttons
        $this.OkButton = [Button]::new("OK")
        # Capture dialog reference
        $dialog = $this
        $this.OkButton.OnClick = {
            if ($dialog.OnSubmit) {
                & $dialog.OnSubmit $dialog.InputBox.Text
            }
        }.GetNewClosure()
        $this.OkButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.OkButton)
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = {
            if ($dialog.OnCancel) {
                & $dialog.OnCancel
            }
        }.GetNewClosure()
        $this.CancelButton.Initialize($global:ServiceContainer)
        $this.AddChild($this.CancelButton)
        
        # Key bindings
        $this.BindKey([System.ConsoleKey]::Escape, { 
            if ($this.OnCancel) {
                & $this.OnCancel
            }
        })
        $this.BindKey([System.ConsoleKey]::Tab, { $this.FocusNext() })
        $this.BindKey([System.ConsoleKey]::Enter, {
            $focused = $this.FindFocused()
            if ($focused -eq $this.InputBox -or $focused -eq $this.OkButton) {
                & $this.OkButton.OnClick
            } elseif ($focused -eq $this.CancelButton) {
                & $this.CancelButton.OnClick
            }
        })
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        # Focus on input box and select all text
        $this.InputBox.Focus()
        # TODO: Add SelectAll method to TextBox
    }
    
    [void] OnBoundsChanged() {
        # Calculate dialog dimensions based on prompt
        $promptLines = $this.Prompt -split "`n"
        $maxLineLength = ($promptLines | ForEach-Object { $_.Length } | Measure-Object -Maximum).Maximum
        $dialogWidth = [Math]::Max(50, $maxLineLength + 8)
        $dialogHeight = 10 + $promptLines.Count
        $centerX = [int](($this.Width - $dialogWidth) / 2)
        $centerY = [int](($this.Height - $dialogHeight) / 2)
        
        # Position components
        $this.InputBox.SetBounds($centerX + 2, $centerY + 2 + $promptLines.Count + 1, $dialogWidth - 4, 3)
        
        # Position buttons (use similar logic to ProjectsScreen)
        $buttonY = $centerY + $dialogHeight - 4
        $buttonHeight = 3
        $buttonSpacing = 2
        $maxButtonWidth = 10
        $totalButtonWidth = ($maxButtonWidth * 2) + $buttonSpacing
        
        # Center buttons if dialog is wide enough
        if ($dialogWidth -gt $totalButtonWidth) {
            $buttonStartX = $centerX + [int](($dialogWidth - $totalButtonWidth) / 2)
            $buttonWidth = $maxButtonWidth
        } else {
            $buttonStartX = $centerX + 2
            $buttonWidth = [int](($dialogWidth - 4 - $buttonSpacing) / 2)
        }
        
        $this.OkButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        # Store dialog bounds for rendering
        $this._dialogBounds = @{
            X = $centerX
            Y = $centerY
            Width = $dialogWidth
            Height = $dialogHeight
        }
    }
    
    hidden [hashtable]$_dialogBounds
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 2048
        
        # First, clear the entire screen with a dark overlay
        $overlayBg = [VT]::RGBBG(16, 16, 16)  # Dark gray overlay
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo(0, $y))
            $sb.Append($overlayBg)
            $sb.Append([StringCache]::GetSpaces($this.Width))
        }
        
        if ($this._dialogBounds) {
            # Draw dialog box
            $borderColor = $this.Theme.GetColor("dialog.border")
            $bgColor = $this.Theme.GetBgColor("dialog.background")
            $titleColor = $this.Theme.GetColor("dialog.title")
            
            $x = $this._dialogBounds.X
            $y = $this._dialogBounds.Y
            $w = $this._dialogBounds.Width
            $h = $this._dialogBounds.Height
            
            # Fill background
            for ($i = 0; $i -lt $h; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append($bgColor)
                $sb.Append([StringCache]::GetSpaces($w))
            }
            
            # Draw border
            $sb.Append([VT]::MoveTo($x, $y))
            $sb.Append($borderColor)
            $sb.Append([VT]::TL() + ([VT]::H() * ($w - 2)) + [VT]::TR())
            
            for ($i = 1; $i -lt $h - 1; $i++) {
                $sb.Append([VT]::MoveTo($x, $y + $i))
                $sb.Append([VT]::V())
                $sb.Append([VT]::MoveTo($x + $w - 1, $y + $i))
                $sb.Append([VT]::V())
            }
            
            $sb.Append([VT]::MoveTo($x, $y + $h - 1))
            $sb.Append([VT]::BL() + ([VT]::H() * ($w - 2)) + [VT]::BR())
            
            # Draw title
            $title = " $($this.Title) "
            $titleX = $x + [int](($w - $title.Length) / 2)
            $sb.Append([VT]::MoveTo($titleX, $y))
            $sb.Append($titleColor)
            $sb.Append($title)
            
            # Draw prompt
            $promptLines = $this.Prompt -split "`n"
            $promptY = $y + 2
            $sb.Append($this.Theme.GetColor("foreground"))
            foreach ($line in $promptLines) {
                $lineX = $x + 2
                $sb.Append([VT]::MoveTo($lineX, $promptY))
                $sb.Append($line)
                $promptY++
            }
        }
        
        # Render children
        foreach ($child in $this.Children) {
            if ($child.Visible) {
                $sb.Append($child.Render())
            }
        }
        
        $sb.Append([VT]::Reset())
        
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
    
    [void] FocusNext() {
        $focusableChildren = $this.Children | Where-Object { $_.IsFocusable -and $_.Visible }
        if ($focusableChildren.Count -eq 0) { return }
        
        $currentIndex = -1
        for ($i = 0; $i -lt $focusableChildren.Count; $i++) {
            if ($focusableChildren[$i].IsFocused) {
                $currentIndex = $i
                break
            }
        }
        
        $nextIndex = ($currentIndex + 1) % $focusableChildren.Count
        $focusableChildren[$nextIndex].Focus()
    }
}


####\Screens/TimeEntryDialog.ps1
# TimeEntryDialog - Dialog for adding/editing time entries
# Based on tracker.txt time tracking structure

class TimeEntryDialog : BaseDialog {
    [Project]$Project = $null
    [PSCustomObject]$TimeEntry = $null  # For editing existing entries
    [bool]$IsEditMode = $false
    
    # Input fields
    [TextBox]$DateTextBox
    [TextBox]$HoursTextBox
    [TextBox]$DescriptionTextBox
    
    # Buttons
    [Button]$SaveButton
    [Button]$CancelButton
    
    # Callbacks
    [scriptblock]$OnSave = {}
    [scriptblock]$OnCancel = {}
    
    TimeEntryDialog() : base("Add Time Entry") {
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project) : base("Add Time Entry") {
        $this.Project = $project
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    TimeEntryDialog([Project]$project, [PSCustomObject]$timeEntry) : base("Edit Time Entry") {
        $this.Project = $project
        $this.TimeEntry = $timeEntry
        $this.IsEditMode = $true
        $this.PrimaryButtonText = "Save"
        $this.SecondaryButtonText = "Cancel"
    }
    
    [void] InitializeContent() {
        # Create input fields
        $this.DateTextBox = [TextBox]::new()
        $this.DateTextBox.Title = "Date (MM/DD/YYYY)"
        $this.DateTextBox.ShowBorder = $true
        
        # Set default date to today
        if (-not $this.IsEditMode) {
            $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
        } else {
            # Convert from YYYYMMDD format to MM/dd/yyyy
            try {
                $entryDate = [DateTime]::ParseExact($this.TimeEntry.Date, "yyyyMMdd", $null)
                $this.DateTextBox.Text = $entryDate.ToString("MM/dd/yyyy")
            } catch {
                $this.DateTextBox.Text = (Get-Date).ToString("MM/dd/yyyy")
            }
        }
        
        $this.HoursTextBox = [TextBox]::new()
        $this.HoursTextBox.Title = "Hours (e.g., 8.5)"
        $this.HoursTextBox.ShowBorder = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Total) {
            $this.HoursTextBox.Text = $this.TimeEntry.Total
        }
        
        $this.DescriptionTextBox = [TextBox]::new()
        $this.DescriptionTextBox.Title = "Description"
        $this.DescriptionTextBox.ShowBorder = $true
        $this.DescriptionTextBox.IsMultiline = $true
        
        if ($this.IsEditMode -and $this.TimeEntry.Description) {
            $this.DescriptionTextBox.Text = $this.TimeEntry.Description
        }
        
        # Initialize components
        if ($this.ServiceContainer) {
            $this.DateTextBox.Initialize($this.ServiceContainer)
            $this.HoursTextBox.Initialize($this.ServiceContainer)
            $this.DescriptionTextBox.Initialize($this.ServiceContainer)
        }
        
        # Create buttons
        $saveText = if ($this.IsEditMode) { "Update Entry" } else { "Add Entry" }
        $this.SaveButton = [Button]::new($saveText)
        $this.SaveButton.IsDefault = $true
        $this.SaveButton.OnClick = { $this.HandleSave() }
        
        $this.CancelButton = [Button]::new("Cancel")
        $this.CancelButton.OnClick = { $this.HandleCancel() }
        
        if ($this.ServiceContainer) {
            $this.SaveButton.Initialize($this.ServiceContainer)
            $this.CancelButton.Initialize($this.ServiceContainer)
        }
        
        # Add children
        $this.AddChild($this.DateTextBox)
        $this.AddChild($this.HoursTextBox)
        $this.AddChild($this.DescriptionTextBox)
        $this.AddChild($this.SaveButton)
        $this.AddChild($this.CancelButton)
        
        # Set initial focus
        $this.DateTextBox.Focus()
    }
    
    [void] OnBoundsChanged() {
        # Layout: Stack inputs vertically with buttons at bottom
        $margin = 2
        $buttonHeight = 3
        $inputHeight = 3
        $descriptionHeight = 5
        
        $currentY = $this.Y + $margin
        $inputWidth = $this.Width - ($margin * 2)
        
        # Date input
        $this.DateTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Hours input
        $this.HoursTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $inputHeight
        )
        $currentY += $inputHeight + 1
        
        # Description input (taller)
        $this.DescriptionTextBox.SetBounds(
            $this.X + $margin,
            $currentY,
            $inputWidth,
            $descriptionHeight
        )
        $currentY += $descriptionHeight + 2
        
        # Buttons at bottom
        $buttonWidth = 15
        $buttonSpacing = 4
        $totalButtonWidth = ($buttonWidth * 2) + $buttonSpacing
        $buttonStartX = $this.X + [int](($this.Width - $totalButtonWidth) / 2)
        $buttonY = $this.Y + $this.Height - $buttonHeight - 1
        
        $this.SaveButton.SetBounds(
            $buttonStartX,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
        
        $this.CancelButton.SetBounds(
            $buttonStartX + $buttonWidth + $buttonSpacing,
            $buttonY,
            $buttonWidth,
            $buttonHeight
        )
    }
    
    [void] HandleSave() {
        # Validate inputs
        $validationError = $this.ValidateInputs()
        if ($validationError) {
            # In a real implementation, show error dialog
            # For now, just return
            return
        }
        
        # Create time entry data
        $timeEntryData = $this.CreateTimeEntryData()
        
        if ($this.OnSave) {
            & $this.OnSave $timeEntryData
        }
    }
    
    [void] HandleCancel() {
        if ($this.OnCancel) {
            & $this.OnCancel
        }
    }
    
    [string] ValidateInputs() {
        # Validate date
        $dateStr = $this.DateTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($dateStr)) {
            return "Date is required"
        }
        
        try {
            [DateTime]::Parse($dateStr) | Out-Null
        } catch {
            return "Invalid date format. Use MM/DD/YYYY"
        }
        
        # Validate hours
        $hoursStr = $this.HoursTextBox.Text.Trim()
        if ([string]::IsNullOrEmpty($hoursStr)) {
            return "Hours is required"
        }
        
        $hours = 0.0
        if (-not [double]::TryParse($hoursStr, [ref]$hours) -or $hours -le 0) {
            return "Hours must be a positive number"
        }
        
        return $null  # No validation errors
    }
    
    [PSCustomObject] CreateTimeEntryData() {
        # Parse and format date to YYYYMMDD
        $entryDate = [DateTime]::Parse($this.DateTextBox.Text.Trim())
        $internalDate = $entryDate.ToString("yyyyMMdd")
        
        # Parse hours
        $hours = [double]::Parse($this.HoursTextBox.Text.Trim())
        
        # Get day of week for hour distribution
        $dayOfWeek = $entryDate.DayOfWeek
        
        # Create time entry following tracker.txt structure
        $newTimeEntry = [PSCustomObject]@{
            Date = $internalDate
            Nickname = $this.Project.Nickname
            ID1 = if ($this.Project.ID1) { $this.Project.ID1 } else { "" }
            ID2 = $this.FormatID2($this.Project.ID2)
            MonHours = if ($dayOfWeek -eq "Monday") { $hours.ToString("F2") } else { "" }
            TueHours = if ($dayOfWeek -eq "Tuesday") { $hours.ToString("F2") } else { "" }
            WedHours = if ($dayOfWeek -eq "Wednesday") { $hours.ToString("F2") } else { "" }
            ThuHours = if ($dayOfWeek -eq "Thursday") { $hours.ToString("F2") } else { "" }
            FriHours = if ($dayOfWeek -eq "Friday") { $hours.ToString("F2") } else { "" }
            Total = $hours.ToString("F2")
            Description = $this.DescriptionTextBox.Text.Trim()
        }
        
        return $newTimeEntry
    }
    
    [string] FormatID2([string]$id2) {
        # Format ID2 with V0 prefix, S suffix, padded to 12 characters
        # Following tracker.txt format
        if ([string]::IsNullOrWhiteSpace($id2)) {
            return ""
        }
        
        $id2Text = $id2.Trim()
        $paddingNeeded = 12 - ($id2Text.Length + 2)
        
        if ($paddingNeeded > 0) {
            return "V" + ("0" * $paddingNeeded) + $id2Text + "S"
        } else {
            return "V" + $id2Text + "S"
        }
    }
    
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        switch ($keyInfo.Key) {
            ([System.ConsoleKey]::Enter) {
                if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
                    $this.HandleSave()
                    return $true
                }
            }
            ([System.ConsoleKey]::Escape) {
                $this.HandleCancel()
                return $true
            }
            ([System.ConsoleKey]::Tab) {
                # Handle tab navigation between fields
                $focused = $this.FindFocused()
                if ($focused -eq $this.DateTextBox) {
                    $this.HoursTextBox.Focus()
                } elseif ($focused -eq $this.HoursTextBox) {
                    $this.DescriptionTextBox.Focus()
                } elseif ($focused -eq $this.DescriptionTextBox) {
                    $this.SaveButton.Focus()
                } else {
                    $this.DateTextBox.Focus()
                }
                return $true
            }
        }
        
        # Let base class handle other input
        return $false
    }
}


####\Screens/TimeEntryScreen.ps1
# TimeEntryScreen.ps1 - Time entry screen based on working ProjectsScreen

class TimeEntryScreen : Screen {
    [DataGrid]$TimeGrid
    [Button]$PrevWeekButton
    [Button]$NextWeekButton  
    [Button]$CurrentWeekButton
    [Button]$QuickEntryButton
    [DateTime]$CurrentWeekFriday
    [TimeTrackingService]$TimeService
    [ProjectService]$ProjectService
    [EventBus]$EventBus
    hidden [hashtable]$EventSubscriptions = @{}
    
    # Layout
    hidden [int]$ButtonHeight = 3
    hidden [int]$ButtonSpacing = 2
    
    TimeEntryScreen() : base() {
        $this.Title = "Time Entry"
    }
    
    [void] OnInitialize() {
        # Get services
        $this.TimeService = $this.ServiceContainer.GetService("TimeTrackingService")
        $this.ProjectService = $this.ServiceContainer.GetService("ProjectService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        
        # Set current week
        $this.CurrentWeekFriday = $this.TimeService.GetCurrentWeekFriday()
        
        # Subscribe to events
        if ($this.EventBus) {
            $screen = $this
            
            # Subscribe to time entry updates
            $this.EventSubscriptions['TimeEntryUpdated'] = $this.EventBus.Subscribe('timeentry.updated', {
                param($sender, $eventData)
                $screen.RefreshGrid()
            }.GetNewClosure())
        }
        
        # Create DataGrid with columns
        $this.TimeGrid = [DataGrid]::new()
        $this.TimeGrid.Title = $this.GetWeekTitle()
        $this.TimeGrid.ShowBorder = $true
        $this.TimeGrid.ShowGridLines = $true
        
        # Initialize the TimeGrid with ServiceContainer to get theme
        $this.TimeGrid.Initialize($this.ServiceContainer)
        
        # Define columns for time entry grid
        $columns = @(
            @{ Name = "Name"; Header = "Name"; Width = 30; Getter = { param($item) $item.Name } }
            @{ Name = "ID1"; Header = "ID1"; Width = 10; Getter = { param($item) $item.ID1 } }
            @{ Name = "ID2"; Header = "ID2"; Width = 15; Getter = { param($item) $item.ID2 } }
            @{ Name = "Monday"; Header = "Mon"; Width = 6; Getter = { param($item) if ($item.Monday -gt 0) { $item.Monday.ToString("F1") } else { "" } } }
            @{ Name = "Tuesday"; Header = "Tue"; Width = 6; Getter = { param($item) if ($item.Tuesday -gt 0) { $item.Tuesday.ToString("F1") } else { "" } } }
            @{ Name = "Wednesday"; Header = "Wed"; Width = 6; Getter = { param($item) if ($item.Wednesday -gt 0) { $item.Wednesday.ToString("F1") } else { "" } } }
            @{ Name = "Thursday"; Header = "Thu"; Width = 6; Getter = { param($item) if ($item.Thursday -gt 0) { $item.Thursday.ToString("F1") } else { "" } } }
            @{ Name = "Friday"; Header = "Fri"; Width = 6; Getter = { param($item) if ($item.Friday -gt 0) { $item.Friday.ToString("F1") } else { "" } } }
            @{ Name = "Total"; Header = "Total"; Width = 7; Getter = { param($item) $item.Total.ToString("F1") } }
        )
        $this.TimeGrid.SetColumns($columns)
        $this.AddChild($this.TimeGrid)
        
        # Create navigation buttons
        $screen = $this  # Capture reference for closures
        
        $this.PrevWeekButton = [Button]::new("< Prev Week")
        $this.PrevWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.PrevWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.PrevWeekButton)
        
        $this.CurrentWeekButton = [Button]::new("Current Week")
        $this.CurrentWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.TimeService.GetCurrentWeekFriday()
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.CurrentWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.CurrentWeekButton)
        
        $this.NextWeekButton = [Button]::new("Next Week >")
        $this.NextWeekButton.OnClick = { 
            $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
            $screen.RefreshGrid()
        }.GetNewClosure()
        $this.NextWeekButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.NextWeekButton)
        
        $this.QuickEntryButton = [Button]::new("Quick Entry (Q)")
        $this.QuickEntryButton.IsDefault = $true
        $this.QuickEntryButton.OnClick = { $screen.ShowQuickEntry() }.GetNewClosure()
        $this.QuickEntryButton.Initialize($this.ServiceContainer)
        $this.AddChild($this.QuickEntryButton)
        
        # Load initial data
        $this.RefreshGrid()
        
        # Focus the grid
        if ($this.TimeGrid.Items.Count -gt 0) {
            $this.TimeGrid.Focus()
        }
        
        # Register shortcuts
        $this.RegisterShortcuts()
    }
    
    [void] OnBoundsChanged() {
        if (-not $this.TimeGrid) { return }
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnBoundsChanged: Bounds=($($this.X),$($this.Y),$($this.Width),$($this.Height))")
        }
        
        # Calculate layout
        $gridHeight = $this.Height - $this.ButtonHeight - 1
        
        # Position grid - use relative positioning within the screen bounds
        $this.TimeGrid.SetBounds(0, 0, $this.Width, $gridHeight)
        
        # Position buttons at bottom
        $buttonY = $this.Y + $this.Height - $this.ButtonHeight - 1
        $buttonWidth = 16
        $totalButtonWidth = ($buttonWidth * 4) + ($this.ButtonSpacing * 3)
        
        # Center buttons
        $buttonX = $this.X + [Math]::Floor(($this.Width - $totalButtonWidth) / 2)
        
        $this.PrevWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.CurrentWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.NextWeekButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
        $buttonX += $buttonWidth + $this.ButtonSpacing
        
        $this.QuickEntryButton.SetBounds($buttonX, $buttonY, $buttonWidth, $this.ButtonHeight)
    }
    
    [void] OnActivated() {
        ([Screen]$this).OnActivated()
        
        # Refresh data when activated
        $this.RefreshGrid()
        if ($this.TimeGrid) {
            $this.TimeGrid.Focus()
        }
    }
    
    [string] GetWeekTitle() {
        $monday = $this.CurrentWeekFriday.AddDays(-4)
        return "Time Entry - Week of $($monday.ToString('MM/dd/yyyy')) to $($this.CurrentWeekFriday.ToString('MM/dd/yyyy'))"
    }
    
    [void] RefreshGrid() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Starting refresh for week $($this.CurrentWeekFriday.ToString('yyyyMMdd'))")
        }
        
        # Update title
        $this.TimeGrid.Title = $this.GetWeekTitle()
        
        # Get entries for current week
        $weekString = $this.CurrentWeekFriday.ToString("yyyyMMdd")
        $entries = $this.TimeService.GetWeekEntries($weekString)
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Got $($entries.Count) entries")
            if ($entries.Count -gt 0) {
                $global:Logger.Debug("TimeEntryScreen.RefreshGrid: First entry: Name=$($entries[0].Name) ID2=$($entries[0].ID2)")
            }
        }
        
        # Sort by: Projects first (by name), then non-projects (by ID2)
        $sorted = $entries | Sort-Object @(
            @{Expression = {if ($_.ID1 -eq "Internal") {1} else {0}}},
            @{Expression = {$_.Name}},
            @{Expression = {$_.ID2}}
        )
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: TimeGrid exists: $($this.TimeGrid -ne $null)")
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: TimeGrid bounds: ($($this.TimeGrid.X),$($this.TimeGrid.Y),$($this.TimeGrid.Width),$($this.TimeGrid.Height))")
        }
        
        # Clear and repopulate grid using proper DataGrid method
        $this.TimeGrid.SetItems($sorted)
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: After SetItems, TimeGrid.Items.Count = $($this.TimeGrid.Items.Count)")
        }
        
        $this.TimeGrid.Invalidate()
        $this.Invalidate()
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.RefreshGrid: Refresh complete, invalidated grid and screen")
        }
    }
    
    [void] ShowQuickEntry() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Starting quick entry")
        }
        
        try {
            # Create quick entry dialog
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: CurrentWeekFriday = $($this.CurrentWeekFriday)")
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: QuickTimeEntryDialog type exists: $([QuickTimeEntryDialog] -as [type] -ne $null)")
            }
            
            # Try explicit casting
            $weekFriday = [DateTime]$this.CurrentWeekFriday
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: weekFriday type = $($weekFriday.GetType().Name), value = $weekFriday")
            }
            
            # Try workaround - create via Invoke-Expression or reflection
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Attempting workaround creation")
            }
            
            # Workaround attempt
            $dialog = New-Object QuickTimeEntryDialog -ArgumentList $weekFriday
            
            # Initialize dialog with ServiceContainer for theme
            $dialog.Initialize($this.ServiceContainer)
            
            if ($global:Logger) {
                $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Dialog created successfully")
            }
            
            $screen = $this
            $dialog.OnSave = {
                param($timeEntry)
                # Save the entry
                $screen.TimeService.UpdateTimeEntry($timeEntry)
                $screen.RefreshGrid()
            }.GetNewClosure()
            
            # Show dialog
            if ($global:ScreenManager) {
                $global:ScreenManager.Push($dialog)
                if ($global:Logger) {
                    $global:Logger.Debug("TimeEntryScreen.ShowQuickEntry: Dialog pushed to ScreenManager")
                }
            }
        }
        catch {
            if ($global:Logger) {
                $global:Logger.Error("TimeEntryScreen.ShowQuickEntry: Error creating dialog: $_")
            }
        }
    }
    
    [void] EditSelectedEntry() {
        $selected = $this.TimeGrid.GetSelectedItem()
        if (-not $selected) { return }
        
        # Create edit dialog - TimeEntryDialog expects a Project parameter, not DateTime and ID2
        # For now, use the parameterless constructor
        $dialog = [TimeEntryDialog]::new()
        $dialog.OnSave = {
            $this.RefreshGrid()
        }.GetNewClosure()
        
        # Show dialog
        if ($global:ScreenManager) {
            $global:ScreenManager.Push($dialog)
        }
    }
    
    [string] OnRender() {
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnRender: Starting render, Children.Count = $($this.Children.Count)")
            $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid exists = $($this.TimeGrid -ne $null)")
            if ($this.TimeGrid) {
                $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid.Items.Count = $($this.TimeGrid.Items.Count)")
                $global:Logger.Debug("TimeEntryScreen.OnRender: TimeGrid bounds = ($($this.TimeGrid.X),$($this.TimeGrid.Y),$($this.TimeGrid.Width),$($this.TimeGrid.Height))")
            }
        }
        
        $result = ([Screen]$this).OnRender()
        
        if ($global:Logger) {
            $global:Logger.Debug("TimeEntryScreen.OnRender: Rendered content length = $($result.Length)")
        }
        return $result
    }
    
    [void] RegisterShortcuts() {
        $shortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        if ($shortcutManager) {
            $screen = $this
            
            # Q - Quick entry
            $quickAction = { $screen.ShowQuickEntry() }.GetNewClosure()
            
            $shortcutManager.RegisterShortcut(@{
                Id = "time.quick"
                Name = "Quick Entry"
                Description = "Quick time entry"
                KeyChar = 'q'
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = $quickAction
            })
            
            # E - Edit entry
            $shortcutManager.RegisterShortcut(@{
                Id = "time.edit"
                Name = "Edit Entry"
                Description = "Edit time entry"
                KeyChar = 'e'
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = { $screen.EditSelectedEntry() }.GetNewClosure()
            })
            
            # Left/Right arrows for week navigation
            $shortcutManager.RegisterShortcut(@{
                Id = "time.prevweek"
                Name = "Previous Week"
                Description = "Navigate to previous week"
                Key = [System.ConsoleKey]::LeftArrow
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = {
                    $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(-7)
                    $screen.RefreshGrid()
                }.GetNewClosure()
            })
            
            $shortcutManager.RegisterShortcut(@{
                Id = "time.nextweek"
                Name = "Next Week"
                Description = "Navigate to next week"
                Key = [System.ConsoleKey]::RightArrow
                Scope = [ShortcutScope]::Screen
                ScreenType = "TimeEntryScreen"
                Priority = 50
                Action = {
                    $screen.CurrentWeekFriday = $screen.CurrentWeekFriday.AddDays(7)
                    $screen.RefreshGrid()
                }.GetNewClosure()
            })
        }
    }
    
    [bool] HandleInput([System.ConsoleKeyInfo]$key) {
        # Let base handle first (for child components)
        if (([Screen]$this).HandleInput($key)) {
            return $true
        }
        
        # Handle screen-specific keys
        switch ($key.Key) {
            ([ConsoleKey]::Q) {
                if ($global:Logger) {
                    $global:Logger.Debug("TimeEntryScreen.HandleInput: Q key detected, calling ShowQuickEntry()")
                }
                $this.ShowQuickEntry()
                return $true
            }
            ([ConsoleKey]::E) {
                $this.EditSelectedEntry()
                return $true
            }
            ([ConsoleKey]::LeftArrow) {
                if ($key.Modifiers -eq [ConsoleModifiers]::None) {
                    $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(-7)
                    $this.RefreshGrid()
                    return $true
                }
            }
            ([ConsoleKey]::RightArrow) {
                if ($key.Modifiers -eq [ConsoleModifiers]::None) {
                    $this.CurrentWeekFriday = $this.CurrentWeekFriday.AddDays(7)
                    $this.RefreshGrid()
                    return $true
                }
            }
            ([ConsoleKey]::Enter) {
                $this.EditSelectedEntry()
                return $true
            }
        }
        
        return $false
    }
}


####\Screens/VisualMacroFactoryScreen.ps1
# VisualMacroFactoryScreen.ps1 - Visual macro builder for IDEA scripts
# Three-pane interface: Component Library | Macro Sequence | Context Panel

class VisualMacroFactoryScreen : Screen {
    # UI Components - Three panes
    [SearchableListBox]$ComponentLibrary      # Left pane
    [DataGrid]$MacroSequence                  # Center pane
    [DataGrid]$ContextPanel                   # Right pane
    
    # Services
    [MacroContextManager]$ContextManager
    [FunctionRegistry]$FunctionRegistry
    [CommandService]$CommandService
    [EventBus]$EventBus
    [ShortcutManager]$ShortcutManager
    
    # Available actions
    [System.Collections.ArrayList]$AvailableActions
    [int]$SelectedSequenceIndex = -1
    
    VisualMacroFactoryScreen() : base() {
        $this.Title = "Visual Macro Factory"
        $this.DrawBackground = $true
        $this.AvailableActions = [System.Collections.ArrayList]::new()
    }
    
    [void] OnInitialize() {
        # Get services
        $this.CommandService = $this.ServiceContainer.GetService("CommandService")
        $this.EventBus = $this.ServiceContainer.GetService('EventBus')
        $this.ShortcutManager = $this.ServiceContainer.GetService('ShortcutManager')
        
        # Initialize macro services
        $this.ContextManager = [MacroContextManager]::new()
        $this.FunctionRegistry = [FunctionRegistry]::new()
        $this.FunctionRegistry.SetCommandService($this.CommandService)
        $this.ContextManager.SetFunctionRegistry($this.FunctionRegistry)
        
        # Create UI components
        $this.CreateComponentLibrary()
        $this.CreateMacroSequence()
        $this.CreateContextPanel()
        
        # Register shortcuts
        $this.RegisterShortcuts()
    }
    
    [void] LoadAvailableActions() {
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.LoadAvailableActions: Starting to load actions")
        }
        
        # Load built-in actions
        $this.AvailableActions.Add([SummarizationAction]::new()) | Out-Null
        $this.AvailableActions.Add([AppendFieldAction]::new()) | Out-Null
        $this.AvailableActions.Add([ExportToExcelAction]::new()) | Out-Null
        
        # Add custom IDEA@ command action
        $this.AvailableActions.Add([CustomIdeaCommandAction]::new()) | Out-Null
        
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.LoadAvailableActions: Loaded $($this.AvailableActions.Count) actions")
        }
        
        # Populate the component library with the loaded actions
        $this.ComponentLibrary.SetItems($this.AvailableActions)
        
        # TODO: Load additional actions from Actions/ directory
    }
    
    [void] CreateComponentLibrary() {
        $this.ComponentLibrary = [SearchableListBox]::new()
        $this.ComponentLibrary.Title = "üìö Component Library"
        $this.ComponentLibrary.ShowBorder = $true
        $this.ComponentLibrary.SearchPrompt = "Search actions... (category:core type:export)"
        
        # Custom renderer for actions
        $this.ComponentLibrary.ItemRenderer = {
            param($action)
            if (-not $action) { return "" }
            return $action.GetDisplayText()
        }
        
        # Handle double-click to add action
        $this.ComponentLibrary.OnItemActivated = {
            param($action)
            $this.AddActionToSequence($action)
        }.GetNewClosure()
        
        $this.ComponentLibrary.Initialize($this.ServiceContainer)
        $this.AddChild($this.ComponentLibrary)
        
        # Load available actions
        $this.LoadAvailableActions()
    }
    
    [void] CreateMacroSequence() {
        $this.MacroSequence = [DataGrid]::new()
        $this.MacroSequence.Title = "üîß Macro Sequence"
        $this.MacroSequence.ShowBorder = $true
        
        # Define columns for macro sequence
        $columns = @(
            @{ Name = "Step"; Width = 6; Alignment = "Center" },
            @{ Name = "Action"; Width = 20; Alignment = "Left" },
            @{ Name = "Description"; Width = 30; Alignment = "Left" },
            @{ Name = "Status"; Width = 10; Alignment = "Center" }
        )
        $this.MacroSequence.SetColumns($columns)
        
        # Handle selection changes
        $this.MacroSequence.OnSelectionChanged = {
            $this.SelectedSequenceIndex = $this.MacroSequence.SelectedIndex
            $this.UpdateContextPanel()
        }.GetNewClosure()
        
        $this.MacroSequence.Initialize($this.ServiceContainer)
        $this.AddChild($this.MacroSequence)
    }
    
    [void] CreateContextPanel() {
        $this.ContextPanel = [DataGrid]::new()
        $this.ContextPanel.Title = "üéØ Macro Context"
        $this.ContextPanel.ShowBorder = $true
        
        # Define columns for context variables
        $columns = @(
            @{ Name = "Variable"; Width = 15; Alignment = "Left" },
            @{ Name = "Type"; Width = 10; Alignment = "Left" },
            @{ Name = "Value"; Width = 25; Alignment = "Left" },
            @{ Name = "Source"; Width = 15; Alignment = "Left" }
        )
        $this.ContextPanel.SetColumns($columns)
        
        $this.ContextPanel.Initialize($this.ServiceContainer)
        $this.AddChild($this.ContextPanel)
        
        # Initial context update
        $this.UpdateContextPanel()
        
        # Set initial focus to component library
        if ($this.ComponentLibrary) {
            $this.ComponentLibrary.Focus()
        }
    }
    
    [void] RegisterShortcuts() {
        if (-not $this.ShortcutManager) { return }
        
        # Delete: Remove selected action from sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_delete"
            Name = "Delete Action"
            Description = "Remove selected action from macro sequence"
            Key = [System.ConsoleKey]::Delete
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and $this.SelectedSequenceIndex -ge 0) {
                    $this.RemoveActionFromSequence($this.SelectedSequenceIndex)
                }
            }.GetNewClosure()
        })
        
        # Ctrl+Up: Move action up in sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_move_up"
            Name = "Move Action Up"
            Description = "Move selected action up in sequence"
            Key = [System.ConsoleKey]::UpArrow
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and $this.SelectedSequenceIndex -gt 0) {
                    $this.ContextManager.MoveAction($this.SelectedSequenceIndex, $this.SelectedSequenceIndex - 1)
                    $this.SelectedSequenceIndex--
                    $this.UpdateMacroSequence()
                    $this.UpdateContextPanel()
                }
            }.GetNewClosure()
        })
        
        # Ctrl+Down: Move action down in sequence
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_move_down"
            Name = "Move Action Down"
            Description = "Move selected action down in sequence"
            Key = [System.ConsoleKey]::DownArrow
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                if ($this.MacroSequence.HasFocus() -and 
                    $this.SelectedSequenceIndex -ge 0 -and 
                    $this.SelectedSequenceIndex -lt $this.ContextManager.Actions.Count - 1) {
                    $this.ContextManager.MoveAction($this.SelectedSequenceIndex, $this.SelectedSequenceIndex + 1)
                    $this.SelectedSequenceIndex++
                    $this.UpdateMacroSequence()
                    $this.UpdateContextPanel()
                }
            }.GetNewClosure()
        })
        
        # F5: Generate and preview script
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_preview"
            Name = "Preview Script"
            Description = "Generate and preview the IDEAScript"
            Key = [System.ConsoleKey]::F5
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.PreviewGeneratedScript()
            }.GetNewClosure()
        })
        
        # Ctrl+S: Save macro
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_save"
            Name = "Save Macro"
            Description = "Save the current macro"
            Key = [System.ConsoleKey]::S
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.SaveMacro()
            }.GetNewClosure()
        })
        
        # Ctrl+O: Open macro
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_open"
            Name = "Open Macro"
            Description = "Open an existing macro"
            Key = [System.ConsoleKey]::O
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.OpenMacro()
            }.GetNewClosure()
        })
        
        # Ctrl+N: New macro (clear)
        $this.ShortcutManager.RegisterShortcut(@{
            Id = "macro_factory_new"
            Name = "New Macro"
            Description = "Start a new macro (clear current)"
            Key = [System.ConsoleKey]::N
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Screen
            ScreenType = "VisualMacroFactoryScreen"
            Action = {
                $this.NewMacro()
            }.GetNewClosure()
        })
    }
    
    [void] AddActionToSequence([BaseAction]$action) {
        # Clone the action to avoid modifying the template
        $newAction = $action.GetType()::new()
        
        $this.ContextManager.AddAction($newAction)
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
        
        # Focus the macro sequence and select the new item
        $this.MacroSequence.Focus()
        $this.MacroSequence.SelectedIndex = $this.ContextManager.Actions.Count - 1
        $this.SelectedSequenceIndex = $this.MacroSequence.SelectedIndex
    }
    
    [void] RemoveActionFromSequence([int]$index) {
        $this.ContextManager.RemoveAction($index)
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
        
        # Adjust selection
        if ($this.SelectedSequenceIndex -ge $this.ContextManager.Actions.Count) {
            $this.SelectedSequenceIndex = $this.ContextManager.Actions.Count - 1
        }
        $this.MacroSequence.SelectedIndex = $this.SelectedSequenceIndex
    }
    
    [void] UpdateMacroSequence() {
        $rows = @()
        
        for ($i = 0; $i -lt $this.ContextManager.Actions.Count; $i++) {
            $action = $this.ContextManager.Actions[$i]
            $context = $this.ContextManager.GetContextAtStep($i)
            
            # Check if action requirements are met
            $isValid = $action.ValidateContext($context)
            $status = if ($isValid) { "‚úÖ Ready" } else { "‚ö†Ô∏è Issues" }
            
            $rows += @{
                Step = ($i + 1).ToString()
                Action = $action.Name
                Description = $action.Description
                Status = $status
            }
        }
        
        $this.MacroSequence.SetItems($rows)
    }
    
    [void] UpdateContextPanel() {
        $rows = @()
        
        # Get context for the selected step (or full context if none selected)
        $context = if ($this.SelectedSequenceIndex -ge 0) {
            $this.ContextManager.GetContextAtStep($this.SelectedSequenceIndex)
        } else {
            $this.ContextManager.GetFullContext()
        }
        
        foreach ($varName in $context.Keys) {
            $varInfo = $context[$varName]
            $source = if ($varInfo.ContainsKey('ProducedBy')) { $varInfo.ProducedBy } else { "System" }
            
            $rows += @{
                Variable = $varName
                Type = $varInfo.Type
                Value = if ($varInfo.ContainsKey('Value')) { $varInfo.Value } else { "<undefined>" }
                Source = $source
            }
        }
        
        $this.ContextPanel.SetItems($rows)
        
        # Update title to show context step
        if ($this.SelectedSequenceIndex -ge 0) {
            $this.ContextPanel.Title = "üéØ Context at Step $($this.SelectedSequenceIndex + 1)"
        } else {
            $this.ContextPanel.Title = "üéØ Full Macro Context"
        }
    }
    
    [void] PreviewGeneratedScript() {
        try {
            $script = $this.ContextManager.GenerateScript()
            
            # TODO: Show script in a dialog or new screen
            # For now, just log the script
            if ($global:Logger) {
                $global:Logger.Info("Generated Script: $script")
            }
            
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("Script Generation Error: $($_.Exception.Message)")
            }
        }
    }
    
    [void] SaveMacro() {
        # TODO: Implement macro saving to file
        if ($global:Logger) {
            $global:Logger.Info("Save Macro: Not yet implemented")
        }
    }
    
    [void] OpenMacro() {
        # TODO: Implement macro loading from file
        if ($global:Logger) {
            $global:Logger.Info("Open Macro: Not yet implemented")
        }
    }
    
    [void] NewMacro() {
        $this.ContextManager.Clear()
        $this.SelectedSequenceIndex = -1
        $this.UpdateMacroSequence()
        $this.UpdateContextPanel()
    }
    
    [void] OnBoundsChanged() {
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: Width=$($this.Width) Height=$($this.Height)")
        }
        
        if ($this.Width -le 0 -or $this.Height -le 0) { 
            if ($global:Logger) {
                $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: Skipping due to zero bounds")
            }
            return 
        }
        
        # Three-pane layout: 30% | 40% | 30%
        $leftWidth = [int]($this.Width * 0.3)
        $centerWidth = [int]($this.Width * 0.4)
        $rightWidth = $this.Width - $leftWidth - $centerWidth
        
        $contentHeight = $this.Height - 2  # Account for title
        
        if ($global:Logger) {
            $global:Logger.Debug("VisualMacroFactoryScreen.OnBoundsChanged: leftWidth=$leftWidth centerWidth=$centerWidth rightWidth=$rightWidth contentHeight=$contentHeight")
        }
        
        # Position Component Library (left pane)
        if ($this.ComponentLibrary) {
            $this.ComponentLibrary.SetBounds(0, 1, $leftWidth, $contentHeight)
        }
        
        # Position Macro Sequence (center pane)
        if ($this.MacroSequence) {
            $this.MacroSequence.SetBounds($leftWidth, 1, $centerWidth, $contentHeight)
        }
        
        # Position Context Panel (right pane)
        if ($this.ContextPanel) {
            $this.ContextPanel.SetBounds($leftWidth + $centerWidth, 1, $rightWidth, $contentHeight)
        }
    }
}


####\Services/CommandService.ps1
# CommandService.ps1 - Service for managing command library
# Handles JSON storage, CRUD operations, and clipboard functionality

class CommandService {
    [string]$DataPath
    [System.Collections.ArrayList]$Commands
    [Logger]$Logger
    
    CommandService() {
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/commands.json"
        $this.Commands = [System.Collections.ArrayList]::new()
        $this.Logger = $global:Logger
        $this.LoadCommands()
    }
    
    # Load commands from JSON file
    [void] LoadCommands() {
        try {
            if (Test-Path $this.DataPath) {
                $jsonContent = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                $this.Commands.Clear()
                
                foreach ($commandData in $jsonContent) {
                    # Convert PSCustomObject to hashtable
                    $hashtable = @{}
                    $commandData.PSObject.Properties | ForEach-Object {
                        $hashtable[$_.Name] = $_.Value
                    }
                    $command = [Command]::FromHashtable($hashtable)
                    $this.Commands.Add($command) | Out-Null
                }
                
                if ($this.Logger) {
                    $this.Logger.Info("Loaded $($this.Commands.Count) commands from $($this.DataPath)")
                }
            } else {
                if ($this.Logger) {
                    $this.Logger.Info("No existing commands file found, starting with empty library")
                }
                # Add some default IDEA commands
                $this.CreateDefaultCommands()
            }
        } catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to load commands: $($_.Exception.Message)")
            }
        }
    }
    
    # Create default IDEA commands for new installations
    [void] CreateDefaultCommands() {
        # Add some common IDEA@ functions and commands
        $defaultCommands = @(
            @{
                Title = "@CurrentDate_YYYYMMDD"
                Description = "Returns current date in YYYYMMDD format"
                Tags = @("function", "date", "idea")
                Group = "Built-in Functions"
                CommandText = "@CurrentDate_YYYYMMDD"
            },
            @{
                Title = "@PromptForField"
                Description = "Prompts user to select a field from the current database"
                Tags = @("function", "field", "input", "idea")
                Group = "Built-in Functions"
                CommandText = "@PromptForField(`"Select field:`")"
            },
            @{
                Title = "Open Database"
                Description = "Opens a database file in IDEA"
                Tags = @("database", "open", "idea")
                Group = "Database Operations"
                CommandText = "Set db = Client.OpenDatabase(`"database.IMD`")"
            },
            @{
                Title = "Summarize by Field"
                Description = "Creates a summarization by specified field"
                Tags = @("summarize", "group", "analysis", "idea")
                Group = "Analysis"
                CommandText = "Set task = db.Summarization`nTask.AddFieldToSummarize `"FIELD_NAME`"`nTask.OutputDBName = `"Summary_Output`"`ndbName = task.Run()"
            },
            @{
                Title = "Export to Excel"
                Description = "Exports current database to Excel format"
                Tags = @("export", "excel", "output", "idea")
                Group = "Export"
                CommandText = "Set task = db.ExportToExcel`nTask.OutputFile = `"output.xlsx`"`nTask.Run()"
            }
        )
        
        foreach ($cmdData in $defaultCommands) {
            $command = $this.AddCommand($cmdData.Title, $cmdData.Description, $cmdData.Tags, $cmdData.Group, $cmdData.CommandText)
        }
        
        if ($this.Logger) {
            $this.Logger.Info("Created $($defaultCommands.Count) default IDEA commands")
        }
    }
    
    # Save commands to JSON file
    [void] SaveCommands() {
        try {
            $commandsData = @()
            foreach ($command in $this.Commands) {
                $commandsData += $command.ToHashtable()
            }
            
            $json = $commandsData | ConvertTo-Json -Depth 10
            $json | Set-Content $this.DataPath -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Saved $($this.Commands.Count) commands to $($this.DataPath)")
            }
        } catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save commands: $($_.Exception.Message)")
            }
        }
    }
    
    # Get all commands
    [System.Collections.ArrayList] GetAllCommands() {
        return $this.Commands
    }
    
    # Get command by ID
    [Command] GetCommand([string]$id) {
        foreach ($command in $this.Commands) {
            if ($command.Id -eq $id) {
                return $command
            }
        }
        return $null
    }
    
    # Add new command
    [Command] AddCommand([string]$commandText) {
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            throw "Command text is required"
        }
        
        $command = [Command]::new($commandText)
        $this.Commands.Add($command) | Out-Null
        $this.SaveCommands()
        
        if ($this.Logger) {
            $this.Logger.Info("Added new command: $($command.Id)")
        }
        
        return $command
    }
    
    # Add command with full details
    [Command] AddCommand([string]$title, [string]$description, [string[]]$tags, [string]$group, [string]$commandText) {
        if ([string]::IsNullOrWhiteSpace($commandText)) {
            throw "Command text is required"
        }
        
        $command = [Command]::new()
        $command.Title = $title ?? ""
        $command.Description = $description ?? ""
        $command.Tags = $tags ?? @()
        $command.Group = $group ?? ""
        $command.CommandText = $commandText
        
        $this.Commands.Add($command) | Out-Null
        $this.SaveCommands()
        
        if ($this.Logger) {
            $this.Logger.Info("Added new command: $($command.GetDisplayText())")
        }
        
        return $command
    }
    
    # Update existing command
    [bool] UpdateCommand([Command]$command) {
        if (-not $command.IsValid()) {
            throw "Command text is required"
        }
        
        $existingIndex = -1
        for ($i = 0; $i -lt $this.Commands.Count; $i++) {
            if ($this.Commands[$i].Id -eq $command.Id) {
                $existingIndex = $i
                break
            }
        }
        
        if ($existingIndex -ge 0) {
            $this.Commands[$existingIndex] = $command
            $this.SaveCommands()
            
            if ($this.Logger) {
                $this.Logger.Info("Updated command: $($command.GetDisplayText())")
            }
            return $true
        }
        
        return $false
    }
    
    # Delete command
    [bool] DeleteCommand([string]$id) {
        for ($i = 0; $i -lt $this.Commands.Count; $i++) {
            if ($this.Commands[$i].Id -eq $id) {
                $command = $this.Commands[$i]
                $this.Commands.RemoveAt($i)
                $this.SaveCommands()
                
                if ($this.Logger) {
                    $this.Logger.Info("Deleted command: $($command.GetDisplayText())")
                }
                return $true
            }
        }
        
        return $false
    }
    
    # Copy command to clipboard and record usage
    [void] CopyToClipboard([string]$id) {
        $command = $this.GetCommand($id)
        if ($command) {
            try {
                Set-Clipboard -Value $command.CommandText
                $command.RecordUsage()
                $this.SaveCommands()
                
                if ($this.Logger) {
                    $this.Logger.Info("Copied command to clipboard: $($command.GetDisplayText())")
                }
            } catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to copy to clipboard: $($_.Exception.Message)")
                }
                throw "Failed to copy to clipboard: $($_.Exception.Message)"
            }
        } else {
            throw "Command not found: $id"
        }
    }
    
    # Search commands with enhanced syntax
    [System.Collections.ArrayList] SearchCommands([string]$query) {
        $results = [System.Collections.ArrayList]::new()
        
        if ([string]::IsNullOrWhiteSpace($query)) {
            # Return all commands if no query
            foreach ($command in $this.Commands) {
                $results.Add($command) | Out-Null
            }
            return $results
        }
        
        # Parse search query
        $searchCriteria = $this.ParseSearchQuery($query)
        
        foreach ($command in $this.Commands) {
            if ($this.MatchesSearchCriteria($command, $searchCriteria)) {
                $results.Add($command) | Out-Null
            }
        }
        
        return $results
    }
    
    # Parse search query into criteria
    hidden [hashtable] ParseSearchQuery([string]$query) {
        $criteria = @{
            DefaultSearch = @()
            TitleSearch = @()
            DescriptionSearch = @()
            TagSearch = @()
            GroupSearch = @()
            AndMode = $false
        }
        
        # Check for AND mode (+)
        if ($query -match '\+') {
            $criteria.AndMode = $true
        }
        
        # Split by spaces and process each term
        $terms = $query -split '\s+' | Where-Object { $_ -ne '' }
        
        foreach ($term in $terms) {
            if ($term -match '^(\+?)([tdg]):(.+)$') {
                $isAnd = $matches[1] -eq '+'
                $type = $matches[2]
                $searchTerm = $matches[3]
                
                # Handle OR within the search term (|)
                $searchValues = $searchTerm -split '\|'
                
                switch ($type) {
                    't' { $criteria.TagSearch += $searchValues }
                    'd' { $criteria.DescriptionSearch += $searchValues }
                    'g' { $criteria.GroupSearch += $searchValues }
                }
            } else {
                # Default search (title and general)
                $cleanTerm = $term -replace '^\+', ''
                $criteria.DefaultSearch += $cleanTerm
            }
        }
        
        return $criteria
    }
    
    # Check if command matches search criteria
    hidden [bool] MatchesSearchCriteria([Command]$command, [hashtable]$criteria) {
        $matches = @()
        
        # Default search (title and general text)
        if ($criteria.DefaultSearch.Count -gt 0) {
            $titleMatch = $false
            $generalMatch = $false
            
            foreach ($term in $criteria.DefaultSearch) {
                if ($command.Title -and $command.Title -match [regex]::Escape($term)) {
                    $titleMatch = $true
                }
                if ($command.GetSearchableText() -match [regex]::Escape($term)) {
                    $generalMatch = $true
                }
            }
            
            $matches += ($titleMatch -or $generalMatch)
        }
        
        # Tag search
        if ($criteria.TagSearch.Count -gt 0) {
            $tagMatch = $false
            $tagText = ($command.Tags -join ' ')
            
            foreach ($term in $criteria.TagSearch) {
                if ($tagText -match [regex]::Escape($term)) {
                    $tagMatch = $true
                    break
                }
            }
            
            $matches += $tagMatch
        }
        
        # Description search
        if ($criteria.DescriptionSearch.Count -gt 0) {
            $descMatch = $false
            
            foreach ($term in $criteria.DescriptionSearch) {
                if ($command.Description -and $command.Description -match [regex]::Escape($term)) {
                    $descMatch = $true
                    break
                }
            }
            
            $matches += $descMatch
        }
        
        # Group search
        if ($criteria.GroupSearch.Count -gt 0) {
            $groupMatch = $false
            
            foreach ($term in $criteria.GroupSearch) {
                if ($command.Group -and $command.Group -match [regex]::Escape($term)) {
                    $groupMatch = $true
                    break
                }
            }
            
            $matches += $groupMatch
        }
        
        # Return based on AND/OR logic
        if ($matches.Count -eq 0) {
            return $true  # No specific criteria, match all
        }
        
        if ($criteria.AndMode) {
            # AND: all criteria must match
            return ($matches | Where-Object { $_ -eq $false }).Count -eq 0
        } else {
            # OR: any criteria can match
            return ($matches | Where-Object { $_ -eq $true }).Count -gt 0
        }
    }
    
    # Get all unique groups
    [string[]] GetGroups() {
        $groups = @()
        foreach ($command in $this.Commands) {
            if (-not [string]::IsNullOrWhiteSpace($command.Group) -and $groups -notcontains $command.Group) {
                $groups += $command.Group
            }
        }
        return $groups | Sort-Object
    }
    
    # Get all unique tags
    [string[]] GetTags() {
        $tags = @()
        foreach ($command in $this.Commands) {
            foreach ($tag in $command.Tags) {
                if (-not [string]::IsNullOrWhiteSpace($tag) -and $tags -notcontains $tag) {
                    $tags += $tag
                }
            }
        }
        return $tags | Sort-Object
    }
}


####\Services/ConfigurationService.ps1
# ConfigurationService.ps1 - Configuration management with persistence

class ConfigurationService {
    hidden [string]$ConfigPath
    hidden [hashtable]$Config
    hidden [hashtable]$Defaults
    hidden [bool]$AutoSave = $true
    
    ConfigurationService() {
        $this.ConfigPath = Join-Path $global:PraxisRoot "_Config" "settings.json"
        $this.InitializeDefaults()
        $this.Load()
    }
    
    ConfigurationService([string]$configPath) {
        $this.ConfigPath = $configPath
        $this.InitializeDefaults()
        $this.Load()
    }
    
    hidden [void] InitializeDefaults() {
        $this.Defaults = @{
            Theme = @{
                CurrentTheme = "matrix"  # Changed to matrix as requested
                AvailableThemes = @("default", "matrix", "custom")
                CustomColors = @{
                    background = @(0, 0, 0)
                    foreground = @(0, 255, 0)
                    accent = @(0, 200, 0)
                    border = @(0, 100, 0)
                }
            }
            Editor = @{
                TabSize = 4
                WordWrap = $false
                ShowLineNumbers = $true
                HighlightCurrentLine = $true
                AutoSaveInterval = 0  # 0 = disabled, otherwise minutes
                SyntaxHighlighting = $true
            }
            FileBrowser = @{
                DefaultPath = (Get-Location).Path
                ShowHiddenFiles = $false
                IgnoredExtensions = @(".tmp", ".cache", ".log")
                SortBy = "Name"  # Name, Date, Size
                SortDescending = $false
                ShowFileSize = $true
                ShowModifiedDate = $false
            }
            UI = @{
                AnimationsEnabled = $true
                ShowScrollbars = $true
                CompactMode = $false
            }
            Projects = @{
                DefaultPath = Join-Path $global:PraxisRoot "_ProjectData"
                AutoSave = $true
                BackupEnabled = $true
                BackupCount = 5
            }
            Tasks = @{
                DefaultPriority = "Medium"
                ShowCompletedTasks = $true
                CompletedTaskRetention = 30  # days
            }
            Performance = @{
                EnableCaching = $true
                MaxCacheSize = 100  # MB
                RenderOptimization = $true
            }
            Logging = @{
                Level = "Info"
                MaxFileSize = 10  # MB
                MaxFiles = 5
            }
        }
    }
    
    [void] Load() {
        # Ensure config directory exists
        $configDir = Split-Path -Parent $this.ConfigPath
        if (-not (Test-Path $configDir)) {
            New-Item -ItemType Directory -Path $configDir -Force | Out-Null
        }
        
        # Load config from file or use defaults
        if (Test-Path $this.ConfigPath) {
            try {
                $json = Get-Content -Path $this.ConfigPath -Raw
                $loaded = $json | ConvertFrom-Json -AsHashtable
                
                # Merge with defaults to ensure all keys exist
                $this.Config = $this.MergeHashtables($this.Defaults, $loaded)
                
                if ($global:Logger) {
                    $global:Logger.Info("Configuration loaded from: $($this.ConfigPath)")
                }
            } catch {
                Write-Warning "Failed to load configuration: $_"
                $this.Config = $this.Defaults.Clone()
            }
        } else {
            # No config file, use defaults and save
            $this.Config = $this.Defaults.Clone()
            $this.Save()
        }
    }
    
    [void] Save() {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $this.ConfigPath -Value $json -Encoding UTF8
            
            if ($global:Logger) {
                $global:Logger.Debug("Configuration saved to: $($this.ConfigPath)")
            }
        } catch {
            Write-Warning "Failed to save configuration: $_"
        }
    }
    
    # Deep merge hashtables, preserving structure
    hidden [hashtable] MergeHashtables([hashtable]$base, [hashtable]$overlay) {
        $result = $base.Clone()
        
        foreach ($key in $overlay.Keys) {
            if ($base.ContainsKey($key) -and $base[$key] -is [hashtable] -and $overlay[$key] -is [hashtable]) {
                # Recursively merge nested hashtables
                $result[$key] = $this.MergeHashtables($base[$key], $overlay[$key])
            } else {
                # Overlay value takes precedence
                $result[$key] = $overlay[$key]
            }
        }
        
        return $result
    }
    
    # Get configuration value with dot notation support
    [object] Get([string]$path) {
        return $this.Get($path, $null)
    }
    
    [object] Get([string]$path, $default) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $default
            }
        }
        
        return $current
    }
    
    # Set configuration value with dot notation support
    [void] Set([string]$path, $value) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if (-not $current.ContainsKey($part)) {
                $current[$part] = @{}
            } elseif ($current[$part] -isnot [hashtable]) {
                # Path conflict - convert to hashtable
                $current[$part] = @{}
            }
            
            $current = $current[$part]
        }
        
        # Set the final value
        $lastPart = $parts[-1]
        $current[$lastPart] = $value
        
        # Auto-save if enabled
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Check if configuration key exists
    [bool] Has([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        foreach ($part in $parts) {
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                return $false
            }
        }
        
        return $true
    }
    
    # Remove configuration key
    [void] Remove([string]$path) {
        $parts = $path -split '\.'
        $current = $this.Config
        
        # Navigate to the parent of the target
        for ($i = 0; $i -lt $parts.Count - 1; $i++) {
            $part = $parts[$i]
            
            if ($current -is [hashtable] -and $current.ContainsKey($part)) {
                $current = $current[$part]
            } else {
                # Path doesn't exist
                return
            }
        }
        
        # Remove the final key
        $lastPart = $parts[-1]
        if ($current -is [hashtable] -and $current.ContainsKey($lastPart)) {
            $current.Remove($lastPart)
            
            # Auto-save if enabled
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Reset to defaults
    [void] Reset() {
        $this.Config = $this.Defaults.Clone()
        $this.Save()
    }
    
    # Reset specific section to defaults
    [void] ResetSection([string]$section) {
        if ($this.Defaults.ContainsKey($section)) {
            $this.Config[$section] = $this.Defaults[$section].Clone()
            
            if ($this.AutoSave) {
                $this.Save()
            }
        }
    }
    
    # Get all configuration as hashtable
    [hashtable] GetAll() {
        return $this.Config.Clone()
    }
    
    # Import configuration from hashtable
    [void] Import([hashtable]$config) {
        $this.Config = $this.MergeHashtables($this.Defaults, $config)
        
        if ($this.AutoSave) {
            $this.Save()
        }
    }
    
    # Export configuration to file
    [void] Export([string]$path) {
        try {
            $json = $this.Config | ConvertTo-Json -Depth 10 -Compress:$false
            Set-Content -Path $path -Value $json -Encoding UTF8
        } catch {
            throw "Failed to export configuration: $_"
        }
    }
}


####\Services/EventBus.ps1
# EventBus Service for PRAXIS
# Based on AxiomPhoenix EventManager with adaptations for PRAXIS architecture
# Provides pub/sub event system for decoupled communication between components

class EventBus {
    [hashtable]$EventHandlers = @{}
    [int]$NextHandlerId = 1
    [System.Collections.Generic.List[hashtable]]$EventHistory
    [int]$MaxHistorySize = 100
    [bool]$EnableHistory = $false  # Disabled by default for performance
    [ServiceContainer]$ServiceContainer
    [bool]$EnableDebugLogging = $false  # Enable detailed event logging
    hidden [int]$TotalEventsPublished = 0
    hidden [int]$TotalHandlersCalled = 0
    
    EventBus() {
        $this.EventHistory = [System.Collections.Generic.List[hashtable]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.ServiceContainer = $container
        $logger = $container.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus initialized", "Info")
        }
    }
    
    # Subscribe to an event with a handler
    # Returns a subscription ID that can be used to unsubscribe
    [string] Subscribe([string]$eventName, [scriptblock]$handler) {
        if ([string]::IsNullOrWhiteSpace($eventName)) {
            if ($global:Logger) {
                $global:Logger.Error("EventBus.Subscribe: Event name is null or empty")
                $global:Logger.Error("Stack trace: " + [System.Environment]::StackTrace)
            }
            throw [ArgumentException]::new("Event name cannot be null or empty")
        }
        if (-not $handler) {
            throw [ArgumentNullException]::new("Handler cannot be null")
        }
        
        if (-not $this.EventHandlers.ContainsKey($eventName)) {
            $this.EventHandlers[$eventName] = @{}
        }
        
        $handlerId = "handler_$($this.NextHandlerId)"
        $this.NextHandlerId++
        
        $this.EventHandlers[$eventName][$handlerId] = @{
            Handler = $handler
            SubscribedAt = [DateTime]::Now
            ExecutionCount = 0
        }
        
        $logger = $this.ServiceContainer.GetService('Logger')
        if ($logger) {
            $logger.Log("EventBus: Subscribed handler '$handlerId' to event '$eventName'", "Debug")
        }
        
        return $handlerId
    }
    
    # Subscribe with a weak reference to an object
    # Automatically unsubscribes if the object is garbage collected
    [string] SubscribeWeak([string]$eventName, [object]$target, [scriptblock]$handler) {
        $weakRef = [System.WeakReference]::new($target)
        $wrappedHandler = {
            param($sender, $eventData)
            $strongRef = $weakRef.Target
            if ($strongRef) {
                & $handler $sender $eventData
            } else {
                # Target has been garbage collected, unsubscribe
                $eventBus = $sender
                $eventBus.Unsubscribe($eventName, $args[0])
            }
        }.GetNewClosure()
        
        return $this.Subscribe($eventName, $wrappedHandler)
    }
    
    # Unsubscribe a specific handler
    [void] Unsubscribe([string]$eventName, [string]$handlerId) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            if ($this.EventHandlers[$eventName].ContainsKey($handlerId)) {
                $this.EventHandlers[$eventName].Remove($handlerId)
                
                # Clean up empty event entries
                if ($this.EventHandlers[$eventName].Count -eq 0) {
                    $this.EventHandlers.Remove($eventName)
                }
                
                $logger = $this.ServiceContainer.GetService('Logger')
                if ($logger) {
                    $logger.Log("EventBus: Unsubscribed handler '$handlerId' from event '$eventName'", "Debug")
                }
            }
        }
    }
    
    # Unsubscribe all handlers for an event
    [void] UnsubscribeAll([string]$eventName) {
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlerCount = $this.EventHandlers[$eventName].Count
            $this.EventHandlers.Remove($eventName)
            
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Unsubscribed all $handlerCount handlers from event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event with optional data
    [void] Publish([string]$eventName, [hashtable]$eventData = @{}) {
        # Add timestamp to event data
        $eventData['Timestamp'] = [DateTime]::Now
        $eventData['EventName'] = $eventName
        
        $this.TotalEventsPublished++
        
        # Debug logging
        if ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: Publishing event '$eventName' with data: $($eventData | ConvertTo-Json -Compress)", "Debug")
            }
        }
        
        # Add to history if enabled
        if ($this.EnableHistory) {
            $this.AddToHistory($eventName, $eventData)
        }
        
        # Execute handlers
        if ($this.EventHandlers.ContainsKey($eventName)) {
            $handlers = @($this.EventHandlers[$eventName].GetEnumerator())
            
            if ($this.EnableDebugLogging) {
                $debugLogger = $this.ServiceContainer.GetService('Logger')
                if ($debugLogger) {
                    $debugLogger.Log("EventBus: Found $($handlers.Count) handlers for event '$eventName'", "Debug")
                }
            }
            
            foreach ($entry in $handlers) {
                try {
                    $handlerData = $entry.Value
                    $handlerData.ExecutionCount++
                    $this.TotalHandlersCalled++
                    
                    if ($this.EnableDebugLogging) {
                        $debugLogger = $this.ServiceContainer.GetService('Logger')
                        if ($debugLogger) {
                            $debugLogger.Log("EventBus: Calling handler '$($entry.Key)' for event '$eventName'", "Debug")
                        }
                    }
                    
                    # Call handler with EventBus as sender and eventData
                    & $handlerData.Handler $this $eventData
                }
                catch {
                    $logger = $this.ServiceContainer.GetService('Logger')
                    if ($logger) {
                        $logger.Log("EventBus: Error in handler '$($entry.Key)' for event '$eventName': $($_.Exception.Message)", "Error")
                    }
                }
            }
        }
        elseif ($this.EnableDebugLogging) {
            $logger = $this.ServiceContainer.GetService('Logger')
            if ($logger) {
                $logger.Log("EventBus: No handlers registered for event '$eventName'", "Debug")
            }
        }
    }
    
    # Publish an event asynchronously (returns immediately)
    [void] PublishAsync([string]$eventName, [hashtable]$eventData = @{}) {
        $job = Start-Job -ScriptBlock {
            param($eventBus, $eventName, $eventData)
            $eventBus.Publish($eventName, $eventData)
        } -ArgumentList $this, $eventName, $eventData
        
        # Clean up job after completion
        Register-ObjectEvent -InputObject $job -EventName StateChanged -Action {
            if ($Event.SourceEventArgs.JobStateInfo.State -eq 'Completed') {
                Remove-Job -Job $Event.SourceEventArgs
                Unregister-Event -SourceIdentifier $Event.SourceIdentifier
            }
        } | Out-Null
    }
    
    # Add event to history
    hidden [void] AddToHistory([string]$eventName, [hashtable]$eventData) {
        # Sanitize event data to prevent circular references
        $sanitizedData = @{}
        foreach ($key in $eventData.Keys) {
            $value = $eventData[$key]
            if ($value -is [string] -or $value -is [int] -or $value -is [double] -or 
                $value -is [bool] -or $value -is [datetime] -or $value -eq $null) {
                $sanitizedData[$key] = $value
            }
            elseif ($value.GetType().Name -eq 'UIElement' -or $value.GetType().BaseType.Name -eq 'UIElement') {
                # Handle UIElement without requiring the type to be loaded
                $name = if ($value.PSObject.Properties['Name']) { $value.Name } else { 'Unknown' }
                $sanitizedData[$key] = "[UIElement: $name]"
            }
            else {
                $sanitizedData[$key] = "[Object: $($value.GetType().Name)]"
            }
        }
        
        $historyEntry = @{
            EventName = $eventName
            EventData = $sanitizedData
            Timestamp = [DateTime]::Now
            HandlerCount = if ($this.EventHandlers.ContainsKey($eventName)) { 
                $this.EventHandlers[$eventName].Count 
            } else { 0 }
        }
        
        $this.EventHistory.Add($historyEntry)
        
        if ($this.EventHistory.Count -gt $this.MaxHistorySize) {
            $this.EventHistory.RemoveAt(0)
        }
    }
    
    # Get event history
    [hashtable[]] GetEventHistory([string]$eventName = $null) {
        if ($eventName) {
            return $this.EventHistory.Where({ $_.EventName -eq $eventName })
        }
        return $this.EventHistory | ForEach-Object { $_ }
    }
    
    # Clear event history
    [void] ClearHistory() {
        $this.EventHistory.Clear()
    }
    
    # Get information about registered events
    [hashtable] GetEventInfo() {
        $info = @{
            RegisteredEvents = @{}
            TotalHandlers = 0
            TotalEventsPublished = $this.TotalEventsPublished
            TotalHandlersCalled = $this.TotalHandlersCalled
            EnableHistory = $this.EnableHistory
            EnableDebugLogging = $this.EnableDebugLogging
            HistorySize = $this.EventHistory.Count
        }
        
        foreach ($eventName in $this.EventHandlers.Keys) {
            $handlers = $this.EventHandlers[$eventName]
            $info.RegisteredEvents[$eventName] = @{
                HandlerCount = $handlers.Count
                Handlers = $handlers.Keys | ForEach-Object { 
                    @{
                        Id = $_
                        ExecutionCount = $handlers[$_].ExecutionCount
                        SubscribedAt = $handlers[$_].SubscribedAt
                    }
                }
            }
            $info.TotalHandlers += $handlers.Count
        }
        
        return $info
    }
    
    # Get debug report
    [string] GetDebugReport() {
        $sb = [System.Text.StringBuilder]::new()
        $info = $this.GetEventInfo()
        
        $sb.AppendLine("EventBus Debug Report")
        $sb.AppendLine("====================")
        $sb.AppendLine("Total Events Published: $($info.TotalEventsPublished)")
        $sb.AppendLine("Total Handlers Called: $($info.TotalHandlersCalled)")
        $sb.AppendLine("Active Handlers: $($info.TotalHandlers)")
        $sb.AppendLine("History Enabled: $($info.EnableHistory)")
        $sb.AppendLine("Debug Logging: $($info.EnableDebugLogging)")
        $sb.AppendLine("History Size: $($info.HistorySize)/$($this.MaxHistorySize)")
        $sb.AppendLine("")
        $sb.AppendLine("Registered Events:")
        
        foreach ($eventName in $info.RegisteredEvents.Keys | Sort-Object) {
            $eventInfo = $info.RegisteredEvents[$eventName]
            $sb.AppendLine("  $eventName : $($eventInfo.HandlerCount) handler(s)")
            
            foreach ($handler in $eventInfo.Handlers) {
                $sb.AppendLine("    - $($handler.Id): $($handler.ExecutionCount) executions")
            }
        }
        
        return $sb.ToString()
    }
}

# Common Event Names (for consistency across the application)
class EventNames {
    # Project Events
    static [string]$ProjectCreated = 'project.created'
    static [string]$ProjectUpdated = 'project.updated'
    static [string]$ProjectDeleted = 'project.deleted'
    static [string]$ProjectSelected = 'project.selected'
    
    # Task Events
    static [string]$TaskCreated = 'task.created'
    static [string]$TaskUpdated = 'task.updated'
    static [string]$TaskDeleted = 'task.deleted'
    static [string]$TaskSelected = 'task.selected'
    static [string]$TaskStatusChanged = 'task.statusChanged'
    
    # Navigation Events
    static [string]$TabChanged = 'navigation.tabChanged'
    static [string]$ScreenChanged = 'navigation.screenChanged'
    static [string]$DialogOpened = 'navigation.dialogOpened'
    static [string]$DialogClosed = 'navigation.dialogClosed'
    
    # Application Events
    static [string]$AppInitialized = 'app.initialized'
    static [string]$AppShutdown = 'app.shutdown'
    static [string]$ThemeChanged = 'app.themeChanged'
    static [string]$ConfigChanged = 'app.configChanged'
    static [string]$RefreshRequested = 'app.refreshRequested'
    static [string]$DataChanged = 'app.dataChanged'
    
    # Command Events
    static [string]$CommandExecuted = 'command.executed'
    static [string]$CommandRegistered = 'command.registered'
    
    # UI Events
    static [string]$FocusChanged = 'ui.focusChanged'
    static [string]$SelectionChanged = 'ui.selectionChanged'
}

# Helper class for command registration
class CommandRegistration {
    static [void] RegisterCommand([string]$name, [string]$description, [scriptblock]$action) {
        $eventBus = $global:ServiceContainer.GetService('EventBus')
        if ($eventBus) {
            $eventBus.Publish([EventNames]::CommandRegistered, @{
                Name = $name
                Description = $description
                Action = $action
            })
        }
    }
}


####\Services/ExcelImportService.ps1
class ExcelImportService {
    $ServiceContainer
    [hashtable] $FieldMappings
    
    ExcelImportService() {
        $this.InitializeFieldMappings()
    }
    
    [void] Initialize($container) {
        $this.ServiceContainer = $container
    }
    
    [void] InitializeFieldMappings() {
        # Based on changes.txt mappings
        $this.FieldMappings = @{
            'RequestDate' = @{ Cell = 'W23'; Type = 'Date' }
            'AuditType' = @{ Cell = 'W78'; Type = 'String' }
            'AuditorName' = @{ Cell = 'W10'; Type = 'String' }
            'AuditorPhone' = @{ Cell = 'W12'; Type = 'String' }
            'AuditorTL' = @{ Cell = 'W15'; Type = 'String' }
            'AuditorTLPhone' = @{ Cell = 'W16'; Type = 'String' }
            'TPName' = @{ Cell = 'W3'; Type = 'String' }
            'TPNum' = @{ Cell = 'W4'; Type = 'String' }
            'Address' = @{ Cell = 'W5'; Type = 'String' }
            'City' = @{ Cell = 'W6'; Type = 'String' }
            'Province' = @{ Cell = 'W7'; Type = 'String' }
            'PostalCode' = @{ Cell = 'W8'; Type = 'String' }
            'Country' = @{ Cell = 'W9'; Type = 'String' }
            'AuditPeriodFrom' = @{ Cell = 'W27'; Type = 'Date' }
            'AuditPeriodTo' = @{ Cell = 'W28'; Type = 'Date' }
            'AuditPeriod1Start' = @{ Cell = 'W29'; Type = 'Date' }
            'AuditPeriod1End' = @{ Cell = 'W30'; Type = 'Date' }
            'AuditPeriod2Start' = @{ Cell = 'W31'; Type = 'Date' }
            'AuditPeriod2End' = @{ Cell = 'W32'; Type = 'Date' }
            'AuditPeriod3Start' = @{ Cell = 'W33'; Type = 'Date' }
            'AuditPeriod3End' = @{ Cell = 'W34'; Type = 'Date' }
            'AuditPeriod4Start' = @{ Cell = 'W35'; Type = 'Date' }
            'AuditPeriod4End' = @{ Cell = 'W36'; Type = 'Date' }
            'AuditPeriod5Start' = @{ Cell = 'W37'; Type = 'Date' }
            'AuditPeriod5End' = @{ Cell = 'W38'; Type = 'Date' }
            'Contact1Name' = @{ Cell = 'W54'; Type = 'String' }
            'Contact1Phone' = @{ Cell = 'W55'; Type = 'String' }
            'Contact1Ext' = @{ Cell = 'W56'; Type = 'String' }
            'Contact1Address' = @{ Cell = 'W57'; Type = 'String' }
            'Contact1Title' = @{ Cell = 'W58'; Type = 'String' }
            'Contact2Name' = @{ Cell = 'W59'; Type = 'String' }
            'Contact2Phone' = @{ Cell = 'W60'; Type = 'String' }
            'Contact2Ext' = @{ Cell = 'W61'; Type = 'String' }
            'Contact2Address' = @{ Cell = 'W62'; Type = 'String' }
            'Contact2Title' = @{ Cell = 'W63'; Type = 'String' }
            'AuditProgram' = @{ Cell = 'W72'; Type = 'String' }
            'AuditCase' = @{ Cell = 'W18'; Type = 'String' }
            'CASCase' = @{ Cell = 'W17'; Type = 'String' }  # Critical ID2 field
            'AuditStartDate' = @{ Cell = 'W24'; Type = 'Date' }
            'AccountingSoftware1' = @{ Cell = 'W98'; Type = 'String' }
            'AccountingSoftware1Other' = @{ Cell = 'W100'; Type = 'String' }
            'AccountingSoftware1Type' = @{ Cell = 'W101'; Type = 'String' }
            'AccountingSoftware2' = @{ Cell = 'W102'; Type = 'String' }
            'AccountingSoftware2Other' = @{ Cell = 'W104'; Type = 'String' }
            'AccountingSoftware2Type' = @{ Cell = 'W105'; Type = 'String' }
            'FXInfo' = @{ Cell = 'W129'; Type = 'String' }
            'ShipToAddress' = @{ Cell = 'W130'; Type = 'String' }
            'Comments' = @{ Cell = 'W108'; Type = 'String' }
        }
    }
    
    [hashtable] ImportFromExcel([string]$FilePath) {
        # Validate file exists
        if (-not (Test-Path $FilePath)) {
            throw "Excel file not found: $FilePath"
        }
        
        # Initialize COM objects
        $excel = $null
        $workbook = $null
        $importedData = @{}
        
        try {
            # Create Excel application
            $excel = New-Object -ComObject Excel.Application
            $excel.Visible = $false
            $excel.DisplayAlerts = $false
            
            # Open workbook
            $workbook = $excel.Workbooks.Open($FilePath, 0, $true) # ReadOnly
            
            # Try to find SVI-CAS worksheet
            $worksheet = $null
            try {
                $worksheet = $workbook.Worksheets.Item('SVI-CAS')
            }
            catch {
                # Use first worksheet if SVI-CAS not found
                $worksheet = $workbook.Worksheets.Item(1)
                Write-Warning "SVI-CAS worksheet not found, using first worksheet: $($worksheet.Name)"
            }
            
            # Extract data based on mappings
            foreach ($field in $this.FieldMappings.Keys) {
                $mapping = $this.FieldMappings[$field]
                try {
                    $cellValue = $worksheet.Range($mapping.Cell).Value2
                    
                    # Convert based on type
                    if ($null -ne $cellValue -and $cellValue -ne '') {
                        switch ($mapping.Type) {
                            'Date' {
                                if ($cellValue -is [double]) {
                                    $importedData[$field] = [DateTime]::FromOADate($cellValue)
                                }
                                else {
                                    $importedData[$field] = [DateTime]::Parse($cellValue.ToString())
                                }
                            }
                            'String' {
                                $importedData[$field] = $cellValue.ToString().Trim()
                            }
                            default {
                                $importedData[$field] = $cellValue
                            }
                        }
                    }
                }
                catch {
                    Write-Warning "Failed to extract $field from cell $($mapping.Cell): $_"
                }
            }
            
            return $importedData
        }
        finally {
            # Clean up COM objects
            if ($workbook) {
                try { $workbook.Close($false) } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($workbook) | Out-Null
            }
            if ($excel) {
                try { $excel.Quit() } catch {}
                [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null
            }
            [System.GC]::Collect()
            [System.GC]::WaitForPendingFinalizers()
        }
    }
    
    [object] CreateProjectFromImport([hashtable]$ImportedData) {
        $projectService = $this.ServiceContainer.GetService('ProjectService')
        
        # Create new project with imported data
        $project = [Project]::new()
        
        # Map basic fields
        $project.FullProjectName = $ImportedData.TPName
        $project.Nickname = $ImportedData.TPName  # Can be changed later
        $project.ID2 = $ImportedData.CASCase  # CAS Case# is the ID2
        $project.ClientID = $ImportedData.TPNum
        $project.Status = 'Active'
        
        # Map audit information
        $project.AuditType = $ImportedData.AuditType
        $project.AuditProgram = $ImportedData.AuditProgram
        $project.AuditCase = $ImportedData.AuditCase
        $project.AuditStartDate = $ImportedData.AuditStartDate
        $project.AuditPeriodFrom = $ImportedData.AuditPeriodFrom
        $project.AuditPeriodTo = $ImportedData.AuditPeriodTo
        
        # Map additional audit periods
        $project.AuditPeriod1Start = $ImportedData.AuditPeriod1Start
        $project.AuditPeriod1End = $ImportedData.AuditPeriod1End
        $project.AuditPeriod2Start = $ImportedData.AuditPeriod2Start
        $project.AuditPeriod2End = $ImportedData.AuditPeriod2End
        $project.AuditPeriod3Start = $ImportedData.AuditPeriod3Start
        $project.AuditPeriod3End = $ImportedData.AuditPeriod3End
        $project.AuditPeriod4Start = $ImportedData.AuditPeriod4Start
        $project.AuditPeriod4End = $ImportedData.AuditPeriod4End
        $project.AuditPeriod5Start = $ImportedData.AuditPeriod5Start
        $project.AuditPeriod5End = $ImportedData.AuditPeriod5End
        
        # Map address information
        $project.Address = $ImportedData.Address
        $project.City = $ImportedData.City
        $project.Province = $ImportedData.Province
        $project.PostalCode = $ImportedData.PostalCode
        $project.Country = $ImportedData.Country
        $project.ShipToAddress = $ImportedData.ShipToAddress
        
        # Map auditor information
        $project.AuditorName = $ImportedData.AuditorName
        $project.AuditorPhone = $ImportedData.AuditorPhone
        $project.AuditorTL = $ImportedData.AuditorTL
        $project.AuditorTLPhone = $ImportedData.AuditorTLPhone
        
        # Map contact information directly to project fields
        $project.Contact1Name = $ImportedData.Contact1Name
        $project.Contact1Phone = $ImportedData.Contact1Phone
        $project.Contact1Ext = $ImportedData.Contact1Ext
        $project.Contact1Address = $ImportedData.Contact1Address
        $project.Contact1Title = $ImportedData.Contact1Title
        $project.Contact2Name = $ImportedData.Contact2Name
        $project.Contact2Phone = $ImportedData.Contact2Phone
        $project.Contact2Ext = $ImportedData.Contact2Ext
        $project.Contact2Address = $ImportedData.Contact2Address
        $project.Contact2Title = $ImportedData.Contact2Title
        
        # Map software information
        $project.AccountingSoftware1 = $ImportedData.AccountingSoftware1
        $project.AccountingSoftware1Other = $ImportedData.AccountingSoftware1Other
        $project.AccountingSoftware1Type = $ImportedData.AccountingSoftware1Type
        $project.AccountingSoftware2 = $ImportedData.AccountingSoftware2
        $project.AccountingSoftware2Other = $ImportedData.AccountingSoftware2Other
        $project.AccountingSoftware2Type = $ImportedData.AccountingSoftware2Type
        
        # Map additional fields
        $project.RequestDate = $ImportedData.RequestDate
        $project.FXInfo = $ImportedData.FXInfo
        $project.Comments = $ImportedData.Comments
        
        return $project
    }
}


####\Services/FunctionRegistry.ps1
# FunctionRegistry.ps1 - Registry for @functions used in Visual Macro Factory
# Integrates with CommandService to provide both built-in and custom @functions

class FunctionRegistry {
    [hashtable]$BuiltInFunctions = @{}
    [CommandService]$CommandService
    [Logger]$Logger
    
    FunctionRegistry() {
        $this.Logger = $global:Logger
        $this.RegisterBuiltInFunctions()
    }
    
    # Set the CommandService reference for accessing custom commands
    [void] SetCommandService([CommandService]$commandService) {
        $this.CommandService = $commandService
    }
    
    # Register built-in @functions
    [void] RegisterBuiltInFunctions() {
        # User input functions
        $this.BuiltInFunctions["PromptForField"] = @{
            Name = "PromptForField"
            Description = "Prompts user to select a field from the current database"
            Category = "User Input"
            Usage = "@PromptForField"
            Template = "@PromptForField"
        }
        
        $this.BuiltInFunctions["PromptForValue"] = @{
            Name = "PromptForValue"
            Description = "Prompts user for a text value"
            Category = "User Input"
            Usage = "@PromptForValue(""Enter value:"")"
            Template = "@PromptForValue(""Enter description"")"
        }
        
        $this.BuiltInFunctions["PromptForNumber"] = @{
            Name = "PromptForNumber"
            Description = "Prompts user for a numeric value"
            Category = "User Input"
            Usage = "@PromptForNumber(""Enter amount:"")"
            Template = "@PromptForNumber(""Enter description"")"
        }
        
        # System functions
        $this.BuiltInFunctions["CurrentDate_YYYYMMDD"] = @{
            Name = "CurrentDate_YYYYMMDD"
            Description = "Current date in YYYYMMDD format"
            Category = "System"
            Usage = "@CurrentDate_YYYYMMDD"
            Template = "@CurrentDate_YYYYMMDD"
        }
        
        $this.BuiltInFunctions["CurrentDate_MMDDYYYY"] = @{
            Name = "CurrentDate_MMDDYYYY"
            Description = "Current date in MM/DD/YYYY format"
            Category = "System"
            Usage = "@CurrentDate_MMDDYYYY"
            Template = "@CurrentDate_MMDDYYYY"
        }
        
        $this.BuiltInFunctions["CurrentUser"] = @{
            Name = "CurrentUser"
            Description = "Current Windows username"
            Category = "System"
            Usage = "@CurrentUser"
            Template = "@CurrentUser"
        }
        
        $this.BuiltInFunctions["CurrentTime_HHMMSS"] = @{
            Name = "CurrentTime_HHMMSS"
            Description = "Current time in HHMMSS format"
            Category = "System"
            Usage = "@CurrentTime_HHMMSS"
            Template = "@CurrentTime_HHMMSS"
        }
        
        # File functions
        $this.BuiltInFunctions["TempFile"] = @{
            Name = "TempFile"
            Description = "Generate a temporary file path"
            Category = "File"
            Usage = "@TempFile(.xlsx)"
            Template = "@TempFile(.xlsx)"
        }
    }
    
    # Get all available @functions (built-in + custom from CommandService)
    [hashtable[]] GetAllFunctions() {
        $functions = @()
        
        # Add built-in functions
        foreach ($func in $this.BuiltInFunctions.Values) {
            $functions += $func
        }
        
        # Add custom functions from CommandService if available
        if ($this.CommandService) {
            $customFunctions = $this.GetCustomFunctions()
            $functions += $customFunctions
        }
        
        return $functions
    }
    
    # Get custom @functions from CommandService
    [hashtable[]] GetCustomFunctions() {
        $functions = @()
        
        if (-not $this.CommandService) {
            return $functions
        }
        
        # Look for commands that define @functions
        foreach ($command in $this.CommandService.Commands) {
            # Check if command defines a @function (starts with @)
            if ($command.Command -match '^@(\w+)') {
                $funcName = $matches[1]
                $functions += @{
                    Name = $funcName
                    Description = $command.Description
                    Category = "Custom"
                    Usage = $command.Command
                    Template = $command.Command
                    Source = "CommandLibrary"
                    Tags = $command.Tags
                }
            }
            
            # Also check for commands tagged as functions
            if ($command.Tags -contains "function" -or $command.Tags -contains "@function") {
                $functions += @{
                    Name = $command.Name
                    Description = $command.Description
                    Category = "Custom"
                    Usage = $command.Command
                    Template = $command.Command
                    Source = "CommandLibrary"
                    Tags = $command.Tags
                }
            }
        }
        
        return $functions
    }
    
    # Search functions by name or description
    [hashtable[]] SearchFunctions([string]$query) {
        $allFunctions = $this.GetAllFunctions()
        $results = @()
        
        $query = $query.ToLower()
        
        foreach ($func in $allFunctions) {
            $name = $func.Name.ToLower()
            $desc = $func.Description.ToLower()
            
            if ($name.Contains($query) -or $desc.Contains($query)) {
                $results += $func
            }
        }
        
        return $results
    }
    
    # Get functions by category
    [hashtable[]] GetFunctionsByCategory([string]$category) {
        $allFunctions = $this.GetAllFunctions()
        $results = @()
        
        foreach ($func in $allFunctions) {
            if ($func.Category -eq $category) {
                $results += $func
            }
        }
        
        return $results
    }
    
    # Resolve @function at runtime (for script generation)
    [string] ResolveFunction([string]$functionCall, [hashtable]$context = @{}) {
        # This would be called during macro execution to replace @functions with actual values
        # For now, return the function call as-is for the IDEAScript to handle
        return $functionCall
    }
}


####\Services/Logger.ps1
# Logger.ps1 - Fast logging service adapted from AxiomPhoenix
# Optimized for speed - no console output, minimal file I/O

class Logger {
    [string]$LogPath
    [System.Collections.Queue]$LogQueue
    [int]$MaxQueueSize = 100  # Smaller queue for faster flushing
    [bool]$EnableFileLogging = $true
    [bool]$EnableConsoleLogging = $false  # Never log to console in TUI
    [string]$MinimumLevel = "Info"
    [hashtable]$LevelPriority = @{
        'Trace' = 0
        'Debug' = 1
        'Info' = 2
        'Warning' = 3
        'Error' = 4
        'Fatal' = 5
    }
    hidden [System.Text.StringBuilder]$_buffer
    hidden [int]$_unflushedCount = 0
    hidden [int]$_flushThreshold = 10  # Flush every N messages
    
    Logger() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { (Get-Location).Path }
        $logDir = Join-Path $praxisDir "_Logs"
        if (-not (Test-Path $logDir)) {
            New-Item -ItemType Directory -Path $logDir -Force | Out-Null
        }
        $this.LogPath = Join-Path $logDir "praxis.log"
        $this._Initialize()
    }
    
    hidden [void] _Initialize() {
        $this.LogQueue = [System.Collections.Queue]::new()
        $this._buffer = [System.Text.StringBuilder]::new(4096)  # Pre-allocate buffer
        
        # Check for debug mode
        if ($global:PraxisDebug -or $env:PRAXIS_DEBUG) {
            $this.MinimumLevel = "Debug"
        }
        
        # Rotate log if too large (>10MB)
        try {
            if ((Test-Path $this.LogPath) -and (Get-Item $this.LogPath).Length -gt 10MB) {
                $backupPath = $this.LogPath + ".old"
                Move-Item $this.LogPath $backupPath -Force -ErrorAction SilentlyContinue
            }
        } catch {
            # Ignore rotation errors
        }
    }
    
    [void] Log([string]$message, [string]$level = "Info") {
        # Fast level check
        if ($this.LevelPriority[$level] -lt $this.LevelPriority[$this.MinimumLevel]) {
            return
        }
        
        # Format timestamp efficiently
        $timestamp = [DateTime]::Now.ToString('yyyy-MM-dd HH:mm:ss.fff')
        $levelPadded = $level.ToUpper().PadRight(7)
        
        # Build log line
        $logLine = "$timestamp [$levelPadded] $message"
        
        # Add to buffer instead of queue for speed
        $this._buffer.AppendLine($logLine)
        $this._unflushedCount++
        
        # Auto-flush on threshold or error/fatal
        if ($this._unflushedCount -ge $this._flushThreshold -or 
            $level -eq "Error" -or $level -eq "Fatal") {
            $this.Flush()
        }
    }
    
    [void] LogException([Exception]$exception, [string]$context = "") {
        $message = if ($context) { "$context - " } else { "" }
        $message += "$($exception.GetType().Name): $($exception.Message)"
        $this.Log($message, "Error")
        
        # Log stack trace as debug
        if ($exception.StackTrace) {
            $this.Log("Stack: $($exception.StackTrace -replace "`n", " ")", "Debug")
        }
    }
    
    [void] Flush() {
        if ($this._buffer.Length -eq 0 -or -not $this.EnableFileLogging) {
            return
        }
        
        try {
            # Write buffer to file in one operation
            [System.IO.File]::AppendAllText($this.LogPath, $this._buffer.ToString())
            $this._buffer.Clear()
            $this._unflushedCount = 0
        }
        catch {
            # Ignore logging errors to prevent crashes
        }
    }
    
    # Quick logging methods
    [void] Debug([string]$message) { $this.Log($message, "Debug") }
    [void] Info([string]$message) { $this.Log($message, "Info") }
    [void] Warning([string]$message) { $this.Log($message, "Warning") }
    [void] Error([string]$message) { $this.Log($message, "Error") }
    
    [void] Cleanup() {
        $this.Flush()
    }
}

# Global Write-Log function for compatibility
function global:Write-Log {
    param(
        [string]$Message,
        [string]$Level = "Info"
    )
    
    if ($global:Logger) {
        $global:Logger.Log($Message, $Level)
    }
}


####\Services/MacroContextManager.ps1
# MacroContextManager.ps1 - Manages macro state and variable context
# The "smart conductor" that ensures temporal safety and handles name collisions

class MacroContextManager {
    [System.Collections.ArrayList]$Actions = [System.Collections.ArrayList]::new()
    [hashtable]$GlobalContext = @{}
    [Logger]$Logger
    [FunctionRegistry]$FunctionRegistry
    
    MacroContextManager() {
        $this.Logger = $global:Logger
        $this.InitializeGlobalContext()
    }
    
    # Set the FunctionRegistry reference
    [void] SetFunctionRegistry([FunctionRegistry]$functionRegistry) {
        $this.FunctionRegistry = $functionRegistry
    }
    
    # Initialize with common IDEA context variables
    [void] InitializeGlobalContext() {
        $this.GlobalContext = @{
            # Common IDEA database context
            "ActiveDatabase" = @{
                Type = "Database"
                Description = "Currently active database in IDEA"
                Available = $true
            }
            
            # System variables
            "CurrentUser" = @{
                Type = "String"
                Description = "Current Windows username"
                Available = $true
            }
            
            "CurrentDate" = @{
                Type = "Date"
                Description = "Current system date"
                Available = $true
            }
        }
    }
    
    # Add an action to the macro sequence
    [void] AddAction([BaseAction]$action) {
        $this.AddAction($action, $this.Actions.Count)
    }
    
    # Add an action at a specific position
    [void] AddAction([BaseAction]$action, [int]$position) {
        if ($position -lt 0 -or $position -gt $this.Actions.Count) {
            $position = $this.Actions.Count
        }
        
        $this.Actions.Insert($position, $action)
        $this.UpdateProducedVariables()
        
        if ($this.Logger) {
            $this.Logger.Debug("Added action '$($action.Name)' at position $position")
        }
    }
    
    # Remove an action from the sequence
    [void] RemoveAction([int]$index) {
        if ($index -ge 0 -and $index -lt $this.Actions.Count) {
            $action = $this.Actions[$index]
            $this.Actions.RemoveAt($index)
            $this.UpdateProducedVariables()
            
            if ($this.Logger) {
                $this.Logger.Debug("Removed action '$($action.Name)' from position $index")
            }
        }
    }
    
    # Move an action to a different position
    [void] MoveAction([int]$fromIndex, [int]$toIndex) {
        if ($fromIndex -eq $toIndex -or 
            $fromIndex -lt 0 -or $fromIndex -ge $this.Actions.Count -or
            $toIndex -lt 0 -or $toIndex -ge $this.Actions.Count) {
            return
        }
        
        $action = $this.Actions[$fromIndex]
        $this.Actions.RemoveAt($fromIndex)
        
        # Adjust target index if we removed an item before it
        if ($fromIndex -lt $toIndex) {
            $toIndex--
        }
        
        $this.Actions.Insert($toIndex, $action)
        $this.UpdateProducedVariables()
        
        if ($this.Logger) {
            $this.Logger.Debug("Moved action '$($action.Name)' from $fromIndex to $toIndex")
        }
    }
    
    # Get the context available at a specific step (temporal safety)
    [hashtable] GetContextAtStep([int]$stepIndex) {
        $context = $this.GlobalContext.Clone()
        
        # Add variables produced by all previous actions
        for ($i = 0; $i -lt $stepIndex -and $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            foreach ($produced in $action.Produces) {
                $varName = $this.ResolveVariableName($produced.Name, $i)
                $context[$varName] = @{
                    Type = $produced.Type
                    Description = $produced.Description
                    ProducedBy = $action.Name
                    StepIndex = $i
                    Available = $true
                }
            }
        }
        
        return $context
    }
    
    # Get all variables available in the macro (for final context view)
    [hashtable] GetFullContext() {
        return $this.GetContextAtStep($this.Actions.Count)
    }
    
    # Resolve variable name with automatic collision handling
    [string] ResolveVariableName([string]$baseName, [int]$actionIndex) {
        $context = $this.GetContextAtStep($actionIndex)
        
        # If no collision, use base name
        if (-not $context.ContainsKey($baseName)) {
            return $baseName
        }
        
        # Handle collision by appending action name and counter
        $action = $this.Actions[$actionIndex]
        $actionName = $action.Name -replace '\s+', ''  # Remove spaces
        $suffix = 1
        
        do {
            $candidateName = "${baseName}_${actionName}_${suffix}"
            $suffix++
        } while ($context.ContainsKey($candidateName))
        
        return $candidateName
    }
    
    # Update all produced variables after sequence changes
    [void] UpdateProducedVariables() {
        # This ensures variable names are recalculated when actions are added/removed/moved
        # The actual resolution happens in GetContextAtStep, so no action needed here
        # But we could invalidate any cached contexts if we implement caching
    }
    
    # Validate that all actions have their required context
    [hashtable] ValidateMacro() {
        $validation = @{
            IsValid = $true
            Errors = @()
            Warnings = @()
        }
        
        for ($i = 0; $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            $availableContext = $this.GetContextAtStep($i)
            
            # Check if all required variables are available
            foreach ($requirement in $action.Consumes) {
                if (-not $availableContext.ContainsKey($requirement.Name)) {
                    $validation.IsValid = $false
                    $validation.Errors += "Step $($i + 1) ($($action.Name)): Missing required variable '$($requirement.Name)'"
                }
            }
        }
        
        return $validation
    }
    
    # Generate the final IDEAScript
    [string] GenerateScript() {
        $validation = $this.ValidateMacro()
        if (-not $validation.IsValid) {
            throw "Cannot generate script: Macro validation failed. Errors: $($validation.Errors -join '; ')"
        }
        
        $sb = [System.Text.StringBuilder]::new()
        $sb.AppendLine("' Generated by PRAXIS Visual Macro Factory")
        $sb.AppendLine("' Generated on: $(Get-Date)")
        $sb.AppendLine("' Total steps: $($this.Actions.Count)")
        $sb.AppendLine("")
        
        for ($i = 0; $i -lt $this.Actions.Count; $i++) {
            $action = $this.Actions[$i]
            $context = $this.GetContextAtStep($i + 1)  # Context after this action runs
            
            $sb.AppendLine("' Step $($i + 1): $($action.Name)")
            if ($action.Description) {
                $sb.AppendLine("' $($action.Description)")
            }
            $sb.AppendLine("")
            
            try {
                $actionScript = $action.RenderScript($context)
                $sb.AppendLine($actionScript)
            } catch {
                $sb.AppendLine("' ERROR generating script for $($action.Name): $($_.Exception.Message)")
            }
            
            $sb.AppendLine("")
        }
        
        return $sb.ToString()
    }
    
    # Clear all actions and reset context
    [void] Clear() {
        $this.Actions.Clear()
        $this.InitializeGlobalContext()
        
        if ($this.Logger) {
            $this.Logger.Debug("Cleared macro context")
        }
    }
    
    # Get summary of current macro
    [hashtable] GetSummary() {
        return @{
            ActionCount = $this.Actions.Count
            TotalVariables = $this.GetFullContext().Count
            IsValid = $this.ValidateMacro().IsValid
            Actions = $this.Actions | ForEach-Object { $_.Name }
        }
    }
}


####\Services/ProjectService.ps1
# ProjectService - Business logic for project management
# Lightweight service focusing on project-related operations

class ProjectService {
    hidden [System.Collections.ArrayList]$Projects = [System.Collections.ArrayList]::new()
    hidden [string]$DataFile
    
    ProjectService() {
        # Use PRAXIS data directory
        $praxisDir = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PSScriptRoot }
        $this.DataFile = Join-Path $praxisDir "_ProjectData/projects.json"
        
        # Ensure directory exists
        $dataDir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        
        $this.LoadProjects()
    }
    
    [void] LoadProjects() {
        if (Test-Path $this.DataFile) {
            try {
                $json = Get-Content $this.DataFile -Raw
                $data = $json | ConvertFrom-Json
                $this.Projects.Clear()
                foreach ($projData in $data) {
                    # Handle both old and new format
                    if ($projData.PSObject.Properties['FullProjectName']) {
                        # New PMC format
                        $project = [Project]::new($projData.FullProjectName, $projData.Nickname)
                        $project.Id = $projData.Id
                        $project.ID1 = $projData.ID1 ?? ""
                        $project.ID2 = $projData.ID2 ?? ""
                        if ($projData.DateAssigned) { $project.DateAssigned = [DateTime]::Parse($projData.DateAssigned) }
                        if ($projData.BFDate) { $project.BFDate = [DateTime]::Parse($projData.BFDate) }
                        if ($projData.DateDue) { $project.DateDue = [DateTime]::Parse($projData.DateDue) }
                        $project.Note = $projData.Note ?? ""
                        $project.CAAPath = $projData.CAAPath ?? ""
                        $project.RequestPath = $projData.RequestPath ?? ""
                        $project.T2020Path = $projData.T2020Path ?? ""
                        $project.CumulativeHrs = $projData.CumulativeHrs ?? 0
                        if ($projData.ClosedDate -and $projData.ClosedDate -ne "0001-01-01T00:00:00") { 
                            $project.ClosedDate = [DateTime]::Parse($projData.ClosedDate) 
                        }
                        
                        # Load all the new fields
                        $project.Status = $projData.Status ?? "Active"
                        $project.ClientID = $projData.ClientID ?? ""
                        
                        # Audit fields
                        $project.AuditType = $projData.AuditType ?? ""
                        $project.AuditProgram = $projData.AuditProgram ?? ""
                        $project.AuditCase = $projData.AuditCase ?? ""
                        if ($projData.AuditStartDate -and $projData.AuditStartDate -ne "0001-01-01T00:00:00") {
                            $project.AuditStartDate = [DateTime]::Parse($projData.AuditStartDate)
                        }
                        if ($projData.AuditPeriodFrom -and $projData.AuditPeriodFrom -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodFrom = [DateTime]::Parse($projData.AuditPeriodFrom)
                        }
                        if ($projData.AuditPeriodTo -and $projData.AuditPeriodTo -ne "0001-01-01T00:00:00") {
                            $project.AuditPeriodTo = [DateTime]::Parse($projData.AuditPeriodTo)
                        }
                        
                        # Additional audit periods
                        for ($i = 1; $i -le 5; $i++) {
                            $startProp = "AuditPeriod${i}Start"
                            $endProp = "AuditPeriod${i}End"
                            if ($projData.$startProp -and $projData.$startProp -ne "0001-01-01T00:00:00") {
                                $project.$startProp = [DateTime]::Parse($projData.$startProp)
                            }
                            if ($projData.$endProp -and $projData.$endProp -ne "0001-01-01T00:00:00") {
                                $project.$endProp = [DateTime]::Parse($projData.$endProp)
                            }
                        }
                        
                        # Address fields
                        $project.Address = $projData.Address ?? ""
                        $project.City = $projData.City ?? ""
                        $project.Province = $projData.Province ?? ""
                        $project.PostalCode = $projData.PostalCode ?? ""
                        $project.Country = $projData.Country ?? ""
                        $project.ShipToAddress = $projData.ShipToAddress ?? ""
                        
                        # Auditor fields
                        $project.AuditorName = $projData.AuditorName ?? ""
                        $project.AuditorPhone = $projData.AuditorPhone ?? ""
                        $project.AuditorTL = $projData.AuditorTL ?? ""
                        $project.AuditorTLPhone = $projData.AuditorTLPhone ?? ""
                        
                        # Contact fields
                        $project.Contact1Name = $projData.Contact1Name ?? ""
                        $project.Contact1Phone = $projData.Contact1Phone ?? ""
                        $project.Contact1Ext = $projData.Contact1Ext ?? ""
                        $project.Contact1Address = $projData.Contact1Address ?? ""
                        $project.Contact1Title = $projData.Contact1Title ?? ""
                        $project.Contact2Name = $projData.Contact2Name ?? ""
                        $project.Contact2Phone = $projData.Contact2Phone ?? ""
                        $project.Contact2Ext = $projData.Contact2Ext ?? ""
                        $project.Contact2Address = $projData.Contact2Address ?? ""
                        $project.Contact2Title = $projData.Contact2Title ?? ""
                        
                        # Software fields
                        $project.AccountingSoftware1 = $projData.AccountingSoftware1 ?? ""
                        $project.AccountingSoftware1Other = $projData.AccountingSoftware1Other ?? ""
                        $project.AccountingSoftware1Type = $projData.AccountingSoftware1Type ?? ""
                        $project.AccountingSoftware2 = $projData.AccountingSoftware2 ?? ""
                        $project.AccountingSoftware2Other = $projData.AccountingSoftware2Other ?? ""
                        $project.AccountingSoftware2Type = $projData.AccountingSoftware2Type ?? ""
                        
                        # Other fields
                        if ($projData.RequestDate -and $projData.RequestDate -ne "0001-01-01T00:00:00") {
                            $project.RequestDate = [DateTime]::Parse($projData.RequestDate)
                        }
                        $project.FXInfo = $projData.FXInfo ?? ""
                        $project.Comments = $projData.Comments ?? ""
                        
                        $project.Deleted = $projData.Deleted ?? $false
                    } else {
                        # Legacy format
                        $project = [Project]::new($projData.Name)
                        $project.Id = $projData.Id
                        if ($projData.Description) { $project.Note = $projData.Description }
                    }
                    $this.Projects.Add($project) | Out-Null
                }
            }
            catch {
                Write-Error "Failed to load projects: $_"
            }
        }
        
        # Ensure default project exists
        if (-not ($this.Projects | Where-Object { $_.Nickname -eq "Default" })) {
            $default = [Project]::new("Default")
            $default.Note = "Default project for uncategorized tasks"
            $this.Projects.Add($default) | Out-Null
            $this.SaveProjects()
        }
    }
    
    [void] SaveProjects() {
        $dir = Split-Path $this.DataFile -Parent
        if (-not (Test-Path $dir)) {
            New-Item -ItemType Directory -Path $dir -Force | Out-Null
        }
        
        $data = @()
        foreach ($project in $this.Projects) {
            $data += @{
                Id = $project.Id
                FullProjectName = $project.FullProjectName
                Nickname = $project.Nickname
                ID1 = $project.ID1
                ID2 = $project.ID2
                DateAssigned = $project.DateAssigned.ToString("yyyy-MM-ddTHH:mm:ss")
                BFDate = $project.BFDate.ToString("yyyy-MM-ddTHH:mm:ss")
                DateDue = $project.DateDue.ToString("yyyy-MM-ddTHH:mm:ss")
                Note = $project.Note
                CAAPath = $project.CAAPath
                RequestPath = $project.RequestPath
                T2020Path = $project.T2020Path
                CumulativeHrs = $project.CumulativeHrs
                ClosedDate = $project.ClosedDate.ToString("yyyy-MM-ddTHH:mm:ss")
                Deleted = $project.Deleted
            }
        }
        
        $json = $data | ConvertTo-Json -Depth 10
        Set-Content -Path $this.DataFile -Value $json
    }
    
    [Project[]] GetAllProjects() {
        return $this.Projects.ToArray()
    }
    
    [Project] GetProject([string]$id) {
        return $this.Projects | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Project] GetProjectByName([string]$name) {
        return $this.Projects | Where-Object { $_.Nickname -eq $name -or $_.FullProjectName -eq $name } | Select-Object -First 1
    }
    
    [Project] AddProject([string]$name) {
        # Check if already exists
        $existing = $this.GetProjectByName($name)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($name)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([string]$fullName, [string]$nickname) {
        # Check if already exists
        $existing = $this.GetProjectByName($nickname)
        if ($existing) {
            return $existing
        }
        
        $project = [Project]::new($fullName, $nickname)
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [Project] AddProject([Project]$project) {
        # Check if already exists by nickname
        $existing = $this.GetProjectByName($project.Nickname)
        if ($existing) {
            return $existing
        }
        
        $this.Projects.Add($project) | Out-Null
        $this.SaveProjects()
        return $project
    }
    
    [void] UpdateProject([Project]$project) {
        $this.SaveProjects()
    }
    
    [void] DeleteProject([string]$id) {
        $project = $this.GetProject($id)
        if ($project -and $project.Nickname -ne "Default") {
            $this.Projects.Remove($project)
            $this.SaveProjects()
        }
    }
    
    [hashtable[]] GetProjectsWithStats([object]$taskService) {
        $result = @()
        
        foreach ($project in $this.Projects) {
            $tasks = $taskService.GetTasksByProject($project.Nickname)
            $completed = ($tasks | Where-Object { $_.Status -eq "Done" }).Count
            $total = $tasks.Count
            
            $result += @{
                Project = $project
                Name = $project.Nickname  # Use nickname for compatibility
                FullName = $project.FullProjectName
                TaskCount = $total
                CompletedCount = $completed
                Progress = if ($total -gt 0) { $completed / $total } else { 0 }
            }
        }
        
        return $result
    }
}


####\Services/ShortcutManager.ps1
# ShortcutManager.ps1 - Centralized keyboard shortcut management service

enum ShortcutScope {
    Global      # Available everywhere
    Screen      # Available in specific screen types
    Context     # Available in specific contexts (e.g., when dialog is open)
}

class ShortcutDefinition {
    [string]$Id
    [string]$Name
    [string]$Description
    [System.ConsoleKey]$Key
    [System.ConsoleModifiers]$Modifiers
    [char]$KeyChar
    [ShortcutScope]$Scope
    [string]$ScreenType  # For Screen scope
    [string]$Context     # For Context scope
    [scriptblock]$Action
    [bool]$Enabled = $true
    [int]$Priority = 0   # Higher priority shortcuts are checked first
    
    ShortcutDefinition() {}
    
    [bool] Matches([System.ConsoleKeyInfo]$keyInfo) {
        # Check if this shortcut matches the pressed key
        if ($this.Key -ne [System.ConsoleKey]::None) {
            if ($keyInfo.Key -ne $this.Key) {
                return $false
            }
            if ($this.Modifiers -ne [System.ConsoleModifiers]::None) {
                if (($keyInfo.Modifiers -band $this.Modifiers) -ne $this.Modifiers) {
                    return $false
                }
            }
            return $true
        }
        elseif ($this.KeyChar -ne [char]0) {
            # Character-based shortcut
            return $keyInfo.KeyChar -eq $this.KeyChar
        }
        return $false
    }
    
    [string] GetDisplayText() {
        $parts = @()
        
        if ($this.Modifiers -band [System.ConsoleModifiers]::Control) {
            $parts += "Ctrl"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Alt) {
            $parts += "Alt"
        }
        if ($this.Modifiers -band [System.ConsoleModifiers]::Shift) {
            $parts += "Shift"
        }
        
        if ($this.Key -ne [System.ConsoleKey]::None) {
            $parts += $this.Key.ToString()
        }
        elseif ($this.KeyChar -ne [char]0) {
            $parts += $this.KeyChar.ToString()
        }
        
        return $parts -join "+"
    }
}

class ShortcutManager {
    hidden [System.Collections.Generic.List[ShortcutDefinition]]$Shortcuts
    hidden [Logger]$Logger
    hidden [EventBus]$EventBus
    
    ShortcutManager() {
        $this.Shortcuts = [System.Collections.Generic.List[ShortcutDefinition]]::new()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService('Logger')
        $this.EventBus = $container.GetService('EventBus')
        
        # Register default global shortcuts
        $this.RegisterDefaultShortcuts()
    }
    
    [void] RegisterDefaultShortcuts() {
        # Global shortcuts
        $this.RegisterShortcut(@{
            Id = "global.quit"
            Name = "Quit Application"
            Description = "Exit the application"
            Key = [System.ConsoleKey]::Q
            Modifiers = [System.ConsoleModifiers]::Control
            Scope = [ShortcutScope]::Global
            Priority = 100
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.RequestExit()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette"
            Name = "Command Palette"
            Description = "Open the command palette"
            KeyChar = ':'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
        
        $this.RegisterShortcut(@{
            Id = "global.command_palette_alt"
            Name = "Command Palette (Alt)"
            Description = "Open the command palette"
            KeyChar = '/'
            Scope = [ShortcutScope]::Global
            Priority = 90
            Action = {
                if ($global:ScreenManager) {
                    $global:ScreenManager.ShowCommandPalette()
                }
            }
        })
    }
    
    [void] RegisterShortcut([hashtable]$definition) {
        $shortcut = [ShortcutDefinition]::new()
        
        # Map hashtable properties to object
        foreach ($key in $definition.Keys) {
            if ($null -ne $shortcut.PSObject.Properties[$key]) {
                $shortcut.$key = $definition[$key]
            }
        }
        
        # Validate required properties
        if ([string]::IsNullOrEmpty($shortcut.Id)) {
            throw "Shortcut ID is required"
        }
        if (-not $shortcut.Action) {
            throw "Shortcut action is required"
        }
        
        # Remove existing shortcut with same ID
        $this.UnregisterShortcut($shortcut.Id)
        
        # Add new shortcut
        $this.Shortcuts.Add($shortcut)
        
        # Sort by priority (descending)
        $this.Shortcuts.Sort({ param($a, $b) $b.Priority.CompareTo($a.Priority) })
        
        if ($this.Logger) {
            $this.Logger.Debug("Registered shortcut: $($shortcut.Id) - $($shortcut.GetDisplayText())")
        }
    }
    
    [void] UnregisterShortcut([string]$id) {
        $existing = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($existing) {
            $this.Shortcuts.Remove($existing) | Out-Null
        }
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen, [string]$currentContext) {
        if ($this.Logger) {
            $this.Logger.Debug("ShortcutManager.HandleKeyPress: Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)' Screen=$currentScreen Context=$currentContext")
            $this.Logger.Debug("ShortcutManager: Total shortcuts registered: $($this.Shortcuts.Count)")
        }
        
        # Find matching shortcuts
        $candidates = $this.Shortcuts | Where-Object {
            $_.Enabled -and $_.Matches($keyInfo)
        }
        
        if ($this.Logger -and $candidates.Count -gt 0) {
            $this.Logger.Debug("ShortcutManager: Found $($candidates.Count) matching shortcuts")
        }
        
        # Filter by scope
        $applicable = @()
        foreach ($shortcut in $candidates) {
            if ($this.Logger) {
                $this.Logger.Debug("Checking shortcut: $($shortcut.Id) Scope=$($shortcut.Scope) ScreenType=$($shortcut.ScreenType)")
            }
            
            switch ($shortcut.Scope) {
                ([ShortcutScope]::Global) {
                    $applicable += $shortcut
                }
                ([ShortcutScope]::Screen) {
                    if ($shortcut.ScreenType -eq $currentScreen -or 
                        [string]::IsNullOrEmpty($shortcut.ScreenType)) {
                        if ($this.Logger) {
                            $this.Logger.Debug("Screen shortcut matches: $($shortcut.Id)")
                        }
                        $applicable += $shortcut
                    }
                }
                ([ShortcutScope]::Context) {
                    if ($shortcut.Context -eq $currentContext -or
                        [string]::IsNullOrEmpty($shortcut.Context)) {
                        $applicable += $shortcut
                    }
                }
            }
        }
        
        # Execute the highest priority applicable shortcut
        if ($applicable.Count -gt 0) {
            $shortcut = $applicable[0]  # Already sorted by priority
            
            if ($this.Logger) {
                $this.Logger.Debug("Executing shortcut: $($shortcut.Id)")
            }
            
            # Publish event before execution
            if ($this.EventBus) {
                $this.EventBus.Publish('shortcut.executing', @{
                    ShortcutId = $shortcut.Id
                    Key = $keyInfo
                })
            }
            
            try {
                # Execute the action
                & $shortcut.Action
                
                # Publish success event
                if ($this.EventBus) {
                    $this.EventBus.Publish('shortcut.executed', @{
                        ShortcutId = $shortcut.Id
                        Key = $keyInfo
                    })
                }
                
                return $true
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Error executing shortcut $($shortcut.Id): $_")
                }
                return $false
            }
        }
        
        return $false
    }
    
    [ShortcutDefinition[]] GetShortcuts([ShortcutScope]$scope, [string]$screenType) {
        return $this.Shortcuts | Where-Object {
            $_.Scope -eq $scope -and
            ($_.ScreenType -eq $screenType -or [string]::IsNullOrEmpty($_.ScreenType))
        }
    }
    
    [ShortcutDefinition[]] GetAllShortcuts() {
        return $this.Shortcuts
    }
    
    [hashtable] GetShortcutMap() {
        # Returns a hashtable for easy display in UI
        $map = @{}
        
        foreach ($shortcut in $this.Shortcuts) {
            $key = $shortcut.GetDisplayText()
            if (-not $map.ContainsKey($key)) {
                $map[$key] = @()
            }
            $map[$key] += @{
                Name = $shortcut.Name
                Description = $shortcut.Description
                Scope = $shortcut.Scope
                ScreenType = $shortcut.ScreenType
            }
        }
        
        return $map
    }
    
    [void] EnableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $true
        }
    }
    
    [void] DisableShortcut([string]$id) {
        $shortcut = $this.Shortcuts | Where-Object { $_.Id -eq $id }
        if ($shortcut) {
            $shortcut.Enabled = $false
        }
    }
    
    [string] GetShortcutHelp([ShortcutScope]$scope = [ShortcutScope]::Global, [string]$screenType = "") {
        $sb = [System.Text.StringBuilder]::new()
        $shortcutList = $this.GetShortcuts($scope, $screenType)
        
        if ($shortcutList.Count -gt 0) {
            $grouped = $shortcutList | Group-Object { $_.GetDisplayText() }
            
            foreach ($group in $grouped | Sort-Object Name) {
                $sb.AppendLine("$($group.Name):")
                foreach ($shortcut in $group.Group) {
                    $sb.AppendLine("  - $($shortcut.Name): $($shortcut.Description)")
                }
            }
        }
        
        return $sb.ToString()
    }
}


####\Services/SimpleShortcutHandler.ps1
# SimpleShortcutHandler.ps1 - Direct keyboard shortcuts via EventBus

class SimpleShortcutHandler {
    hidden [EventBus]$EventBus
    hidden [Logger]$Logger
    
    [void] Initialize([ServiceContainer]$container) {
        $this.EventBus = $container.GetService('EventBus')
        $this.Logger = $container.GetService('Logger')
    }
    
    [bool] HandleKeyPress([System.ConsoleKeyInfo]$keyInfo, [string]$currentScreen) {
        # Only handle character keys when no modifiers are pressed
        if ($keyInfo.Modifiers -ne [System.ConsoleModifiers]::None) {
            return $false
        }
        
        $char = [char]::ToLower($keyInfo.KeyChar)
        
        # Handle shortcuts based on current screen
        switch ($currentScreen) {
            "ProjectsScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewProject', 'ProjectsScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditProject', 'ProjectsScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteProject', 'ProjectsScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshProjects', 'ProjectsScreen')
                        return $true
                    }
                    'v' {
                        $this.PublishCommand('ViewProject', 'ProjectsScreen')
                        return $true
                    }
                }
            }
            "TaskScreen" {
                switch ($char) {
                    'n' {
                        $this.PublishCommand('NewTask', 'TaskScreen')
                        return $true
                    }
                    'e' {
                        $this.PublishCommand('EditTask', 'TaskScreen')
                        return $true
                    }
                    'd' {
                        $this.PublishCommand('DeleteTask', 'TaskScreen')
                        return $true
                    }
                    'r' {
                        $this.PublishCommand('RefreshTasks', 'TaskScreen')
                        return $true
                    }
                }
            }
        }
        
        return $false
    }
    
    hidden [void] PublishCommand([string]$command, [string]$target) {
        if ($this.Logger) {
            $this.Logger.Debug("SimpleShortcutHandler: Publishing command $command for $target")
        }
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::CommandExecuted, @{
                Command = $command
                Target = $target
            })
        }
    }
}


####\Services/StateManager.ps1
# StateManager.ps1 - Fast, robust, PowerShell-native state management
# Based on AxiomPhoenix patterns with PRAXIS optimizations

class StateManager {
    # Core state storage - PowerShell hashtables for maximum speed
    hidden [hashtable]$_state = @{}
    hidden [hashtable]$_subscribers = @{}
    hidden [hashtable]$_indexes = @{}
    
    # Performance optimization
    hidden [System.Collections.Generic.Dictionary[string, object]]$_fastIndex
    hidden [bool]$_isDirty = $false
    hidden [datetime]$_lastSave = [datetime]::MinValue
    
    # Transaction support
    hidden [int]$_transactionDepth = 0
    hidden [bool]$_pendingSave = $false
    hidden [hashtable]$_transactionChanges = @{}
    
    # Event integration
    [EventBus]$EventBus
    [Logger]$Logger
    
    # Configuration
    [string]$StatePath = ""
    [bool]$AutoSave = $true
    [int]$AutoSaveIntervalMs = 5000
    [int]$MaxBackups = 5
    [bool]$EnableCompression = $true
    
    # Performance metrics
    hidden [int]$_getOperations = 0
    hidden [int]$_setOperations = 0
    hidden [datetime]$_lastStatsReset = [datetime]::Now
    
    StateManager() {
        $this._fastIndex = [System.Collections.Generic.Dictionary[string, object]]::new()
        $this.InitializeDefaultState()
    }
    
    [void] Initialize([ServiceContainer]$services) {
        try {
            # Get required services
            $this.EventBus = $services.GetService("EventBus")
            $this.Logger = $services.GetService("Logger")
            
            # Set default state path
            if ([string]::IsNullOrEmpty($this.StatePath)) {
                $praxisRoot = if ($global:PraxisRoot) { $global:PraxisRoot } else { $PWD }
                $this.StatePath = Join-Path $praxisRoot "_State/application.json"
            }
            
            # Ensure state directory exists
            $stateDir = Split-Path $this.StatePath -Parent
            if (-not (Test-Path $stateDir)) {
                New-Item -ItemType Directory -Path $stateDir -Force | Out-Null
            }
            
            # Load existing state
            $this.LoadState()
            
            # Start auto-save if enabled
            if ($this.AutoSave) {
                $this.StartAutoSave()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager initialized: Path=$($this.StatePath), AutoSave=$($this.AutoSave)")
            }
            
        } catch {
            $this.LogError("StateManager initialization failed", @{ Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== CORE STATE OPERATIONS ====================
    
    # FAST: Direct hashtable access with error handling
    [object] GetState([string]$key) {
        return $this.GetState($key, $null)
    }
    
    [object] GetState([string]$key, [object]$defaultValue) {
        if ([string]::IsNullOrEmpty($key)) {
            return $defaultValue
        }
        
        try {
            $this._getOperations++
            
            # Try fast index first (Dictionary lookup - microseconds)
            if ($this._fastIndex.ContainsKey($key)) {
                return $this._fastIndex[$key]
            }
            
            # Fall back to dot-notation path traversal
            $keys = $key -split '\.'
            $current = $this._state
            
            foreach ($k in $keys) {
                if ($current -eq $null -or -not $current.ContainsKey($k)) {
                    return $defaultValue
                }
                $current = $current[$k]
            }
            
            # Cache in fast index for next time
            $this._fastIndex[$key] = $current
            
            return if ($current -eq $null) { $defaultValue } else { $current }
            
        } catch {
            $this.LogError("GetState failed", @{ Key = $key; Error = $_.Exception.Message })
            return $defaultValue
        }
    }
    
    # FAST: Direct state updates with smart change detection
    [void] SetState([string]$key, [object]$value) {
        $this.SetState($key, $value, $true)
    }
    
    [void] SetState([string]$key, [object]$value, [bool]$publishEvents) {
        if ([string]::IsNullOrEmpty($key)) {
            return
        }
        
        try {
            $this._setOperations++
            
            # Fast equality check to avoid unnecessary updates
            $currentValue = $this.GetState($key)
            if ($this.AreEqual($currentValue, $value)) {
                return  # No change, skip update
            }
            
            # Store old value for events
            $oldValue = $currentValue
            
            # Update both storage mechanisms
            $this.SetStateInternal($key, $value)
            $this._fastIndex[$key] = $value
            
            # Track transaction changes
            if ($this._transactionDepth -gt 0) {
                $this._transactionChanges[$key] = @{ 
                    NewValue = $value
                    OldValue = $oldValue 
                }
            }
            
            # Mark as dirty and trigger save
            $this.MarkDirty()
            
            # Publish change events
            if ($publishEvents -and $this.EventBus) {
                $this.PublishStateChange($key, $value, $oldValue)
            }
            
        } catch {
            $this.LogError("SetState failed", @{ Key = $key; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== TRANSACTION SUPPORT ====================
    
    [void] BeginTransaction() {
        $this._transactionDepth++
        if ($this._transactionDepth -eq 1) {
            $this._transactionChanges.Clear()
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Transaction started")
            }
        }
    }
    
    [void] EndTransaction() {
        if ($this._transactionDepth -gt 0) {
            $this._transactionDepth--
            
            # Process all changes when transaction completes
            if ($this._transactionDepth -eq 0) {
                try {
                    # Batch save
                    if ($this._pendingSave) {
                        $this.SaveState()
                        $this._pendingSave = $false
                    }
                    
                    # Batch event publishing
                    if ($this._transactionChanges.Count -gt 0 -and $this.EventBus) {
                        $this.EventBus.Publish("State.TransactionComplete", @{
                            Changes = $this._transactionChanges
                            ChangeCount = $this._transactionChanges.Count
                        })
                    }
                    
                    if ($this.Logger) {
                        $this.Logger.Debug("StateManager: Transaction completed with $($this._transactionChanges.Count) changes")
                    }
                    
                } catch {
                    $this.LogError("Transaction completion failed", @{ Error = $_.Exception.Message })
                    throw
                } finally {
                    $this._transactionChanges.Clear()
                }
            }
        }
    }
    
    [void] RollbackTransaction() {
        if ($this._transactionDepth -gt 0) {
            try {
                # Restore all changed values to their original state
                foreach ($change in $this._transactionChanges.GetEnumerator()) {
                    $key = $change.Key
                    $oldValue = $change.Value.OldValue
                    
                    # Directly restore without triggering events or new transaction tracking
                    $this.SetStateInternal($key, $oldValue)
                    $this._fastIndex[$key] = $oldValue
                }
                
                if ($this.Logger) {
                    $this.Logger.Debug("StateManager: Transaction rolled back, $($this._transactionChanges.Count) changes reverted")
                }
                
            } catch {
                $this.LogError("Transaction rollback failed", @{ Error = $_.Exception.Message })
                throw
            } finally {
                $this._transactionChanges.Clear()
                $this._transactionDepth = 0
                $this._pendingSave = $false
            }
        }
    }
    
    # ==================== PERSISTENCE ====================
    
    [void] LoadState() {
        if (-not (Test-Path $this.StatePath)) {
            if ($this.Logger) {
                $this.Logger.Info("StateManager: No existing state file, using defaults")
            }
            return
        }
        
        try {
            $json = Get-Content $this.StatePath -Raw -ErrorAction Stop
            if ([string]::IsNullOrEmpty($json)) {
                return
            }
            
            $data = $json | ConvertFrom-Json -AsHashtable -ErrorAction Stop
            if ($data -and $data.ContainsKey("State")) {
                $this._state = $data.State
                $this.RebuildFastIndex()
            }
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager: State loaded successfully from $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to load state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            
            # Try to load from backup
            $this.LoadFromBackup()
        }
    }
    
    [void] SaveState() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Create backup before save
            $this.CreateBackup()
            
            # Prepare data for serialization
            $data = @{
                State = $this._state
                Metadata = @{
                    Version = "1.0.0"
                    SavedAt = [datetime]::Now.ToString('o')
                    StateKeys = @($this._state.Keys)
                    FastIndexKeys = @($this._fastIndex.Keys) 
                    Stats = @{
                        GetOperations = $this._getOperations
                        SetOperations = $this._setOperations
                    }
                }
            }
            
            # Convert to JSON with compression option
            $jsonParams = @{
                Depth = 10
                Compress = $this.EnableCompression
            }
            $json = $data | ConvertTo-Json @jsonParams
            
            # Atomic write (write to temp file, then replace)
            $tempPath = "$($this.StatePath).tmp"
            [System.IO.File]::WriteAllText($tempPath, $json, [System.Text.Encoding]::UTF8)
            Move-Item $tempPath $this.StatePath -Force
            
            # Update tracking
            $this._isDirty = $false
            $this._lastSave = [datetime]::Now
            
            # Publish save event
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Saved", @{
                    Path = $this.StatePath
                    StateKeyCount = $data.Metadata.StateKeys.Count
                    SaveTime = $this._lastSave
                })
            }
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: State saved to $($this.StatePath)")
            }
            
        } catch {
            $this.LogError("Failed to save state", @{ Path = $this.StatePath; Error = $_.Exception.Message })
            throw
        }
    }
    
    # ==================== PERFORMANCE OPTIMIZATIONS ====================
    
    [void] RebuildFastIndex() {
        try {
            $this._fastIndex.Clear()
            $this.BuildFastIndexRecursive("", $this._state)
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Fast index rebuilt with $($this._fastIndex.Count) entries")
            }
            
        } catch {
            $this.LogError("Fast index rebuild failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] BuildFastIndexRecursive([string]$prefix, [hashtable]$data) {
        foreach ($key in $data.Keys) {
            $fullKey = if ($prefix) { "$prefix.$key" } else { $key }
            $value = $data[$key]
            
            # Add to fast index
            $this._fastIndex[$fullKey] = $value
            
            # Recurse into nested hashtables
            if ($value -is [hashtable]) {
                $this.BuildFastIndexRecursive($fullKey, $value)
            }
        }
    }
    
    [bool] AreEqual([object]$a, [object]$b) {
        # Fast reference equality check first
        if ([object]::ReferenceEquals($a, $b)) {
            return $true
        }
        
        # Null checks
        if ($a -eq $null -or $b -eq $null) {
            return ($a -eq $null -and $b -eq $null)
        }
        
        # Use PowerShell's efficient comparison
        try {
            # For complex objects, try Equals method first
            if ($a.GetType().GetMethod("Equals", @([object]))) {
                return $a.Equals($b)
            }
            
            # Fall back to PowerShell comparison
            return $a -eq $b
            
        } catch {
            # If comparison fails, assume not equal
            return $false
        }
    }
    
    # ==================== EVENT SYSTEM ====================
    
    [void] OnStateChanged([string]$pattern, [scriptblock]$handler) {
        if ([string]::IsNullOrEmpty($pattern) -or $handler -eq $null) {
            return
        }
        
        try {
            if (-not $this._subscribers.ContainsKey($pattern)) {
                $this._subscribers[$pattern] = @()
            }
            
            $this._subscribers[$pattern] += $handler
            
            if ($this.Logger) {
                $this.Logger.Debug("StateManager: Subscriber added for pattern '$pattern'")
            }
            
        } catch {
            $this.LogError("Failed to add state subscriber", @{ Pattern = $pattern; Error = $_.Exception.Message })
        }
    }
    
    hidden [void] PublishStateChange([string]$key, [object]$newValue, [object]$oldValue) {
        if ($this._transactionDepth -gt 0) {
            return  # Don't publish during transactions
        }
        
        try {
            # Publish to EventBus
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Changed", @{
                    Key = $key
                    NewValue = $newValue
                    OldValue = $oldValue
                    Timestamp = [datetime]::Now
                })
            }
            
            # Publish to pattern subscribers
            foreach ($pattern in $this._subscribers.Keys) {
                if ($this.MatchesPattern($key, $pattern)) {
                    foreach ($handler in $this._subscribers[$pattern]) {
                        try {
                            & $handler @{
                                Key = $key
                                NewValue = $newValue
                                OldValue = $oldValue
                            }
                        } catch {
                            $this.LogError("State subscriber handler failed", @{ 
                                Pattern = $pattern
                                Key = $key
                                Error = $_.Exception.Message 
                            })
                        }
                    }
                }
            }
            
        } catch {
            $this.LogError("Failed to publish state change", @{ Key = $key; Error = $_.Exception.Message })
        }
    }
    
    [bool] MatchesPattern([string]$key, [string]$pattern) {
        # Simple wildcard pattern matching
        if ($pattern -eq "*") {
            return $true
        }
        
        if ($pattern.EndsWith("*")) {
            $prefix = $pattern.Substring(0, $pattern.Length - 1)
            return $key.StartsWith($prefix)
        }
        
        return $key -eq $pattern
    }
    
    # ==================== INTERNAL HELPERS ====================
    
    [void] InitializeDefaultState() {
        $this._state = @{
            app = @{
                version = "1.0.0"
                startTime = [datetime]::Now
                sessionId = [System.Guid]::NewGuid().ToString()
            }
            ui = @{
                currentScreen = ""
                selectedItems = @{}
                viewStates = @{}
            }
            data = @{
                projects = @{}
                tasks = @{}
                config = @{}
            }
        }
        
        $this.RebuildFastIndex()
    }
    
    hidden [void] SetStateInternal([string]$key, [object]$value) {
        $keys = $key -split '\.'
        $current = $this._state
        
        # Navigate to parent container
        for ($i = 0; $i -lt $keys.Count - 1; $i++) {
            $k = $keys[$i]
            if (-not $current.ContainsKey($k)) {
                $current[$k] = @{}
            }
            $current = $current[$k]
        }
        
        # Set the final value
        $finalKey = $keys[-1]
        $current[$finalKey] = $value
    }
    
    [void] MarkDirty() {
        $this._isDirty = $true
        
        if ($this._transactionDepth -gt 0) {
            $this._pendingSave = $true
        } elseif ($this.AutoSave) {
            # Immediate save for non-transaction updates
            $this.SaveState()
        }
    }
    
    hidden [void] CreateBackup() {
        if (-not (Test-Path $this.StatePath)) {
            return
        }
        
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                New-Item -ItemType Directory -Path $backupDir -Force | Out-Null
            }
            
            $timestamp = [datetime]::Now.ToString("yyyyMMdd_HHmmss")
            $backupPath = Join-Path $backupDir "application_$timestamp.json"
            
            Copy-Item $this.StatePath $backupPath
            
            # Clean old backups
            $this.CleanOldBackups($backupDir)
            
        } catch {
            $this.LogError("Backup creation failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] CleanOldBackups([string]$backupDir) {
        try {
            $backups = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending
            
            if ($backups.Count -gt $this.MaxBackups) {
                $toDelete = $backups | Select-Object -Skip $this.MaxBackups
                foreach ($file in $toDelete) {
                    Remove-Item $file.FullName -Force
                }
            }
            
        } catch {
            $this.LogError("Backup cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] LoadFromBackup() {
        try {
            $backupDir = Join-Path (Split-Path $this.StatePath -Parent) "Backups"
            if (-not (Test-Path $backupDir)) {
                return
            }
            
            $latestBackup = Get-ChildItem $backupDir -Filter "application_*.json" | Sort-Object CreationTime -Descending | Select-Object -First 1
            
            if ($latestBackup) {
                $json = Get-Content $latestBackup.FullName -Raw
                $data = $json | ConvertFrom-Json -AsHashtable
                
                if ($data -and $data.ContainsKey("State")) {
                    $this._state = $data.State
                    $this.RebuildFastIndex()
                    
                    if ($this.Logger) {
                        $this.Logger.Info("StateManager: Recovered from backup: $($latestBackup.Name)")
                    }
                }
            }
            
        } catch {
            $this.LogError("Backup recovery failed", @{ Error = $_.Exception.Message })
        }
    }
    
    hidden [void] StartAutoSave() {
        # Note: PowerShell doesn't have great built-in timer support
        # This could be enhanced with System.Timers.Timer if needed
        # For now, auto-save happens on each SetState call
    }
    
    hidden [void] LogError([string]$message, [hashtable]$context = @{}) {
        if ($this.Logger) {
            $this.Logger.Error("$message - Context: $($context | ConvertTo-Json -Compress)")
        }
    }
    
    # ==================== PUBLIC API METHODS ====================
    
    [hashtable] GetPerformanceStats() {
        $uptime = [datetime]::Now - $this._lastStatsReset
        
        return @{
            GetOperations = $this._getOperations
            SetOperations = $this._setOperations
            FastIndexSize = $this._fastIndex.Count
            StateKeyCount = $this._state.Keys.Count
            TransactionDepth = $this._transactionDepth
            IsDirty = $this._isDirty
            LastSave = $this._lastSave
            Uptime = $uptime.ToString()
            OperationsPerSecond = if ($uptime.TotalSeconds -gt 0) { ($this._getOperations + $this._setOperations) / $uptime.TotalSeconds } else { 0 }
        }
    }
    
    [void] ResetPerformanceStats() {
        $this._getOperations = 0
        $this._setOperations = 0
        $this._lastStatsReset = [datetime]::Now
    }
    
    [void] ClearState() {
        $this.BeginTransaction()
        try {
            $this._state.Clear()
            $this._fastIndex.Clear()
            $this.InitializeDefaultState()
            
            if ($this.EventBus) {
                $this.EventBus.Publish("State.Cleared", @{ Timestamp = [datetime]::Now })
            }
            
        } finally {
            $this.EndTransaction()
        }
    }
    
    [void] Cleanup() {
        try {
            if ($this._isDirty) {
                $this.SaveState()
            }
            
            $this._subscribers.Clear()
            $this._fastIndex.Clear()
            
            if ($this.Logger) {
                $this.Logger.Info("StateManager cleanup completed")
            }
            
        } catch {
            $this.LogError("Cleanup failed", @{ Error = $_.Exception.Message })
        }
    }
}


####\Services/SubtaskService.ps1
# SubtaskService.ps1 - Service for managing subtasks

class SubtaskService {
    [System.Collections.Generic.List[Subtask]]$Subtasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    SubtaskService() {
        $this.Subtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "subtasks.json"
        
        # Load existing subtasks
        $this.Load()
    }
    
    # CRUD Operations
    [Subtask] AddSubtask([string]$parentTaskId, [string]$title) {
        $subtask = [Subtask]::new($parentTaskId)
        $subtask.Title = $title
        
        # Set sort order to be last among siblings
        $siblings = $this.GetSubtasksForTask($parentTaskId)
        if ($siblings.Count -gt 0) {
            $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
            $subtask.SortOrder = $maxOrder + 1
        } else {
            $subtask.SortOrder = 0
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] CreateSubtask([hashtable]$properties) {
        $subtask = [Subtask]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($key -eq 'Progress') {
                # Use UpdateProgress to auto-handle status changes
                $subtask.UpdateProgress($properties[$key])
            } elseif ($subtask.PSObject.Properties.Name -contains $key) {
                $subtask.$key = $properties[$key]
            }
        }
        
        # Ensure sort order is set
        if (-not $properties.ContainsKey('SortOrder')) {
            $siblings = $this.GetSubtasksForTask($subtask.ParentTaskId)
            if ($siblings.Count -gt 0) {
                $maxOrder = ($siblings | Measure-Object SortOrder -Maximum).Maximum
                $subtask.SortOrder = $maxOrder + 1
            } else {
                $subtask.SortOrder = 0
            }
        }
        
        $this.Subtasks.Add($subtask)
        $this._isDirty = $true
        $this.Save()
        
        return $subtask
    }
    
    [Subtask] GetSubtask([string]$id) {
        return $this.Subtasks | Where-Object { $_.Id -eq $id -and -not $_.Deleted } | Select-Object -First 1
    }
    
    [System.Collections.Generic.List[Subtask]] GetSubtasksForTask([string]$parentTaskId) {
        $taskSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if ($subtask.ParentTaskId -eq $parentTaskId -and -not $subtask.Deleted) {
                $taskSubtasks.Add($subtask)
            }
        }
        
        # Sort by SortOrder
        return $taskSubtasks | Sort-Object SortOrder
    }
    
    [System.Collections.Generic.List[Subtask]] GetAllSubtasks() {
        $activeSubtasks = [System.Collections.Generic.List[Subtask]]::new()
        
        foreach ($subtask in $this.Subtasks) {
            if (-not $subtask.Deleted) {
                $activeSubtasks.Add($subtask)
            }
        }
        
        return $activeSubtasks
    }
    
    [void] UpdateSubtask([Subtask]$subtask) {
        $existingSubtask = $this.GetSubtask($subtask.Id)
        if ($existingSubtask) {
            $existingSubtask.Title = $subtask.Title
            $existingSubtask.Description = $subtask.Description
            $existingSubtask.Status = $subtask.Status
            $existingSubtask.Priority = $subtask.Priority
            $existingSubtask.UpdateProgress($subtask.Progress)  # Use UpdateProgress to auto-handle status
            $existingSubtask.DueDate = $subtask.DueDate
            $existingSubtask.Tags = $subtask.Tags
            $existingSubtask.EstimatedMinutes = $subtask.EstimatedMinutes
            $existingSubtask.ActualMinutes = $subtask.ActualMinutes
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] DeleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Deleted = $true
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] CompleteSubtask([string]$id) {
        $subtask = $this.GetSubtask($id)
        if ($subtask) {
            $subtask.Status = [TaskStatus]::Completed
            $subtask.Progress = 100
            $subtask.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    [void] ReorderSubtasks([string]$parentTaskId, [string[]]$subtaskIds) {
        $sortOrder = 0
        foreach ($subtaskId in $subtaskIds) {
            $subtask = $this.GetSubtask($subtaskId)
            if ($subtask -and $subtask.ParentTaskId -eq $parentTaskId) {
                $subtask.SortOrder = $sortOrder
                $subtask.UpdatedAt = Get-Date
                $sortOrder++
            }
        }
        $this._isDirty = $true
        $this.Save()
    }
    
    # Calculate parent task progress based on subtask completion
    [int] CalculateTaskProgress([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        if ($taskSubtasks.Count -eq 0) {
            return 0
        }
        
        $totalProgress = 0
        foreach ($subtask in $taskSubtasks) {
            $totalProgress += $subtask.Progress
        }
        
        return [Math]::Floor($totalProgress / $taskSubtasks.Count)
    }
    
    [hashtable] GetTaskStatistics([string]$parentTaskId) {
        $taskSubtasks = $this.GetSubtasksForTask($parentTaskId)
        
        $stats = @{
            Total = $taskSubtasks.Count
            Completed = 0
            InProgress = 0
            Pending = 0
            Overdue = 0
            EstimatedMinutes = 0
            ActualMinutes = 0
        }
        
        foreach ($subtask in $taskSubtasks) {
            switch ($subtask.Status) {
                ([TaskStatus]::Completed) { $stats.Completed++ }
                ([TaskStatus]::InProgress) { $stats.InProgress++ }
                ([TaskStatus]::Pending) { $stats.Pending++ }
            }
            
            if ($subtask.IsOverdue()) {
                $stats.Overdue++
            }
            
            $stats.EstimatedMinutes += $subtask.EstimatedMinutes
            $stats.ActualMinutes += $subtask.ActualMinutes
        }
        
        return $stats
    }
    
    # Data persistence
    [void] Save() {
        if (-not $this._isDirty) {
            return
        }
        
        try {
            # Convert to serializable format
            $data = @()
            foreach ($subtask in $this.Subtasks) {
                $data += @{
                    Id = $subtask.Id
                    ParentTaskId = $subtask.ParentTaskId
                    Title = $subtask.Title
                    Description = $subtask.Description
                    Status = [int]$subtask.Status
                    Priority = [int]$subtask.Priority
                    Progress = $subtask.Progress
                    SortOrder = $subtask.SortOrder
                    Tags = $subtask.Tags
                    DueDate = if ($subtask.DueDate -eq [DateTime]::MinValue) { "" } else { $subtask.DueDate.ToString("yyyy-MM-ddTHH:mm:ss") }
                    CreatedAt = $subtask.CreatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    UpdatedAt = $subtask.UpdatedAt.ToString("yyyy-MM-ddTHH:mm:ss")
                    EstimatedMinutes = $subtask.EstimatedMinutes
                    ActualMinutes = $subtask.ActualMinutes
                    Deleted = $subtask.Deleted
                }
            }
            
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to save subtasks: $($_.Exception.Message)"
        }
    }
    
    [void] Load() {
        if (-not (Test-Path $this.DataPath)) {
            return
        }
        
        try {
            $json = Get-Content -Path $this.DataPath -Raw -Encoding UTF8
            $data = $json | ConvertFrom-Json
            
            $this.Subtasks.Clear()
            
            foreach ($item in $data) {
                $subtask = [Subtask]::new()
                $subtask.Id = $item.Id
                $subtask.ParentTaskId = $item.ParentTaskId
                $subtask.Title = $item.Title
                $subtask.Description = $item.Description
                $subtask.Status = [TaskStatus]$item.Status
                $subtask.Priority = [TaskPriority]$item.Priority
                $subtask.Progress = $item.Progress
                $subtask.SortOrder = $item.SortOrder
                $subtask.Tags = $item.Tags
                $subtask.DueDate = if ([string]::IsNullOrEmpty($item.DueDate)) { [DateTime]::MinValue } else { [DateTime]::Parse($item.DueDate) }
                $subtask.CreatedAt = [DateTime]::Parse($item.CreatedAt)
                $subtask.UpdatedAt = [DateTime]::Parse($item.UpdatedAt)
                $subtask.EstimatedMinutes = if ($item.PSObject.Properties.Name -contains 'EstimatedMinutes') { $item.EstimatedMinutes } else { 0 }
                $subtask.ActualMinutes = if ($item.PSObject.Properties.Name -contains 'ActualMinutes') { $item.ActualMinutes } else { 0 }
                $subtask.Deleted = if ($item.PSObject.Properties.Name -contains 'Deleted') { $item.Deleted } else { $false }
                
                $this.Subtasks.Add($subtask)
            }
            
            $this._isDirty = $false
            
        } catch {
            Write-Error "Failed to load subtasks: $($_.Exception.Message)"
        }
    }
}


####\Services/TaskService.ps1
# TaskService.ps1 - Service for managing tasks

class TaskService {
    [System.Collections.Generic.List[Task]]$Tasks
    hidden [string]$DataPath
    hidden [bool]$_isDirty = $false
    
    TaskService() {
        $this.Tasks = [System.Collections.Generic.List[Task]]::new()
        
        # Set data path
        $dataDir = Join-Path $global:PraxisRoot "_ProjectData"
        $this.DataPath = Join-Path $dataDir "tasks.json"
        
        # Load existing tasks
        $this.Load()
    }
    
    # CRUD Operations
    [Task] AddTask([string]$title, [string]$projectId) {
        $task = [Task]::new()
        $task.Title = $title
        $task.ProjectId = $projectId
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] CreateTask([hashtable]$properties) {
        $task = [Task]::new()
        
        # Set properties from hashtable
        foreach ($key in $properties.Keys) {
            if ($task.PSObject.Properties.Name -contains $key) {
                $task.$key = $properties[$key]
            }
        }
        
        $this.Tasks.Add($task)
        $this._isDirty = $true
        $this.Save()
        
        return $task
    }
    
    [Task] GetTask([string]$id) {
        return $this.Tasks | Where-Object { $_.Id -eq $id } | Select-Object -First 1
    }
    
    [Task[]] GetAllTasks() {
        return $this.Tasks.ToArray()
    }
    
    [Task[]] GetTasksByProject([string]$projectId) {
        return $this.Tasks | Where-Object { $_.ProjectId -eq $projectId -and -not $_.Deleted }
    }
    
    [Task[]] GetActiveTasks() {
        return $this.Tasks | Where-Object { 
            -not $_.Deleted -and 
            $_.Status -ne [TaskStatus]::Completed -and 
            $_.Status -ne [TaskStatus]::Cancelled 
        }
    }
    
    [void] UpdateTask([Task]$task) {
        $task.MarkAsUpdated()  # Use BaseModel method
        $this._isDirty = $true
        $this.Save()
    }
    
    [void] DeleteTask([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.SoftDelete()  # Use BaseModel method
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Status management
    [void] UpdateTaskStatus([string]$id, [TaskStatus]$status) {
        $task = $this.GetTask($id)
        if ($task) {
            $task.Status = $status
            $task.MarkAsUpdated()  # Use BaseModel method
            
            # Auto-update progress
            if ($status -eq [TaskStatus]::Completed) {
                $task.Progress = 100
            } elseif ($status -eq [TaskStatus]::Pending) {
                $task.Progress = 0
            }
            
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Priority management
    [void] CyclePriority([string]$id) {
        $task = $this.GetTask($id)
        if ($task) {
            switch ($task.Priority) {
                ([TaskPriority]::Low) { $task.Priority = [TaskPriority]::Medium }
                ([TaskPriority]::Medium) { $task.Priority = [TaskPriority]::High }
                ([TaskPriority]::High) { $task.Priority = [TaskPriority]::Low }
            }
            $task.UpdatedAt = Get-Date
            $this._isDirty = $true
            $this.Save()
        }
    }
    
    # Persistence
    [void] Save() {
        if (-not $this._isDirty) { return }
        
        try {
            $json = $this.Tasks | ConvertTo-Json -Depth 10
            $json | Set-Content -Path $this.DataPath -Encoding UTF8
            $this._isDirty = $false
            
            if ($global:Logger) {
                $global:Logger.Debug("TaskService: Saved $($this.Tasks.Count) tasks")
            }
        } catch {
            if ($global:Logger) {
                $global:Logger.Error("TaskService: Failed to save tasks: $_")
            }
        }
    }
    
    [void] Load() {
        if (Test-Path $this.DataPath) {
            try {
                $json = Get-Content -Path $this.DataPath -Raw
                $data = $json | ConvertFrom-Json
                
                $this.Tasks.Clear()
                foreach ($item in $data) {
                    $task = [Task]::new()
                    
                    # Map properties
                    $task.Id = $item.Id
                    $task.Title = $item.Title
                    $task.Description = $item.Description
                    $task.Status = [TaskStatus]$item.Status
                    $task.Priority = [TaskPriority]$item.Priority
                    $task.Progress = $item.Progress
                    $task.ProjectId = $item.ProjectId
                    $task.Tags = $item.Tags
                    $task.DueDate = if ($item.DueDate) { [DateTime]$item.DueDate } else { [DateTime]::MinValue }
                    $task.CreatedAt = [DateTime]$item.CreatedAt
                    $task.UpdatedAt = [DateTime]$item.UpdatedAt
                    $task.Deleted = $item.Deleted
                    
                    $this.Tasks.Add($task)
                }
                
                if ($global:Logger) {
                    $global:Logger.Debug("TaskService: Loaded $($this.Tasks.Count) tasks")
                }
            } catch {
                if ($global:Logger) {
                    $global:Logger.Error("TaskService: Failed to load tasks: $_")
                }
                # Start with empty list on error
                $this.Tasks.Clear()
            }
        } else {
            # Create sample tasks for testing
            $this.CreateSampleTasks()
        }
    }
    
    hidden [void] CreateSampleTasks() {
        # Create a few sample tasks
        $task1 = $this.AddTask("Implement user authentication", "")
        $task1.Description = "Add login/logout functionality with session management"
        $task1.Priority = [TaskPriority]::High
        $task1.Status = [TaskStatus]::InProgress
        $task1.Progress = 45
        
        $task2 = $this.AddTask("Write API documentation", "")
        $task2.Description = "Document all REST endpoints with examples"
        $task2.Priority = [TaskPriority]::Medium
        $task2.DueDate = (Get-Date).AddDays(7)
        
        $task3 = $this.AddTask("Fix navigation bug", "")
        $task3.Description = "Users report navigation not working after login"
        $task3.Priority = [TaskPriority]::High
        $task3.Status = [TaskStatus]::Completed
        $task3.Progress = 100
        
        $this.Save()
    }
}


####\Services/ThemeManager.ps1
# ThemeManager.ps1 - Fast theme management with pre-cached ANSI sequences
# All colors are pre-computed to avoid runtime lookups

class ThemeManager {
    hidden [hashtable]$_themes = @{}
    hidden [string]$_currentTheme = "default"
    hidden [hashtable]$_cache = @{}
    hidden [System.Collections.Generic.List[scriptblock]]$_listeners
    hidden [EventBus]$EventBus
    
    ThemeManager() {
        $this._listeners = [System.Collections.Generic.List[scriptblock]]::new()
        $this.InitializeDefaultTheme()
        
        # EventBus will be set later via SetEventBus
    }
    
    [void] InitializeDefaultTheme() {
        # Define default theme with RGB values
        $defaultTheme = @{
            # Base colors
            "background" = @(24, 24, 24)        # Dark background
            "foreground" = @(204, 204, 204)     # Light gray text
            "accent" = @(0, 150, 255)           # Blue accent
            "success" = @(0, 200, 83)           # Green
            "warning" = @(255, 195, 0)          # Yellow
            "error" = @(255, 85, 85)            # Red
            
            # UI elements
            "border" = @(68, 68, 68)           # Dark gray
            "border.focused" = @(0, 150, 255)   # Blue
            "selection" = @(60, 60, 60)         # Selection background
            "disabled" = @(128, 128, 128)       # Gray
            
            # Generic component colors (for backward compatibility)
            "title" = @(0, 150, 255)              # Blue titles
            "normal" = @(204, 204, 204)           # Normal text
            "selected" = @(60, 60, 60)            # Alias for selection
            
            # Component specific
            "button.background" = @(48, 48, 48)
            "button.foreground" = @(204, 204, 204)
            "button.focused.background" = @(0, 150, 255)
            "button.focused.foreground" = @(255, 255, 255)
            
            "input.background" = @(32, 32, 32)
            "input.foreground" = @(204, 204, 204)
            "input.focused.border" = @(0, 150, 255)
            
            "menu.background" = @(32, 32, 32)
            "menu.foreground" = @(204, 204, 204)
            "menu.selected.background" = @(0, 150, 255)
            "menu.selected.foreground" = @(255, 255, 255)
            
            "tab.background" = @(48, 48, 48)
            "tab.foreground" = @(170, 170, 170)
            "tab.active.background" = @(24, 24, 24)
            "tab.active.foreground" = @(255, 255, 255)
            "tab.active.accent" = @(0, 150, 255)
            
            # DataGrid specific colors
            "header.background" = @(48, 48, 48)
            "header.foreground" = @(0, 150, 255)
            "scrollbar" = @(68, 68, 68)
            "scrollbar.thumb" = @(128, 128, 128)
            
            # Additional component colors
            "checkbox" = @(0, 150, 255)
            "checkbox.selected" = @(0, 200, 255)
            "search" = @(255, 195, 0)
            "highlight" = @(255, 255, 0)
            "directory" = @(0, 150, 255)
            "file" = @(204, 204, 204)
            "input.border" = @(68, 68, 68)
            "input.placeholder" = @(128, 128, 128)
            "progress.active" = @(0, 150, 255)
            "progress.complete" = @(0, 200, 83)
            "progress.text" = @(204, 204, 204)
        }
        
        $this.RegisterTheme("default", $defaultTheme)
        
        # Define matrix theme - black background with green text
        $matrixTheme = @{
            # Base colors
            "background" = @(0, 0, 0)             # Pure black background
            "foreground" = @(0, 255, 0)           # Bright green text
            "accent" = @(0, 200, 0)               # Darker green accent
            "success" = @(0, 255, 0)              # Bright green
            "warning" = @(255, 255, 0)            # Yellow
            "error" = @(255, 0, 0)                # Red
            
            # UI elements
            "border" = @(0, 100, 0)               # Dark green borders
            "border.focused" = @(0, 255, 0)       # Bright green when focused
            "selection" = @(0, 100, 0)            # Dark green selection - more visible
            "disabled" = @(0, 128, 0)             # Medium green for disabled
            
            # Generic component colors (for backward compatibility)
            "title" = @(0, 255, 0)                # Bright green for titles
            "normal" = @(0, 200, 0)               # Normal text (slightly dimmer green)
            "selected" = @(0, 100, 0)             # Alias for selection
            
            # Component specific
            "button.background" = @(0, 20, 0)
            "button.foreground" = @(0, 255, 0)
            "button.focused.background" = @(0, 100, 0)
            "button.focused.foreground" = @(0, 255, 0)
            
            "input.background" = @(0, 10, 0)
            "input.foreground" = @(0, 255, 0)
            "input.focused.border" = @(0, 255, 0)
            
            "menu.background" = @(0, 0, 0)
            "menu.foreground" = @(0, 200, 0)
            "menu.selected.background" = @(0, 80, 0)
            "menu.selected.foreground" = @(0, 255, 0)
            
            "tab.background" = @(0, 30, 0)
            "tab.foreground" = @(0, 150, 0)
            "tab.active.background" = @(0, 0, 0)
            "tab.active.foreground" = @(0, 255, 0)
            "tab.active.accent" = @(0, 255, 0)
            
            # DataGrid specific colors
            "header.background" = @(0, 30, 0)
            "header.foreground" = @(0, 255, 0)
            "scrollbar" = @(0, 100, 0)
            "scrollbar.thumb" = @(0, 150, 0)
            
            # Additional component colors
            "checkbox" = @(0, 255, 0)
            "checkbox.selected" = @(0, 255, 100)
            "search" = @(255, 255, 0)
            "highlight" = @(255, 255, 0)
            "directory" = @(0, 255, 0)
            "file" = @(0, 200, 0)
            "input.border" = @(0, 100, 0)
            "input.placeholder" = @(0, 128, 0)
            "progress.active" = @(0, 255, 0)
            "progress.complete" = @(0, 255, 0)
            "progress.text" = @(0, 200, 0)
            
            # Dialog colors
            "dialog.background" = @(0, 0, 0)
            "dialog.border" = @(0, 150, 0)
            "dialog.title" = @(0, 255, 0)
        }
        
        $this.RegisterTheme("matrix", $matrixTheme)
        $this.SetTheme("matrix")
    }
    
    # Register a new theme
    [void] RegisterTheme([string]$name, [hashtable]$colors) {
        $this._themes[$name] = $colors
        
        # If this is the current theme, rebuild cache
        if ($name -eq $this._currentTheme) {
            $this.RebuildCache()
        }
    }
    
    # Switch to a different theme
    [void] SetTheme([string]$name) {
        if (-not $this._themes.ContainsKey($name)) {
            throw "Theme '$name' not found"
        }
        
        $oldTheme = $this._currentTheme
        $this._currentTheme = $name
        $this.RebuildCache()
        
        # Notify via EventBus if available
        if ($this.EventBus) {
            $this.EventBus.Publish('app.themeChanged', @{
                OldTheme = $oldTheme
                NewTheme = $name
                ThemeManager = $this
            })
        }
        
        # Also notify legacy listeners for backward compatibility
        $this.NotifyListeners()
    }
    
    # Get pre-computed ANSI color sequence
    [string] GetColor([string]$key) {
        if ($this._cache.ContainsKey($key)) {
            return $this._cache[$key]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$key] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get background color sequence
    [string] GetBgColor([string]$key) {
        $bgKey = "$key.bg"
        if ($this._cache.ContainsKey($bgKey)) {
            return $this._cache[$bgKey]
        }
        
        # Not in cache, compute it
        $rgb = $this.GetRGB($key)
        if ($rgb) {
            $ansi = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            $this._cache[$bgKey] = $ansi
            return $ansi
        }
        
        return ""  # No color defined
    }
    
    # Get raw RGB values
    [int[]] GetRGB([string]$key) {
        $theme = $this._themes[$this._currentTheme]
        
        if ($theme.ContainsKey($key)) {
            return $theme[$key]
        }
        
        # Try parent keys (e.g., "button" for "button.focused.background")
        $parts = $key -split '\.'
        for ($i = $parts.Count - 1; $i -gt 0; $i--) {
            $parentKey = $parts[0..($i-1)] -join '.'
            if ($theme.ContainsKey($parentKey)) {
                return $theme[$parentKey]
            }
        }
        
        return $null
    }
    
    # Rebuild the entire cache
    hidden [void] RebuildCache() {
        $this._cache.Clear()
        $theme = $this._themes[$this._currentTheme]
        
        # Pre-compute all theme colors
        foreach ($key in $theme.Keys) {
            $rgb = $theme[$key]
            if ($rgb -is [array] -and $rgb.Count -eq 3) {
                # Foreground
                $this._cache[$key] = [VT]::RGB($rgb[0], $rgb[1], $rgb[2])
                # Background
                $this._cache["$key.bg"] = [VT]::RGBBG($rgb[0], $rgb[1], $rgb[2])
            }
        }
        
        # Add common combinations
        $this._cache["reset"] = [VT]::Reset()
        $this._cache["clear"] = [VT]::Clear()
        $this._cache["clearline"] = [VT]::ClearLine()
    }
    
    # Subscribe to theme changes (legacy method - use EventBus instead)
    [void] Subscribe([scriptblock]$callback) {
        # Always use legacy listeners for now to avoid initialization order issues
        # EventBus subscription happens too early
        $this._listeners.Add($callback)
    }
    
    # Notify all listeners of theme change (legacy method)
    hidden [void] NotifyListeners() {
        # Only notify legacy listeners if EventBus is not available
        if (-not $this.EventBus) {
            foreach ($listener in $this._listeners) {
                try {
                    & $listener
                } catch {
                    # Ignore listener errors
                }
            }
        }
    }
    
    # Set EventBus after initialization (called by ServiceContainer)
    [void] SetEventBus([EventBus]$eventBus) {
        $this.EventBus = $eventBus
    }
    
    # Get list of available themes
    [string[]] GetThemeNames() {
        return $this._themes.Keys | Sort-Object
    }
    
    # Get current theme name
    [string] GetCurrentTheme() {
        return $this._currentTheme
    }
}


####\Services/TimeTrackingService.ps1
# TimeTrackingService - Manages all time entries and calculations

class TimeTrackingService {
    [string]$DataPath
    [System.Collections.ArrayList]$TimeEntries
    [System.Collections.ArrayList]$TimeCodes
    [Logger]$Logger
    [EventBus]$EventBus
    [ProjectService]$ProjectService
    
    TimeTrackingService() {
        $this.TimeEntries = [System.Collections.ArrayList]::new()
        $this.TimeCodes = [System.Collections.ArrayList]::new()
        $this.DataPath = Join-Path $global:PraxisRoot "_ProjectData/timeentries.json"
        $this.LoadData()
        $this.InitializeCommonTimeCodes()
    }
    
    [void] Initialize([ServiceContainer]$container) {
        $this.Logger = $container.GetService("Logger")
        $this.EventBus = $container.GetService("EventBus")
        $this.ProjectService = $container.GetService("ProjectService")
    }
    
    [void] InitializeCommonTimeCodes() {
        # Add common codes if not already present
        $commonCodes = [TimeCode]::GetCommonCodes()
        foreach ($code in $commonCodes) {
            if (-not ($this.TimeCodes | Where-Object { $_.ID2 -eq $code.ID2 })) {
                $this.TimeCodes.Add($code) | Out-Null
            }
        }
    }
    
    [void] LoadData() {
        if (Test-Path $this.DataPath) {
            try {
                $data = Get-Content $this.DataPath -Raw | ConvertFrom-Json
                
                # Load time entries
                if ($data.TimeEntries) {
                    foreach ($entry in $data.TimeEntries) {
                        $timeEntry = [TimeEntry]::new()
                        foreach ($prop in $entry.PSObject.Properties) {
                            if ($timeEntry.PSObject.Properties[$prop.Name]) {
                                $timeEntry.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeEntries.Add($timeEntry) | Out-Null
                    }
                }
                
                # Load time codes
                if ($data.TimeCodes) {
                    foreach ($code in $data.TimeCodes) {
                        $timeCode = [TimeCode]::new()
                        foreach ($prop in $code.PSObject.Properties) {
                            if ($timeCode.PSObject.Properties[$prop.Name]) {
                                $timeCode.$($prop.Name) = $prop.Value
                            }
                        }
                        $this.TimeCodes.Add($timeCode) | Out-Null
                    }
                }
            }
            catch {
                if ($this.Logger) {
                    $this.Logger.Error("Failed to load time tracking data: $_")
                }
            }
        }
    }
    
    [void] SaveData() {
        $data = @{
            TimeEntries = $this.TimeEntries
            TimeCodes = $this.TimeCodes
            LastUpdated = [DateTime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        }
        
        try {
            $json = $data | ConvertTo-Json -Depth 10
            Set-Content -Path $this.DataPath -Value $json -Encoding UTF8
            
            if ($this.Logger) {
                $this.Logger.Info("Time tracking data saved")
            }
        }
        catch {
            if ($this.Logger) {
                $this.Logger.Error("Failed to save time tracking data: $_")
            }
        }
    }
    
    # Get or create time entry for a specific week and ID2
    [TimeEntry] GetOrCreateTimeEntry([string]$weekEndingFriday, [string]$id2) {
        $existing = $this.TimeEntries | Where-Object { 
            $_.WeekEndingFriday -eq $weekEndingFriday -and $_.ID2 -eq $id2 
        } | Select-Object -First 1
        
        if ($existing) {
            return $existing
        }
        
        # Create new entry
        $entry = [TimeEntry]::new($weekEndingFriday, $id2)
        
        # If it's a project ID2, populate project info
        if ($id2.Length -gt 5) {
            $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
            if ($project) {
                $entry.Name = $project.Nickname
                $entry.ID1 = $project.ID1
            }
        }
        
        $this.TimeEntries.Add($entry) | Out-Null
        return $entry
    }
    
    # Get entries for a specific week
    [TimeEntry[]] GetWeekEntries([string]$weekEndingFriday) {
        return $this.TimeEntries | Where-Object { $_.WeekEndingFriday -eq $weekEndingFriday }
    }
    
    # Get entries for current week
    [TimeEntry[]] GetCurrentWeekEntries() {
        $friday = $this.GetCurrentWeekFriday()
        return $this.GetWeekEntries($friday.ToString("yyyyMMdd"))
    }
    
    # Update time entry
    [void] UpdateTimeEntry([TimeEntry]$entry) {
        $entry.CalculateTotal()
        $entry.CalculateFiscalYear()
        $entry.UpdatedAt = [DateTime]::Now
        
        $this.SaveData()
        
        if ($this.EventBus) {
            $this.EventBus.Publish([EventNames]::TimeEntryUpdated, $this, @{ TimeEntry = $entry })
        }
    }
    
    # Add hours for today
    [void] AddHoursForToday([string]$id2, [decimal]$hours, [string]$description = "") {
        $today = [DateTime]::Now
        $friday = $this.GetWeekFridayForDate($today)
        
        $entry = $this.GetOrCreateTimeEntry($friday.ToString("yyyyMMdd"), $id2)
        
        # Add hours to appropriate day
        switch ($today.DayOfWeek) {
            Monday { $entry.Monday += $hours }
            Tuesday { $entry.Tuesday += $hours }
            Wednesday { $entry.Wednesday += $hours }
            Thursday { $entry.Thursday += $hours }
            Friday { $entry.Friday += $hours }
            default {
                if ($this.Logger) {
                    $this.Logger.Warning("Cannot add time for weekend day")
                }
                return
            }
        }
        
        $this.UpdateTimeEntry($entry)
    }
    
    # Get Friday date for current week
    [DateTime] GetCurrentWeekFriday() {
        $today = [DateTime]::Now
        return $this.GetWeekFridayForDate($today)
    }
    
    # Get Friday date for any date's week
    [DateTime] GetWeekFridayForDate([DateTime]$date) {
        $friday = $date
        while ($friday.DayOfWeek -ne [DayOfWeek]::Friday) {
            if ($friday.DayOfWeek -eq [DayOfWeek]::Saturday) {
                $friday = $friday.AddDays(-1)
            } else {
                $friday = $friday.AddDays(1)
            }
        }
        return $friday
    }
    
    # Calculate total hours for a project
    [decimal] GetProjectTotalHours([string]$id2) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { $_.ID2 -eq $id2 }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Calculate fiscal year total for non-project code
    [decimal] GetFiscalYearTotal([string]$id2, [string]$fiscalYear) {
        $total = 0
        $entries = $this.TimeEntries | Where-Object { 
            $_.ID2 -eq $id2 -and $_.FiscalYear -eq $fiscalYear 
        }
        foreach ($entry in $entries) {
            $total += $entry.Total
        }
        return $total
    }
    
    # Get current fiscal year string
    [string] GetCurrentFiscalYear() {
        $today = [DateTime]::Now
        if ($today.Month -ge 4) {
            return "$($today.Year)-$($today.Year + 1)"
        } else {
            return "$($today.Year - 1)-$($today.Year)"
        }
    }
    
    # Get all unique ID2s (both project and non-project)
    [string[]] GetAllID2s() {
        $id2s = @()
        
        # Add project ID2s
        $projects = $this.ProjectService.GetAllProjects() | Where-Object { -not $_.Deleted -and $_.ID2 }
        foreach ($project in $projects) {
            $id2s += $project.ID2
        }
        
        # Add time code ID2s
        foreach ($code in $this.TimeCodes) {
            if ($code.IsActive) {
                $id2s += $code.ID2
            }
        }
        
        return $id2s | Select-Object -Unique | Sort-Object
    }
    
    # Get display info for an ID2
    [hashtable] GetID2DisplayInfo([string]$id2) {
        # Check if it's a project
        $project = $this.ProjectService.GetAllProjects() | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($project) {
            return @{
                Name = $project.Nickname
                ID1 = $project.ID1
                ID2 = $id2
                IsProject = $true
            }
        }
        
        # It's a non-project code
        $timeCode = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        return @{
            Name = ""
            ID1 = ""
            ID2 = $id2
            IsProject = $false
            Description = if ($timeCode) { $timeCode.Description } else { "" }
        }
    }
    
    # Add or update time code
    [void] AddTimeCode([string]$id2, [string]$description = "") {
        $existing = $this.TimeCodes | Where-Object { $_.ID2 -eq $id2 } | Select-Object -First 1
        if ($existing) {
            $existing.Description = $description
            $existing.UpdatedAt = [DateTime]::Now
        } else {
            $code = [TimeCode]::new($id2, $description)
            $this.TimeCodes.Add($code) | Out-Null
        }
        $this.SaveData()
    }
}


####\apply-final-fixes.ps1
#!/usr/bin/env pwsh
# Apply final fixes for shortcuts and focus

Write-Host "Applying final fixes..." -ForegroundColor Cyan

# 1. Clean up debug output from ScreenManager
Write-Host "  Cleaning up ScreenManager..." -ForegroundColor Yellow
$content = Get-Content "Core/ScreenManager.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n', ''
$content | Set-Content "Core/ScreenManager.ps1" -Force

# 2. Clean up debug output from ShortcutManager  
Write-Host "  Cleaning up ShortcutManager..." -ForegroundColor Yellow
$content = Get-Content "Services/ShortcutManager.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Services/ShortcutManager.ps1" -Force

# 3. Clean up debug output from screens
Write-Host "  Cleaning up ProjectsScreen..." -ForegroundColor Yellow
$content = Get-Content "Screens/ProjectsScreen.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Screens/ProjectsScreen.ps1" -Force

Write-Host "  Cleaning up TaskScreen..." -ForegroundColor Yellow
$content = Get-Content "Screens/TaskScreen.ps1" -Raw
$content = $content -replace 'Write-Host "[^"]*"[^`n]*\n\s*', ''
$content | Set-Content "Screens/TaskScreen.ps1" -Force

Write-Host "`nFixes applied!" -ForegroundColor Green
Write-Host @"

The following issues have been fixed:

1. SHORTCUTS: Fixed case-sensitive matching bug
   - Shortcuts now work with both uppercase and lowercase keys
   - 'e' and 'E' both trigger edit, 'd' and 'D' both trigger delete

2. FOCUS: Fixed focus initialization on all screens
   - Each screen now properly sets initial focus when activated
   - Tab navigation works across all screens

3. CTRL+ARROWS: Added tab navigation shortcuts
   - Ctrl+Right Arrow = Tab (next focus)
   - Ctrl+Left Arrow = Shift+Tab (previous focus)

To test:
- Run: pwsh -File Start.ps1
- Navigate to any screen (1-6)
- Try shortcuts: n=new, e=edit, d=delete
- Try Ctrl+Arrows for navigation

"@ -ForegroundColor Cyan


####\check-syntax.ps1
#!/usr/bin/env pwsh

# Check syntax of TimeEntryScreen
try {
    $null = [System.Management.Automation.Language.Parser]::ParseFile(
        "$PSScriptRoot/Screens/TimeEntryScreen.ps1",
        [ref]$null,
        [ref]$null
    )
    Write-Host "TimeEntryScreen.ps1 syntax is valid" -ForegroundColor Green
} catch {
    Write-Host "Syntax error in TimeEntryScreen.ps1: $_" -ForegroundColor Red
}


####\debug-vmf-init.ps1
#!/usr/bin/env pwsh

# Debug VisualMacroFactoryScreen initialization using the proper load order from Start.ps1
param([switch]$LoadOnly)

# Load order from Start.ps1
$loadOrder = @(
    "Core/StringCache.ps1"
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Core/StringBuilderPool.ps1"
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    "Base/BaseModel.ps1"
    "Services/ShortcutManager.ps1"
    "Models/Command.ps1"
    "Models/BaseAction.ps1"
    "Actions/CustomIdeaCommandAction.ps1"
    "Actions/SummarizationAction.ps1"
    "Actions/AppendFieldAction.ps1"
    "Actions/ExportToExcelAction.ps1"
    "Services/CommandService.ps1"
    "Services/FunctionRegistry.ps1"
    "Services/MacroContextManager.ps1"
    "Components/ListBox.ps1"
    "Components/SearchableListBox.ps1"
    "Components/DataGrid.ps1"
    "Screens/VisualMacroFactoryScreen.ps1"
)

Write-Host "Loading components for VisualMacroFactoryScreen test..." -ForegroundColor Cyan

foreach ($file in $loadOrder) {
    $path = Join-Path $PSScriptRoot $file
    if (Test-Path $path) {
        try {
            . $path
            Write-Host "  ‚úì $file" -ForegroundColor Green
        } catch {
            Write-Host "  ‚úó $file - $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "  ‚úó $file - File not found" -ForegroundColor Red
        exit 1
    }
}

Write-Host "`nInitializing services..." -ForegroundColor Cyan

# Set global variables that services need
$global:PraxisRoot = $PSScriptRoot

# Initialize global ServiceContainer
$global:ServiceContainer = [ServiceContainer]::new()

# Create services in proper order
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)

$commandService = [CommandService]::new()
$global:ServiceContainer.Register("CommandService", $commandService)

Write-Host "`nTesting VisualMacroFactoryScreen..." -ForegroundColor Green

try {
    Write-Host "Creating VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen = [VisualMacroFactoryScreen]::new()
    Write-Host "‚úì Constructor completed" -ForegroundColor Green
    
    Write-Host "Available Actions before init: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    Write-Host "Calling Initialize..." -ForegroundColor Yellow
    $screen.Initialize($global:ServiceContainer)
    Write-Host "‚úì Initialize completed" -ForegroundColor Green
    
    Write-Host "Available Actions after init: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    if ($screen.AvailableActions.Count -gt 0) {
        Write-Host "‚úì Actions loaded successfully:" -ForegroundColor Green
        foreach ($action in $screen.AvailableActions) {
            Write-Host "  - $($action.Name) [$($action.GetType().Name)]" -ForegroundColor DarkGray
        }
    } else {
        Write-Host "‚úó No actions loaded - investigating LoadAvailableActions..." -ForegroundColor Red
        
        # Test action creation manually
        Write-Host "Testing manual action creation:" -ForegroundColor Yellow
        try {
            $testAction = [SummarizationAction]::new()
            Write-Host "  ‚úì SummarizationAction: $($testAction.Name)" -ForegroundColor Green
        } catch {
            Write-Host "  ‚úó SummarizationAction failed: $_" -ForegroundColor Red
        }
    }
    
    # Check if shortcuts were registered
    Write-Host "Checking shortcut registration..." -ForegroundColor Yellow
    $shortcuts = $shortcutManager.GetShortcuts([ShortcutScope]::Screen, "VisualMacroFactoryScreen")
    Write-Host "Registered shortcuts: $($shortcuts.Count)" -ForegroundColor Cyan
    foreach ($shortcut in $shortcuts) {
        Write-Host "  - $($shortcut.Id): $($shortcut.GetDisplayText())" -ForegroundColor DarkGray
    }
    
} catch {
    Write-Host "‚úó Test failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Cyan


####\fc2.ps1
#------------------------------------------------------------------------------------------
# SCRIPT:      filecopy-and-concatenate.ps1
#
# DESCRIPTION: Finds specified file types in a given path and its subdirectories.
#              For each file, it can create a .txt copy and/or concatenate all
#              file contents into a single output file.
#
# FEATURES:
#   - Full parameter support for path, file types, and output name.
#   - Safety features: Supports -WhatIf and -Confirm for all file operations.
#   - Verbose output: Use the -Verbose switch to see detailed progress.
#   - Performance: Uses an efficient single-write operation for the concatenated file.
#   - Robustness: Uses idiomatic PowerShell for path manipulation and error handling.
#   - Compatibility: Works on Windows PowerShell 5.1 and newer.
#   - NEW: Can create individual .txt copies of each source file.
#
# USAGE:
#   # Basic run in the current folder for PowerShell files
#   .\filecopy-and-concatenate.ps1 -Verbose
#
#   # Run on a different project, for C# files, with a different output name
#   .\filecopy-and-concatenate.ps1 -Path "C:\Projects\MyWebApp" -Include "*.cs" -OutputFileName "SourceCode.txt"
#
#   # To also create individual .txt copies of each file:
#   .\filecopy-and-concatenate.ps1 -CreateIndividualCopies -Verbose
#
#   # Perform a "dry run" to see what would happen without making any changes
#   .\filecopy-and-concatenate.ps1 -Path "C:\SomethingImportant" -CreateIndividualCopies -WhatIf
#
#------------------------------------------------------------------------------------------

# Enable support for -WhatIf, -Confirm, and advanced parameter binding
[CmdletBinding(SupportsShouldProcess = $true)]
param(
    # The starting directory to search in. Defaults to the current directory.
    [Parameter(Mandatory = $false, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "The root path to search for files.")]
    [string]
    $Path = (Get-Location).Path,

    # An array of file patterns to include. Defaults to PowerShell script files.
    [Parameter(Mandatory = $false, HelpMessage = "File patterns to include, e.g., '*.ps1', '*.psm1'.")]
    [string[]]
    $Include = @("*.ps1", "*.psm1"),

    # The name of the final concatenated output file.
    [Parameter(Mandatory = $false, HelpMessage = "Name of the concatenated output file.")]
    [string]
    $OutputFileName = "all.txt",

    # Switch to create a .txt copy of each individual file found.
    [Parameter(Mandatory = $false, HelpMessage = "If specified, creates a .txt copy of each found file.")]
    [switch]
    $CreateIndividualCopies
)

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

try {
    # Resolve-Path returns a PathInfo object. We use it for robustness.
    $resolvedPathObject = Resolve-Path -Path $Path
    $basePathString = $resolvedPathObject.Path # Store the string path for reuse
    $outputFilePath = Join-Path -Path $basePathString -ChildPath $OutputFileName

    Write-Verbose "Starting operations in: $basePathString"
    Write-Verbose "Searching for file types: $($Include -join ', ')"
    Write-Verbose "Output file will be: $outputFilePath"
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Individual .txt copies will be created."
    }

    # --- Step 1: Find all specified files recursively ---
    $filesToProcess = Get-ChildItem -Path $basePathString -Recurse -Include $Include -File

    if ($null -eq $filesToProcess) {
        Write-Warning "No files found matching the specified criteria."
        return # Exit gracefully if no files are found
    }

    Write-Verbose "Found $($filesToProcess.Count) files to process."

    # --- Step 2: Clear the existing output file if it exists ---
    # This is part of the concatenation process, so it's good to do it early.
    if ((Test-Path $outputFilePath) -and $PSCmdlet.ShouldProcess($outputFilePath, "Remove existing output file")) {
        Remove-Item $outputFilePath -Force
    }

    # --- Step 3: Process each file for individual copies (if requested) ---
    if ($CreateIndividualCopies.IsPresent) {
        Write-Verbose "Processing files to create individual .txt copies..."
        foreach ($file in $filesToProcess) {
            # Create a new filename by changing the extension to .txt
            $txtCopyPath = [System.IO.Path]::ChangeExtension($file.FullName, ".txt")

            # Use ShouldProcess for -WhatIf and -Confirm support
            if ($PSCmdlet.ShouldProcess($txtCopyPath, "Copy from '$($file.Name)'")) {
                Copy-Item -Path $file.FullName -Destination $txtCopyPath -Force
                Write-Verbose "Created copy: '$txtCopyPath'"
            }
        }
    }

    # --- Step 4: Concatenate all files into the output file (Efficiently) ---
    Write-Verbose "Starting concatenation of all files into '$OutputFileName'..."
    if ($PSCmdlet.ShouldProcess($outputFilePath, "Concatenate $($filesToProcess.Count) files")) {
        # Using a subexpression `$(...)` to gather all output before writing to the file once.
        Set-Content -Path $outputFilePath -Encoding UTF8 -Value $(
            foreach ($file in $filesToProcess) {
                # Calculate the relative path for the header
                $relativePath = $file.FullName.Substring($basePathString.Length)
                # Ensure consistent format like '\subdir\file.ps1'
                $relativePath = '\' + $relativePath.TrimStart('\/')

                # Output the header for this file
                "####$relativePath"

                # Output the file's content
                Get-Content -Path $file.FullName -Raw -Encoding Default

                # Output two blank lines for separation
                ""
                ""
            }
        )
        Write-Host "All operations complete. Concatenated content saved to '$outputFilePath'."
    }
}
catch {
    # A global catch block for any unexpected, terminating errors.
    Write-Error "A critical error occurred: $($_.Exception.Message)"
    Write-Error "Script execution halted at line $($_.InvocationInfo.ScriptLineNumber): $($_.InvocationInfo.Line)"
}



####\force-test-tab7.ps1
#!/usr/bin/env pwsh

# Force test tab 7 by directly creating and testing the screen
Write-Host "Testing VisualMacroFactoryScreen directly..." -ForegroundColor Cyan

# Load full framework
. "$PSScriptRoot/Start.ps1" -LoadOnly 2>/dev/null

# Create and initialize the screen directly
try {
    Write-Host "Creating VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen = [VisualMacroFactoryScreen]::new()
    
    Write-Host "Initializing screen..." -ForegroundColor Yellow  
    $screen.Initialize($global:ServiceContainer)
    
    Write-Host "Screen created successfully" -ForegroundColor Green
    Write-Host "  ComponentLibrary exists: $($null -ne $screen.ComponentLibrary)" -ForegroundColor Cyan
    Write-Host "  MacroSequence exists: $($null -ne $screen.MacroSequence)" -ForegroundColor Cyan
    Write-Host "  ContextPanel exists: $($null -ne $screen.ContextPanel)" -ForegroundColor Cyan
    Write-Host "  AvailableActions count: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    if ($screen.ComponentLibrary) {
        Write-Host "  ComponentLibrary Items count: $($screen.ComponentLibrary.Items.Count)" -ForegroundColor Cyan
        Write-Host "  ComponentLibrary _filteredItems count: $($screen.ComponentLibrary._filteredItems.Count)" -ForegroundColor Cyan
    }
    
    # Test bounds
    Write-Host "Setting test bounds..." -ForegroundColor Yellow
    $screen.SetBounds(0, 0, 120, 30)
    Write-Host "  Screen bounds: $($screen.X),$($screen.Y) - $($screen.Width)x$($screen.Height)" -ForegroundColor Cyan
    
    if ($screen.ComponentLibrary) {
        Write-Host "  ComponentLibrary bounds: $($screen.ComponentLibrary.X),$($screen.ComponentLibrary.Y) - $($screen.ComponentLibrary.Width)x$($screen.ComponentLibrary.Height)" -ForegroundColor Cyan
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "Test completed!" -ForegroundColor Green


####\RUN_THIS_TEST.ps1
#!/usr/bin/env pwsh
Write-Host @"

SHORTCUT AND FOCUS TEST INSTRUCTIONS
====================================

The debug output has been added to help diagnose the issues.

When you run Start.ps1, you will see:
- [REG] messages when shortcuts are registered
- [UNREG] messages when shortcuts are unregistered  
- [DEBUG] messages for each key press
- [SM] messages from ShortcutManager processing
- [MATCH] messages when checking if shortcuts match
- Screen activation messages

To test:
1. Run: pwsh -File Start.ps1
2. Press 1 to go to Projects screen
3. Press 'e' - watch for debug output
4. Press 2 to go to Tasks screen  
5. Press 'e' again

The debug output will show exactly what's happening with shortcuts.

"@ -ForegroundColor Yellow


####\simple-action-test.ps1
#!/usr/bin/env pwsh

# Simple action creation test without starting PRAXIS
param([switch]$LoadOnly)

# Load framework components without starting UI
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"

# Services
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"

# Base classes
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Base/BaseModel.ps1"

# Models
. "$PSScriptRoot/Models/BaseAction.ps1"

# Actions
. "$PSScriptRoot/Actions/CustomIdeaCommandAction.ps1"
. "$PSScriptRoot/Actions/SummarizationAction.ps1"
. "$PSScriptRoot/Actions/AppendFieldAction.ps1"
. "$PSScriptRoot/Actions/ExportToExcelAction.ps1"

Write-Host "Testing Action class creation..." -ForegroundColor Green

try {
    Write-Host "Testing BaseAction..." -ForegroundColor Yellow
    $baseAction = [BaseAction]::new()
    Write-Host "‚úì BaseAction created successfully" -ForegroundColor Green
} catch {
    Write-Host "‚úó BaseAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing SummarizationAction..." -ForegroundColor Yellow
    $summarizationAction = [SummarizationAction]::new()
    Write-Host "‚úì SummarizationAction created successfully: $($summarizationAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó SummarizationAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing AppendFieldAction..." -ForegroundColor Yellow
    $appendFieldAction = [AppendFieldAction]::new()
    Write-Host "‚úì AppendFieldAction created successfully: $($appendFieldAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó AppendFieldAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing ExportToExcelAction..." -ForegroundColor Yellow
    $exportAction = [ExportToExcelAction]::new()
    Write-Host "‚úì ExportToExcelAction created successfully: $($exportAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó ExportToExcelAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing CustomIdeaCommandAction..." -ForegroundColor Yellow
    $customAction = [CustomIdeaCommandAction]::new()
    Write-Host "‚úì CustomIdeaCommandAction created successfully: $($customAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó CustomIdeaCommandAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

Write-Host "`nAction creation test completed!" -ForegroundColor Cyan


####\Start.ps1
#!/usr/bin/env pwsh
# PRAXIS - Performance-focused TUI Framework
# Entry point and bootstrapper

param(
    [switch]$Debug,
    [switch]$Performance,
    [string]$Theme = "default",
    [switch]$LoadOnly
)

# Enable debug output if requested
if ($Debug) {
    $global:PraxisDebug = $true
}

# Ensure we're in the right directory
$script:PraxisRoot = $PSScriptRoot
$global:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Ensure data directory exists
$dataDir = Join-Path $script:PraxisRoot "_ProjectData"
if (-not (Test-Path $dataDir)) {
    New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
}

# Load order is critical for class inheritance
$loadOrder = @(
    # Core modules first
    "Core/StringCache.ps1"
    "Core/VT100.ps1"
    "Core/ServiceContainer.ps1"
    "Core/StringBuilderPool.ps1"
    "Core/DocumentBuffer.ps1"
    "Core/EditorCommands.ps1"
    
    # Services (needed by base classes)
    "Services/Logger.ps1"
    "Services/EventBus.ps1"
    "Services/ThemeManager.ps1"
    
    # Base classes
    "Base/UIElement.ps1"
    "Base/Container.ps1"
    "Base/Screen.ps1"
    "Base/BaseModel.ps1"
    
    # Services that depend on base classes
    "Services/ShortcutManager.ps1"
    
    # Models
    "Models/Project.ps1"
    "Models/Task.ps1"
    "Models/Subtask.ps1"
    "Models/TimeEntry.ps1"
    "Models/TimeCode.ps1"
    "Models/Command.ps1"
    "Models/BaseAction.ps1"
    
    # Actions (after BaseAction)
    "Actions/CustomIdeaCommandAction.ps1"
    "Actions/SummarizationAction.ps1"
    "Actions/AppendFieldAction.ps1"
    "Actions/ExportToExcelAction.ps1"
    
    # Services
    "Services/ProjectService.ps1"
    "Services/TaskService.ps1"
    "Services/SubtaskService.ps1"
    "Services/TimeTrackingService.ps1"
    "Services/CommandService.ps1"
    "Services/ConfigurationService.ps1"
    "Services/StateManager.ps1"
    "Services/FunctionRegistry.ps1"
    "Services/MacroContextManager.ps1"
    
    # Components
    "Components/ListBox.ps1"
    "Components/TextBox.ps1"
    "Components/Button.ps1"
    "Components/DataGrid.ps1"
    "Components/TreeView.ps1"
    "Components/ProgressBar.ps1"
    "Components/FastFileTree.ps1"
    "Components/RangerFileTree.ps1"
    "Components/SearchableListBox.ps1"
    "Components/MultiSelectListBox.ps1"
    "Components/TabContainer.ps1"
    
    # Layout Components (NEW!)
    "Components/HorizontalSplit.ps1"
    "Components/VerticalSplit.ps1"
    "Components/GridPanel.ps1"
    "Components/DockPanel.ps1"
    
    # Core systems
    "Core/ScreenManager.ps1"
    
    # BaseDialog (after components are loaded)
    "Base/BaseDialog.ps1"
    
    # Dialogs (must be loaded before screens that use them)
    "Screens/TextInputDialog.ps1",
    "Screens/NumberInputDialog.ps1",
    "Screens/ConfirmationDialog.ps1",
    "Screens/NewProjectDialog.ps1",
    "Screens/EditProjectDialog.ps1",
    "Screens/NewTaskDialog.ps1",
    "Screens/EditTaskDialog.ps1",
    "Screens/SubtaskDialog.ps1",
    "Screens/TimeEntryDialog.ps1",
    "Screens/QuickTimeEntryDialog.ps1",
    "Screens/CommandEditDialog.ps1",
    "Screens/EventBusMonitor.ps1",
    
    # Screens (after dialogs they depend on)
    "Screens/TestScreen.ps1",
    "Screens/ProjectDetailScreen.ps1",
    "Screens/ProjectsScreen.ps1",
    "Screens/TaskScreen.ps1",
    "Screens/DashboardScreen.ps1",
    "Screens/SettingsScreen.ps1",
    "Screens/FileBrowserScreen.ps1",
    "Screens/TextEditorScreenNew.ps1",
    "Screens/TimeEntryScreen.ps1",
    "Screens/CommandLibraryScreen.ps1",
    "Screens/VisualMacroFactoryScreen.ps1",
    
    # CommandPalette (after screens it references)
    "Components/CommandPalette.ps1"
    
    # Main screen
    "Screens/MainScreen.ps1"
)

# Load all modules
Write-Host "Loading PRAXIS framework..." -ForegroundColor Cyan
foreach ($file in $loadOrder) {
    $path = Join-Path $script:PraxisRoot $file
    if (Test-Path $path) {
        try {
            . $path
            if ($Debug) {
                Write-Host "  ‚úì $file" -ForegroundColor Green
            }
        } catch {
            Write-Host "  ‚úó $file - $_" -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "  ‚úó $file - File not found" -ForegroundColor Red
        exit 1
    }
}

# Initialize services
Write-Host "Initializing services..." -ForegroundColor Cyan

# Logger (first so other services can use it)
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
if ($Debug) {
    Write-Host "  Logger created at: $($logger.LogPath)" -ForegroundColor DarkGray
}

# Theme manager
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# EventBus (after Logger and ThemeManager, before other services)
$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

# ShortcutManager
$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)
if ($Debug) {
    Write-Host "  EventBus initialized" -ForegroundColor DarkGray
}

# Connect ThemeManager to EventBus
$themeManager.SetEventBus($eventBus)

# Removed FocusManager and ShortcutManager services
# Using direct patterns instead: ScreenManager global shortcuts + Screen.FocusNext()

# Project service
$projectService = [ProjectService]::new()
$global:ServiceContainer.Register("ProjectService", $projectService)

# Task service
$taskService = [TaskService]::new()
$global:ServiceContainer.Register("TaskService", $taskService)

# Subtask service
$subtaskService = [SubtaskService]::new()
$global:ServiceContainer.Register("SubtaskService", $subtaskService)
# Time tracking service
$timeTrackingService = [TimeTrackingService]::new()
$global:ServiceContainer.Register("TimeTrackingService", $timeTrackingService)

# Command service
$commandService = [CommandService]::new()
$global:ServiceContainer.Register("CommandService", $commandService)

# Configuration service
$configService = [ConfigurationService]::new()
$global:ServiceContainer.Register("ConfigurationService", $configService)

# Apply theme from configuration
$currentTheme = $configService.Get("Theme.CurrentTheme", "matrix")
if ($themeManager._themes.ContainsKey($currentTheme)) {
    $themeManager.SetTheme($currentTheme)
} else {
    # Fallback to matrix theme if configured theme doesn't exist
    $themeManager.SetTheme("matrix")
}

# State manager - high-performance centralized state
$stateManager = [StateManager]::new()
$stateManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("StateManager", $stateManager)

# Screen manager
$screenManager = [ScreenManager]::new($global:ServiceContainer)
$global:ScreenManager = $screenManager
$global:ServiceContainer.Register("ScreenManager", $screenManager)

# Create main screen with tabs
Write-Host "Creating main interface..." -ForegroundColor Cyan

# Create and run main screen
if ($Debug) { Write-Host "  Creating MainScreen..." -ForegroundColor DarkGray }
$mainScreen = [MainScreen]::new()

if ($Debug) { Write-Host "  Pushing to ScreenManager..." -ForegroundColor DarkGray }
$screenManager.Push($mainScreen)

if ($Debug) { Write-Host "  Main screen initialized" -ForegroundColor DarkGray }

# Exit early if LoadOnly is requested
if ($LoadOnly) {
    Write-Host "Framework loaded successfully (LoadOnly mode)" -ForegroundColor Green
    return
}

Write-Host "Starting PRAXIS..." -ForegroundColor Green
Write-Host "  ‚Ä¢ Press 1-6 to switch tabs (Projects, Tasks, Dashboard, Files, Editor, Settings)" -ForegroundColor DarkGray
Write-Host "  ‚Ä¢ Press Ctrl+Tab to cycle tabs" -ForegroundColor DarkGray
Write-Host "  ‚Ä¢ Press / or : for command palette" -ForegroundColor DarkGray
Write-Host "  ‚Ä¢ Press Q or Escape to quit" -ForegroundColor DarkGray
Write-Host ""

# Run the application
try {
    $global:Logger.Info("Starting PRAXIS main loop")
    $screenManager.Run()
} catch {
    if ($global:Logger) {
        if ($_.Exception) {
            $global:Logger.LogException($_.Exception, "Fatal error in main loop")
        } else {
            $global:Logger.Error("Fatal error in main loop: $_")
        }
    }
    Write-Host "Error: $_" -ForegroundColor Red
    Write-Host $_.ScriptStackTrace -ForegroundColor DarkRed
    if ($global:Logger) {
        Write-Host "`nCheck log file at: $($global:Logger.LogPath)" -ForegroundColor Yellow
    }
} finally {
    # Cleanup
    $global:Logger.Info("Shutting down PRAXIS")
    $stateManager = $global:ServiceContainer.GetService("StateManager")
    if ($stateManager) {
        $stateManager.Cleanup()
    }
    $global:Logger.Cleanup()
    $global:ServiceContainer.Cleanup()
    Write-Host "`nPRAXIS terminated." -ForegroundColor Cyan
}


####\test-action-creation.ps1
#!/usr/bin/env pwsh

# Test action creation to see what's failing
. "$PSScriptRoot/Start.ps1" -LoadOnly

Write-Host "Testing Action class creation..." -ForegroundColor Green

try {
    Write-Host "Testing BaseAction..." -ForegroundColor Yellow
    $baseAction = [BaseAction]::new()
    Write-Host "‚úì BaseAction created successfully" -ForegroundColor Green
} catch {
    Write-Host "‚úó BaseAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing SummarizationAction..." -ForegroundColor Yellow
    $summarizationAction = [SummarizationAction]::new()
    Write-Host "‚úì SummarizationAction created successfully: $($summarizationAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó SummarizationAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing AppendFieldAction..." -ForegroundColor Yellow
    $appendFieldAction = [AppendFieldAction]::new()
    Write-Host "‚úì AppendFieldAction created successfully: $($appendFieldAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó AppendFieldAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing ExportToExcelAction..." -ForegroundColor Yellow
    $exportAction = [ExportToExcelAction]::new()
    Write-Host "‚úì ExportToExcelAction created successfully: $($exportAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó ExportToExcelAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

try {
    Write-Host "Testing CustomIdeaCommandAction..." -ForegroundColor Yellow
    $customAction = [CustomIdeaCommandAction]::new()
    Write-Host "‚úì CustomIdeaCommandAction created successfully: $($customAction.Name)" -ForegroundColor Green
} catch {
    Write-Host "‚úó CustomIdeaCommandAction failed: $($_.Exception.Message)" -ForegroundColor Red
}

Write-Host "`nAction creation test completed!" -ForegroundColor Cyan


####\test-class-loading.ps1
#!/usr/bin/env pwsh

# Test if dialog classes are properly loaded
Write-Host "Testing class loading..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

Write-Host "`nChecking if classes exist..." -ForegroundColor Yellow

# Test BaseDialog
try {
    $test = [BaseDialog] -as [type]
    if ($test) {
        Write-Host "  ‚úì BaseDialog class found" -ForegroundColor Green
    } else {
        Write-Host "  ‚úó BaseDialog class not found" -ForegroundColor Red
    }
} catch {
    Write-Host "  ‚úó BaseDialog error: $($_.Exception.Message)" -ForegroundColor Red
}

# Test CommandEditDialog
try {
    $test = [CommandEditDialog] -as [type]
    if ($test) {
        Write-Host "  ‚úì CommandEditDialog class found" -ForegroundColor Green
    } else {
        Write-Host "  ‚úó CommandEditDialog class not found" -ForegroundColor Red
    }
} catch {
    Write-Host "  ‚úó CommandEditDialog error: $($_.Exception.Message)" -ForegroundColor Red
}

# Test ConfirmationDialog
try {
    $test = [ConfirmationDialog] -as [type]
    if ($test) {
        Write-Host "  ‚úì ConfirmationDialog class found" -ForegroundColor Green
    } else {
        Write-Host "  ‚úó ConfirmationDialog class not found" -ForegroundColor Red
    }
} catch {
    Write-Host "  ‚úó ConfirmationDialog error: $($_.Exception.Message)" -ForegroundColor Red
}

# Try creating instances
Write-Host "`nTesting instance creation..." -ForegroundColor Yellow

if ([CommandEditDialog] -as [type]) {
    try {
        $dialog = [CommandEditDialog]::new()
        Write-Host "  ‚úì CommandEditDialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó CommandEditDialog creation failed: $($_.Exception.Message)" -ForegroundColor Red
    }
} else {
    Write-Host "  ‚úó Cannot test CommandEditDialog creation - class not found" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-direct.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen directly
Write-Host "Testing CommandLibraryScreen directly..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    
    Write-Host "Initializing screen..." -ForegroundColor Yellow  
    $screen.Initialize($global:ServiceContainer)
    
    Write-Host "Screen created successfully" -ForegroundColor Green
    Write-Host "  CommandList exists: $($null -ne $screen.CommandList)" -ForegroundColor Cyan
    
    if ($screen.CommandList) {
        Write-Host "  CommandList Items count: $($screen.CommandList.Items.Count)" -ForegroundColor Cyan
        Write-Host "  CommandList _filteredItems count: $($screen.CommandList._filteredItems.Count)" -ForegroundColor Cyan
        
        Write-Host "  Commands from service:" -ForegroundColor Cyan
        $commands = $screen.CommandService.GetAllCommands()
        Write-Host "    CommandService.GetAllCommands() count: $($commands.Count)" -ForegroundColor Cyan
        
        foreach ($cmd in $commands) {
            Write-Host "    - $($cmd.Title): $($cmd.Description)" -ForegroundColor DarkGray
        }
    }
    
    # Test bounds
    Write-Host "Setting test bounds..." -ForegroundColor Yellow
    $screen.SetBounds(0, 0, 80, 20)
    Write-Host "  Screen bounds: $($screen.X),$($screen.Y) - $($screen.Width)x$($screen.Height)" -ForegroundColor Cyan
    
    if ($screen.CommandList) {
        Write-Host "  CommandList bounds: $($screen.CommandList.X),$($screen.CommandList.Y) - $($screen.CommandList.Width)x$($screen.CommandList.Height)" -ForegroundColor Cyan
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "Test completed!" -ForegroundColor Green


####\test-commandlibrary-focus.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen focus
Write-Host "Testing CommandLibraryScreen focus..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    Write-Host "CommandList has focus: $($screen.CommandList.IsFocused)" -ForegroundColor Cyan
    Write-Host "CommandList is focusable: $($screen.CommandList.IsFocusable)" -ForegroundColor Cyan
    Write-Host "Selected index: $($screen.CommandList.SelectedIndex)" -ForegroundColor Cyan
    
    # Test OnActivated
    Write-Host "`nTesting OnActivated..." -ForegroundColor Yellow
    $screen.OnActivated()
    Write-Host "After OnActivated - CommandList has focus: $($screen.CommandList.IsFocused)" -ForegroundColor Cyan
    
    # Test cursor navigation simulation
    Write-Host "`nTesting cursor navigation..." -ForegroundColor Yellow
    $downKey = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::DownArrow, $false, $false, $false)
    $oldIndex = $screen.CommandList.SelectedIndex
    
    $handled = $screen.CommandList.HandleInput($downKey)
    $newIndex = $screen.CommandList.SelectedIndex
    
    Write-Host "Down arrow handled: $handled" -ForegroundColor Cyan
    Write-Host "Index changed from $oldIndex to $newIndex" -ForegroundColor Cyan
    
    if ($newIndex -ne $oldIndex) {
        Write-Host "‚úì Cursor navigation working!" -ForegroundColor Green
    } else {
        Write-Host "‚úó Cursor navigation not working" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-render.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen rendering
Write-Host "Testing CommandLibraryScreen rendering output..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating and setting up CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test rendering
    Write-Host "`nTesting render output (first 500 chars)..." -ForegroundColor Cyan
    $renderOutput = $screen.OnRender()
    
    if ($renderOutput.Length -gt 0) {
        Write-Host "‚úì Render output generated: $($renderOutput.Length) characters" -ForegroundColor Green
        
        # Show a sample of the render output (strip ANSI for readability)
        $sample = $renderOutput.Substring(0, [Math]::Min(500, $renderOutput.Length))
        $cleanSample = $sample -replace '\e\[[0-9;]*m', '' -replace '\e\[[0-9;]*[A-Za-z]', ''
        Write-Host "`nSample output (ANSI stripped):" -ForegroundColor Cyan
        Write-Host $cleanSample -ForegroundColor DarkGray
        
        # Check if it contains command titles
        $containsCommands = $renderOutput -match "@CurrentDate_YYYYMMDD"
        Write-Host "`nContains command titles: $containsCommands" -ForegroundColor $(if ($containsCommands) { "Green" } else { "Red" })
        
    } else {
        Write-Host "‚úó No render output generated!" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-shortcuts.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen shortcuts
Write-Host "Testing CommandLibraryScreen keyboard shortcuts..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 20)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test shortcut registration
    $shortcutManager = $global:ServiceContainer.GetService('ShortcutManager')
    $shortcuts = $shortcutManager.GetShortcuts([ShortcutScope]::Screen, "CommandLibraryScreen")
    
    Write-Host "`nRegistered shortcuts for CommandLibraryScreen:" -ForegroundColor Cyan
    foreach ($shortcut in $shortcuts) {
        Write-Host "  $($shortcut.GetDisplayText()): $($shortcut.Name)" -ForegroundColor Yellow
    }
    
    # Test NewCommand method directly
    Write-Host "`nTesting NewCommand method..." -ForegroundColor Cyan
    try {
        # Mock ScreenManager for the test
        $global:ScreenManager = [PSCustomObject]@{
            GetScreen = { return $null }
            RegisterScreen = { }
            PushScreen = { 
                param($screen)
                Write-Host "  ‚úì PushScreen called with: $($screen.GetType().Name)" -ForegroundColor Green
            }
        }
        
        $screen.NewCommand()
        Write-Host "  ‚úì NewCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-commandlibrary-simple.ps1
#!/usr/bin/env pwsh

# Simple test of CommandLibraryScreen functionality
Write-Host "Testing CommandLibraryScreen with fixed ScreenManager API..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test NewCommand directly
    Write-Host "`nTesting NewCommand..." -ForegroundColor Yellow
    try {
        $screen.NewCommand()
        Write-Host "  ‚úì NewCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test EditCommand (no selection)
    Write-Host "`nTesting EditCommand (no selection)..." -ForegroundColor Yellow
    try {
        $screen.EditCommand()
        Write-Host "  ‚úì EditCommand handled no selection correctly" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó EditCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test DeleteCommand (no selection)
    Write-Host "`nTesting DeleteCommand (no selection)..." -ForegroundColor Yellow
    try {
        $screen.DeleteCommand()
        Write-Host "  ‚úì DeleteCommand handled no selection correctly" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó DeleteCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-copy-command.ps1
#!/usr/bin/env pwsh

# Test copy command functionality
Write-Host "Testing CopySelectedCommand..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Select first command
    $screen.CommandList.SelectedIndex = 0
    $selectedCommand = $screen.CommandList.GetSelectedItem()
    Write-Host "Selected: $($selectedCommand.GetDisplayText())" -ForegroundColor Yellow
    
    # Test copy
    Write-Host "`nTesting CopySelectedCommand..." -ForegroundColor Yellow
    try {
        $screen.CopySelectedCommand()
        Write-Host "  ‚úì Copy executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó Copy failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-cursor-validation-crash.ps1
#!/usr/bin/env pwsh

# Test cursor validation crash scenario
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load dependencies
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Testing cursor validation after undo..." -ForegroundColor Red

# Create the scenario
$buffer = [DocumentBuffer]::new()

# Add sample content
$sampleLines = @(
    "Welcome to PRAXIS Text Editor!",
    "",
    "This is line 2"
)
$buffer.Lines.Clear()
foreach ($line in $sampleLines) {
    $buffer.Lines.Add($line) | Out-Null
}
$buffer.ClearUndoHistory()
$buffer.IsModified = $false

# Set cursor position like editor would
$CursorX = 0
$CursorY = 0

Write-Host "Initial state:"
Write-Host "  Lines: $($buffer.GetLineCount())"
Write-Host "  Cursor: ($CursorX,$CursorY)"

# Type a character
Write-Host "`nTyping 'H' at cursor position..."
$insertCmd = [InsertTextCommand]::new($CursorY, $CursorX, "H")
$buffer.ExecuteCommand($insertCmd)
$CursorX++  # Move cursor like editor does

Write-Host "After typing:"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"
Write-Host "  Cursor: ($CursorX,$CursorY)"

# Now undo and validate cursor like TextEditorScreenNew.UndoEdit() does
Write-Host "`nPerforming undo with cursor validation..."
try {
    # This is what UndoEdit does
    $buffer.Undo()
    
    # Simulate ValidateCursorPosition
    Write-Host "Validating cursor position..."
    $lineCount = $buffer.GetLineCount()
    if ($lineCount -eq 0) {
        $CursorX = 0
        $CursorY = 0
    } else {
        # Clamp cursor Y
        $CursorY = [Math]::Max(0, [Math]::Min($CursorY, $lineCount - 1))
        
        # Get current line for X validation
        Write-Host "  Getting line $CursorY..."
        $currentLine = $buffer.GetLine($CursorY)
        Write-Host "  Current line: '$currentLine'"
        Write-Host "  Current line length: $($currentLine.Length)"
        Write-Host "  Cursor X before clamp: $CursorX"
        
        # Clamp cursor X
        $CursorX = [Math]::Max(0, [Math]::Min($CursorX, $currentLine.Length))
        Write-Host "  Cursor X after clamp: $CursorX"
    }
    
    Write-Host "‚úì Undo and validation completed successfully!"
    Write-Host "  Final cursor: ($CursorX,$CursorY)"
    Write-Host "  Line 0: '$($buffer.GetLine(0))'"
    
} catch {
    Write-Host "‚úó CRASH during undo/validation!" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack Trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-dialog-creation.ps1
#!/usr/bin/env pwsh

# Test dialog creation and initialization
Write-Host "Testing dialog creation and initialization..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    $dialog.Initialize($global:ServiceContainer)
    $dialog.SetBounds(0, 0, 80, 25)
    
    Write-Host "  ‚úì CommandEditDialog created and initialized successfully" -ForegroundColor Green
    
    # Test SetCommand
    Write-Host "`nTesting SetCommand with null (new command)..." -ForegroundColor Yellow
    try {
        $dialog.SetCommand($null)
        Write-Host "  ‚úì SetCommand(null) successful" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó SetCommand(null) failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test with existing command
    Write-Host "`nTesting SetCommand with existing command..." -ForegroundColor Yellow
    $commandService = $global:ServiceContainer.GetService("CommandService")
    $commands = $commandService.GetAllCommands()
    if ($commands.Count -gt 0) {
        try {
            $dialog.SetCommand($commands[0])
            Write-Host "  ‚úì SetCommand(existing) successful" -ForegroundColor Green
        } catch {
            Write-Host "  ‚úó SetCommand(existing) failed: $($_.Exception.Message)" -ForegroundColor Red
        }
    } else {
        Write-Host "  - No commands available to test with" -ForegroundColor Yellow
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-dialog-render.ps1
#!/usr/bin/env pwsh

# Test dialog rendering to make sure no substring errors
Write-Host "Testing CommandEditDialog rendering..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating and initializing CommandEditDialog..." -ForegroundColor Yellow
    $dialog = [CommandEditDialog]::new()
    $dialog.Initialize($global:ServiceContainer)
    $dialog.SetBounds(0, 0, 120, 40)  # Give it plenty of space
    
    Write-Host "Testing OnBoundsChanged..." -ForegroundColor Yellow
    $dialog.OnBoundsChanged()
    Write-Host "  ‚úì OnBoundsChanged successful" -ForegroundColor Green
    
    Write-Host "Testing SetCommand(null)..." -ForegroundColor Yellow
    $dialog.SetCommand($null)
    Write-Host "  ‚úì SetCommand successful" -ForegroundColor Green
    
    Write-Host "Testing dialog rendering..." -ForegroundColor Yellow
    $rendered = $dialog.Render()
    if ($rendered -and $rendered.Length -gt 0) {
        Write-Host "  ‚úì Dialog rendered successfully (length: $($rendered.Length))" -ForegroundColor Green
    } else {
        Write-Host "  ‚úó Dialog render returned empty or null" -ForegroundColor Red
    }
    
    Write-Host "Testing with existing command..." -ForegroundColor Yellow
    $commandService = $global:ServiceContainer.GetService("CommandService")
    $commands = $commandService.GetAllCommands()
    if ($commands.Count -gt 0) {
        $dialog.SetCommand($commands[0])
        $rendered2 = $dialog.Render()
        if ($rendered2 -and $rendered2.Length -gt 0) {
            Write-Host "  ‚úì Dialog with existing command rendered successfully" -ForegroundColor Green
        } else {
            Write-Host "  ‚úó Dialog with existing command failed to render" -ForegroundColor Red
        }
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-exact-undo-crash.ps1
#!/usr/bin/env pwsh

# Test exact TextEditorScreenNew scenario that crashes
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load only what we need
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Reproducing exact TextEditorScreenNew undo scenario..." -ForegroundColor Red

# Create buffer exactly like TextEditorScreenNew constructor
Write-Host "Step 1: Creating buffer with empty line..."
$buffer = [DocumentBuffer]::new()
Write-Host "  Initial lines: $($buffer.GetLineCount())"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"
Write-Host "  Can undo: $($buffer.CanUndo())"

# Simulate AddSampleContent exactly like TextEditorScreenNew does
Write-Host "`nStep 2: Simulating AddSampleContent()..."
$sampleLines = @(
    "Welcome to PRAXIS Text Editor!",
    "",
    "This is the new Buffer/View architecture with:",
    "‚Ä¢ Command Pattern for robust undo/redo",
    "‚Ä¢ Line-level render caching for performance", 
    "‚Ä¢ Proper Buffer/View separation",
    "",
    "Try typing text, using arrow keys, or:",
    "‚Ä¢ Ctrl+Z to undo",
    "‚Ä¢ Ctrl+Y to redo", 
    "‚Ä¢ Ctrl+S to save (when implemented)",
    "",
    "The architecture is now professional-grade!"
)

# This is what AddSampleContent does
$buffer.Lines.Clear()
foreach ($line in $sampleLines) {
    $buffer.Lines.Add($line) | Out-Null
}
$buffer.ClearUndoHistory()
$buffer.IsModified = $false

Write-Host "  After sample content:"
Write-Host "  Lines: $($buffer.GetLineCount())"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"
Write-Host "  Can undo: $($buffer.CanUndo()) (should be false)"

# Now simulate typing a character like InsertCharacter does
Write-Host "`nStep 3: Simulating typing 'H' at position (0,0)..."
$insertCmd = [InsertTextCommand]::new(0, 0, "H")
$buffer.ExecuteCommand($insertCmd)

Write-Host "  After insert:"
Write-Host "  Line 0: '$($buffer.GetLine(0))'"  
Write-Host "  Can undo: $($buffer.CanUndo()) (should be true)"

# Now try undo - this is where it might crash
Write-Host "`nStep 4: Attempting undo (this might crash)..."
try {
    Write-Host "  Calling buffer.Undo()..."
    $buffer.Undo()
    Write-Host "  ‚úì Undo completed successfully!"
    Write-Host "  Line 0 after undo: '$($buffer.GetLine(0))'"
    Write-Host "  Can undo: $($buffer.CanUndo())"
    Write-Host "  Can redo: $($buffer.CanRedo())"
} catch {
    Write-Host "  ‚úó UNDO CRASHED!" -ForegroundColor Red
    Write-Host "  Exception Type: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "  Stack Trace:" -ForegroundColor Red
    Write-Host "  $($_.ScriptStackTrace)" -ForegroundColor Red
    
    # Show the command details that failed
    Write-Host "`n  Debug info:" -ForegroundColor Yellow
    Write-Host "  Undo stack count: $($buffer._undoStack.Count)"
    if ($buffer._undoStack.Count -gt 0) {
        $lastCmd = $buffer._undoStack[$buffer._undoStack.Count - 1]
        Write-Host "  Last command type: $($lastCmd.GetType().Name)"
        Write-Host "  Command Line: $($lastCmd.Line)"
        Write-Host "  Command Col: $($lastCmd.Col)" 
        Write-Host "  Command Text: '$($lastCmd.Text)'"
    }
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-final-shortcuts.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen shortcuts with ScreenManager fix
Write-Host "Testing CommandLibraryScreen shortcuts with fixed ScreenManager..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test NewCommand with global ScreenManager
    Write-Host "`nTesting NewCommand with proper ScreenManager..." -ForegroundColor Yellow
    
    # Mock global ScreenManager
    $global:ScreenManager = [PSCustomObject]@{
        GetScreen = { 
            param($name)
            return $null  # Force creation of new dialog
        }
        RegisterScreen = { 
            param($name, $screen)
            Write-Host "  ‚úì RegisterScreen called: $name" -ForegroundColor Green
        }
        Push = { 
            param($screen)
            Write-Host "  ‚úì Push called with: $($screen.GetType().Name)" -ForegroundColor Green
        }
    }
    
    try {
        $screen.NewCommand()
        Write-Host "  ‚úì NewCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test EditCommand (should warn about no selection)
    Write-Host "`nTesting EditCommand (no selection)..." -ForegroundColor Yellow
    try {
        $screen.EditCommand()
        Write-Host "  ‚úì EditCommand handled no selection correctly" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó EditCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test with a selection
    Write-Host "`nTesting EditCommand with selection..." -ForegroundColor Yellow
    $screen.CommandList.SelectedIndex = 0  # Select first command
    try {
        $screen.EditCommand()
        Write-Host "  ‚úì EditCommand with selection executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó EditCommand with selection failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-full-commandlibrary.ps1
#!/usr/bin/env pwsh

# Comprehensive test of CommandLibraryScreen functionality
Write-Host "Testing full CommandLibraryScreen functionality..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test all shortcut key handling
    Write-Host "`nTesting shortcut key handling..." -ForegroundColor Yellow
    
    # Test 'n' key (NewCommand)
    $nKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    $handled = $screen.HandleScreenInput($nKey)
    Write-Host "  'n' key (NewCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'e' key (EditCommand) 
    $eKey = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
    $handled = $screen.HandleScreenInput($eKey)
    Write-Host "  'e' key (EditCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'd' key (DeleteCommand)
    $dKey = [System.ConsoleKeyInfo]::new('d', [System.ConsoleKey]::D, $false, $false, $false)
    $handled = $screen.HandleScreenInput($dKey)
    Write-Host "  'd' key (DeleteCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test Enter key (CopySelectedCommand)
    $enterKey = [System.ConsoleKeyInfo]::new([char]13, [System.ConsoleKey]::Enter, $false, $false, $false)
    $handled = $screen.HandleScreenInput($enterKey)
    Write-Host "  Enter key (CopyCommand): $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test with selection
    Write-Host "`nTesting with command selected..." -ForegroundColor Yellow
    $screen.CommandList.SelectedIndex = 0
    $selectedCommand = $screen.CommandList.GetSelectedItem()
    Write-Host "  Selected: $($selectedCommand.GetDisplayText())" -ForegroundColor Cyan
    
    # Test copy with selection
    try {
        $screen.CopySelectedCommand()
        Write-Host "  ‚úì Copy with selection successful" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó Copy failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test that SearchableListBox excludes shortcut keys
    Write-Host "`nTesting SearchableListBox key exclusion..." -ForegroundColor Yellow
    $listHandled = $screen.CommandList.HandleInput($nKey)
    Write-Host "  SearchableListBox handles 'n': $listHandled" -ForegroundColor $(if (-not $listHandled) { "Green" } else { "Red" })
    
    # Test search with normal characters
    $aKey = [System.ConsoleKeyInfo]::new('a', [System.ConsoleKey]::A, $false, $false, $false)
    $listHandled = $screen.CommandList.HandleInput($aKey)
    Write-Host "  SearchableListBox handles 'a': $listHandled" -ForegroundColor $(if ($listHandled) { "Green" } else { "Red" })
    
    Write-Host "`n‚úì All CommandLibraryScreen functionality working!" -ForegroundColor Green
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-full-dialog-flow.ps1
#!/usr/bin/env pwsh

# Test complete CommandLibraryScreen + Dialog flow
Write-Host "Testing complete CommandLibraryScreen with dialogs..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 120, 40)
    
    Write-Host "Commands loaded: $($screen.CommandList.Items.Count)" -ForegroundColor Green
    
    # Test NewCommand dialog creation and rendering
    Write-Host "`nTesting NewCommand dialog creation..." -ForegroundColor Yellow
    try {
        $screen.NewCommand()
        Write-Host "  ‚úì NewCommand dialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó NewCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test EditCommand with selection
    Write-Host "`nTesting EditCommand with selection..." -ForegroundColor Yellow
    $screen.CommandList.SelectedIndex = 0
    try {
        $screen.EditCommand()
        Write-Host "  ‚úì EditCommand dialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó EditCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test DeleteCommand with selection
    Write-Host "`nTesting DeleteCommand with selection..." -ForegroundColor Yellow
    try {
        $screen.DeleteCommand()
        Write-Host "  ‚úì DeleteCommand dialog created successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó DeleteCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    # Test CopySelectedCommand
    Write-Host "`nTesting CopySelectedCommand..." -ForegroundColor Yellow
    try {
        $screen.CopySelectedCommand()
        Write-Host "  ‚úì CopySelectedCommand executed successfully" -ForegroundColor Green
    } catch {
        Write-Host "  ‚úó CopySelectedCommand failed: $($_.Exception.Message)" -ForegroundColor Red
    }
    
    Write-Host "`n‚úÖ All CommandLibraryScreen functionality working perfectly!" -ForegroundColor Green
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-full-editor-undo.ps1
#!/usr/bin/env pwsh

# Test the full TextEditorScreenNew undo crash
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

Write-Host "Testing full TextEditorScreenNew undo crash..." -ForegroundColor Red

# Load all required dependencies in correct order
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize services like PRAXIS does
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)

$eventBus = [EventBus]::new()
$global:ServiceContainer.Register("EventBus", $eventBus)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

Write-Host "‚úì All dependencies loaded and services initialized"

# Create editor exactly like PRAXIS does
Write-Host "`nCreating TextEditorScreenNew..." 
try {
    $editor = [TextEditorScreenNew]::new()
    $editor.Initialize($global:ServiceContainer)
    $editor.SetBounds(0, 0, 80, 24)
    Write-Host "‚úì Editor created and initialized"
} catch {
    Write-Host "‚úó Failed to create editor: $_" -ForegroundColor Red
    exit 1
}

# Show initial state
Write-Host "`nInitial state:"
Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "  Lines: $($editor._buffer.GetLineCount())"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
Write-Host "  Can undo: $($editor._buffer.CanUndo())"

# Simulate typing exactly like the real editor
Write-Host "`nSimulating typing 'A'..."
try {
    $keyInfo = [System.ConsoleKeyInfo]::new('A', [System.ConsoleKey]::A, $false, $false, $false)
    $handled = $editor.HandleScreenInput($keyInfo)
    Write-Host "‚úì Character typed, handled: $handled"
    Write-Host "  New cursor: ($($editor.CursorX),$($editor.CursorY))"
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Can undo: $($editor._buffer.CanUndo())"
} catch {
    Write-Host "‚úó Failed to type character: $_" -ForegroundColor Red
    exit 1
}

# Now try to undo - this is where it should crash
Write-Host "`nAttempting undo (this may crash)..."
try {
    Write-Host "  Calling editor.UndoEdit()..."
    $editor.UndoEdit()
    Write-Host "  ‚úì Undo completed successfully!"
    Write-Host "  Final cursor: ($($editor.CursorX),$($editor.CursorY))" 
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Status: '$($editor.StatusMessage)'"
} catch {
    Write-Host "  ‚úó UNDO CRASHED IN FULL EDITOR!" -ForegroundColor Red
    Write-Host "  Exception Type: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "  Inner Exception: $($_.Exception.InnerException)" -ForegroundColor Red
    Write-Host "  Stack Trace:" -ForegroundColor Red
    $_.ScriptStackTrace -split "`n" | ForEach-Object { Write-Host "    $_" -ForegroundColor Red }
    
    Write-Host "`n  Additional debug info:" -ForegroundColor Yellow
    Write-Host "  Editor cursor: ($($editor.CursorX),$($editor.CursorY))"
    Write-Host "  Buffer lines: $($editor._buffer.GetLineCount())"
    Write-Host "  Buffer can undo: $($editor._buffer.CanUndo())"
    Write-Host "  Editor status: '$($editor.StatusMessage)'"
    
    exit 1
}

Write-Host "`nTest completed successfully!" -ForegroundColor Green


####\test-keypress-undo.ps1
#!/usr/bin/env pwsh

# Test if the crash is related to the keypress handling context
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

Write-Host "Testing keypress context undo crash..." -ForegroundColor Red

# Load the full editor with all dependencies
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
$eventBus = [EventBus]::new()
$global:ServiceContainer.Register("EventBus", $eventBus)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

# Create editor
$editor = [TextEditorScreenNew]::new()
$editor.Initialize($global:ServiceContainer)
$editor.SetBounds(0, 0, 80, 24)

Write-Host "Editor initialized. Initial state:"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
Write-Host "  Can undo: $($editor._buffer.CanUndo())"

# Type a character using HandleScreenInput (the actual input mechanism)
Write-Host "`nTyping 'T' using HandleScreenInput..."
$keyInfo = [System.ConsoleKeyInfo]::new('T', [System.ConsoleKey]::T, $false, $false, $false)
$handled = $editor.HandleScreenInput($keyInfo)
Write-Host "Character handled: $handled"
Write-Host "After typing: '$($editor._buffer.GetLine(0))'"
Write-Host "Can undo: $($editor._buffer.CanUndo())"

# Now simulate the exact Ctrl+Z keypress that crashes in the real app
Write-Host "`nSimulating Ctrl+Z keypress using HandleScreenInput..."
Write-Host "This might crash immediately..."

try {
    # Create the exact same keypress as the real application would receive
    $ctrlZ = [System.ConsoleKeyInfo]::new([char]26, [System.ConsoleKey]::Z, $false, $false, $true)
    Write-Host "Created Ctrl+Z keyinfo: Key=$($ctrlZ.Key), Modifiers=$($ctrlZ.Modifiers)"
    
    Write-Host "Calling HandleScreenInput with Ctrl+Z..."
    $handled = $editor.HandleScreenInput($ctrlZ)
    
    Write-Host "‚úì Ctrl+Z handled successfully: $handled"
    Write-Host "Final state: '$($editor._buffer.GetLine(0))'"
    Write-Host "Status: '$($editor.StatusMessage)'"
    
} catch {
    Write-Host "‚úó CTRL+Z CRASHED!" -ForegroundColor Red
    Write-Host "Exception Type: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Inner Exception: $($_.Exception.InnerException)" -ForegroundColor Red
    $_.ScriptStackTrace -split "`n" | ForEach-Object { Write-Host "  $_" -ForegroundColor Red }
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-live-commandlibrary.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen in live application environment
Write-Host "Testing CommandLibraryScreen in live application..." -ForegroundColor Cyan

# Start the application normally
Write-Host "Starting PRAXIS application..." -ForegroundColor Yellow
Write-Host "- Navigate to Commands tab and test keyboard shortcuts" -ForegroundColor Green
Write-Host "- Press 'n' to create new command" -ForegroundColor Green  
Write-Host "- Press 'e' to edit selected command" -ForegroundColor Green
Write-Host "- Press 'd' to delete selected command" -ForegroundColor Green
Write-Host "- Press Enter to copy command to clipboard" -ForegroundColor Green
Write-Host "- Use arrow keys to navigate commands" -ForegroundColor Green
Write-Host "- Type to search commands (excludes n/e/d)" -ForegroundColor Green
Write-Host "" -ForegroundColor White
Write-Host "Press Ctrl+Q to exit when done testing" -ForegroundColor Yellow

# Run the actual application
& "$PSScriptRoot/Start.ps1"


####\test-macro-factory-ui.ps1
#!/usr/bin/env pwsh

# Test the VisualMacroFactoryScreen in PRAXIS to verify actions are visible
param([switch]$LoadOnly)

# Provide instruction to user
Write-Host "This will start PRAXIS. To test the Macro Factory:" -ForegroundColor Cyan
Write-Host "1. Press '7' to go to Macro Factory tab" -ForegroundColor Yellow  
Write-Host "2. Check if the left pane shows 4 actions:" -ForegroundColor Yellow
Write-Host "   - üìä Summarization" -ForegroundColor Green
Write-Host "   - ‚öôÔ∏è Append Calculated Field" -ForegroundColor Green
Write-Host "   - üìã Export to Excel" -ForegroundColor Green  
Write-Host "   - üîß Custom IDEA@ Command" -ForegroundColor Green
Write-Host "3. Test if keyboard shortcuts work:" -ForegroundColor Yellow
Write-Host "   - F5 should trigger preview" -ForegroundColor Green
Write-Host "   - Ctrl+S should trigger save" -ForegroundColor Green
Write-Host "   - Ctrl+N should trigger new macro" -ForegroundColor Green
Write-Host "4. Press Q to quit when done testing" -ForegroundColor Yellow
Write-Host ""
Write-Host "Starting PRAXIS..." -ForegroundColor Green

# Start PRAXIS
. "$PSScriptRoot/Start.ps1"


####\test-minimal-ui-undo.ps1
#!/usr/bin/env pwsh

# Minimal reproduction of the UI undo crash
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load dependencies first
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

# Create a minimal class that mimics the exact pattern from TextEditorScreenNew
class MinimalEditor {
    hidden [object]$_buffer
    [int]$CursorX = 0
    [int]$CursorY = 0
    [string]$StatusMessage = ""
    
    MinimalEditor() {
        
        $this._buffer = [DocumentBuffer]::new()
        
        # Exactly mimic AddSampleContent
        $sampleLines = @(
            "Welcome to PRAXIS Text Editor!",
            "",
            "This is the new Buffer/View architecture with:",
            "‚Ä¢ Command Pattern for robust undo/redo"
        )
        
        $this._buffer.Lines.Clear()
        foreach ($line in $sampleLines) {
            $this._buffer.Lines.Add($line) | Out-Null
        }
        $this._buffer.ClearUndoHistory()
        $this._buffer.IsModified = $false
    }
    
    [void] TypeCharacter([char]$char) {
        Write-Host "Typing '$char' at ($($this.CursorX),$($this.CursorY))"
        $command = [InsertTextCommand]::new($this.CursorY, $this.CursorX, [string]$char)
        $this._buffer.ExecuteCommand($command)
        $this.CursorX++
        Write-Host "  After typing: Line 0 = '$($this._buffer.GetLine(0))'"
        Write-Host "  Can undo: $($this._buffer.CanUndo())"
    }
    
    [void] UndoEdit() {
        Write-Host "Starting undo operation..."
        
        if (-not $this._buffer.CanUndo()) {
            Write-Host "  Nothing to undo"
            return
        }
        
        try {
            Write-Host "  Calling buffer.Undo()..."
            $this._buffer.Undo()
            Write-Host "  Buffer undo completed"
            
            Write-Host "  Validating cursor position..."
            $this.ValidateCursorPosition()
            Write-Host "  Cursor validation completed"
            
            $this.StatusMessage = "Undo"
            Write-Host "  ‚úì Undo operation completed successfully"
            Write-Host "  Final state: Line 0 = '$($this._buffer.GetLine(0))'"
            Write-Host "  Final cursor: ($($this.CursorX),$($this.CursorY))"
            
        } catch {
            Write-Host "  ‚úó UNDO CRASHED!" -ForegroundColor Red
            Write-Host "  Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
            Write-Host "  Message: $($_.Exception.Message)" -ForegroundColor Red
            Write-Host "  Stack: $($_.ScriptStackTrace)" -ForegroundColor Red
            throw $_
        }
    }
    
    [void] ValidateCursorPosition() {
        $lineCount = $this._buffer.GetLineCount()
        if ($lineCount -eq 0) {
            $this.CursorX = 0
            $this.CursorY = 0
            return
        }
        
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.CursorY, $lineCount - 1))
        $currentLine = $this._buffer.GetLine($this.CursorY)
        $this.CursorX = [Math]::Max(0, [Math]::Min($this.CursorX, $currentLine.Length))
    }
}

Write-Host "Creating minimal editor..." -ForegroundColor Yellow
$editor = [MinimalEditor]::new()

Write-Host "`nInitial state:"
Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"

Write-Host "`nTyping character 'X'..." -ForegroundColor Green
$editor.TypeCharacter('X')

Write-Host "`nAttempting undo..." -ForegroundColor Red
$editor.UndoEdit()

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-screen-input.ps1
#!/usr/bin/env pwsh

# Test CommandLibraryScreen HandleScreenInput method
Write-Host "Testing CommandLibraryScreen HandleScreenInput..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    $screen.SetBounds(0, 0, 80, 25)
    
    # Test HandleScreenInput method
    Write-Host "Testing HandleScreenInput method..." -ForegroundColor Yellow
    
    # Test 'n' key
    $nKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    $handled = $screen.HandleScreenInput($nKey)
    Write-Host "HandleScreenInput('n') returned: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'e' key  
    $eKey = [System.ConsoleKeyInfo]::new('e', [System.ConsoleKey]::E, $false, $false, $false)
    $handled = $screen.HandleScreenInput($eKey)
    Write-Host "HandleScreenInput('e') returned: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test 'd' key
    $dKey = [System.ConsoleKeyInfo]::new('d', [System.ConsoleKey]::D, $false, $false, $false)
    $handled = $screen.HandleScreenInput($dKey)
    Write-Host "HandleScreenInput('d') returned: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Test full HandleInput flow (should try child first, then screen shortcuts)
    Write-Host "`nTesting full HandleInput flow..." -ForegroundColor Yellow
    
    # First, child (SearchableListBox) should NOT handle n/e/d
    $childHandled = $screen.CommandList.HandleInput($nKey)
    Write-Host "Child CommandList.HandleInput('n'): $childHandled" -ForegroundColor $(if (-not $childHandled) { "Green" } else { "Red" })
    
    # Then, screen HandleInput should handle it via shortcuts
    $screenHandled = $screen.HandleInput($nKey)
    Write-Host "Screen HandleInput('n'): $screenHandled" -ForegroundColor $(if ($screenHandled) { "Green" } else { "Red" })
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-searchable-with-actions.ps1
#!/usr/bin/env pwsh

# Test SearchableListBox with actual actions to isolate the issue
param([switch]$LoadOnly)

# Load minimal components needed for test
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Models/BaseAction.ps1"
. "$PSScriptRoot/Actions/SummarizationAction.ps1"
. "$PSScriptRoot/Components/ListBox.ps1"
. "$PSScriptRoot/Components/SearchableListBox.ps1"

Write-Host "Testing SearchableListBox with actions..." -ForegroundColor Green

# Set up minimal services
$global:PraxisRoot = $PSScriptRoot
$global:ServiceContainer = [ServiceContainer]::new()

$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

try {
    Write-Host "Creating actions..." -ForegroundColor Yellow
    $actions = @()
    $actions += [SummarizationAction]::new()
    Write-Host "‚úì Created $($actions.Count) actions" -ForegroundColor Green
    
    Write-Host "Testing action GetDisplayText..." -ForegroundColor Yellow
    foreach ($action in $actions) {
        $displayText = $action.GetDisplayText()
        Write-Host "  Action: $displayText" -ForegroundColor Cyan
    }
    
    Write-Host "Creating SearchableListBox..." -ForegroundColor Yellow
    $listBox = [SearchableListBox]::new()
    $listBox.Title = "Test Actions"
    
    # Set up item renderer
    $listBox.ItemRenderer = {
        param($action)
        if (-not $action) { return "" }
        return $action.GetDisplayText()
    }
    
    Write-Host "Initializing SearchableListBox..." -ForegroundColor Yellow
    $listBox.Initialize($global:ServiceContainer)
    
    Write-Host "Setting items on SearchableListBox..." -ForegroundColor Yellow
    $listBox.SetItems($actions)
    
    Write-Host "SearchableListBox state:" -ForegroundColor Cyan
    Write-Host "  Items.Count: $($listBox.Items.Count)" -ForegroundColor DarkGray
    Write-Host "  _filteredItems.Count: $($listBox._filteredItems.Count)" -ForegroundColor DarkGray
    Write-Host "  SelectedIndex: $($listBox.SelectedIndex)" -ForegroundColor DarkGray
    
    if ($listBox.Items.Count -gt 0) {
        Write-Host "‚úì Items loaded successfully" -ForegroundColor Green
    } else {
        Write-Host "‚úó No items in SearchableListBox!" -ForegroundColor Red
    }
    
    if ($listBox._filteredItems.Count -gt 0) {
        Write-Host "‚úì Filtered items available" -ForegroundColor Green
    } else {
        Write-Host "‚úó No filtered items!" -ForegroundColor Red
    }
    
} catch {
    Write-Host "‚úó Test failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Cyan


####\test-shortcut-debug.ps1
#!/usr/bin/env pwsh

# Debug shortcut issue with CommandLibraryScreen
Write-Host "Debugging CommandLibraryScreen shortcuts..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating CommandLibraryScreen..." -ForegroundColor Yellow
    $screen = [CommandLibraryScreen]::new()
    $screen.Initialize($global:ServiceContainer)
    
    # Check screen type name
    $screenTypeName = $screen.GetType().Name
    Write-Host "Screen type name: '$screenTypeName'" -ForegroundColor Cyan
    
    # Check registered shortcuts
    $shortcutManager = $global:ServiceContainer.GetService('ShortcutManager')
    $shortcuts = $shortcutManager.GetShortcuts([ShortcutScope]::Screen, "CommandLibraryScreen")
    
    Write-Host "`nShortcuts registered for 'CommandLibraryScreen':" -ForegroundColor Yellow
    foreach ($shortcut in $shortcuts) {
        Write-Host "  $($shortcut.Id): '$($shortcut.KeyChar)' -> $($shortcut.Name)" -ForegroundColor Cyan
    }
    
    # Test if ShortcutManager would find these shortcuts
    Write-Host "`nTesting shortcut matching..." -ForegroundColor Yellow
    $nKey = [System.ConsoleKeyInfo]::new('n', [System.ConsoleKey]::N, $false, $false, $false)
    
    # Simulate what ScreenManager would pass
    $handled = $shortcutManager.HandleKeyPress($nKey, $screenTypeName, "")
    Write-Host "Key 'n' handled by ShortcutManager: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    
    # Check if there are conflicting shortcuts
    $allShortcuts = $shortcutManager.GetAllShortcuts()
    $nShortcuts = $allShortcuts | Where-Object { $_.KeyChar -eq 'n' }
    
    Write-Host "`nAll shortcuts with key 'n':" -ForegroundColor Yellow
    foreach ($shortcut in $nShortcuts) {
        Write-Host "  $($shortcut.Id): Scope=$($shortcut.Scope) ScreenType='$($shortcut.ScreenType)' Priority=$($shortcut.Priority)" -ForegroundColor Cyan
    }
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-shortcut-fix.ps1
#!/usr/bin/env pwsh

# Test SearchableListBox shortcut key exclusion
Write-Host "Testing SearchableListBox shortcut key exclusion..." -ForegroundColor Cyan

# Load framework
. "$PSScriptRoot/Start.ps1" -LoadOnly

try {
    Write-Host "Creating SearchableListBox..." -ForegroundColor Yellow
    $listBox = [SearchableListBox]::new()
    $listBox.SetItems(@("Item 1", "Item 2", "Item 3"))
    
    Write-Host "ExcludedSearchKeys: $($listBox.ExcludedSearchKeys -join ', ')" -ForegroundColor Cyan
    
    # Test excluded keys
    $excludedKeys = @('n', 'e', 'd')
    foreach ($keyChar in $excludedKeys) {
        $key = [System.ConsoleKeyInfo]::new($keyChar, [System.ConsoleKey]::($keyChar.ToString().ToUpper()), $false, $false, $false)
        $handled = $listBox.HandleInput($key)
        
        Write-Host "Key '$keyChar' handled by SearchableListBox: $handled" -ForegroundColor $(if (-not $handled) { "Green" } else { "Red" })
        Write-Host "  Search mode active: $($listBox._searchMode)" -ForegroundColor Cyan
        Write-Host "  Search query: '$($listBox.SearchQuery)'" -ForegroundColor Cyan
    }
    
    # Test non-excluded key
    Write-Host "`nTesting non-excluded key 's'..." -ForegroundColor Yellow
    $sKey = [System.ConsoleKeyInfo]::new('s', [System.ConsoleKey]::S, $false, $false, $false)
    $handled = $listBox.HandleInput($sKey)
    
    Write-Host "Key 's' handled by SearchableListBox: $handled" -ForegroundColor $(if ($handled) { "Green" } else { "Red" })
    Write-Host "  Search mode active: $($listBox._searchMode)" -ForegroundColor Cyan
    Write-Host "  Search query: '$($listBox.SearchQuery)'" -ForegroundColor Cyan
    
} catch {
    Write-Host "ERROR: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-simple-editor.ps1
#!/usr/bin/env pwsh

# Simple test for DocumentBuffer and Commands
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load minimal components
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Testing DocumentBuffer and Command Pattern..." -ForegroundColor Green

# Test DocumentBuffer
Write-Host "`n1. Testing DocumentBuffer:" -ForegroundColor Yellow
$buffer = [DocumentBuffer]::new()
Write-Host "   ‚úì DocumentBuffer created"
Write-Host "   Initial line count: $($buffer.GetLineCount())"
Write-Host "   First line: '$($buffer.GetLine(0))'"

# Test InsertTextCommand
Write-Host "`n2. Testing InsertTextCommand:" -ForegroundColor Yellow
$insertCmd = [InsertTextCommand]::new(0, 0, "Hello World")
$buffer.ExecuteCommand($insertCmd)
Write-Host "   ‚úì Insert command executed"
Write-Host "   Line after insert: '$($buffer.GetLine(0))'"
Write-Host "   Is modified: $($buffer.IsModified)"

# Test Undo
Write-Host "`n3. Testing Undo:" -ForegroundColor Yellow
Write-Host "   Can undo: $($buffer.CanUndo())"
$buffer.Undo()
Write-Host "   ‚úì Undo executed"
Write-Host "   Line after undo: '$($buffer.GetLine(0))'"
Write-Host "   Can redo: $($buffer.CanRedo())"

# Test Redo
Write-Host "`n4. Testing Redo:" -ForegroundColor Yellow
$buffer.Redo()
Write-Host "   ‚úì Redo executed"
Write-Host "   Line after redo: '$($buffer.GetLine(0))'"

# Test DeleteTextCommand
Write-Host "`n5. Testing DeleteTextCommand:" -ForegroundColor Yellow
$deleteCmd = [DeleteTextCommand]::new(0, 0, "Hello")
$buffer.ExecuteCommand($deleteCmd)
Write-Host "   ‚úì Delete command executed"
Write-Host "   Line after delete: '$($buffer.GetLine(0))'"

# Test InsertNewlineCommand
Write-Host "`n6. Testing InsertNewlineCommand:" -ForegroundColor Yellow
$newlineCmd = [InsertNewlineCommand]::new(0, 3, "")
$buffer.ExecuteCommand($newlineCmd)
Write-Host "   ‚úì Newline command executed"
Write-Host "   Line count: $($buffer.GetLineCount())"
Write-Host "   Line 0: '$($buffer.GetLine(0))'"
Write-Host "   Line 1: '$($buffer.GetLine(1))'"

# Test file operations
Write-Host "`n7. Testing file operations:" -ForegroundColor Yellow
$testFile = "$PSScriptRoot/test-buffer.txt"

try {
    $buffer.SaveToFile($testFile)
    Write-Host "   ‚úì File saved successfully"
    
    $buffer2 = [DocumentBuffer]::new($testFile)
    Write-Host "   ‚úì File loaded successfully"
    Write-Host "   Loaded line count: $($buffer2.GetLineCount())"
    Write-Host "   Loaded line 0: '$($buffer2.GetLine(0))'"
    Write-Host "   Loaded line 1: '$($buffer2.GetLine(1))'"
    
    Remove-Item -Path $testFile -Force
    Write-Host "   ‚úì Test file cleaned up"
} catch {
    Write-Host "   ‚úó File operation failed: $_" -ForegroundColor Red
}

Write-Host "`nAll core tests completed successfully! ‚úì" -ForegroundColor Green
Write-Host "Buffer/View architecture and Command Pattern are working." -ForegroundColor Cyan


####\test-tab7-bounds.ps1
#!/usr/bin/env pwsh

Write-Host "Testing tab 7 bounds by starting PRAXIS, going to tab 7, and checking logs..." -ForegroundColor Cyan

# Start PRAXIS in background
$job = Start-Job -ScriptBlock {
    Set-Location $using:PSScriptRoot
    . "./Start.ps1" -Debug
}

# Wait for startup
Start-Sleep -Seconds 3

# Try to send key 7 to switch to tab 7 (this might not work reliably)
Write-Host "PRAXIS should be running. Manually press '7' to go to tab 7, then 'q' to quit." -ForegroundColor Yellow
Write-Host "Press Enter here when you've tested tab 7..." -ForegroundColor Green
Read-Host

# Stop the job
Stop-Job $job -Force
Remove-Job $job -Force

# Check recent logs for VisualMacroFactory
Write-Host "`nRecent VisualMacroFactory log entries:" -ForegroundColor Cyan
$logContent = Get-Content "/home/teej/projects/github/praxis/_Logs/praxis.log" -Tail 100
$relevantEntries = $logContent | Where-Object { $_ -match "VisualMacroFactory|LoadAvailable|ComponentLibrary|OnBoundsChanged.*Width" }

if ($relevantEntries) {
    $relevantEntries | ForEach-Object { Write-Host $_ -ForegroundColor Yellow }
} else {
    Write-Host "No VisualMacroFactory entries found in recent logs" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Cyan


####\test-tab7-debug.ps1
#!/usr/bin/env pwsh

# Test tab 7 initialization with debug output
Write-Host "Starting PRAXIS with debug to test Tab 7 initialization..." -ForegroundColor Cyan
Write-Host "This will:" -ForegroundColor Yellow
Write-Host "1. Start PRAXIS with debug mode" -ForegroundColor Green
Write-Host "2. Automatically switch to tab 7 (Macro Factory)" -ForegroundColor Green 
Write-Host "3. Show debug logs to see what's happening" -ForegroundColor Green
Write-Host "4. Auto-quit after 5 seconds" -ForegroundColor Green
Write-Host ""

# Start PRAXIS with debug and capture output
$process = Start-Process -FilePath "pwsh" -ArgumentList "-File", "$PSScriptRoot/Start.ps1", "-Debug" -PassThru -RedirectStandardOutput "$PSScriptRoot/debug-output.txt" -RedirectStandardError "$PSScriptRoot/debug-error.txt"

# Wait a moment for startup
Start-Sleep -Seconds 2

# Send key to switch to tab 7
Add-Type -AssemblyName System.Windows.Forms
[System.Windows.Forms.SendKeys]::SendWait("7")

# Wait a moment for tab switch
Start-Sleep -Seconds 2

# Send quit command
[System.Windows.Forms.SendKeys]::SendWait("q")

# Wait for process to end
$process.WaitForExit(5000)

# Show debug output
Write-Host "Debug Output:" -ForegroundColor Cyan
Get-Content "$PSScriptRoot/debug-output.txt" | Select-Object -Last 50

Write-Host "`nError Output:" -ForegroundColor Red
Get-Content "$PSScriptRoot/debug-error.txt" | Select-Object -Last 20

# Clean up
Remove-Item "$PSScriptRoot/debug-output.txt" -ErrorAction SilentlyContinue
Remove-Item "$PSScriptRoot/debug-error.txt" -ErrorAction SilentlyContinue


####\test-texteditor-new.ps1
#!/usr/bin/env pwsh

# Test script for the new text editor architecture
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load essential components only
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize minimal services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

Write-Host "Testing new TextEditorScreenNew architecture..." -ForegroundColor Green

# Test DocumentBuffer
Write-Host "`n1. Testing DocumentBuffer:" -ForegroundColor Yellow
$buffer = [DocumentBuffer]::new()
Write-Host "   ‚úì DocumentBuffer created, line count: $($buffer.GetLineCount())"

# Test commands
Write-Host "   Testing InsertTextCommand..."
$insertCmd = [InsertTextCommand]::new(0, 0, "Hello World")
$buffer.ExecuteCommand($insertCmd)
Write-Host "   ‚úì Insert command executed: '$($buffer.GetLine(0))'"

Write-Host "   Testing undo..."
$buffer.Undo()
Write-Host "   ‚úì Undo executed: '$($buffer.GetLine(0))'"

Write-Host "   Testing redo..."
$buffer.Redo()
Write-Host "   ‚úì Redo executed: '$($buffer.GetLine(0))'"

# Test newline command
Write-Host "   Testing newline command..."
$newlineCmd = [InsertNewlineCommand]::new(0, 5, "")
$buffer.ExecuteCommand($newlineCmd)
Write-Host "   ‚úì Newline inserted, line count: $($buffer.GetLineCount())"
Write-Host "     Line 0: '$($buffer.GetLine(0))'"
Write-Host "     Line 1: '$($buffer.GetLine(1))'"

# Test TextEditorScreen
Write-Host "`n2. Testing TextEditorScreenNew:" -ForegroundColor Yellow
$editor = [TextEditorScreenNew]::new()
$editor.Initialize($global:ServiceContainer)
Write-Host "   ‚úì TextEditorScreenNew created and initialized"

# Test bounds and rendering
$editor.SetBounds(0, 0, 80, 24)
Write-Host "   ‚úì Bounds set to 80x24"

try {
    $renderOutput = $editor.Render()
    Write-Host "   ‚úì Render successful, output length: $($renderOutput.Length)"
} catch {
    Write-Host "   ‚úó Render failed: $_" -ForegroundColor Red
}

Write-Host "`n3. Testing file operations:" -ForegroundColor Yellow
$testFile = "$PSScriptRoot/test-editor-content.txt"

# Create test content
$testContent = @"
Line 1: Hello World
Line 2: This is a test
Line 3: New architecture works!
"@

Set-Content -Path $testFile -Value $testContent
Write-Host "   ‚úì Test file created: $testFile"

# Test file loading
$editorWithFile = [TextEditorScreenNew]::new($testFile)
Write-Host "   ‚úì Editor with file created"
Write-Host "     Lines loaded: $($editorWithFile._buffer.GetLineCount())"
Write-Host "     First line: '$($editorWithFile._buffer.GetLine(0))'"

# Clean up
Remove-Item -Path $testFile -Force
Write-Host "   ‚úì Test file cleaned up"

Write-Host "`nAll tests completed successfully! ‚úì" -ForegroundColor Green
Write-Host "New text editor architecture is working." -ForegroundColor Cyan


####\test-typing-undo.ps1
#!/usr/bin/env pwsh

# Test typing and undo scenario
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load essential components
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Screens/TextEditorScreenNew.ps1"

# Initialize services
$global:ServiceContainer = [ServiceContainer]::new()
$logger = [Logger]::new()
$global:Logger = $logger
$global:ServiceContainer.Register("Logger", $logger)
$themeManager = [ThemeManager]::new()
$global:ServiceContainer.Register("ThemeManager", $themeManager)

Write-Host "Testing typing and undo scenario..." -ForegroundColor Yellow

# Create editor like PRAXIS does
$editor = [TextEditorScreenNew]::new()
$editor.Initialize($global:ServiceContainer)
$editor.SetBounds(0, 0, 80, 24)

Write-Host "‚úì Editor created and initialized"
Write-Host "Initial cursor position: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "Buffer line count: $($editor._buffer.GetLineCount())"
Write-Host "Can undo: $($editor._buffer.CanUndo())"

# Simulate typing some text
Write-Host "`nSimulating typing 'Hello'..."
$testChars = @('H', 'e', 'l', 'l', 'o')
foreach ($char in $testChars) {
    $keyInfo = [System.ConsoleKeyInfo]::new($char, [System.ConsoleKey]::$char, $false, $false, $false)
    try {
        $handled = $editor.HandleScreenInput($keyInfo)
        Write-Host "  Typed '$char', handled: $handled"
    } catch {
        Write-Host "  ‚úó Error typing '$char': $_" -ForegroundColor Red
    }
}

Write-Host "After typing:"
Write-Host "  Cursor position: ($($editor.CursorX),$($editor.CursorY))"
Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
Write-Host "  Can undo: $($editor._buffer.CanUndo())"

# Try to undo
Write-Host "`nTesting undo..."
try {
    $editor.UndoEdit()
    Write-Host "‚úì Undo 1 completed"
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
    
    $editor.UndoEdit()
    Write-Host "‚úì Undo 2 completed" 
    Write-Host "  Line 0: '$($editor._buffer.GetLine(0))'"
    Write-Host "  Cursor: ($($editor.CursorX),$($editor.CursorY))"
    
} catch {
    Write-Host "‚úó Undo crashed: $_" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}

Write-Host "`nTest completed!" -ForegroundColor Green


####\test-undo-debug.ps1
#!/usr/bin/env pwsh

# Debug script for undo crash
$script:PraxisRoot = $PSScriptRoot
Set-Location $script:PraxisRoot

# Load minimal components
. "$PSScriptRoot/Core/DocumentBuffer.ps1"
. "$PSScriptRoot/Core/EditorCommands.ps1"

Write-Host "Testing undo crash scenario..." -ForegroundColor Red

# Create buffer like TextEditorScreenNew does
$buffer = [DocumentBuffer]::new()
Write-Host "Initial buffer created with $($buffer.GetLineCount()) lines"

# Simulate AddSampleContent
$sampleLines = @("Line 1", "Line 2", "Line 3")
$buffer.Lines.Clear()
foreach ($line in $sampleLines) {
    $buffer.Lines.Add($line) | Out-Null
}
$buffer.ClearUndoHistory()
$buffer.IsModified = $false

Write-Host "Sample content added: $($buffer.GetLineCount()) lines"
Write-Host "Can undo: $($buffer.CanUndo())"
Write-Host "Can redo: $($buffer.CanRedo())"

# Try to undo - this should be safe since we cleared history
Write-Host "`nTrying to undo (should be safe)..."
try {
    $buffer.Undo()
    Write-Host "‚úì Undo completed successfully"
} catch {
    Write-Host "‚úó Undo crashed: $_" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
}

# Now add some real content and try undo
Write-Host "`nAdding real content via command..."
$insertCmd = [InsertTextCommand]::new(0, 0, "TEST")
$buffer.ExecuteCommand($insertCmd)
Write-Host "Line 0 after insert: '$($buffer.GetLine(0))'"
Write-Host "Can undo: $($buffer.CanUndo())"

# Try to undo the real command
Write-Host "`nTrying to undo real command..."
try {
    $buffer.Undo()
    Write-Host "‚úì Undo completed successfully"
    Write-Host "Line 0 after undo: '$($buffer.GetLine(0))'"
} catch {
    Write-Host "‚úó Undo crashed: $_" -ForegroundColor Red
    Write-Host "Exception: $($_.Exception.GetType().Name)" -ForegroundColor Red
    Write-Host "Message: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
}


####\test-vmf-screen.ps1
#!/usr/bin/env pwsh

# Test VisualMacroFactoryScreen initialization
param([switch]$LoadOnly)

# Load necessary components
. "$PSScriptRoot/Core/StringCache.ps1"
. "$PSScriptRoot/Core/VT100.ps1"
. "$PSScriptRoot/Core/ServiceContainer.ps1"
. "$PSScriptRoot/Core/StringBuilderPool.ps1"

# Services needed for initialization
. "$PSScriptRoot/Services/Logger.ps1"
. "$PSScriptRoot/Services/EventBus.ps1"
. "$PSScriptRoot/Services/ThemeManager.ps1"
. "$PSScriptRoot/Services/ShortcutManager.ps1"
. "$PSScriptRoot/Services/CommandService.ps1"
. "$PSScriptRoot/Services/FunctionRegistry.ps1"
. "$PSScriptRoot/Services/MacroContextManager.ps1"

# Base classes
. "$PSScriptRoot/Base/UIElement.ps1"
. "$PSScriptRoot/Base/Container.ps1"
. "$PSScriptRoot/Base/Screen.ps1"
. "$PSScriptRoot/Base/BaseModel.ps1"

# Models
. "$PSScriptRoot/Models/BaseAction.ps1"
. "$PSScriptRoot/Models/Command.ps1"

# Actions
. "$PSScriptRoot/Actions/CustomIdeaCommandAction.ps1"
. "$PSScriptRoot/Actions/SummarizationAction.ps1"
. "$PSScriptRoot/Actions/AppendFieldAction.ps1"
. "$PSScriptRoot/Actions/ExportToExcelAction.ps1"

# Components
. "$PSScriptRoot/Components/SearchableListBox.ps1"
. "$PSScriptRoot/Components/DataGrid.ps1"

# VisualMacroFactoryScreen
. "$PSScriptRoot/Screens/VisualMacroFactoryScreen.ps1"

Write-Host "Testing VisualMacroFactoryScreen initialization..." -ForegroundColor Green

# Initialize global ServiceContainer
$global:ServiceContainer = [ServiceContainer]::new()

# Create required services
$logger = [Logger]::new()
$global:ServiceContainer.Register("Logger", $logger)

$eventBus = [EventBus]::new()
$eventBus.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("EventBus", $eventBus)

$shortcutManager = [ShortcutManager]::new()
$shortcutManager.Initialize($global:ServiceContainer)
$global:ServiceContainer.Register("ShortcutManager", $shortcutManager)

$commandService = [CommandService]::new()
$global:ServiceContainer.Register("CommandService", $commandService)

try {
    Write-Host "Creating VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen = [VisualMacroFactoryScreen]::new()
    Write-Host "‚úì VisualMacroFactoryScreen created successfully" -ForegroundColor Green
    
    Write-Host "Initializing VisualMacroFactoryScreen..." -ForegroundColor Yellow
    $screen.Initialize($global:ServiceContainer)
    Write-Host "‚úì VisualMacroFactoryScreen initialized successfully" -ForegroundColor Green
    
    Write-Host "Checking AvailableActions count: $($screen.AvailableActions.Count)" -ForegroundColor Cyan
    
    if ($screen.AvailableActions.Count -gt 0) {
        Write-Host "‚úì Actions loaded successfully" -ForegroundColor Green
        foreach ($action in $screen.AvailableActions) {
            Write-Host "  - $($action.Name)" -ForegroundColor DarkGray
        }
    } else {
        Write-Host "‚úó No actions loaded!" -ForegroundColor Red
    }
    
} catch {
    Write-Host "‚úó VisualMacroFactoryScreen failed: $($_.Exception.Message)" -ForegroundColor Red
    Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor DarkRed
}

Write-Host "`nVisualMacroFactoryScreen test completed!" -ForegroundColor Cyan


