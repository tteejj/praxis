# TextEditorScreen - Multi-line text editor screen with mode-aware input
# Escape toggles between text mode and command mode for tab switching

class TextEditorScreen : Screen {
    # Text content and cursor state
    [System.Collections.ArrayList]$Lines
    [int]$CursorX = 0
    [int]$CursorY = 0
    [int]$ScrollOffsetY = 0
    [int]$ScrollOffsetX = 0
    [string]$FilePath = ""
    [bool]$Modified = $false
    [string]$StatusMessage = ""
    [bool]$InTextMode = $true  # Start in text mode
    
    # Focusable child component for PRAXIS architecture
    [Button]$TextAreaChild
    
    # Editor settings
    [int]$TabWidth = 4
    [bool]$ShowLineNumbers = $true
    [int]$LineNumberWidth = 5
    
    TextEditorScreen() : base() {
        $this.Title = "Text Editor"
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.Lines.Add("") | Out-Null
        $this.InitializeChild()
    }
    
    TextEditorScreen([string]$filePath) : base() {
        $this.Title = "Text Editor"
        $this.FilePath = $filePath
        $this.Lines = [System.Collections.ArrayList]::new()
        $this.InitializeChild()
    }
    
    [void] InitializeChild() {
        # Create simple Button child for focus handling (zero size)
        $this.TextAreaChild = [Button]::new("")
        $this.TextAreaChild.IsFocusable = $true
        $this.TextAreaChild.SetBounds(0, 0, 0, 0)
        $this.AddChild($this.TextAreaChild)
        
        if ($global:Logger) {
            $global:Logger.Debug("TextEditorScreen: Added Button child, Children.Count=$($this.Children.Count)")
        }
    }
    
    [void] OnInitialize() {
        # Initialize the child component
        if ($this.TextAreaChild) {
            $this.TextAreaChild.Initialize($this.ServiceContainer)
        }
        
        # Load file if specified
        if ($this.FilePath -and (Test-Path $this.FilePath)) {
            $this.LoadFile()
        } elseif (-not $this.Lines.Count) {
            $this.Lines.Add("") | Out-Null
        }
        
        # Update title
        if ($this.FilePath) {
            $this.Title = "Text Editor - $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        
        # Focus the child so the screen has a focused element
        if ($this.TextAreaChild) {
            $this.TextAreaChild.Focus()
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: Focused Button child, IsFocused=$($this.TextAreaChild.IsFocused)")
            }
        }
    }
    
    [void] LoadFile() {
        try {
            $content = Get-Content -Path $this.FilePath -Raw -ErrorAction Stop
            if ($content) {
                $this.Lines.Clear()
                $lineArray = $content -split "`r?`n"
                foreach ($line in $lineArray) {
                    $this.Lines.Add($line) | Out-Null
                }
            } else {
                $this.Lines.Clear()
                $this.Lines.Add("") | Out-Null
            }
            $this.Modified = $false
            $this.StatusMessage = "File loaded: $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        catch {
            $this.StatusMessage = "Error loading file: $_"
            if (-not $this.Lines.Count) {
                $this.Lines.Add("") | Out-Null
            }
        }
        $this.Invalidate()
    }
    
    [void] SaveFile() {
        if (-not $this.FilePath) {
            # Open file browser for save location
            $this.OpenFileBrowser()
            return
        }
        
        try {
            $content = $this.Lines -join "`n"
            Set-Content -Path $this.FilePath -Value $content -NoNewline -ErrorAction Stop
            $this.Modified = $false
            $this.StatusMessage = "File saved: $([System.IO.Path]::GetFileName($this.FilePath))"
        }
        catch {
            $this.StatusMessage = "Error saving file: $_"
        }
        $this.Invalidate()
    }
    
    [void] OpenFileBrowser() {
        # Open file browser for file selection
        try {
            $fileBrowserType = [type]"FileBrowserScreen"
            if ($fileBrowserType) {
                $fileBrowser = $fileBrowserType::new()
                
                # Set up callback for file selection
                $editor = $this
                $fileBrowser.FileSelectedCallback = {
                    param($filePath)
                    if ($filePath -and (Test-Path $filePath)) {
                        $item = Get-Item $filePath -ErrorAction SilentlyContinue
                        if ($item -and -not $item.PSIsContainer) {
                            # File selected - either save current content or load new file
                            if ($editor.StatusMessage -eq "SELECT_SAVE_LOCATION") {
                                # Save current content to selected file
                                $editor.FilePath = $filePath
                                $editor.SaveFile()
                            } else {
                                # Load selected file
                                $editor.FilePath = $filePath
                                $editor.LoadFile()
                            }
                        }
                    }
                    
                    # Close the file browser
                    $screenManager = $editor.ServiceContainer.GetService("ScreenManager")
                    $screenManager.Pop() | Out-Null
                }.GetNewClosure()
                
                # Push the file browser
                $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                $screenManager.Push($fileBrowser)
            }
        } catch {
            $this.StatusMessage = "FileBrowser not available"
            $this.Invalidate()
        }
    }
    
    # Override the main HandleInput to intercept before child gets it
    [bool] HandleInput([System.ConsoleKeyInfo]$keyInfo) {
        if ($global:Logger) {
            $global:Logger.Debug("TextEditorScreen.HandleInput: Key=$($keyInfo.Key) InTextMode=$($this.InTextMode)")
        }
        # ESCAPE: Toggle between text mode and command mode
        if ($keyInfo.Key -eq [ConsoleKey]::Escape) {
            if ($this.InTextMode) {
                # Switch to command mode
                $this.InTextMode = $false
                $this.Invalidate()  # Update title bar
                return $true  # Consume the escape
            } else {
                # In command mode, let escape exit the editor
                $screenManager = $this.ServiceContainer.GetService("ScreenManager")
                if ($screenManager) {
                    $screenManager.Pop() | Out-Null
                }
                return $true
            }
        }
        
        # In command mode, let all keys bubble up for tab switching
        if (-not $this.InTextMode) {
            if ($global:Logger) {
                $global:Logger.Debug("TextEditorScreen: In command mode, Key=$($keyInfo.Key) Char='$($keyInfo.KeyChar)'")
            }
            # Any letter key switches back to text mode
            if ($keyInfo.KeyChar -and [char]::IsLetter($keyInfo.KeyChar)) {
                $this.InTextMode = $true
                $this.Invalidate()
                if ($global:Logger) {
                    $global:Logger.Debug("TextEditorScreen: Switched to text mode for letter '$($keyInfo.KeyChar)'")
                }
                # Fall through to handle the character
            } else {
                if ($global:Logger) {
                    $global:Logger.Debug("TextEditorScreen: Letting parent handle key '$($keyInfo.Key)' for tab switching")
                }
                return $false  # Let parent handle 1-6 for tab switching
            }
        }
        
        # In text mode, handle input normally via HandleScreenInput
        return $this.HandleScreenInput($keyInfo)
    }
    
    # Text editing input handling (only called in text mode)
    [bool] HandleScreenInput([System.ConsoleKeyInfo]$keyInfo) {
        # Clear status message on input (except for certain messages)
        if ($this.StatusMessage -and -not $this.StatusMessage.StartsWith("Error") -and $this.StatusMessage -ne "SELECT_SAVE_LOCATION") {
            $this.StatusMessage = ""
        }
        
        # Handle control key combinations (work in both modes)
        if ($keyInfo.Modifiers -band [ConsoleModifiers]::Control) {
            switch ($keyInfo.Key) {
                ([ConsoleKey]::S) { 
                    $this.SaveFile()
                    return $true 
                }
                ([ConsoleKey]::O) { 
                    $this.OpenFileBrowser()
                    return $true 
                }
                ([ConsoleKey]::Q) { 
                    if ($this.Modified) {
                        $this.StatusMessage = "Unsaved changes! Press Ctrl+Q again to quit"
                        $this.Invalidate()
                    } else {
                        $this.Active = $false
                    }
                    return $true
                }
            }
        }
        
        # Text mode - handle all text editing
        switch ($keyInfo.Key) {
            # Navigation
            ([ConsoleKey]::UpArrow) { $this.MoveCursor(0, -1); return $true }
            ([ConsoleKey]::DownArrow) { $this.MoveCursor(0, 1); return $true }
            ([ConsoleKey]::LeftArrow) { $this.MoveCursor(-1, 0); return $true }
            ([ConsoleKey]::RightArrow) { $this.MoveCursor(1, 0); return $true }
            ([ConsoleKey]::Home) { $this.CursorX = 0; $this.EnsureCursorVisible(); $this.Invalidate(); return $true }
            ([ConsoleKey]::End) { 
                if ($this.CursorY -lt $this.Lines.Count) {
                    $this.CursorX = $this.Lines[$this.CursorY].Length
                }
                $this.EnsureCursorVisible()
                $this.Invalidate()
                return $true
            }
            ([ConsoleKey]::PageUp) { $this.PageUp(); return $true }
            ([ConsoleKey]::PageDown) { $this.PageDown(); return $true }
            
            # Editing
            ([ConsoleKey]::Enter) { $this.InsertNewline(); return $true }
            ([ConsoleKey]::Backspace) { $this.Backspace(); return $true }
            ([ConsoleKey]::Delete) { $this.Delete(); return $true }
            ([ConsoleKey]::Tab) { $this.InsertTab(); return $true }
        }
        
        # Insert printable characters
        if ($keyInfo.KeyChar -and [char]::IsControl($keyInfo.KeyChar) -eq $false) {
            $this.InsertChar($keyInfo.KeyChar)
            return $true
        }
        
        return $false
    }
    
    # Text editor specific methods (unchanged from original)
    [void] MoveCursor([int]$dx, [int]$dy) {
        $this.CursorY = [Math]::Max(0, [Math]::Min($this.Lines.Count - 1, $this.CursorY + $dy))
        
        if ($dx -ne 0) {
            $this.CursorX = [Math]::Max(0, $this.CursorX + $dx)
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        } else {
            # Vertical movement - try to maintain column
            $lineLength = $this.Lines[$this.CursorY].Length
            $this.CursorX = [Math]::Min($lineLength, $this.CursorX)
        }
        
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertChar([char]$char) {
        $line = $this.Lines[$this.CursorY]
        $this.Lines[$this.CursorY] = $line.Insert($this.CursorX, $char)
        $this.CursorX++
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] InsertNewline() {
        $line = $this.Lines[$this.CursorY]
        $before = if ($this.CursorX -gt 0) { $line.Substring(0, $this.CursorX) } else { "" }
        $after = if ($this.CursorX -lt $line.Length) { $line.Substring($this.CursorX) } else { "" }
        
        $this.Lines[$this.CursorY] = $before
        $this.Lines.Insert($this.CursorY + 1, $after)
        
        $this.CursorY++
        $this.CursorX = 0
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Backspace() {
        if ($this.CursorX -gt 0) {
            # Delete character before cursor
            $line = $this.Lines[$this.CursorY]
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX - 1, 1)
            $this.CursorX--
        } elseif ($this.CursorY -gt 0) {
            # Join with previous line
            $prevLine = $this.Lines[$this.CursorY - 1]
            $currentLine = $this.Lines[$this.CursorY]
            $this.CursorX = $prevLine.Length
            $this.Lines[$this.CursorY - 1] = $prevLine + $currentLine
            $this.Lines.RemoveAt($this.CursorY)
            $this.CursorY--
        }
        
        $this.Modified = $true
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] Delete() {
        $line = $this.Lines[$this.CursorY]
        
        if ($this.CursorX -lt $line.Length) {
            # Delete character at cursor
            $this.Lines[$this.CursorY] = $line.Remove($this.CursorX, 1)
        } elseif ($this.CursorY -lt $this.Lines.Count - 1) {
            # Join with next line
            $nextLine = $this.Lines[$this.CursorY + 1]
            $this.Lines[$this.CursorY] = $line + $nextLine
            $this.Lines.RemoveAt($this.CursorY + 1)
        }
        
        $this.Modified = $true
        $this.Invalidate()
    }
    
    [void] InsertTab() {
        for ($i = 0; $i -lt $this.TabWidth; $i++) {
            $this.InsertChar(' ')
        }
    }
    
    [void] PageUp() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Max(0, $this.CursorY - $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] PageDown() {
        $pageSize = $this.Height - 6
        $this.CursorY = [Math]::Min($this.Lines.Count - 1, $this.CursorY + $pageSize)
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [void] EnsureCursorVisible() {
        $editorHeight = $this.Height - 6
        $editorWidth = $this.Width - $this.LineNumberWidth
        
        # Vertical scrolling
        if ($this.CursorY -lt $this.ScrollOffsetY) {
            $this.ScrollOffsetY = $this.CursorY
        } elseif ($this.CursorY -ge $this.ScrollOffsetY + $editorHeight) {
            $this.ScrollOffsetY = $this.CursorY - $editorHeight + 1
        }
        
        # Horizontal scrolling
        if ($this.CursorX -lt $this.ScrollOffsetX) {
            $this.ScrollOffsetX = $this.CursorX
        } elseif ($this.CursorX -ge $this.ScrollOffsetX + $editorWidth) {
            $this.ScrollOffsetX = $this.CursorX - $editorWidth + 1
        }
    }
    
    [void] OnBoundsChanged() {
        # When bounds change, ensure cursor is still visible
        $this.EnsureCursorVisible()
        $this.Invalidate()
    }
    
    [string] OnRender() {
        $sb = Get-PooledStringBuilder 4096  # Text editor can have large content
        
        # Get theme colors
        $bgColor = if ($this.Theme) { $this.Theme.GetBgColor("background") } else { "" }
        $fgColor = if ($this.Theme) { $this.Theme.GetColor("foreground") } else { "" }
        $lineNumColor = if ($this.Theme) { $this.Theme.GetColor("linenumber") } else { $fgColor }
        $statusBg = if ($this.Theme) { $this.Theme.GetBgColor("status") } else { $bgColor }
        $statusFg = if ($this.Theme) { $this.Theme.GetColor("status.foreground") } else { $fgColor }
        $cursorBg = if ($this.Theme) { $this.Theme.GetBgColor("cursor") } else { $fgColor }
        
        # Calculate content area
        $contentHeight = $this.Height - 3  # Reserve space for title and status
        $contentWidth = $this.Width - ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartX = $this.X + ($this.ShowLineNumbers ? $this.LineNumberWidth : 0)
        $contentStartY = $this.Y + 1
        
        # Clear background
        for ($y = 0; $y -lt $this.Height; $y++) {
            $sb.Append([VT]::MoveTo($this.X, $this.Y + $y))
            $sb.Append($bgColor)
            $sb.Append(" " * $this.Width)
        }
        
        # Draw title with mode indicator
        $sb.Append([VT]::MoveTo($this.X, $this.Y))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        $titleText = $this.Title
        if ($this.Modified) { $titleText += " *" }
        # Add mode indicator
        if (-not $this.InTextMode) {
            $titleText += " [CMD]"
        }
        $titleText = $titleText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($titleText)
        
        # Render text lines
        $endY = [Math]::Min($this.ScrollOffsetY + $contentHeight, $this.Lines.Count)
        for ($lineIdx = $this.ScrollOffsetY; $lineIdx -lt $endY; $lineIdx++) {
            $screenY = $contentStartY + ($lineIdx - $this.ScrollOffsetY)
            $line = $this.Lines[$lineIdx]
            
            # Draw line numbers if enabled
            if ($this.ShowLineNumbers) {
                $sb.Append([VT]::MoveTo($this.X, $screenY))
                $sb.Append($lineNumColor)
                $lineNum = ($lineIdx + 1).ToString().PadLeft($this.LineNumberWidth - 1) + " "
                $sb.Append($lineNum)
            }
            
            # Draw line content
            $sb.Append([VT]::MoveTo($contentStartX, $screenY))
            $sb.Append($fgColor)
            
            if ($line.Length -gt $this.ScrollOffsetX) {
                $visibleText = $line.Substring($this.ScrollOffsetX)
                if ($visibleText.Length -gt $contentWidth) {
                    $visibleText = $visibleText.Substring(0, $contentWidth)
                }
                $sb.Append($visibleText)
            }
        }
        
        # Draw cursor (always visible in text mode)
        if ($this.InTextMode) {
            $cursorScreenX = $contentStartX + ($this.CursorX - $this.ScrollOffsetX)
            $cursorScreenY = $contentStartY + ($this.CursorY - $this.ScrollOffsetY)
            
            # Only draw cursor if it's visible
            if ($cursorScreenX -ge $contentStartX -and $cursorScreenX -lt $contentStartX + $contentWidth -and
                $cursorScreenY -ge $contentStartY -and $cursorScreenY -lt $contentStartY + $contentHeight) {
                
                $sb.Append([VT]::MoveTo($cursorScreenX, $cursorScreenY))
                $sb.Append($cursorBg)
                
                # Get character under cursor
                $charUnderCursor = " "
                if ($this.CursorY -lt $this.Lines.Count) {
                    $line = $this.Lines[$this.CursorY]
                    if ($this.CursorX -lt $line.Length) {
                        $charUnderCursor = $line[$this.CursorX]
                    }
                }
                $sb.Append($charUnderCursor)
            }
        }
        
        # Draw status line
        $statusY = $this.Y + $this.Height - 1
        $sb.Append([VT]::MoveTo($this.X, $statusY))
        $sb.Append($statusBg)
        $sb.Append($statusFg)
        
        $statusText = ""
        if ($this.StatusMessage) {
            $statusText = $this.StatusMessage
        } else {
            $statusText = "Line $($this.CursorY + 1), Col $($this.CursorX + 1)"
            if ($this.FilePath) {
                $statusText += " | $([System.IO.Path]::GetFileName($this.FilePath))"
            }
            if (-not $this.InTextMode) {
                $statusText += " | ESC:Exit 1-6:Tabs Letter:Edit"
            } else {
                $statusText += " | ESC:Commands"
            }
        }
        $statusText = $statusText.PadRight($this.Width).Substring(0, $this.Width)
        $sb.Append($statusText)
        
        $sb.Append([VT]::Reset())
        $result = $sb.ToString()
        Return-PooledStringBuilder $sb
        return $result
    }
}