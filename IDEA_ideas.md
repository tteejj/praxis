-@commands repository, as previously implemented BUT instead

-copy of macros/whatever to IDEA's folders for project set up so they are available locally IN IDEA

creation of custom @functions to remove some of the input pain - like curval

-maybe read the history and turn it into a macro to use?

-maybe tie to my processing notes??

-realtime update of the file in texteditor to go along with my notes?? jump sections for easy edit?
	-need massive updates to texteditor.
	dual pane, left original, right my version. checkbox/selector to hide a section. if hidden, not used, hides in both. free form, or just a focusable text box are to add notes? right pane is a seperate file of course added as comments to the file? that way the history could be run as a macro on the next file. and the hidden parts would ensure only the correct steps were used. maybe allow reordering? like my previous kanban screen, a ctr+arrow or some key would move that block up/down? maybe allow the addition of any custom macros I have created already? ***maybe a custom macro builder from a component library? i can look at a file, add the macros i want and then fire it off??? that would tie in to the @command registry mentioned earlier but integrate that and this macro library. would need to identify fields needed to run , so need common defs for those and a way to update them - just a global var then or something - but the macro would need to be smart enough to know it needs an input for field 1,2,4 and ask appropriately. 



Of course. Here is a comprehensive report that consolidates our discussions on both the IDEAScript History Editor and the Visual Macro Factory. This document outlines the background, technical feasibility, proposed architecture, and implementation strategies for each concept, complete with code snippets and strategic recommendations.

***

## Project Report: Advanced IDEAScript Workflow Tools

**Document Version:** 1.0  
**Date:** July 25, 2025  
**Prepared For:** TUI Project Lead  
**Subject:** Technical Design and Feasibility Analysis for Custom CaseWare IDEA Tooling

### 1.0 Executive Summary

This document outlines the design and architecture for two powerful, interconnected tools aimed at revolutionizing the CaseWare IDEA workflow. The current process of managing and reusing IDEAScript macros is heavily reliant on manual text editing, which is inefficient and error-prone. The proposed tools aim to replace this fragile process with a robust, visual, and intelligent system integrated directly into a custom PowerShell TUI.

*   **Proposal 1: The IDEAScript History Editor & Annotator:** A tool for refining, annotating, and modularizing existing IDEAScript history files, turning them into reliable, reusable macros.
*   **Proposal 2: The Visual Macro Factory:** A component-based visual editor for building complex, reliable macros from a library of pre-defined "Actions," eliminating the need to write IDEAScript code by hand.

Both proposals are highly feasible due to the plain-text nature of IDEAScript (`.iss` files) and can be built upon the existing, well-architected PowerShell TUI framework. This report recommends focusing initially on the **Visual Macro Factory**, as it offers the highest return on investment and provides a self-contained, high-impact project.

---

### 2.0 Proposal 1: The IDEAScript History Editor & Annotator

This tool addresses the challenge of cleaning up and reusing the raw History logs generated by CaseWare IDEA.

#### 2.1 Concept Overview

The core idea is to treat an IDEA History file not as a static script, but as a dynamic sequence of steps that can be manipulated.

*   **Dual-Pane Interface:** A side-by-side view showing the original, untouched history on the left and an editable, annotated version on the right.
*   **Interactive Step Management:** Users can hide or disable specific steps (e.g., a mistaken import) so they are excluded from the final macro. They can also reorder steps to change the logic flow.
*   **Annotation:** Users can add persistent, user-friendly notes to each step, explaining its purpose. These notes are saved as comments within the final script.
*   **Real-time Updates:** The editor can watch the IDEA project folder and automatically reload the history file as it's updated by the IDEA application.

#### 2.2 Technical Feasibility Analysis

This concept is highly feasible.

*   **IDEAScript is Plain Text:** CaseWare IDEA saves its history as `.iss` files, which are plain-text scripts similar to VBA. They can be easily read, parsed, and written by any PowerShell script.
*   **Structured but Simple:** While IDEAScript has control flow, a history log is primarily a simple, linear sequence of commands. This makes parsing it into logical "blocks" a straightforward task.
*   **PowerShell `FileSystemWatcher`:** The "real-time update" feature can be reliably implemented using the `.NET FileSystemWatcher` class available in PowerShell to monitor for file changes.

#### 2.3 Proposed Architecture & Implementation

The key is to shift from a simple text editor to a **"Script Block" Editor**.

1.  **Data Structure:** When an `.iss` file is loaded, it is parsed into an `ArrayList` of objects, where each object represents a logical block of script.

    ```powershell
    # The data object for a single step in the macro history
    $scriptBlock = [PSObject]@{
        Content      = 'task.FieldStatistics.Run()' # The actual IDEAScript code
        IsVisible    = $true                        # Controls if this step is included in the final macro
        Notes        = "Calculate stats for the 'AMOUNT' field."
        OriginalLine = 15                           # To reference the original file
    }
    ```

2.  **User Interface:**
    *   The **Left Pane** displays the original file content.
    *   The **Right Pane** contains a `DataGrid` component bound to the `ArrayList` of script block objects.
    *   **Hiding/Ignoring:** The `IsVisible` property is bound to a checkbox in the grid. Unchecking it simply flags the object for exclusion when the final script is rendered.
    *   **Reordering:** A `Ctrl+Arrow` key binding in the `DataGrid`'s input handler would simply swap the positions of objects within the `ArrayList` and invalidate the grid to trigger a re-render.
    *   **Annotation:** A separate `TextBox` or a pop-up dialog would allow editing the `Notes` property of the selected script block.

3.  **Rendering the Final Script:** To save the modified macro, the application iterates through the `ArrayList` and concatenates the `Content` of each block where `IsVisible` is `$true`, prepending any `Notes` as IDEAScript comments (`'`).

---

### 3.0 Proposal 2: The Visual Macro Factory

This proposal is a more ambitious and powerful tool that moves away from editing existing scripts to building new ones visually. It is designed to be highly reliable by managing a central data context for the entire macro. This tool will operate on the **currently open database** in IDEA, simplifying the initial context.

#### 3.1 Concept Overview

The user builds a macro by assembling components from a library, defining their inputs in a central location, and exporting the result to a runnable `.iss` file.

*   **Three-Pane Interface:**
    1.  **Component Library (Left):** A `SearchableListBox` or `TreeView` containing all available macro actions (e.g., "Summarization," "Append Field").
    2.  **Macro Sequence (Center):** A `DataGrid` showing the ordered list of actions the user has chosen for the current macro. This is the main editing surface.
    3.  **Macro Context Panel (Right):** A "smart" global section. This `DataGrid` displays all variables for the entire macro, including required user inputs and fields generated by previous actions.
*   **Context-Driven Workflow:** The user defines a variable (like a field name or an output file) **once** in the Context Panel. Any action in the sequence that needs this variable will use the centrally defined value.
*   **Temporal Safety:** The Context Panel intelligently shows the user which variables are available at each step of the macro, preventing them from using a generated field before the action that creates it has run.

#### 3.2 Core Architectural Principles for Reliability

The system's reliability is based on a clean separation of concerns and explicit data contracts.

1.  **The "Action" Object (The Explicit Contract):** Each component in the library is a class that inherits from a `BaseAction`. This class explicitly declares its data dependencies.

    ```powershell
    # /Actions/BaseAction.ps1
    class BaseAction {
        [string]$Name
        [string]$Description
        [string]$Category

        # Declares what variables this action NEEDS from the Macro Context.
        [hashtable[]]$Consumes = @() # e.g., @{ Name="fieldToStat"; Type="Numeric Field" }

        # Declares what variables this action CREATES.
        [hashtable[]]$Produces = @() # e.g., @{ Name="statsOutput"; Type="Database" }

        # Generates the final IDEAScript code using the provided context.
        [string] RenderScript([hashtable]$macroContext) {
            throw "Must be implemented by derived class."
        }
    }
    ```

2.  **The `MacroContextManager` (The Smart Conductor):** A non-UI class that manages the state of the macro.
    *   It maintains the master list of all actions in the sequence.
    *   When an action is added, it inspects its `Produces` array and **reliably resolves name collisions** by appending a suffix (e.g., `newField` becomes `newField_AppendField_1`), ensuring uniqueness.
    *   It determines the context for any given step by calculating what variables have been defined or produced by all *preceding* steps.

3.  **The Reactive UI (The "When and Where"):**
    *   The Context Panel (right pane) is **dynamically rebuilt** every time the user selects a different step in the Macro Sequence (center pane).
    *   This ensures the panel only displays variables that are valid and available at that specific point in the logic, making the system inherently safe and intuitive.

#### 3.3 The `@function` System

To handle dynamic values (like user prompts or system variables), a formal registry is proposed.

*   **`@FunctionRegistry` Service:** A central service that manages a list of available `@functions`.
*   **Starter Pack:** A default set of essential functions should be included:
    *   `@PromptForField`: Asks the user to select a field when the script is run.
    *   `@PromptForValue(prompt_text)`: Asks the user for a text value.
    *   `@CurrentDate_YYYYMMDD`: Inserts the current date.
    *   `@CurrentUser`: Inserts the current user's name.
*   **UI Integration:** Input fields in the Context Panel will have a button to open a dialog showing available `@functions`, allowing for easy insertion.

#### 3.4 Proposed "Phase 0" Action Library

Based on analysis of common IDEAScript usage, the following actions would provide immediate high value:

| Category | Action Name | Description |
| :--- | :--- | :--- |
| **Data I/O** | Export to IDEA Database | Saves the current database to a new `.IMD` file. |
| | Export to Excel | Exports the current database to an `.xlsx` file. |
| **Data Cleaning** | Append Calculated Field | Adds a new field based on an equation. |
| | Change Field Type | Converts a field's data type (e.g., Character to Date). |
| | Standardize Case | Converts a text field to UPPER, lower, or Proper case. |
| **Core Analysis** | Summarization | Performs a summarization and creates an output database. |
| | Join Databases | Joins the active database with another. |
| | Append Databases | Appends another database to the active one. |
| | Field Statistics | Calculates statistics for a numeric or date field. |
| | Duplicate Key Detection | Finds duplicate records based on selected keys. |

### 4.0 Conclusion & Recommendation

Both proposed tools offer significant improvements over the current manual IDEAScripting workflow. They are both technically sound and can be implemented effectively using the existing TUI framework.

However, the **Visual Macro Factory (Proposal 2)** represents a more fundamental paradigm shift. By moving from script *editing* to visual macro *composition*, it addresses the root causes of inefficiency and error. Its component-based nature is inherently more scalable, maintainable, and user-friendly.

**Recommendation:**  
It is recommended to begin development with the **Visual Macro Factory**. The architectural patterns required (Action objects, Context Manager) are robust and will provide a solid foundation. The initial "Phase 0" feature set, focused on the active database and the starter pack of actions, will deliver immediate and substantial value. The History Editor can be considered as a future enhancement or a separate, secondary tool.
